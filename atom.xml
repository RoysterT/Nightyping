<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🌙Nightyping</title>
  
  <subtitle>技术，生活与美好</subtitle>
  <link href="https://www.iuoyt.com/atom.xml" rel="self"/>
  
  <link href="https://www.iuoyt.com/"/>
  <updated>2024-02-17T11:14:01.944Z</updated>
  <id>https://www.iuoyt.com/</id>
  
  <author>
    <name>Royster</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法中常见的排序方法</title>
    <link href="https://www.iuoyt.com/posts/d35732cd.html"/>
    <id>https://www.iuoyt.com/posts/d35732cd.html</id>
    <published>2024-02-17T07:51:03.000Z</published>
    <updated>2024-02-17T11:14:01.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能分析">性能分析</h2><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(\log n)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></td><td style="text-align:center">$O(n^{1.3})$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a></td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr></tbody></table><ul><li><strong>稳定性</strong>：在原序列中，<code>r[i]==r[j]</code>且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是稳定的</li></ul><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序（Bubble-Sort）">冒泡排序（Bubble Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>冒泡排序重复地遍历要排序的列表，一次比较相邻两个元素，如果它们的大小顺序错误则进行交换。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// i表示完成排序数字的个数，每一轮排序确认第i+1大的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 每一轮冒泡排序</span></span><br><span class="line">        <span class="comment">// j控制每次比较的元素位置，每轮排序都会把当前最大的数沉底</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果前一个数大于后一个数，则交换它们</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="快速排序（Quick-Sort）">快速排序（Quick Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(\log n)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>快速排序是一种常用的排序算法，采用了分治的思想。其基本思路是选择一个基准元素，将小于基准的元素放到基准元素的左边，将大于基准的元素放到基准元素的右边，然后对左右两个子序列分别进行递归排序。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  数组的起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数组的结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 若右边界大于等于左边界，即还存在需要排序的元素</span></span><br><span class="line">    <span class="keyword">if</span> (right &gt;= left) &#123;</span><br><span class="line">        <span class="comment">// 选择基准值为左边界元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">basic</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="comment">// 定义左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="comment">// 循环直到左右指针相遇</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 从右向左找到第一个小于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; basic) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左指针小于右指针，将右指针所指的值赋给左指针，并将左指针右移</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从左向右找到第一个大于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; basic) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左指针小于右指针，将左指针所指的值赋给右指针，并将右指针左移</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准值放入指针相遇的位置</span></span><br><span class="line">        arr[i] = basic;</span><br><span class="line">        <span class="comment">// 递归调用，对基准值左侧的子数组进行排序</span></span><br><span class="line">        quickSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归调用，对基准值右侧的子数组进行排序</span></span><br><span class="line">        quickSort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="选择排序">选择排序</h2><h3 id="简单选择排序（Selection-Sort）">简单选择排序（Selection Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>选择排序每次从待排序的数据元素中选择最小（或最大）的一个元素，放到已排好序的数列的最后（或最前），直到所有元素均排好序。</p><p><img src="https://oss.iuoyt.com/img/posts/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// 如果数组长度为0，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外层循环控制每次选择的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 最小索引初始化为i</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 在剩余元素中找到最小值的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 找到最小的数</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换当前位置i和最小值的位置minIndex的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[minIndex];</span><br><span class="line">        array[minIndex] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="堆排序（Heap-Sort）">堆排序（Heap Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>堆排序利用了堆的数据结构，将待排序的序列构建成一个最大堆（大顶堆或最小堆），然后依次取出堆顶元素（最大值或最小值），并调整剩余元素使之满足堆的性质，最终得到一个有序序列。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     数组大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] array, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 构建最大堆（Max Heap）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(array, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从堆中提取元素，逐步将最大值放到数组末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将堆顶元素（当前最大值）与数组末尾元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新构建堆，排除已排序部分</span></span><br><span class="line">        heapify(array, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建最大堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待构建堆的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i   当前节点索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化最大值索引为当前节点索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右子节点索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于当前节点，则更新最大值索引为左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于当前节点，则更新最大值索引为右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值索引不等于当前节点索引，则交换当前节点与最大值节点的值，并继续构建堆</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用，对受影响的子树进行堆构建</span></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="插入排序">插入排序</h2><h3 id="直接插入排序（Insertion-Sort）">直接插入排序（Insertion Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>插入排序将待排序的数组分成已排序和未排序两部分，初始时已排序部分只有一个元素（即数组的第一个元素），然后依次将未排序部分的元素插入到已排序部分的适当位置，直到全部元素都被插入到已排序部分，从而得到一个有序数组。</p><p><img src="https://oss.iuoyt.com/img/posts/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的整数数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 将当前元素插入到已排序部分的适当位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 向右移动已排序部分中大于当前元素的元素，为当前元素腾出插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入当前元素到适当位置</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="希尔排序（Shell-Sort）">希尔排序（Shell Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^{1.3})$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>希尔排序是插入排序的一种改进版本，也称为缩小增量排序。它的基本思想是将待排序的数组按照一定的增量分割成若干个子序列，对每个子序列分别进行插入排序，随着增量逐渐减小，每个子序列包含的元素越来越多，当增量减小至1时，整个数组被分成了一个子序列，此时进行的插入排序就是对整个数组的排序。希尔排序的关键在于选择增量序列，常用的增量序列有希尔增量序列、Hibbard增量序列等。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始增量设为数组长度的一半，逐渐减小增量直至1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对每个子序列进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 插入排序的过程，插入的间隔为当前增量gap</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="更多排序算法">更多排序算法</h2><h3 id="归并排序（Merge-Sort）">归并排序（Merge Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>归并排序将待排序数组分成两个子数组，对每个子数组进行递归地归并排序，然后将已排序的子数组合并成一个有序数组。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用辅助函数进行归并排序</span></span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，对指定范围的数组进行归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  数组的起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数组的结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 计算中间位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对左半部分进行归并排序</span></span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        <span class="comment">// 对右半部分进行归并排序</span></span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 合并左右两部分</span></span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，合并两个已排序的子数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  左子数组的起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid   左子数组的结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右子数组的结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算左右两部分的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> right - mid;</span><br><span class="line">    <span class="comment">// 创建临时数组存放左右两部分的元素</span></span><br><span class="line">    <span class="type">int</span>[] leftPart = <span class="keyword">new</span> <span class="title class_">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>[] rightPart = <span class="keyword">new</span> <span class="title class_">int</span>[n2];</span><br><span class="line">    <span class="comment">// 将元素拷贝到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">        leftPart[i] = arr[left + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n2; ++j) &#123;</span><br><span class="line">        rightPart[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftPart[i] &lt;= rightPart[j]) &#123;</span><br><span class="line">            arr[k] = leftPart[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = rightPart[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余元素拷贝到数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = leftPart[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = rightPart[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基数排序（Radix-Sort）">基数排序（Radix Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>基数排序按照低位先排序，然后收集；再按照高位排序，然后再次收集；依次类推，直到最高位。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数组中的最大值，用于确定排序的轮数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每一位进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">        countingSort(arr, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，获取数组中的最大值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，计数排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exp 当前位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> exp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j : arr) &#123;</span><br><span class="line">        count[(j / exp) % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将计数数组转换为前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前遍历原数组，根据计数数组将元素放到正确的位置上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        output[count[(arr[i] / exp) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[(arr[i] / exp) % <span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排好序的数组复制回原数组</span></span><br><span class="line">    System.arraycopy(output, <span class="number">0</span>, arr, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="桶排序（Bucket-Sort）">桶排序（Bucket Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>桶排序将待排序数组分割成若干个桶，然后对每个桶中的元素进行排序，最后按照顺序合并每个桶得到有序数组。</p><p><img src="https://oss.iuoyt.com/img/posts/%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="桶排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最大值和最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算桶的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> (max - min) / n + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (num - min) / n;</span><br><span class="line">        buckets.get(index).add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个桶中的元素进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        Collections.sort(bucket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将各个桶中的元素按照顺序依次取出，组成有序序列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : bucket) &#123;</span><br><span class="line">            arr[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">一些在算法中经常见到的使用的排序方法。</summary>
    
    
    
    <category term="算法" scheme="https://www.iuoyt.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://www.iuoyt.com/tags/Java/"/>
    
    <category term="排序" scheme="https://www.iuoyt.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="算法" scheme="https://www.iuoyt.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Stable Diffusion】如何借助AI完成绘画？</title>
    <link href="https://www.iuoyt.com/posts/731a4ede.html"/>
    <id>https://www.iuoyt.com/posts/731a4ede.html</id>
    <published>2024-01-28T02:53:44.000Z</published>
    <updated>2024-02-01T05:29:57.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AI绘画概述">AI绘画概述</h2><h3 id="绘图过程（Diffusion扩散）">绘图过程（Diffusion扩散）</h3><ol><li><p>条件输入</p><p>常用的文生图（txt2img）中首先要做的就是输入提示词了，这些输入的提示词会在SD WebUI内置的文本编码器（TextEncoder）中被编码为数字，使其可以被AI看懂，然后送入Text Transformer得到生图条件。</p></li><li><p>随机种子</p><p>开始生成前会随机获得一串数字，用于形成一幅随机的噪声图，作为AI绘图的“画板”。如下是一张256×256的RGB随机噪声图。</p><p><img src="https://oss.iuoyt.com/img/posts/20210520111319319.jpg" alt="随机噪声图"></p></li><li><p>图像生成（去噪）</p><p>在潜空间（Latent Space）中，AI会根据输入条件对噪声图进行去噪，即“采样”，经过多次的反复去噪，最后形成一张压缩过的“成品图”。</p><p><img src="https://oss.iuoyt.com/img/posts/92cd2b8f466bd891f92dd7ac4e8d33a57b1c42ca.png@1256w_170h_!web-article-pic.avif" alt="图像采样"></p></li><li><p>变分自编码器（VAE）</p><p>这一步是将潜空间中被压缩的“成品图”扩大成为我们可以看到的正常图片</p></li></ol><blockquote><p><img src="https://oss.iuoyt.com/img/posts/e541253f8201748cffeb3850ffeb2a4bbe866f7f.png@1256w_706h_!web-article-pic.avif" alt="img"></p><p>图源：<a href="https://www.bilibili.com/read/cv21564981">秋葉aaaki - Bilibili</a></p></blockquote><h3 id="Stable-Diffusion">Stable Diffusion</h3><p>目前市面上已经有了许多的用于AI绘画的平台，例如DALL·E、MidJourney、NovelAI，2022年8月，Stable Diffusion诞生了，无需极为强劲的性能就可以运行在日常使用的电脑上。并且由于其全面开源的特性，你可以在自己的电脑上直接完成部署，以及免费、不限量地生成AI绘画图片。</p><p>AUTOMATIC1111将开源的Stable Diffusion做成了一款可以在浏览器中直接操作的“应用”，即<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">Stable Diffusion web UI</a>，借助它，可以将原本繁琐的代码层面的参数调校集成到一个Web页面中，通过WebUI，还可以使用到许多已发布的拓展插件。</p><h3 id="安装">安装</h3><p>B站的<a href="https://space.bilibili.com/12566101">秋葉aaaki</a>老师将Stable Diffusion WebUI以及其所需环境都合并为了整合包，无需安装git、python、cuda等任何内容，无需任何配置，解压就可以使用，安装方式详见视频：<a href="https://www.bilibili.com/video/BV1iM4y1y7oA">秋葉aaaki - Stable Diffusion整合包</a></p><p>安装完成WebUI本体，以及后续可能会用到的模型等，占用空间可能达到甚至150-200G，所以要注意存放位置哦。</p><h2 id="一些概念">一些概念</h2><h3 id="模型（Model）">模型（Model）</h3><p>模型是AI在绘画过程中的参考，是由大量的图像经由AI深度学习训练得出的成果。借助模型，可以让AI完成某一类效果的绘制实现，是AI绘图过程中极其重要的一个部分。文件大小一般在几个G不等，文件后缀为<code>.safetensors</code>、<code>.ckpt</code>。</p><p>国内外有许多优秀的模型站点，诸如<a href="https://huggingface.co/">Hugging Face</a>、<a href="https://civitai.com/">Civitai</a>，都是囊括了大量模型的宝库。</p><blockquote><p>一些常见实用模型：</p><ul><li><p>二次元风格</p><p>关键词：illustration, painting, sketch, drawing, painting, comic, anime, catoon</p><ul><li><a href="https://civitai.com/models/9409">Anything</a></li><li><a href="https://civitai.com/models/1274">Dreamlike Diffusion</a></li><li><a href="https://civitai.com/models/4468">Counterfeit</a></li><li><a href="https://civitai.com/models/4437">AbyssOrangeMix2</a></li></ul></li><li><p>2.5D风格</p><p>关键词：photography, photo, realistic, photorealistic, RAW photo</p><ul><li><a href="https://civitai.com/models/10415">国风3 GuoFeng3</a></li><li><a href="https://civitai.com/models/3816/protogen-x53-photorealism-official-release">Protogen</a></li><li><a href="https://civitai.com/models/10028">NeverEnding Dream (NED)</a></li></ul></li><li><p>真实系风格</p><p>关键词：3D, render, chibi, digital art, concept art, {realistic}</p><ul><li><a href="https://civitai.com/models/9052">LOFI</a></li><li><a href="https://civitai.com/models/5585/deliberate-for-invoke">Deliberate for Invoke</a></li><li><a href="https://civitai.com/models/4201">Realistic Vision</a></li></ul></li><li><p>其他</p><ul><li><a href="https://civitai.com/models/50696">QteaMix 通用Q版模型</a></li></ul></li></ul></blockquote><h3 id="词嵌入（Embeddings）">词嵌入（Embeddings）</h3><p>也写作Textual Inversion（文本倒置），作用是给AI解释部分字、词的含义。这些内容可能是难以理解的多词组合，或者是特定形象的呈现描述，可以理解为用已知的内容描述未知的内容，或者一个字典的书签，一个数据的指针。文件大小通常在20~100K，文件后缀为<code>.pt</code>、<code>.safetensors</code>。</p><p>比如解决AI不会画手的问题，可以使用这些Embeddings处理：</p><ul><li><a href="https://civitai.com/models/7808">EasyNegative</a>（二次元）</li><li><a href="https://civitai.com/models/55700">bad_prompt Negative</a>（二次元）</li><li><a href="https://civitai.com/models/4629">Deep Negative</a>（真人）</li></ul><h3 id="低秩适应模型（LoRA）">低秩适应模型（LoRA）</h3><p>LoRA（Low-Rank Adaptation Models），用于向AI传递、描述一个特征准确、主体清晰的形象，可以理解为一张彩页，上面详细记载了某个特定呈现的细节、特点。文件大小通常在200M以内，文件后缀为<code>.safetensors</code>。</p><p>触发LoRA的方法：<code>&lt;lora:LoRA名称&gt;</code>，设置权重在0.5-0.8可以保留确切特征但减弱对画面风格的影响。某些LoRA还提供了特定的提示词以强化调用的效果，可以一并写在提示词内。</p><h3 id="超网络（Hypernetwork）">超网络（Hypernetwork）</h3><p>与LoRa类似，HyperNetwork一般用于改善生成图像的整体风格（画风），大小在200M以内，文件后缀为<code>.pt</code>。Hypernetwork与LoRA很像，它们都很小且仅修改cross-attention模块，区别在于后者是通过改变权重修改，而Hypernetwork则是通过插入额外的网络改动cross-attention模块。</p><h2 id="书写提示词">书写提示词</h2><ul><li>提示词（Prompt），可以让AI知道你希望它完成什么内容。尽管称为AI绘画，但它其实无法理解你与它描述的自然语言是什么意思，因此，需要给AI提供的内容则需要通过它可以理解的方式。</li><li>在SD中，提示词分为两个部分：正向提示词与反向提示词，顾名思义，AI会按照正向提示词去完成创作，但会尽量避免反向提示词中出现的内容。</li><li>提示词需要使用英文书写，并且是以词组构成，因此并非像是与人描述一样使用长的复杂句。词组之间使用半角逗号分隔。</li></ul><h3 id="正向提示词">正向提示词</h3><blockquote><p>注：以下内容均整理自<a href="https://www.bilibili.com/video/BV12X4y1r7QB/?p=2">20分钟搞懂Prompt与参数设置，你的AI绘画“咒语”学明白了吗？</a></p></blockquote><h4 id="内容型提示词">内容型提示词</h4><ol><li><p>人物及主题特征</p><ul><li><p>服饰穿搭：white dress</p></li><li><p>发型发色：blonde hair, long hair</p></li><li><p>五官特点：small eyes, big mouth</p></li><li><p>面部表情：smiling</p></li><li><p>肢体动作：stretching arms</p></li></ul></li><li><p>场景特征</p><ul><li><p>室内/室外：indoor / outdoor</p></li><li><p>大场景：forest, city, street</p></li><li><p>小细节：tree, bush, white flower</p></li></ul></li><li><p>环境光照</p><ul><li><p>白天/黑夜：day / night</p></li><li><p>特定时段：morning, sunset</p></li><li><p>光环境：sunlight, bright, dark</p></li><li><p>天空：blue sky, starry sky</p></li></ul></li><li><p>画幅视角</p><ul><li><p>距离：close-up, distant</p></li><li><p>人物比例：fullbody, upper body</p></li><li><p>观察视角：from above,view of back</p></li><li><p>镜头类型：wide angle, Sony A7 III</p></li></ul></li><li><p>其他画面要素</p></li><li><p>通用内容：</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SFW</span>, (masterpiece:<span class="number">1</span>,<span class="number">2</span>), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:<span class="number">1</span>.<span class="number">2</span>),</span><br></pre></td></tr></table></figure></li></ol><h4 id="标准化提示词">标准化提示词</h4><ol><li><p>画质</p><ul><li><p>通用高画质：best quality, ultra-detailed, masterpiece, hires, 8k</p></li><li><p>特定高分辨率类型：extremely detailed CG unity 8k wallpaper（超精细的8KUnity游戏CG），unreal engine rendered（虚幻引擎渲染）</p></li></ul></li><li><p>画风提示词</p><ul><li><p>插画风：llustration, painting, paintrush</p></li><li><p>二次元：anime, comic, game CG</p></li><li><p>写实系：photorealistic, realistic, photograph</p></li></ul></li><li><p>其他特殊要求</p></li></ol><h3 id="反向提示词">反向提示词</h3><blockquote><p>通用内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSFW</span>, (worst quality:<span class="number">2</span>), (low quality:<span class="number">2</span>), (normal quality:<span class="number">2</span>), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:<span class="number">1</span>.<span class="number">331</span>), (duplicate:<span class="number">1</span>.<span class="number">331</span>), (morbid:<span class="number">1</span>.<span class="number">21</span>), (mutilated:<span class="number">1</span>.<span class="number">21</span>), (tranny:<span class="number">1</span>.<span class="number">331</span>), mutated hands, (poorly drawn hands:<span class="number">1</span>.<span class="number">5</span>), blurry, (bad anatomy:<span class="number">1</span>.<span class="number">21</span>), (bad proportions:<span class="number">1</span>.<span class="number">331</span>), extra limbs, (disfigured:<span class="number">1</span>.<span class="number">331</span>), (missing arms:<span class="number">1</span>.<span class="number">331</span>), (extra legs:<span class="number">1</span>.<span class="number">331</span>), (fused fingers:<span class="number">1</span>.<span class="number">61051</span>), (too many fingers:<span class="number">1</span>.<span class="number">61051</span>), (unclear eyes:<span class="number">1</span>.<span class="number">331</span>), lowers, bad hands, missing fingers, extra digit,bad hands, missing fingers, (((extra arms and legs))),</span><br></pre></td></tr></table></figure></blockquote><ol><li><strong>图像质量描述：</strong><ul><li>Worst quality: 最差质量</li><li>Low quality: 低质量</li><li>Normal quality: 正常质量</li><li>Lowres: 低分辨率</li><li>Blurry: 模糊</li><li>Unclear eyes: 眼睛不清晰</li></ul></li><li><strong>皮肤瑕疵：</strong><ul><li>Skin spots: 皮肤斑点</li><li>Acnes: 痘痘</li><li>Skin blemishes: 皮肤瑕疵</li><li>Age spot: 老年斑</li></ul></li><li><strong>审美负面描述：</strong><ul><li>Ugly: 丑陋</li><li>Morbid: 病态</li><li>Mutilated: 残缺</li><li>Tranny: 涉及性别问题（潜在冒犯性）</li></ul></li><li><strong>绘画技巧问题：</strong><ul><li>Duplicate: 重复</li><li>Poorly drawn hands: 手绘不好</li><li>Bad anatomy: 解剖结构不准确</li><li>Bad proportions: 比例不准确</li><li>Extra limbs: 多余肢体</li><li>Disfigured: 形象被扭曲</li><li>Missing arms: 缺失手臂</li><li>Extra legs: 多余腿</li><li>Fused fingers: 手指融合</li><li>Too many fingers: 手指过多</li><li>Missing fingers: 缺失手指</li><li>Extra digit: 额外数字或手指</li><li>Bad hands: 手部描绘不好</li><li>Extra arms and legs: 额外手臂和腿</li></ul></li></ol><h3 id="权重配置">权重配置</h3><h4 id="基础设置">基础设置</h4><ul><li>圆括号<code>(prompt)</code>：×1.1（可叠加，每层叠加都 ×1.1）</li><li>括号+数字<code>(prompt:1.5)</code>：指定权重倍数</li><li>大括号<code>&#123;prompt&#125;</code>：×1.05（可叠加，每层叠加都 ×1.05）</li><li>中括号<code>[prompt]</code>：×0.9（可叠加，每层叠加都 ×0.9）</li></ul><h4 id="进阶设置">进阶设置</h4><ul><li><p>混合<code> a|b</code>：混合两个描述同一对象的提示词要素</p><p>【例】<code>white|yellow flower</code>：生成黄色和白色混合的花</p></li><li><p>迁移<code>[|]</code>：连续生成具有多个不同特征的对象，不断迁移</p><p>【例】<code>[white|red|blue] flower</code>：先生成白花，再生成红花，再生成蓝花。</p></li><li><p>迭代<code>(::)</code>：与采样进程关联，一定阶段以后再生成特定对象。</p><p>【例】<code>(white flower:bush:0.8)</code>：进程到达80%（0.8）之前生成白花，80%之后再生成灌木。</p><p>【例】<code>(white flower::0.8)</code>：进程到达80%（0.8）之前生成白花，80%之后删除该提示词。</p></li></ul><h2 id="生图配置">生图配置</h2><h3 id="采样迭代步数（Steps）">采样迭代步数（Steps）</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128162027645.png" alt="迭代步数"></p><p>如前面所说，AI在进行图像创作的过程中是经过了多次迭代的，这里设置的步数即是AI生图的迭代次数，一般设置在20-40，不同的模型、LoRA等一般有不同的推荐步数。通常迭代次数越多，产出的图像就会越清晰/细致，但生图时间也会更长。</p><h3 id="采样方法（Sampler）">采样方法（Sampler）</h3><p>采样方法就是AI生成图像时的特定算法，同样的种子和提示词在不同的采样方法下生出的图会也出现不同，通常模型、LoRA的作者会提供建议使用的采样方法，以达到可以实现的最好效果。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240128145326350.png" alt="采样方法"></p><ul><li>Euler系列（欧拉方法）：<ul><li>Euler：中规中矩、简单直接、不易出错</li><li>Euler a：Euler的前代，多样性较高</li><li>LMS：Euler的衍生版本，但容易出现色块</li></ul></li><li>Heun：Eular的改进算法，在每一步中预测两次噪声，速度比Eular慢一倍</li><li>DPM系列：<ul><li>DPM fast：细节少，质量较低</li><li>DPM adaptive：无视迭代步数，质量较高但时间较长</li><li>DPM2：DPM的2代算法，质量比1代高但速度很慢，可以使用1代增加迭代步数替代</li><li>后缀：<ul><li>a：前代算法，祖先采样器，每一步都会产生新的噪点，生成更多样</li><li>2S：单步算法</li><li>2M：二阶多步采样算法，相当于2S的进阶</li><li>3M：与2M类似，但需要更多的迭代步数，效果会更好一些</li><li>SDE：将OED（常微分方程）求解器更换为SDE（随机微分方程）的版本</li><li>Karras：Karras算法，噪点收敛速度不断降低（收敛步长缩短），可以在更高迭代数量下提高图像质量</li><li>Huen：Euler改进算法，质量更好，但速度慢</li><li>Exponential：画面更柔和，但细节更少</li></ul></li></ul></li><li>UniPC：2023年新推出的算法，10步以内即可生成高质量图像</li></ul><p>总结：</p><ol><li>简单快捷：Eular、Heun</li><li>性价比高（兼顾质量和速度）：DPM++ 2M Karras (20 -30步) 、UNIPC （15-25步）</li><li>质量较高：DPM++ SDE Karras</li><li>稳定复现：不选后缀a / SDE，反之则追求多样性</li></ol><h3 id="提示词相关性（CFG-Scale）">提示词相关性（CFG Scale）</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161245013.png" alt="提示词相关性"></p><p>引导AI按照提示词绘制的程度，推荐7~12，如果过高会出现变形。</p><h3 id="种子（Seed）">种子（Seed）</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161429602.png" alt="随机种子"></p><p>控制噪声图的产生，以控制画面内容一致性</p><h3 id="出图尺寸">出图尺寸</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128160404946.png" alt="出图分辨率"></p><p>即生成图像的分辨率，默认为512×512，对设备（显存）要求较高。由于模型训练数据都比较小，因此将尺寸设置过高会出现多人的情况，最高在1000上下即可。这样生成的图像较为模糊，可以通过高清修复、后期处理、图生图等方式放大图像。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161005363.png" alt="高清修复"></p><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161040438.png" alt="后期处理"></p><h3 id="生成批次">生成批次</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161630533.png" alt="生成批次"></p><p>AI绘画具有不确定性，可以让AI在一组提示词下一次性生成多张图片。（来一发十连抽）</p><blockquote><h2 id="参考资料">参考资料</h2><ol><li><a href="https://www.bilibili.com/read/cv21564981">【AI绘画】大魔导书：AI 是如何绘画的？Stable Diffusion 原理全解（一）</a></li><li><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">What are Diffusion Models?</a></li><li><a href="https://space.bilibili.com/1814756990/channel/collectiondetail?sid=1285674">合集·B站第一套Stable Diffusion系统课程，来了！</a></li><li><a href="https://www.bilibili.com/read/cv26536525/">Stable Diffusion 30种采样方法全解析</a></li><li><a href="https://blog.csdn.net/lizhong2008/article/details/132278253">AI 绘画Stable Diffusion 研究（八）sd采样方法详解_sd采样方法有什么区别-CSDN博客</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">Stable Diffusion是一款开源AI绘画工具，这篇文章介绍了部分AI绘画的原理和概念。</summary>
    
    
    
    <category term="AI绘画" scheme="https://www.iuoyt.com/categories/AI%E7%BB%98%E7%94%BB/"/>
    
    
    <category term="Stable Diffusion" scheme="https://www.iuoyt.com/tags/Stable-Diffusion/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型模式</title>
    <link href="https://www.iuoyt.com/posts/3194e4c1.html"/>
    <id>https://www.iuoyt.com/posts/3194e4c1.html</id>
    <published>2023-12-29T06:06:54.000Z</published>
    <updated>2023-12-29T10:03:50.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a></li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a> 📍当前位置</li></ol></blockquote><h2 id="职责链模式-Chain-of-Responsibility">职责链模式(Chain of Responsibility)</h2><div class="tip "><p><strong>定义</strong>：</p><p>避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。</p></div><h3 id="模式结构">模式结构</h3><h4 id="结构图">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155049439.png" alt="image-20231229155049439"></p><h4 id="实现代码">实现代码</h4><ul><li><p>抽象处理者（Handler）</p><p>它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。每一个处理者的下家还是一个处理者，故在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor）作为其对下家的引用，通过该引用处理者可以连成一条链。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">//维持对下家的引用</span></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor=successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体处理者（ConcreteHandler）</p><p>它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中的下一个对象，以便请求的转发。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (请求满足条件) &#123;</span><br><span class="line">            <span class="comment">//处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//转发请求</span></span><br><span class="line">            <span class="built_in">this</span>.successor.handleRequest(request); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例">应用实例</h3><blockquote><p>某企业的SCM(供应链管理)系统中包含一个采购审批子系统。该企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元及以上的采购单就需要开董事会讨论决定。如下图所示：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155356119.png" alt="采购单分级审批示意图"></p><p>现使用职责链模式设计并实现该系统。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155417392.png" alt="image-20231229155417392"></p><ul><li>抽象处理者（抽象传递者）：<code>PurchaseRequest</code></li><li>具体处理者（具体传递者）：<code>Director</code>、<code>VicePresident</code>、<code>President</code>、<code>Congress</code></li><li>请求类：<code>PurchaseRequest</code></li></ul><h3 id="特点及使用环境">特点及使用环境</h3><h4 id="优点">优点</h4><ol><li>使得一个对象无须知道是其他哪一个对象处理其请求，降低了系统的耦合度</li><li>可简化对象之间的相互连接</li><li>给对象职责的分配带来更多的灵活性</li><li>增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可</li></ol><h4 id="缺点">缺点</h4><ol><li>不能保证请求一定会被处理</li><li>对于比较长的职责链，系统性能将受到一定影响，在进行代码调试时不太方便</li><li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环</li></ol><h4 id="适用环境">适用环境</h4><ol><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li><li>可动态指定一组对象处理请求</li></ol><h2 id="命令模式-Command">命令模式(Command)</h2><div class="tip "><p><strong>定义</strong>：</p><p>将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155739538.png" alt="image-20231229155739538"></p><h3 id="模式结构-2">模式结构</h3><h4 id="结构图-2">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155808876.png" alt="image-20231229155808876"></p><h4 id="实现代码-2">实现代码</h4><ul><li><p>抽象命令类（Command）</p><p>抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体命令类（ConcreteCommand）</p><p>具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现<code>execute()</code>方法时将调用接收者对象的相关操作(Action)。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver; <span class="comment">//维持一个对请求接收者对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action(); <span class="comment">//调用请求接收者的业务处理方法action()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用者（Invoker）</p><p>调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的<code>execute()</code>方法，从而实现间接调用请求接收者的相关操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设值注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务方法，用于调用命令类的execute()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收者（Receiver）</p><p>接收者执行与请求相关的操作，具体实现对请求的业务处理。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-2">应用实例</h3><blockquote><p>为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton可以用于退出系统（由SystemExitClass类来实现），也可以用于显示帮助文档（由DisplayHelpClass类来实现）。</p><p>用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229160222136.png" alt="image-20231229160222136"></p><ul><li>请求调用者：<code>FunctionButton</code></li><li>请求接收者：<code>SystemExitClass</code>、<code>DisplayHelpClass</code></li><li>抽象命令类：<code>Command</code></li><li>具体命令者：<code>ExitCommand</code>、<code>HelpCommand</code></li></ul><h3 id="模式变化">模式变化</h3><h4 id="实现命令队列">实现命令队列</h4><ul><li>实现动机：<ul><li>当一个请求发送者发送一个请求时，有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理</li><li>增加一个CommandQueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者</li><li>批处理</li></ul></li></ul><h4 id="记录请求日志">记录请求日志</h4><ul><li><p>实现动机：</p><p>将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中</p><ul><li>为系统提供一种恢复机制</li><li>可以用于实现批处理</li><li>防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行</li></ul></li></ul><h4 id="实现撤销操作">实现撤销操作</h4><ul><li>可以通过对命令类进行修改使得系统支持撤销(Undo)操作和恢复(Redo)操作</li></ul><h4 id="宏命令">宏命令</h4><ul><li>宏命令又称为组合命令，它是组合模式和命令模式联用的产物</li><li>宏命令是一个具体命令类，它拥有一个集合，在该集合中包含了对其他命令对象的引用</li><li>当调用宏命令的<code>execute()</code>方法时，将递归调用它所包含的每个成员命令的<code>execute()</code>方法。一个宏命令的成员可以是简单命令，还可以继续是宏命令</li><li>执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理</li></ul><h3 id="特点及使用环境-2">特点及使用环境</h3><h4 id="优点-2">优点</h4><ol><li>降低系统的耦合度</li><li>新的命令可以很容易地加入到系统中，符合开闭原则</li><li>可以比较容易地设计一个命令队列或宏命令（组合命令）</li><li>为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案</li></ol><h4 id="缺点-2">缺点</h4><ol><li>使用命令模式可能会导致某些系统有过多的具体命令类（针对每一个对请求接收者的调用操作都需要设计一个具体命令类）</li></ol><h4 id="适用环境-2">适用环境</h4><ol><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作</li><li>系统需要将一组操作组合在一起形成宏命令</li></ol><h2 id="解释器模式-Interpreter">解释器模式(Interpreter)</h2><div class="tip "><p><strong>定义</strong>：</p><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></div><h3 id="模式结构-3">模式结构</h3><h4 id="结构图-3">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229175727479.png" alt="image-20231229175727479"></p><h4 id="实现代码-3">实现代码</h4><ul><li><p>抽象表达式（AbstractExpression）</p><p>在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>终结符表达式（TerminalExpression）</p><p>终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminalExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;</span><br><span class="line">        <span class="comment">//终结符表达式的解释操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非终结符表达式（NonterminalExpression）</p><p>非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式完成。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NonterminalExpression</span><span class="params">(AbstractExpression left,AbstractExpression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left=left;</span><br><span class="line">        <span class="built_in">this</span>.right=right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;</span><br><span class="line">        <span class="comment">//递归调用每一个组成部分的interpret()方法</span></span><br><span class="line">        <span class="comment">//在递归调用时指定组成部分的连接方式，即非终结符的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环境类（Context）</p><ul><li>用于存储一些全局信息，一般包含一个HashMap或ArrayList等类型的集合对象（也可以直接由HashMap等集合类充当环境类），存储一系列公共信息，例如变量名与值的映射关系(key/value)等，用于在执行具体的解释操作时从中获取相关信息</li><li>可以在环境类中增加一些所有表达式解释器都共有的功能，以减轻解释器的职责</li><li>当系统无须提供全局公共信息时可以省略环境类，根据实际情况决定是否需要环境类</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="comment">//往环境类中设值</span></span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">lookup</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">//获取存储在环境类中的值</span></span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-3">应用实例</h3><blockquote><p>某软件公司要开发一套机器人控制程序，在该机器人控制程序中包含一些简单的英文控制指令，每一个指令对应一个表达式(expression)，该表达式可以是简单表达式也可以是复合表达式。每一个简单表达式由移动方向(direction)，移动方式(action)和移动距离(distance)三部分组成，其中，移动方向包括向上(up)、向下(down)、向左(left)、向右(right)；移动方式包括移动(move)和快速移动(run)；移动距离为一个正整数。两个表达式之间可以通过与(and)连接，形成复合(composite)表达式。</p><p>用户通过对图形化的设置界面进行操作可以创建一个机器人控制指令，机器人在收到指令后将按照指令的设置进行移动，例如输入控制指令“up move 5”将“向上移动5个单位”；输入控制指令“down run 10 and left move 20”将“向下快速移动10个单位再向左移动20个单位”。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229180138141.png" alt="image-20231229180138141"></p><ul><li>抽象表达式角色：<code>AbstractNode</code></li><li>终结符表达式角色：<code>DirectionNode</code>、<code>ActionNode</code>、<code>DistanceNode</code></li><li>非终结符表达式角色：<code>AndNode</code>、<code>SentenceNode</code></li></ul><h3 id="特点及使用环境-3">特点及使用环境</h3><h4 id="优点-3">优点</h4><ol><li>易于改变和扩展文法</li><li>可以方便地实现一个简单的语言</li><li>实现文法较为容易（有自动生成工具）</li><li>增加新的解释表达式较为方便</li></ol><h4 id="缺点-3">缺点</h4><ol><li>对于复杂文法难以维护</li><li>执行效率较低</li></ol><h4 id="适用环境-3">适用环境</h4><ol><li>可以将一个需要解释执行的语言中的句子表示为一棵抽象语法树</li><li>一些重复出现的问题可以用一种简单的语言来进行表达</li><li>一个语言的文法较为简单</li><li>执行效率不是关键问题</li></ol><h2 id="迭代器模式★-Iterator">迭代器模式★(Iterator)</h2><div class="tip "><p><strong>定义</strong>：</p><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示。</p></div><h3 id="模式结构-4">模式结构</h3><h4 id="结构图-4">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229140926871.png" alt="image-20231229140926871"></p><h4 id="实现代码-4">实现代码</h4><ul><li><p>抽象迭代器（Iterator）</p><p>它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如用于获取第一个元素的<code>first()</code>方法、用于访问下一个元素的<code>next()</code>方法、用于判断是否还有下一个元素的<code>hasNext()</code>方法、用于获取当前元素的<code>currentItem()</code>方法等， 在具体迭代器中将实现这些方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">//将游标指向第一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//将游标指向下一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//判断是否存在下一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取游标指向的当前元素</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体迭代器（ConcreteIterator）</p><p>它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时游标通常是一个表示位置的非负整数。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据</span></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate objects; </span><br><span class="line">    <span class="comment">//定义一个游标，用于记录当前访问位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(ConcreteAggregate objects)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.objects=objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象聚合类（Aggregate）</p><p>它用于存储和管理元素对象，声明一个<code>createlterator() </code>方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    Iterator <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体聚合类（ConcreteAggregate）</p><p>它是抽象聚合类的子类，实现了在抽象聚合类中声明的<code>createlterator()</code>方法，该方法返回一个与该具体聚合类对应的具体迭代器 ConcreteIterator 实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-4">应用实例</h3><blockquote><p>某软件公司为某商场开发了一套销售管理系统，在对该系统进行分析和设计时，开发人员发现经常需要对系统中的商品数据、客户数据等进行遍历，为了复用这些遍历代码，开发人员设计了一个抽象的数据集合类AbstractObjectList，将存储商品和客户等数据的类作为其子类，AbstractObjectList类结构如下图所示：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229142811224.png" alt="AbstractObjectList类结构图"></p><p>在图中，List类型的对象objects用于存储数据，其方法与说明如下表所示：</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>方法说明</strong></th></tr></thead><tbody><tr><td>AbstractObjectList()</td><td>构造方法，用于给objects对象赋值</td></tr><tr><td>addObject()</td><td>增加元素</td></tr><tr><td>removeObject()</td><td>删除元素</td></tr><tr><td>getObjects()</td><td>获取所有元素</td></tr><tr><td>next()</td><td>移至下一个元素</td></tr><tr><td>isLast()</td><td>判断当前元素是否是最后一个元素</td></tr><tr><td>previous()</td><td>移至上一个元素</td></tr><tr><td>isFirst()</td><td>判断当前元素是否是第一个元素</td></tr><tr><td>getNextItem()</td><td>获取下一个元素</td></tr><tr><td>getPreviousItem()</td><td>获取上一个元素</td></tr></tbody></table><p>AbstractObjectList类的子类ProductList和CustomerList分别用于存储商品数据和客户数据。</p><p>通过分析，发现AbstractObjectList类的职责非常重，它既负责存储和管理数据，又负责遍历数据，违背了单一职责原则，实现代码将非常复杂。因此，开发人员决定使用迭代器模式对AbstractObjectList类进行重构，将负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，还可以给不同的具体数据集合类提供不同的遍历方式。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229143108928.png" alt="image-20231229143108928"></p><ul><li>抽象聚合类：<code>AbstractObjectList</code></li><li>具体聚合类：<code>ProductList</code></li><li>抽象迭代器：<code>AbstractIterator</code></li><li>具体迭代器：<code>ProductIterator</code></li></ul><h3 id="特点及使用环境-4">特点及使用环境</h3><h4 id="优点-4">优点</h4><ol><li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式</li><li>简化了聚合类</li><li>由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则</li></ol><h4 id="缺点-4">缺点</h4><ol><li>在增加新的聚合类时需要对应地增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是一件很容易的事情</li></ol><h4 id="适用环境-4">适用环境</h4><ol><li>访问一个聚合对象的内容而无须暴露它的内部表示</li><li>需要为一个聚合对象提供多种遍历方式</li><li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口</li></ol><h2 id="中介者模式✲">中介者模式✲</h2><h2 id="备忘录模式✲">备忘录模式✲</h2><h2 id="观察者模式★-Observer">观察者模式★(Observer)</h2><div class="tip "><p><strong>定义</strong>：</p><p>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。</p></div><h3 id="模式结构-5">模式结构</h3><h4 id="结构图-5">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229143706930.png" alt="image-20231229143706930"></p><h4 id="实现代码-5">实现代码</h4><ul><li><p>目标（Subject）</p><p>目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法<code>notify()</code>。目标类可以是接口，也可以是抽象类或具体类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个观察者集合用于存储所有观察者对象</span></span><br><span class="line">    <span class="keyword">protected</span> ArrayList observers&lt;Observer&gt; = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//注册方法，用于向观察者集合中增加一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注销方法，用于在观察者集合中删除一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象通知方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体目标（ConcreteSubject）</p><p>具体目标是目标类的子类，它通常包含有经常发生改变的数据，当它的状态发生改变时将向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有）。如果无须扩展目标类，则具体目标类可以省略。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//实现通知方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//遍历观察者集合，调用每一个观察者的响应方法</span></span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers) &#123;</span><br><span class="line">            ((Observer)obs).update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>观察者（Observer）</p><p>观察者将对观察目标的改变作出反应，观察者一般定义为接口，该接口声明了更新数据的方法<code>update()</code>，因此又称为抽象观察者。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//声明响应方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体观察者（ConcreteObserver）</p><p>在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的<code>update()</code>方法。通常在实现时可以调用具体目标类的<code>attach()</code>方法将自己添加到目标类的集合中或通过<code>detach()</code>方法将自己从目标类的集合中 删除。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//实现响应方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体响应代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-5">应用实例</h3><blockquote><p>在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。</p><p>现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229144428657.png" alt="image-20231229144428657"></p><ul><li>抽象目标类：<code>AllyCOntrolCenter</code></li><li>具体目标类：<code>ConcreteAllyControlCenter</code></li><li>抽象观察者：<code>Observer</code></li><li>具体观察者：<code>Player</code></li></ul><h3 id="特点及使用环境-5">特点及使用环境</h3><h4 id="优点-5">优点</h4><ol><li>可以实现表示层和数据逻辑层的分离</li><li>在观察目标和观察者之间建立一个抽象的耦合</li><li>支持广播通信，简化了一对多系统设计的难度</li><li>符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便</li></ol><h4 id="缺点-5">缺点</h4><ol><li>将所有的观察者都通知到会花费很多时间</li><li>如果存在循环依赖时可能导致系统崩溃</li><li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化</li></ol><h4 id="适用环境-5">适用环境</h4><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用</li><li>一个对象的改变将导致一个或多个其他对象发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁</li><li>需要在系统中创建一个触发链</li></ol><h2 id="状态模式☒">状态模式☒</h2><h2 id="策略模式☒">策略模式☒</h2><h2 id="模板方法模式☒">模板方法模式☒</h2><h2 id="访问者模式✲">访问者模式✲</h2>]]></content>
    
    
    <summary type="html">行为型模式关注对象之间的责任分配和通信。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型模式</title>
    <link href="https://www.iuoyt.com/posts/b6c6dbc4.html"/>
    <id>https://www.iuoyt.com/posts/b6c6dbc4.html</id>
    <published>2023-12-29T04:51:37.000Z</published>
    <updated>2023-12-29T10:05:03.370Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a> 📍当前位置</li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a></li></ol></blockquote><h2 id="结构型模式">结构型模式</h2><ul><li>结构型模式关注如何将现有类或对象组织在一起形成更加强大的结构。</li><li>不同的结构型模式从不同的角度组合类或对象，它们在尽可能满足各种面向对象设计原则的同时为类或对象的组合提供一系列巧妙的解决方案。</li></ul><h2 id="适配器模式-Adapter">适配器模式(Adapter)</h2><div class="tip "><p><strong>定义</strong>：</p><p>将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p></div><h3 id="模式结构">模式结构</h3><h4 id="结构图">结构图</h4><ul><li><p>类适配器</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229132413600.png" alt="类适配器"></p></li><li><p>对象适配器</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229132448870.png" alt="对象适配器"></p></li></ul><h4 id="实现代码">实现代码</h4><ul><li><p>目标抽象类（Target）</p><p>目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。在类适配器中，由于Java语言不支持多重继承，它只能是接口。</p></li><li><p>适配器类（Adapter）</p><p>它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器Adapter是适配器模式的核心，在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p><ul><li><p>类适配器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象适配器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个对适配者对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//转发调用</span></span><br><span class="line">        adaptee.specificRequest(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>适配者类（Adaptee）</p><p>适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的源代码。</p></li></ul><h3 id="应用实例">应用实例</h3><blockquote><p>某公司欲开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁（例如警灯闪烁）和声音提示（例如警笛音效）的程序，为了重用先前的代码并且使得汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229133559453.png" alt="image-20231229133559453"></p><ul><li>抽象目标：<code>CarController</code></li><li>适配者：<code>PoliceSound</code>、<code>PoliceLamp</code></li><li>适配器：<code>PoliceCarAdapter</code></li></ul><h3 id="特点及使用环境">特点及使用环境</h3><h4 id="优点">优点</h4><ol><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li><li>增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li><li>灵活性和扩展性非常好</li><li>类适配器模式：置换一些适配者的方法很方便</li><li>对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类</li></ol><h4 id="缺点">缺点</h4><ol><li>类适配器模式：<ol><li>一次最多只能适配一个适配者类，不能同时适配多个适配者</li><li>适配者类不能为最终类</li><li>目标抽象类只能为接口，不能为类</li></ol></li><li>对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦</li></ol><h4 id="适用环境">适用环境</h4><ol><li>系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码</li><li>创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作</li></ol><h2 id="桥接模式☒">桥接模式☒</h2><h2 id="组合模式★-Composite">组合模式★(Composite)</h2><div class="tip "><p><strong>定义</strong>：</p><p>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。</p></div><h3 id="模式结构-2">模式结构</h3><h4 id="结构图-2">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229125805145.png" alt="image-20231229125805145"></p><h4 id="实现代码-2">实现代码</h4><ul><li><p>抽象构件（Component）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">//增加成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span>; </span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span>;</span><br><span class="line">    <span class="comment">//获取成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>; </span><br><span class="line">    <span class="comment">// 业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>叶子构件（Leaf）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">( <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//叶子构件具体业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>容器构件（Composite）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.* ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList &lt;Component&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span> &lt;Component&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Component)list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//容器构件具体业务方法的实现，将递归调用成员构件的业务方法</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj:list) &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-2">应用实例</h3><blockquote><p>某软件公司欲开发一个杀毒(Antivirus)软件，该软件既可以对某个文件夹(Folder)杀毒，也可以对某个指定的文件(File)进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件(ImageFile)和文本文件(TextFile)的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229130502078.png" alt="image-20231229130502078"></p><ul><li>抽象构件：<code>AbstractFile</code></li><li>容器构件：<code>Folder</code></li><li>叶子构件：<code>ImageFile</code>、<code>TextFile</code>、<code>VideoFile</code></li></ul><h3 id="模式变化">模式变化</h3><h4 id="透明组合模式">透明组合模式</h4><ul><li><p>抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getChild()等方法</p></li><li><p>在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象</p></li><li><p>缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229130843722.png" alt="image-20231229130843722"></p></li></ul><h4 id="安全组合模式">安全组合模式</h4><ul><li><p>抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法</p></li><li><p>对于叶子对象，客户端不可能调用到这些方法</p></li><li><p>缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229130915270.png" alt="image-20231229130915270"></p></li></ul><h3 id="特点及使用环境-2">特点及使用环境</h3><h4 id="优点-2">优点</h4><ol><li>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码</li><li>增加新的容器构件和叶子构件都很方便，符合开闭原则</li><li>为树形结构的面向对象实现提供了一种灵活的解决方案</li></ol><h4 id="缺点-2">缺点</h4><ol><li>在增加新构件时很难对容器中的构件类型进行限制</li></ol><h4 id="适用环境-2">适用环境</h4><ol><li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们</li><li>在一个使用面向对象语言开发的系统中需要处理一个树形结构</li><li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型</li></ol><h2 id="装饰模式✲">装饰模式✲</h2><h2 id="外观模式★-Facade">外观模式★(Facade)</h2><div class="tip "><p><strong>定义</strong>：</p><p>为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231229131346810.png" alt="image-20231229131346810"></p><h3 id="模式结构-3">模式结构</h3><h4 id="结构图-3">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229131357167.png" alt="image-20231229131357167"></p><h4 id="实现代码-3">实现代码</h4><ul><li><p>外观角色（Facade）</p><p>在客户端可以调用它的方法，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemA</span> <span class="variable">objl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemB</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemC</span> <span class="variable">obj3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemC</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        objl.methodA();</span><br><span class="line">        obj2.methodB();</span><br><span class="line">        obj3.methodC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子系统角色（SubSystem）</p><p>在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-3">应用实例</h3><blockquote><p>某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229131857710.png" alt="image-20231229131857710"></p><ul><li>外观类：<code>EncryptFacade</code></li><li>子系统类：<code>FileReader</code>、<code>CipherMachine</code>、<code>FileWriter</code></li></ul><h3 id="特点及使用环境-3">特点及使用环境</h3><h4 id="优点-3">优点</h4><ol><li>它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易</li><li>它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li><li>一个子系统的修改对其他子系统没有任何影响，而且子系统的内部变化也不会影响到外观对象</li></ol><h4 id="缺点-3">缺点</h4><ol><li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则</li></ol><h4 id="适用环境-3">适用环境</h4><ol><li>要为访问一系列复杂的子系统提供一个简单入口</li><li>客户端程序与多个子系统之间存在很大的依赖性</li><li>在层次化结构中，可以使用外观模式的定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度</li></ol><h2 id="享元模式☒">享元模式☒</h2><h2 id="代理模式-Proxy">代理模式(Proxy)</h2><div class="tip "><p><strong>定义</strong>：</p><p>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p></div><h3 id="模式结构-4">模式结构</h3><h4 id="结构图-4">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229144858539.png" alt="image-20231229144858539"></p><h4 id="实现代码-4">实现代码</h4><ul><li><p>抽象主题角色（Subject）</p><p>它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理主题角色（Proxy）</p><p>它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个对真实主题对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RealSubject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        preRequest();</span><br><span class="line">        <span class="comment">//调用真实主题对象的方法</span></span><br><span class="line">        realSubject.request();  </span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真实主题角色（RealSubject）</p><p>它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法具体实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-4">应用实例</h3><blockquote><p>某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本需求如下：</p><p>(1) 在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统；</p><p>(2) 在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。</p><p>该软件公司开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229145241223.png" alt="image-20231229145241223"></p><ul><li>抽象主题角色：<code>Searcher</code></li><li>真实主题角色：<code>RealSearcher</code></li><li>代理主题角色：<code>ProxySearcher</code></li><li>其他业务类：<ul><li><code>AccessValidator</code>：验证用户身份</li><li><code>Logger</code>：记录用户查询日志</li></ul></li></ul><h3 id="模式变化-2">模式变化</h3><h4 id="远程代理">远程代理</h4><ul><li><p>客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速地响应并处理客户端的请求</p></li><li><p>可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在</p></li><li><p>客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229145646331.png" alt="image-20231229145646331"></p></li></ul><h4 id="虚拟代理">虚拟代理</h4><ul><li>对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理</li><li>在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象</li><li>使用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能</li></ul><h4 id="Java动态代理">Java动态代理</h4><ul><li>动态代理可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法</li><li>Java语言提供了对动态代理的支持，Java语言实现动态代理时需要用到位于<code>java.lang.reflect</code>包中的一些类<ul><li>Proxy类<ul><li><code>public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code>：该方法用于返回一个Class类型的代理类，在参数中需要提供类加载器并需要指定代理的接口数组（与真实主题类的接口列表一致）</li><li><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>：该方法用于返回一个动态创建的代理类的实例，方法中第一个参数loader表示代理类的类加载器，第二个参数interfaces表示代理类所实现的接口列表（与真实主题类的接口列表一致），第三个参数h表示所指派的调用处理程序类</li></ul></li><li>InvocationHandler接口<ul><li>InvocationHandler接口是代理处理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用处理者（InvocationHandler接口的子类）</li><li><code>public Object invoke(Object proxy, Method method, Object[] args)</code>：该方法用于处理对代理类实例的方法调用并返回相应的结果，当一个代理实例中的业务方法被调用时将自动调用该方法。invoke()方法包含三个参数，其中第一个参数proxy表示代理类的实例，第二个参数method表示需要代理的方法，第三个参数args表示代理方法的参数数组</li></ul></li></ul></li><li>动态代理类需要在运行时指定所代理真实主题类的接口，客户端在调用动态代理对象的方法时，调用请求会将请求自动转发给InvocationHandler对象的<code>invoke()</code>方法，由<code>invoke()</code>方法来实现对请求的统一处理。</li></ul><h3 id="特点及使用环境-4">特点及使用环境</h3><h4 id="优点-4">优点</h4><ol><li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性</li><li>各代理方式：<ol><li>远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率</li><li>虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销</li><li>缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间</li><li>保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限</li></ol></li></ol><h4 id="缺点-4">缺点</h4><ol><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理）</li><li>实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理）</li></ol><h4 id="适用环境-4">适用环境</h4><ol><li>当客户端对象需要访问远程主机中的对象时可以使用远程代理</li><li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理</li><li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理</li><li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理</li><li>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理</li></ol>]]></content>
    
    
    <summary type="html">结构型模式关注如何组合类和对象以形成更大的结构。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深克隆与浅克隆</title>
    <link href="https://www.iuoyt.com/posts/316792e4.html"/>
    <id>https://www.iuoyt.com/posts/316792e4.html</id>
    <published>2023-12-28T06:58:15.000Z</published>
    <updated>2024-01-28T09:03:37.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅克隆-Shallow-Clone">浅克隆(Shallow Clone)</h2><ul><li><p>在浅克隆中，如果原型对象的成员变量是值类型(如int、double、byte、boolean、char等基本数据类型)，将复制一份给克隆对象；如果原型对象的成员变量是引用类型（如类、接口、数组等复杂数据类型），则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当原型对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228150057812.png" alt="image-20231228150057812"></p></li></ul><h2 id="深克隆-Deep-Clone">深克隆(Deep Clone)</h2><ul><li><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将被复制。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228164944861.png" alt="image-20231228164944861"></p></li></ul>]]></content>
    
    
    <summary type="html">根据在复制原型对象的同时是否复制包含在引用类型的成员变量，Java将复制分为两种类型。</summary>
    
    
    
    <category term="Java" scheme="https://www.iuoyt.com/categories/Java/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Java" scheme="https://www.iuoyt.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制与配置文件</title>
    <link href="https://www.iuoyt.com/posts/896ca548.html"/>
    <id>https://www.iuoyt.com/posts/896ca548.html</id>
    <published>2023-12-28T05:12:38.000Z</published>
    <updated>2024-01-28T09:02:24.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java反射机制">Java反射机制</h2><ul><li><p>Java反射（Java Reflection）是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。在反射中使用最多的类是Class，Class类的实例表示正在运行的Java应用程序中的类和接口，其<code>forName(String className)</code>方法可以返回与带有给定字符串名的类或接口相关联的 Class对象，再通过Class对象的<code>newInstance()</code>方法创建此对象所表示的类的一个新实例， 即通过一个类名字符串得到类的实例。</p></li><li><p>例如创建一个字符串类型的对象，其代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c. newlnstance();</span><br><span class="line"><span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure></li><li><p>此外，在JDK中还提供了<code>java.lang.reflect</code>包，封装了其他与反射相关的类。</p></li></ul><h2 id="配置文件">配置文件</h2><ul><li><p>软件系统的配置文件通常为XML文件，可以使用DOM （Document Object Model）、SAX（Simple API for XML）、StAX（Streaming API for XML）等技术来处理 XML 文件。</p></li><li><p>在实际开发中可以把类名存储到XML配置文件中，再读取配置文件获取类名字符串，然后通过Java反射机制来创建对象。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- config.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span> java.lang.String <span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>为了读取该配置文件，并通过存储在其中的类名字符串反射生成对象，可以创建一个工具类XMLUtil，其详细代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> getXmlTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.* ;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.* ;</span><br><span class="line"><span class="keyword">import</span> java.io.* ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取具体类的类名，并返回一个实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建DOM文档对象</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newlnstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder, parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src//getXmlTest//config.xml&quot;</span>));</span><br><span class="line">            <span class="comment">//获取包含类名的文本结点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">classNode</span> <span class="operator">=</span> nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cName</span> <span class="operator">=</span> classNode.getNodeValue();</span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(cName);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newlnstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体使用：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getBean()的返回类型为Object，需要进行强制类型转换</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> (Class)XMLUtil.getBean();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">retu</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Java反射是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制。</summary>
    
    
    
    <category term="Java" scheme="https://www.iuoyt.com/categories/Java/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Java" scheme="https://www.iuoyt.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-创建型模式</title>
    <link href="https://www.iuoyt.com/posts/659b9bb9.html"/>
    <id>https://www.iuoyt.com/posts/659b9bb9.html</id>
    <published>2023-12-28T03:01:27.000Z</published>
    <updated>2023-12-29T04:50:41.766Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a> 📍当前位置</li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a></li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a></li></ol></blockquote><h2 id="创建型模式">创建型模式</h2><ul><li>创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例的创建细节。</li><li>创建型模式描述如何将对象的创建和使用分离，让用户在使用对象时无须关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。每一个创建型模式都通过采用不同的解决方案来回答3个问题，即创建什么（What）、由谁创建（Who）和何时创建 （When）。</li></ul><h2 id="简单工厂模式-Simple-Factory">简单工厂模式(Simple Factory)</h2><div class="tip "><p><strong>定义</strong>：</p><p>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p></div><h3 id="模式结构">模式结构</h3><h4 id="结构图">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228135115130.png" alt="image-20231228135115130"></p><h4 id="实现代码">实现代码</h4><ul><li><p>抽象产品类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">// 所有产品类的公共业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodSame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体产品类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工厂类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">getProduct</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="comment">//通过工厂类创建产品对象</span></span><br><span class="line">        product = Factory.getProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        product.methodSame();</span><br><span class="line">        product.methodDiff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例">应用实例</h3><blockquote><p>​某软件公司要基于Java语言开发一套图表库，该图表库可以为应用系统提供多种不同外观的图表，例如柱状图（HistogramChart）、饼状图（PieChart）、折线图（LineChart）等。该软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，通过设置不同的参数即可得到不同类型的图表，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。</p><p>​现使用简单工厂模式来设计该图表库</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228135130792.png" alt="image-20231228135130792"></p><ul><li>抽象产品类：<code>Chart</code></li><li>具体产品类：<code>HistogramChart</code>、<code>PieChart</code>、<code>LineChart</code></li><li>工厂类：<code>ChartFactory</code></li></ul><h3 id="特点及使用环境">特点及使用环境</h3><h4 id="优点">优点</h4><ol><li>实现了对象创建和使用的分离</li><li>客户端无须知道所创建的具体产品类的类名</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，提高了系统的灵活性</li></ol><h4 id="缺点">缺点</h4><ol><li>工厂类集中了所有产品的创建逻辑，职责过重</li><li>增加系统中类的个数，提高了系统的复杂度和理解难度</li><li>系统扩展困难，添加新产品需要修改工厂逻辑</li><li>由于使用了静态工厂方法，工厂角色无法形成基于继承的等级结构</li></ol><h4 id="适用环境">适用环境</h4><ol><li>工厂类中需要创建的对象较少</li><li>客户端只知道传入工厂的参数，不关心对象如何创建</li></ol><h2 id="工厂方法模式★-Factory-Method">工厂方法模式★(Factory Method)</h2><div class="tip "><p><strong>定义</strong>：</p><p>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p></div><h3 id="模式结构-2">模式结构</h3><h4 id="结构图-2">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228134757404.png" alt="image-20231228134757404"></p><h4 id="实现代码-2">实现代码</h4><ul><li><p>抽象工厂（Factory）：</p><p>在抽象工厂类中声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂（ConcreteFactory）：</p><p>它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象产品（Product）：</p><p>它是定义产品的接口，是工厂方法模式所创建对象的超类型， 也就是产品对象的公共父类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">// 所有产品类的公共业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodSame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体产品（ConcreteProduct）：</p><p>它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p><p>在客户端代码中，开发人员只需关心工厂类即可，不同的具体工厂可以创建不同的产品。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可通过配置文件与反射机制实现</span></span><br><span class="line"><span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConoreteFactory</span>();</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factory.factoryMethod();</span><br></pre></td></tr></table></figure><blockquote><p>反射机制与配置文件可参考：<a href="/posts/896ca548.html">Java反射机制与配置文件</a></p></blockquote></li></ul><h3 id="应用实例-2">应用实例</h3><blockquote><p>​某系统运行日志记录器（Logger）可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。</p><p>​为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统（注：在Java中常用的日志记录工具有 SLF4J、Log4j、GCLogViewer、Logstash 等）。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228134825144.png" alt="image-20231228134825144"></p><ul><li>抽象产品：<code>Logger</code></li><li>具体产品：<code>FileLogger</code>、<code>DatabaseLogger</code></li><li>抽象工厂：<code>LoggerFactory</code></li><li>具体工厂：<code>FileLoggerFactory</code>、<code>DatabaseLoggerFactory</code></li></ul><h3 id="模式变化">模式变化</h3><h4 id="工厂方法的重载">工厂方法的重载</h4><p>在某些情况下，可以通过多种方式来初始化同一个产品类。比如实例中的记录器，可以为各种日志记录器提供默认实现；还可以为数据库日志记录器提供数据库连接字符串，为文件日志记录器提供文件路径；也可以将相关参数封装在一个Object类型的对象中，通过Object对象将配置参数传入工厂类。此时可以提供一组重载的工厂方法，以不同的方式对产品对象进行创建。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228134856569.png" alt="image-20231228134856569"></p><ul><li><p>抽象工厂类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span>;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂类（以DatabaseLoggerFactory举例）：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用默认方式连接数据库</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>();</span><br><span class="line">        <span class="comment">//初始化数据库日志记录器</span></span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用参数args作为连接字符串来连接数据库</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>();</span><br><span class="line">        <span class="comment">//初始化数据库日志记录器</span></span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">//使用封装在参数obj中的连接字符串来连接数据库</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>();</span><br><span class="line">        <span class="comment">//使用封装在参数obj中的数据来初始化数据库日志记录器</span></span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在抽象工厂中声明了多个重载的工厂方法，在具体工厂中实现了这些工厂方法,这些方法可以包含不同的业务逻辑，以满足产品对象的多样化创建需求。</p><h4 id="工厂方法的隐藏">工厂方法的隐藏</h4><p>有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时在工厂类中直接调用产品类的业务方法，客户端无须调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法。</p><ul><li><p>抽象工厂类，将原先的接口（interface）修改为抽象类（abstract）：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="comment">//在工厂类中直接调用日志记录器类的业务方法writeLog()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="built_in">this</span>.createLogger();</span><br><span class="line">        logger.writeLog();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[ ])</span> &#123;</span><br><span class="line">        LoggerFactory factory;</span><br><span class="line">        factory = (LoggerFactory)XMLUtil.getBean();</span><br><span class="line">        <span class="comment">//直接使用工厂对象来调用产品对象的业务方法</span></span><br><span class="line">        factory.writeLog(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过把业务方法的调用移至工厂类中，可以直接使用工厂对象来调用产品对象的业务方法，客户端无须使用工厂方法来创建产品对象。</p><h3 id="特点及使用环境-2">特点及使用环境</h3><h4 id="优点-2">优点</h4><ol><li>向客户隐藏了哪种具体产品类将被实例化这一细节</li><li>能够让工厂自主确定创建何种产品对象</li><li>完全符合开闭原则</li></ol><h4 id="缺点-2">缺点</h4><ol><li>系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销</li><li>增加了系统的抽象性和理解难度</li></ol><h4 id="适用环境-2">适用环境</h4><ol><li>客户端不知道它所需要的对象的类（客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建）</li><li>抽象工厂类通过其子类来指定创建哪个对象</li></ol><h2 id="抽象工厂模式-Abstract-Factory">抽象工厂模式(Abstract Factory)</h2><div class="tip "><p><strong>定义</strong>：</p><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231228141139951.png" alt="image-20231228141139951"></p><h3 id="模式结构-3">模式结构</h3><h4 id="结构图-3">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228135936556.png" alt="image-20231228135936556"></p><h4 id="实现代码-3">实现代码</h4><ul><li><p>抽象工厂（AbstractFactory）</p><p>它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>; <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>; <span class="comment">//工厂方法二</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂（ConcreteFactory）</p><p>它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactoryl</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//工厂方法二</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象产品（AbstractProduct）</p><p>它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</p></li><li><p>具体产品（ConcreteProduct）</p><p>它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</p></li></ul><h3 id="应用实例-3">应用实例</h3><blockquote><p>​某软件公司要开发一套界面皮肤库，可以对基于Java的桌面软件进行界面美化。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天(Spring)风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天(Summer)风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如下图所示：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228141412998.png" alt="image-20231228141412998"></p><p>​该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。</p><p>​现使用抽象工厂模式来设计该界面皮肤库。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228141535559.png" alt="image-20231228141535559"></p><ul><li>抽象工厂：<code>SkinFactory</code></li><li>具体工厂：<code>SpringSkinFactory</code>、<code>SummerSkinFactory</code></li><li>抽象产品：<code>Button</code>、<code>TextField</code>、<code>ComboBox</code></li><li>具体产品：<code>SpringButton</code>、<code>SpringTextField</code>、<code>SpringComboBox</code>、<code>SummerButton</code>、<code>SummerTextField</code>、<code>SummerComboBox</code></li></ul><h3 id="模式变化-2">模式变化</h3><h4 id="开闭原则的倾斜性">开闭原则的倾斜性</h4><p>在抽象工厂模式中增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为开闭原则的倾斜性。</p><ul><li>对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改</li><li>对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了开闭原则</li></ul><h3 id="特点及使用环境-3">特点及使用环境</h3><h4 id="优点-3">优点</h4><ol><li>隔离了具体类的生成，使得客户端并不需要知道什么被创建</li><li>能够保证客户端始终只使用同一个产品族中的对象</li><li>增加新的产品族很方便，无须修改已有系统，符合开闭原则</li></ol><h4 id="缺点-3">缺点</h4><ol><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则</li></ol><h4 id="适用环境-3">适用环境</h4><ol><li>系统不依赖于产品类实例如何被创建、组合和表达的细节</li><li>系统中有多于一个的产品族，但每次只使用其中某一产品族</li><li>属于同一个产品族的产品将在一起使用</li><li>产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li></ol><h2 id="建造者模式★-Builder">建造者模式★(Builder)</h2><div class="tip "><p><strong>定义</strong>：</p><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></div><h3 id="模式结构-4">模式结构</h3><h4 id="结构图-4">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228143123688.png" alt="image-20231228143123688"></p><h4 id="实现代码-4">实现代码</h4><ul><li><p>产品（Product）</p><p>复杂对象是指那些包含多个成员变量的对象，这些成员变量也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//定义部件，部件可以是任意类型，包括值类型和引用类型</span></span><br><span class="line">    <span class="keyword">private</span> String partA; </span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="comment">//Getter方法和Setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象建造者（Builder）</p><p>它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是<code>buildPartX()</code>，它们用于创建复杂对象的各个部件；另一类方法是<code>getResult()</code>，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体建造者（ConcreteBuilder）</p><p>它实现了 Builder接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder1</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;A1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;B1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;C1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指挥者（Director）</p><p>指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制实现），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuilder</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在指挥者类中可以注入一个抽象建造者类型的对象，它提供了一个建造方法<code>construct()</code>, 在该方法中调用了 builder对象的构造部件的方法，最后返回一个产品对象。</p></li><li><p>客户端</p><p>对于客户端而言，只需要关心具体建造者的类型，无须关心产品对象的具体组装过程。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可通过配置文件实现</span></span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder1</span>(); </span><br><span class="line"><span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> director.construct();</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-4">应用实例</h3><blockquote><p>​某游戏软件公司决定开发一款基于角色扮演的多人在线网络游戏，玩家可以在游戏中扮演虚拟世界中的一个特定角色，角色根据不同的游戏情节和统计数据（例如力量、魔法、技能等）具有不同的能力，角色也会随着不断升级而拥有更加强大的能力。<br>​作为该游戏的一个重要组成部分，需要对游戏角色进行设计，而且随着该游戏的升级将不断增加新的角色。通过分析发现，游戏角色是一个复杂对象，它包含性别、面容等多个组成部分，不同类型的游戏角色，其性别、面容、服装、发型等外部特性都有所差异，例如“天使”拥有美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”极其丑陋，留着光头并穿一件刺眼的黑衣。<br>​无论是何种造型的游戏角色，它的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。现使用建造者模式来实现游戏角色的创建。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228144252912.png" alt="image-20231228144252912"></p><ul><li>指挥者：<code>ActorController</code></li><li>抽象建造者：<code>ActorBuilder</code></li><li>具体建造者：<code>HeroBuilder</code>、<code>AngelBuilder</code>、<code>DevilBuilder</code></li><li>复杂产品：<code>Actor</code></li></ul><h3 id="特点及使用环境-4">特点及使用环境</h3><h4 id="优点-4">优点</h4><ol><li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则</li><li>可以更加精细地控制产品的创建过程</li></ol><h4 id="缺点-4">缺点</h4><ol><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，不适合使用建造者模式，因此其使用范围受到一定的限制</li><li>如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本</li></ol><h4 id="适用环境-4">适用环境</h4><ol><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品</li></ol><h2 id="原型模式★-Prototype">原型模式★(Prototype)</h2><div class="tip "><p><strong>定义</strong>：</p><p>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象</p></div><h3 id="模式结构-5">模式结构</h3><h4 id="结构图-5">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228144922896.png" alt="image-20231228144922896"></p><h4 id="实现代码-5">实现代码</h4><ul><li><p>抽象原型类（Prototype）</p><p>它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至还可以是具体实现类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String attr;  <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttr</span><span class="params">(String attr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.attr = attr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAttr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.attr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//克隆方法</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(); <span class="comment">//创建新对象</span></span><br><span class="line">        prototype.setAttr(<span class="built_in">this</span>.attr);</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体原型类（ConcretePrototype）</p><p>它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = <span class="built_in">super</span>.clone(); <span class="comment">//浅克隆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CloneNotSupportedException exception) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Not support cloneable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Prototype) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端</p><p>在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prototype</span> <span class="variable">protptype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line"><span class="type">Prototype</span> <span class="variable">copy</span> <span class="operator">=</span> protptype.clone();</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-5">应用实例</h3><blockquote><p>​在使用某OA系统时，有些岗位的员工发现他们每周的工作都大同小异，因此在填写工作周报时很多内容都是重复的，为了提高工作周报的创建效率，大家迫切希望有一种机制能够快速创建相同或者相似的周报，包括创建周报的附件。</p><p>​试使用原型模式对该OA系统中的工作周报创建模块进行改进。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228170138649.png" alt="image-20231228170138649"></p><ul><li>抽象原型类：<code>Object</code></li><li>具体原型类：<code>WeeklyLog</code></li><li>成员类：<code>Attachment</code></li></ul><h3 id="模式变化-3">模式变化</h3><h3 id="通用实现（浅克隆）">通用实现（浅克隆）</h3><ul><li><p>通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，同时将相关的参数传入新创建的对象中，保证它们的成员变量相同。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String attr; <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttr</span><span class="params">(String attr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.attr = attr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAttr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.attr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//克隆方法</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建新对象</span></span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(); </span><br><span class="line">        prototype.setAttr(<span class="built_in">this</span>.attr);</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line">prototype.setAttr(<span class="string">&quot;Sunny&quot;</span>);</span><br><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">copy</span> <span class="operator">=</span> (ConcretePrototype)prototype.clone();</span><br></pre></td></tr></table></figure></li></ul><h4 id="通过Cloneable实现的浅克隆">通过Cloneable实现的浅克隆</h4><ul><li><p>所有的Java类均继承自java.lang.Object类，Object类提供了一个<code>clone()</code>方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的 <code>clone()</code>方法来实现对象的浅克隆。</p></li><li><p>能够实现克隆的Java类必须实现一个标识接口 Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了 <code>clone()</code>方法，Java编译器将抛出一个CloneNotSupportedException异常。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = <span class="built_in">super</span>. clone(); <span class="comment">//浅克隆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CloneNotSupportedException exception) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Not support cloneable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Prototype) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prototype</span> <span class="variable">protptype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line"><span class="type">Prototype</span> <span class="variable">copy</span> <span class="operator">=</span> protptype.clone();</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Java语言中的<code>clone()</code>方法满足以下几点：</p><ol><li>对任何对象x，都有<code>x.clone()!=x</code>，即克隆对象与原型对象不是同一个对象</li><li>对任何对象x，都有<code>x.clone().getClass() == x.getClass()</code>，即克隆对象与原型对象的类型一样</li><li>如果对象x的<code>equals()</code>的方法定义恰当，那么<code>x.clone().equals(x)</code>应该成立。</li></ol><p>为了获取对象的一个克隆，可以直接利用Object类的<code>clone()</code>方法，具体步骤如下：</p><ol><li>在派生类中覆盖基类的<code>clone()</code>方法，并声明为public</li><li>在派生类的<code>clone()</code>方法中调用<code>super.clone()</code></li><li>派生类需实现Cloneable接口。</li></ol><p>此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</p></blockquote><h4 id="通过序列化实现深克隆">通过序列化实现深克隆</h4><ul><li><p>为了能够在复制周报的同时也能够复制附件对象，需要采用深克隆机制。在Java语言中可以通过序列化（Serialization）等方式来实现深克隆。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制，而原对象仍然存在于内存中。通过序列化实现的复制不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用序列化技术实现深克隆</span></span><br><span class="line"><span class="keyword">public</span> WeeklyLog <span class="title function_">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IQException, ClassNotFoundException, OptionalDataException &#123;</span><br><span class="line">    <span class="comment">//将对象写入流中</span></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); </span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bao);</span><br><span class="line">    oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//将对象从流中取出</span></span><br><span class="line">    <span class="type">ByteArrayInputstream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStrearn</span>(bao.toByteArray());</span><br><span class="line">    <span class="type">Objectinputstream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">    <span class="keyword">return</span> (WeeklyLog)ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="特点及使用环境-5">特点及使用环境</h3><h4 id="优点-5">优点</h4><ol><li>简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率</li><li>扩展性较好</li><li>提供了简化的创建结构，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品</li><li>可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作</li></ol><h4 id="缺点-5">缺点</h4><ol><li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则</li><li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦</li></ol><h4 id="适用环境-5">适用环境</h4><ol><li>创建新对象成本较大，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改</li><li>系统要保存对象的状态，而对象的状态变化很小</li><li>需要避免使用分层次的工厂类来创建分层次的对象</li></ol><h2 id="单例模式-Singleton">单例模式(Singleton)</h2><div class="tip "><p><strong>定义</strong>：</p><p>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例</p></div><h3 id="模式结构-6">模式结构</h3><h4 id="结构图-6">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228174602624.png" alt="image-20231228174602624"></p><h4 id="实现代码-6">实现代码</h4><ul><li><p>单例（Singleton）</p><p>在单例类的内部创建它的唯一实例，并通过静态方法<code>getlnstance()</code>让客户端可以使用它的唯一实例；为了防止在外部对单例类实例化，将其构造函数的可见性设为private；在单例类内部定义了一个Singleton类型的静态对象作为供外部共享访问的唯一实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//静态私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态公有工厂方法，返回唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> Singleton.getlnstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> Singleton.getlnstance();</span><br><span class="line">        <span class="comment">//判断两个对象是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (sl == s2) &#123;</span><br><span class="line">            System.out.printin(<span class="string">&quot;两个对象是相同实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printin(<span class="string">&quot;两个对象是不同实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-6">应用实例</h3><blockquote><p>​某软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系统的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228175207480.png" alt="image-20231228175207480"></p><ul><li>单例：<code>LoadBalancer</code></li></ul><h3 id="模式变化-4">模式变化</h3><h4 id="饿汉式单例">饿汉式单例</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228175330686.png" alt="image-20231228175330686"></p><ul><li><p>当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getlnstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="懒汉式单例">懒汉式单例</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228180547275.png" alt="image-20231228180547275"></p><ul><li><p>懒汉式单例在第一次调用<code>getlnstance()</code>方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//使用synchronized关键字对方法加锁，确保任意时刻只有一个线程可执行该方法</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance = = <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在上述懒汉式单例类中，在<code>getlnstance()</code>方法前面增加了关键字synchronized进行线程锁定，以处理多个线程同时访问的问题。上述代码虽然解决了线程安全问题，但是每次调用<code>getlnstance()</code>时都需要进行线程锁定判断，在多线程高并发访问环境中将会导致系统性能大大降低。</p></li><li><p>假如在某一瞬间线程A和线程B都在调用<code>getlnstance()</code>方法，此时instance对象为null值，均能通过<code>instance==null</code>的判断。由于实现了synchronized加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定的代码。但当A执行完毕时线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背了单例模式的设计思想，因此需要进一步改进，在synchronized中再进行一次<code>instance==null</code>判断，这种方式称为双重检查锁定（Double-Check Locking）。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getlnstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//第一重判断</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//锁定代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span>(LazySingleton.class) &#123;</span><br><span class="line">            <span class="comment">//第二重判断</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//创建单例实例</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="特点及使用环境-6">特点及使用环境</h3><h4 id="优点-6">优点</h4><ol><li>提供了对唯一实例的受控访问</li><li>可以节约系统资源，提高系统的性能</li><li>允许可变数目的实例（多例类）</li></ol><h4 id="缺点-6">缺点</h4><ol><li>扩展困难（缺少抽象层）</li><li>单例类的职责过重</li><li>由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失</li></ol><h4 id="适用环境-6">适用环境</h4><ol><li>系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</li></ol>]]></content>
    
    
    <summary type="html">创建型模式关注对象的创建机制，旨在以合适的方式创建对象。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux简单操作速查</title>
    <link href="https://www.iuoyt.com/posts/f31ac9c6.html"/>
    <id>https://www.iuoyt.com/posts/f31ac9c6.html</id>
    <published>2023-12-17T09:21:18.000Z</published>
    <updated>2023-12-28T02:58:39.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户操作">用户操作</h2><h3 id="修改密码（passwd）">修改密码（passwd）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132259181.png" alt="image-20231221132259181"></p><h3 id="创建新用户（adduser）">创建新用户（adduser）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132357801.png" alt="image-20231221132357801"></p><h3 id="删除用户（deluser）">删除用户（deluser）</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser &lt;username&gt; --remove-home</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132840664.png" alt="image-20231221132840664"></p><h3 id="查看当前用户（whoami）">查看当前用户（whoami）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132422791.png" alt="image-20231221132422791"></p><h3 id="切换到用户（su）">切换到用户（su）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -l <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132619718.png" alt="image-20231221132619718"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>将 COMMAND 传递至启动的 shell</td></tr><tr><td><code>-h</code></td><td>显示帮助信息并退出</td></tr><tr><td><code>-l</code></td><td>将 shell 设为登录 shell</td></tr><tr><td><code>-p</code></td><td>不重置环境变量并保持同一 shell</td></tr><tr><td><code>-s</code></td><td>使用 SHELL 而非 passwd 中的默认值</td></tr></tbody></table><h3 id="查看所属用户组（groups）">查看所属用户组（groups）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132654167.png" alt="image-20231221132654167"></p><p>其中冒号之前表示用户，后面表示该用户所属的用户组</p><h3 id="授予sudo权限">授予sudo权限</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -G sudo <span class="variable">&lt;username&gt;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo adduser <span class="variable">&lt;username&gt;</span> sudo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132741744.png" alt="image-20231221132741744"></p><h3 id="移除sudo权限">移除sudo权限</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser <span class="tag">&lt;<span class="name">username</span>&gt;</span> sudo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132808881.png" alt="image-20231221132808881"></p><h2 id="目录操作">目录操作</h2><h3 id="查看当前路径（pwd）">查看当前路径（pwd）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-P</code></td><td>显示实际物理路径，而非使用连接（link）路径</td></tr><tr><td><code>-L</code></td><td>当目录为连接路径时，显示连接路径</td></tr></tbody></table><p><img src="https://doc.shiyanlou.com/courses/uid871732-20200826-1598406299890" alt="图片描述"></p><h3 id="切换目录（cd）">切换目录（cd）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>cd ~</code></td><td>进入当前用户主目录</td></tr><tr><td><code>cd /</code></td><td>进入系统根目录</td></tr><tr><td><code>cd ..</code></td><td>从当前目录进入父目录</td></tr><tr><td><code>cd -</code></td><td>从当前目录进入上次所在目录</td></tr></tbody></table><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132945769.png" alt="image-20231221132945769"></p><h3 id="查看目录内容（ls）">查看目录内容（ls）</h3><ul><li><p>只显示文件名：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133003656.png" alt="image-20231221133003656"></p></li><li><p>显示详细信息：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133018031.png" alt="image-20231221133018031"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-a</code></td><td>–all 列出目录下的所有文件，包括以 . 开头的隐含文件</td></tr><tr><td><code>-l</code></td><td>除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</td></tr><tr><td><code>-h</code></td><td>–human-readable 以容易理解的格式列出文件大小（例如 1K 234M 2G)</td></tr><tr><td><code>-t</code></td><td>以文件修改时间排序</td></tr></tbody></table><p>隐藏文件前带<code>.</code></p></li><li><p>查看目录完整属性：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -<span class="keyword">dl</span> [<span class="symbol">&lt;dirpath&gt;</span>]</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133100480.png" alt="image-20231221133100480"></p></li><li><p>显示所有文件大小</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -aSsh</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133334152.png" alt="image-20231221133334152"></p></li></ul><h3 id="创建目录（mkdir）">创建目录（mkdir）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [option] &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221141238014.png" alt="image-20231221141238014"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-m</code></td><td>设定权限&lt;模式&gt;</td></tr><tr><td><code>-p</code></td><td>多级创建，可以是一个路径名称。若路径中某些目录尚不存在，系统将自动建立好</td></tr><tr><td><code>-v </code></td><td>每次创建新目录都显示信息</td></tr></tbody></table><h3 id="删除目录（rm-r）">删除目录（rm -r）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r [option] &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221141153974.png" alt="image-20231221141153974"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-f</code></td><td>忽略不存在的文件，从不给出提示</td></tr><tr><td><code>-i</code></td><td>进行交互式删除</td></tr><tr><td><code>-r</code></td><td>指示 rm 将参数中列出的全部目录和子目录均递归地删除（删除目录时必须）</td></tr><tr><td><code>-v</code></td><td>详细显示进行的步骤</td></tr></tbody></table><h3 id="复制目录（cp-r）">复制目录（cp -r）</h3><p>也就是递归复制文件</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">dir</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142500949.png" alt="image-20231221142500949"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定目标目录</td></tr><tr><td><code>-i</code></td><td>覆盖前询问（使前面的 -n 选项失效）</td></tr><tr><td><code>-n</code></td><td>不要覆盖已存在的文件（使前面的 -i 选项失效）</td></tr><tr><td><code>-s</code></td><td>对源文件建立符号链接，而非复制文件</td></tr><tr><td><code>-f</code></td><td>强行复制文件或目录，不论目的文件或目录是否已经存在</td></tr><tr><td><code>-u</code></td><td>只在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件</td></tr></tbody></table><h3 id="移动目录（mv）">移动目录（mv）</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">dir</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221141444450.png" alt="image-20231221141444450"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>若需覆盖文件，则覆盖前先行备份</td></tr><tr><td><code>-f</code></td><td>如果目标文件已经存在，不会询问而直接覆盖</td></tr><tr><td><code>-i</code></td><td>若目标文件已经存在时，就会询问是否覆盖</td></tr><tr><td><code>-u</code></td><td>若目标文件已经存在，且源文件比较新，才会更新</td></tr><tr><td><code>-t</code></td><td>该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后</td></tr></tbody></table><h2 id="文件操作">文件操作</h2><h3 id="查看文件信息（ll）">查看文件信息（ll）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ll</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142520514.png" alt="image-20231221142520514"></p><h3 id="查看文件大小（du-h）">查看文件大小（du -h）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h &lt;<span class="built_in">dir</span>/file&gt;</span><br></pre></td></tr></table></figure><h3 id="查看文件类型（file）">查看文件类型（file）</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">file</span> &lt;<span class="built_in">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142534603.png" alt="image-20231221142534603"></p><h3 id="查看文件（cat）">查看文件（cat）</h3><ul><li><p>正序查看</p>  <figure class="highlight plaintext"><figcaption><span><file></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [option] &lt;file&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142851473.png" alt="image-20231221142851473"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-A</code></td><td>等价于 <code>-vET</code></td></tr><tr><td><code>-b</code></td><td>对非空输出行编号</td></tr><tr><td><code>-e</code></td><td>等价于 <code>-vE</code></td></tr><tr><td><code>-E</code></td><td>在每行结束处显示 $</td></tr><tr><td><code>-n</code></td><td>对输出的所有行编号，由 1 开始对所有输出的行数编号</td></tr><tr><td><code>-s</code></td><td>有连续两行以上的空白行，就代换为一行的空白行</td></tr><tr><td><code>-t</code></td><td>与 <code>-vT</code> 等价</td></tr><tr><td><code>-T</code></td><td>将跳格字符显示为 <code>^I</code></td></tr><tr><td><code>-u</code></td><td>（被忽略）</td></tr><tr><td><code>-v </code></td><td>使用 <code>^</code> 和 <code>M-</code>引用，除了 LFD 和 TAB 之外</td></tr></tbody></table></li><li><p>倒序查看</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac &lt;<span class="built_in">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142908437.png" alt="image-20231221142908437"></p></li></ul><h3 id="文件计算行号查看（nl）">文件计算行号查看（nl）</h3><ul><li><p>nl 命令在 linux 系统中用来计算文件中的行号。nl 可以将输出的文件内容自动加上行号，其默认的结果与 cat -n 有点不太一样。 nl 可以将行号做较多的显示设计，包括位数与是否自动补齐 0 等等的功能。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [<span class="keyword">option</span>] [<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221143002997.png" alt="image-20231221143002997"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>指定行号指定的方式，主要有两种：</td></tr><tr><td><code>-b a</code></td><td>表示不论是否为空行，也同样列出行号（类似 <code>cat -n</code>）</td></tr><tr><td><code>-b t</code></td><td>如果有空行，空的那一行不要列出行号（默认值）</td></tr><tr><td><code>-n</code></td><td>列出行号表示的方法，主要有三种：</td></tr><tr><td><code>-n ln</code></td><td>行号在屏幕的最左方显示</td></tr><tr><td><code>-n rn</code></td><td>行号在自己栏位的最右方显示，且不加 0</td></tr><tr><td><code>-n rz</code></td><td>行号在自己栏位的最右方显示，且加 0</td></tr><tr><td><code>-w</code></td><td>行号栏位的占用的位数</td></tr></tbody></table></li></ul><h3 id="阅读文件">阅读文件</h3><h4 id="more">more</h4><ul><li><p>功能类似 <code>cat</code> ，<code>cat</code> 命令是将整个文件的内容从上到下显示在屏幕上。 <code>more</code> 命令会一页一页的显示，方便使用者逐页阅读，而最基本的指令就是按<kbd>Enter</kbd>向下滚动一行，按<kbd>Space</kbd>往下一页显示，按<kbd>B</kbd>键就会往回（back）一页显示，按<kbd>=</kbd>输出当前行行号，按下 <kbd>H</kbd>显示帮助，按下<kbd>Q</kbd>退出。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221145143202.png" alt="image-20231221145143202"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>+n</code></td><td>从笫 n 行开始显示</td></tr><tr><td><code>-n</code></td><td>定义屏幕大小为 n 行</td></tr><tr><td><code>+/pattern</code></td><td>在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示</td></tr><tr><td><code>-c</code></td><td>从顶部清屏，然后显示</td></tr><tr><td><code>-d</code></td><td>提示“Press space to continue，’q’ to quiet”，禁用响铃功能</td></tr><tr><td><code>-p</code></td><td>通过清除窗口而不是滚屏来对文件进行换页，与-c 选项相似</td></tr><tr><td><code>-s</code></td><td>把连续的多个空行显示为一行</td></tr><tr><td><code>-u</code></td><td>把文件内容中的下划线去掉</td></tr></tbody></table></li></ul><h4 id="less">less</h4><ul><li><p>是 linux 正统查看文件内容的工具，功能极其强大</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">less</span> [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-e</code></td><td>当文件显示结束后，自动离开</td></tr><tr><td><code>-f</code></td><td>强迫打开特殊文件，例如外围设备代号、目录和二进制文件</td></tr><tr><td><code>-i</code></td><td>忽略搜索时的大小写</td></tr><tr><td><code>-m</code></td><td>显示类似 more 命令的百分比</td></tr><tr><td><code>-N</code></td><td>显示每行的行号</td></tr><tr><td><code>-s</code></td><td>显示连续空行为一行</td></tr></tbody></table></li><li><p>常用操作：</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>/字符串</td><td>向下搜索“字符串”的功能</td></tr><tr><td>?字符串</td><td>向上搜索“字符串”的功能</td></tr><tr><td>n</td><td>重复前一个搜索（与 / 或 ? 有关）</td></tr><tr><td>N</td><td>反向重复前一个搜索（与 / 或 ? 有关）</td></tr><tr><td>b</td><td>向前翻一页</td></tr><tr><td>d</td><td>向后翻半页</td></tr><tr><td>q</td><td>退出 less 命令</td></tr><tr><td>空格键</td><td>向后翻一页</td></tr><tr><td>向上键</td><td>向上翻动一行</td></tr><tr><td>向下键</td><td>向下翻动一行</td></tr></tbody></table></li></ul><h4 id="head">head</h4><ul><li><p>用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221145838128.png" alt="image-20231221145838128"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-q</td><td>隐藏文件名</td></tr><tr><td>-v</td><td>显示文件名</td></tr><tr><td>-c&lt;字节&gt;</td><td>显示字节数</td></tr><tr><td>-n&lt;行数&gt;</td><td>显示的行数</td></tr></tbody></table></li></ul><h4 id="tail">tail</h4><ul><li><p>用于显示指定文件末尾内容。常用查看日志文件，默认为尾部10行。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221145910940.png" alt="image-20231221145910940"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-f</code></td><td>循环读取</td></tr><tr><td><code>-q</code></td><td>不显示处理信息</td></tr><tr><td><code>-v</code></td><td>显示详细的处理信息</td></tr><tr><td><code>-c&lt;字节&gt;</code></td><td>显示的字节数</td></tr><tr><td><code>-n&lt;行数&gt;</code></td><td>显示行数</td></tr></tbody></table></li></ul><h3 id="创建文件（touch）">创建文件（touch）</h3><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">touch</span> &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>批量创建文件</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">touch</span> file&#123;<span class="number">1</span>..<span class="number">5</span>&#125;.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221150514197.png" alt="image-20231221150514197"></p></li></ul><h3 id="删除文件（rm）">删除文件（rm）</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221150534482.png" alt="image-20231221150534482"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-f</code></td><td>忽略不存在的文件，从不给出提示</td></tr><tr><td><code>-i</code></td><td>进行交互式删除</td></tr><tr><td><code>-r</code></td><td>指示 rm 将参数中列出的全部目录和子目录均递归地删除</td></tr><tr><td><code>-v</code></td><td>详细显示进行的步骤</td></tr></tbody></table><h3 id="编辑文件（vim）">编辑文件（vim）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建并写入文件（echo-）">创建并写入文件（echo &gt;&gt;）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Text&quot;</span> &gt;&gt; <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221151525050.png" alt="image-20231221151525050"></p><h3 id="多行编辑（cat）">多行编辑（cat）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; &lt;file&gt; &lt;&lt; <span class="string">eof</span></span><br><span class="line"><span class="string">……</span></span><br><span class="line"><span class="string">eof</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221151402910.png" alt="image-20231221151402910"></p><h3 id="复制文件（cp）">复制文件（cp）</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221150733380.png" alt="image-20231221150733380"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定目标目录</td></tr><tr><td><code>-i</code></td><td>覆盖前询问（使前面的 -n 选项失效）</td></tr><tr><td><code>-n</code></td><td>不要覆盖已存在的文件（使前面的 -i 选项失效）</td></tr><tr><td><code>-s</code></td><td>对源文件建立符号链接，而非复制文件</td></tr><tr><td><code>-f</code></td><td>强行复制文件或目录，不论目的文件或目录是否已经存在</td></tr><tr><td><code>-u</code></td><td>只在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件</td></tr></tbody></table><h3 id="设置文件权限（chmod）">设置文件权限（chmod）</h3><table><thead><tr><th style="text-align:left">#</th><th style="text-align:left">权限</th><th style="text-align:left">rwx</th><th style="text-align:left">二进制</th></tr></thead><tbody><tr><td style="text-align:left">7</td><td style="text-align:left">读 + 写 + 执行</td><td style="text-align:left">rwx</td><td style="text-align:left">111</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">读 + 写</td><td style="text-align:left">rw-</td><td style="text-align:left">110</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">读 + 执行</td><td style="text-align:left">r-x</td><td style="text-align:left">101</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">只读</td><td style="text-align:left">r–</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">写 + 执行</td><td style="text-align:left">-wx</td><td style="text-align:left">011</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">只写</td><td style="text-align:left">-w-</td><td style="text-align:left">010</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">只执行</td><td style="text-align:left">–x</td><td style="text-align:left">001</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">无</td><td style="text-align:left">—</td><td style="text-align:left">000</td></tr></tbody></table><ul><li><p>数字表示</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">rwx</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>文件调用权限分为三级 :</p><ul><li>文件所有者（Owner）</li><li>用户所在用户组（Group）</li><li>其它用户（Other Users）</li></ul></li><li><p>权限分为三种：</p><ul><li>可读（Read）</li><li>可写（Write）</li><li>可执行（Execute）</li></ul></li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="img"></p></li><li><p>字符表示</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">u</span>&gt;</span><span class="tag">&lt;<span class="name">op</span>&gt;</span><span class="tag">&lt;<span class="name">permission</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>用户组部分表示：</p><table><thead><tr><th style="text-align:left">who</th><th style="text-align:left">用户类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>u</code></td><td style="text-align:left">user</td><td style="text-align:left">文件所有者</td></tr><tr><td style="text-align:left"><code>g</code></td><td style="text-align:left">group</td><td style="text-align:left">文件所有者所在组</td></tr><tr><td style="text-align:left"><code>o</code></td><td style="text-align:left">others</td><td style="text-align:left">所有其他用户</td></tr><tr><td style="text-align:left"><code>a</code></td><td style="text-align:left">all</td><td style="text-align:left">所有用户, 相当于 <em>ugo</em></td></tr></tbody></table></li><li><p>符号部分表示：</p><table><thead><tr><th style="text-align:left">Operator</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">为指定的用户类型增加权限</td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">去除指定用户类型的权限</td></tr><tr><td style="text-align:left"><code>=</code></td><td style="text-align:left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table></li><li><p>权限部分表示：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">名字</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>r</code></td><td style="text-align:left">读</td><td style="text-align:left">设置为可读权限</td></tr><tr><td style="text-align:left"><code>w</code></td><td style="text-align:left">写</td><td style="text-align:left">设置为可写权限</td></tr><tr><td style="text-align:left"><code>x</code></td><td style="text-align:left">执行权限</td><td style="text-align:left">设置为可执行权限</td></tr><tr><td style="text-align:left"><code>X</code></td><td style="text-align:left">特殊执行权限</td><td style="text-align:left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td style="text-align:left"><code>s</code></td><td style="text-align:left">setuid/gid</td><td style="text-align:left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td style="text-align:left"><code>t</code></td><td style="text-align:left">粘贴位</td><td style="text-align:left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td></tr></tbody></table></li></ul></li><li><p>效果相同语句举例：</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="keyword">a</span>=rwx <span class="built_in">file</span></span><br><span class="line">chmod <span class="number">777</span> <span class="built_in">file</span></span><br></pre></td></tr></table></figure>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod ug=rwx,o=x <span class="built_in">file</span></span><br><span class="line">chmod <span class="number">771</span> <span class="built_in">file</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="移动文件（mv）">移动文件（mv）</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>若需覆盖文件，则覆盖前先行备份</td></tr><tr><td><code>-f</code></td><td>如果目标文件已经存在，不会询问而直接覆盖</td></tr><tr><td><code>-i</code></td><td>若目标文件已经存在时，就会询问是否覆盖</td></tr><tr><td><code>-u</code></td><td>若目标文件已经存在，且源文件比较新，才会更新</td></tr><tr><td><code>-t</code></td><td>该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后</td></tr></tbody></table><h3 id="重命名文件（mv）">重命名文件（mv）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv <span class="tag">&lt;<span class="name">旧名称</span>&gt;</span> <span class="tag">&lt;<span class="name">新名称</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>批量重命名：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量将这5个后缀为.txt的文本文件重命名为以.c为后缀的文件:</span></span><br><span class="line"><span class="attribute">rename</span> <span class="string">&#x27;s/\.txt/\.c/&#x27;</span> <span class="regexp">*.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量将这5个文件，文件名和后缀改为大写:</span></span><br><span class="line">rename <span class="string">&#x27;y/a-z/A-Z/&#x27;</span> <span class="regexp">*.c</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="vim基础操作">vim基础操作</h2><h3 id="进入vim编辑（普通模式）">进入vim编辑（普通模式）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>游标操作：在普通模式下使用方向键或者<kbd>h</kbd>、<kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd>键移动游标</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td><kbd>h</kbd></td><td>左</td></tr><tr><td><kbd>l</kbd></td><td>右（小写 L）</td></tr><tr><td><kbd>j</kbd></td><td>下</td></tr><tr><td><kbd>k</kbd></td><td>上</td></tr><tr><td><kbd>w</kbd></td><td>移动到下一个单词</td></tr><tr><td><kbd>b</kbd></td><td>移动到上一个单词</td></tr></tbody></table></li><li><p>快速操作：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除游标所在的字符</td></tr><tr><td><code>X</code></td><td>删除游标所在前一个字符</td></tr><tr><td><code>Delete</code></td><td>同 <code>x</code></td></tr><tr><td><code>dd</code></td><td>删除整行</td></tr><tr><td><code>dw</code></td><td>删除一个单词（不适用中文）</td></tr><tr><td><code>d$</code>或<code>D</code></td><td>删除至行尾</td></tr><tr><td><code>d^</code></td><td>删除至行首</td></tr><tr><td><code>dG</code></td><td>删除到文档结尾处</td></tr><tr><td><code>d1G</code></td><td>删至文档首部</td></tr></tbody></table></li></ul><h3 id="写入内容（插入模式）">写入内容（插入模式）</h3><ul><li><p>进入：输入<code>i </code>（insert／插入）或者<code>a</code>（append／追加）</p></li><li><p>退出：按下<kbd>Esc</kbd>回到普通模式</p></li><li><p>更多命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>在当前光标处进行编辑</td></tr><tr><td><code>I</code></td><td>在行首插入</td></tr><tr><td><code>A</code></td><td>在行末插入</td></tr><tr><td><code>a</code></td><td>在光标后插入编辑</td></tr><tr><td><code>o</code></td><td>在当前行后插入一个新行</td></tr><tr><td><code>O</code></td><td>在当前行前插入一个新行</td></tr><tr><td><code>cw</code></td><td>替换从光标所在位置后到一个单词结尾的字符</td></tr></tbody></table></li></ul><h3 id="命令模式">命令模式</h3><ul><li><p>在普通模式下输入<code>:</code>进入命令模式</p></li><li><p>退出vim：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:q!</code></td><td>强制退出，不保存</td></tr><tr><td><code>:q</code></td><td>退出</td></tr><tr><td><code>:wq!</code></td><td>强制保存并退出</td></tr><tr><td><code>:w &lt;文件路径&gt;</code></td><td>另存为</td></tr><tr><td><code>:saveas 文件路径</code></td><td>另存为</td></tr><tr><td><code>:x</code></td><td>保存并退出</td></tr><tr><td><code>:wq</code></td><td>保存并退出</td></tr></tbody></table></li><li><p>或者使用<kbd>Shift</kbd> + <kbd>Z</kbd> <kbd>Z</kbd>（按两次z）保存并退出vim</p></li></ul><h2 id="bash操作">bash操作</h2><h3 id="定义变量">定义变量</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> tmp</span><br></pre></td></tr></table></figure><h3 id="变量赋值">变量赋值</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tmp</span><span class="operator">=</span>shiyanlou</span><br></pre></td></tr></table></figure><h3 id="读取变量">读取变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><h3 id="新建子终端">新建子终端</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bash</span></span><br></pre></td></tr></table></figure><h3 id="时间测量（time）">时间测量（time）</h3><ul><li><p>time 命令常用于测量一个命令的运行时间，包括实际使用时间（real time）、用户态使用时间（the process spent in user mode）、内核态使用时间（the process spent in kernel mode）。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">time</span> <span class="selector-attr">[command]</span></span><br></pre></td></tr></table></figure></li><li><p>测量 date 命令运行的时间</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">time</span> <span class="built_in">date</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740854918" alt="img"></p><p>从上面的结果可以到：实际运行时间为 0.005s，用户 cpu 时间为 0.001s，系统 cpu 时间为 0.001s。</p><p>其中，用户 CPU 时间和系统 CPU 时间之和为 CPU 时间，即命令占用 CPU 执行的时间总和。实际时间要大于 CPU 时间，因为 Linux 是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。</p></li></ul><h2 id="搜索操作">搜索操作</h2><h3 id="where">where</h3><ul><li><p>只能检索二进制文件（<code>-b</code>)、man帮助文件(<code>-m</code>)和源代码文件(<code>-s</code>)</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> find</span><br></pre></td></tr></table></figure></li></ul><h3 id="which">which</h3><ul><li><p>在 PATH 变量指定的路径中搜索可执行文件的所在位置，一般用来确认系统中是否安装了指定的软件。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which <span class="tag">&lt;<span class="name">可执行文件名称</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="whereis">whereis</h3><ul><li><p>通过<code>/var/lib/mlocate/mlocate.db</code>数据库查找，主要用于定位可执行文件、源代码文件和帮助文件在文件系统中的位置。whereis 命令还具有搜索源代码、指定备用搜索路径和搜索不寻常项的功能。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>定位可执行文件</td></tr><tr><td><code>-m</code></td><td>定位帮助文件</td></tr><tr><td><code>-s</code></td><td>定位源代码文件</td></tr><tr><td><code>-u</code></td><td>搜索默认路径下除可执行文件、源代码文件和帮助文件以外的其它文件</td></tr><tr><td><code>-B</code></td><td>指定搜索可执行文件的路径</td></tr><tr><td><code>-M</code></td><td>指定搜索帮助文件的路径</td></tr><tr><td><code>-S</code></td><td>指定搜索源代码文件的路径</td></tr></tbody></table></li></ul><h3 id="locate">locate</h3><ul><li><p>locate 命令跟 whereis 命令类似，且它们使用的是相同的数据库。但 whereis 命令只能搜索可执行文件、联机帮助文件和源代码文件，如果要获得更全面的搜索结果，可以使用 locate 命令。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [option] <span class="tag">&lt;<span class="name">搜索字符串</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-q</code></td><td>安静模式，不会显示任何错误讯息</td></tr><tr><td><code>-n</code></td><td>至多显示 n 个输出</td></tr><tr><td><code>-r</code></td><td>使用正则表达式做寻找的条件</td></tr><tr><td><code>-V</code></td><td>显示版本信息</td></tr></tbody></table></li><li><p>安装并立即更新一次数据库：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install locate</span><br><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure></li></ul><h3 id="find">find</h3><ul><li><p>主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="selector-attr">[path]</span> <span class="selector-attr">[option]</span> <span class="selector-attr">[动作表达式]</span></span><br></pre></td></tr></table></figure><p>默认路径是当前目录，默认表达式为 -print。</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td><code>-print</code></td><td>将匹配的文件输出到标准输出</td></tr><tr><td><code>-exec</code></td><td>对匹配的文件执行该参数所给出的 shell 命令</td></tr><tr><td><code>-name</code></td><td>按照文件名查找文件</td></tr><tr><td><code>-type</code></td><td>查找某一类型的文件</td></tr><tr><td><code>-prune</code></td><td>不在当前指定的目录中查找，如果同时使用 <code>-depth</code> 选项，那么 <code>-prune</code> 将被忽略</td></tr><tr><td><code>-user</code></td><td>按照文件属主来查找文件</td></tr><tr><td><code>-group</code></td><td>按照文件所属的组来查找文件</td></tr><tr><td><code>-mtime -n +n</code></td><td>按照文件的更改时间来查找文件，<code>-n</code> 表示文件更改时间距现在小于 n 天，<code>+n</code> 表示文件更改时间距现在大于 n 天</td></tr></tbody></table>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印当前目录下的文件目录列表</span></span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印当前目录下所有以.txt 结尾的文件名</span></span><br><span class="line"><span class="built_in">find</span> . -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印当前目录下所有以.txt 或.pdf 结尾的文件名</span></span><br><span class="line"><span class="built_in">find</span> . \( -name <span class="string">&quot;*.pdf&quot;</span> -or -name <span class="string">&quot;*.txt&quot;</span> \)</span><br><span class="line"><span class="comment"># 打印当前目录下所有不以.txt 结尾的文件名</span></span><br><span class="line"><span class="built_in">find</span> . ! -name <span class="string">&quot;*.txt&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="打包与解压">打包与解压</h2><h3 id="zip">zip</h3><h4 id="打包">打包</h4><ul><li><p>将test目录打包</p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -r -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>将目录 /home/shiyanlou/Desktop 打包成一个文件，<code>-r</code>参数表示递归打包包含子目录的全部内容，<code>-q</code> 参数表示安静模式，即不向屏幕输出信息，<code>-o</code>表示输出文件，需在其后紧跟打包输出文件名。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231221181820531.png" alt="image-20231221181820531"></p></li><li><p>加密打包：<code>-e</code></p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -r -<span class="keyword">e</span> -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221182845455.png" alt="image-20231221182845455"></p></li><li><p>适配Windows换行：<code>-l</code>，将 <code>LF</code> 转换为 <code>CR+LF</code></p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -r -<span class="keyword">l</span> -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="解压">解压</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip <span class="tag">&lt;<span class="name">zip_file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>安静模式：<code>-q</code>，不存在的目录会自动创建</p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -q <span class="keyword">test</span>.<span class="keyword">zip</span> -<span class="keyword">d</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>仅查看内容：<code>-l</code></p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -<span class="keyword">l</span> <span class="keyword">test</span>.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure></li><li><p>指定编码：<code>-O</code></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK <span class="tag">&lt;<span class="name">中文压缩文件.zip</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="tar">tar</h3><h4 id="打包-2">打包</h4><ul><li><p>打包为<code>.tar</code></p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -Pcf <span class="keyword">test</span>.tar <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183411352.png" alt="image-20231221183411352"></p><p><code>-P</code> 保留绝对路径符，<code>-c</code> 表示创建一个 tar 包文件，<code>-f</code> 用于指定创建的文件名，注意文件名必须紧跟在 <code>-f</code> 参数之后</p></li><li><p>打包为<code>.tar.gz</code>：<code>-z</code></p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf <span class="keyword">test</span>.tar.gz <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183533959.png" alt="image-20231221183533959"></p></li><li><p>更多格式：</p><table><thead><tr><th>压缩文件格式</th><th>参数</th></tr></thead><tbody><tr><td><code>*.tar.gz</code></td><td><code>-z</code></td></tr><tr><td><code>*.tar.xz</code></td><td><code>-J</code></td></tr><tr><td><code>*tar.bz2</code></td><td><code>-j</code></td></tr></tbody></table></li></ul><h4 id="解压-2">解压</h4><ul><li><p>解压<code>.tar</code></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf shiyanlou<span class="selector-class">.tar</span> <span class="selector-attr">[-C &lt;tardir&gt;]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183711774.png" alt="image-20231221183711774"></p><p>解包一个文件（<code>-x</code> 参数）到指定路径的<strong>已存在</strong>目录（<code>-C</code> 参数）</p></li><li><p>解压<code>.tar.gz</code>：<code>-z</code></p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183815734.png" alt="image-20231221183815734"></p></li></ul><h4 id="不解压查看">不解压查看</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf <span class="keyword">test</span>.tar</span><br></pre></td></tr></table></figure><h2 id="帮助操作">帮助操作</h2><h3 id="help">help</h3><ul><li><p>只能用于显示内建命令的帮助信息（仅能在bash中使用）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li><p>通常外部命令都有<code>--help</code>参数</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="man">man</h3><ul><li><p>得到的内容比用 help 更多更详细，而且man没有内建与外部命令的区分</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">man</span> <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>按下<kbd>Q</kbd>退出查看</p></li></ul><h3 id="info">info</h3><ul><li><p>安装：</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install <span class="keyword">info</span></span><br></pre></td></tr></table></figure>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">info</span> ls</span><br></pre></td></tr></table></figure><p>按下<kbd>Q</kbd>退出查看</p></li></ul><h2 id="语句控制">语句控制</h2><h3 id="多语句执行">多语句执行</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="number">1</span><span class="comment">; 语句2 ;语句3</span></span><br></pre></td></tr></table></figure><h3 id="条件执行（-）">条件执行（&amp;&amp; ||）</h3><ul><li><p><code>&amp;&amp;</code>：如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的语句，否则不执行</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="selector-tag">A</span> &amp;&amp; 语句<span class="selector-tag">B</span></span><br></pre></td></tr></table></figure></li><li><p><code>||</code>：和<code>&amp;&amp;</code>相反，返回1则执行后面的语句</p></li></ul><h3 id="管道（-）">管道（|）</h3><ul><li><p>将前一语句的输出作为下一语句的输入</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc | less</span><br></pre></td></tr></table></figure></li></ul><h2 id="文本处理">文本处理</h2><h3 id="标准输出处理（xargs）">标准输出处理（xargs）</h3><ul><li><p>xargs 命令可以从标准输入接收输入，并把输入转换为一个特定的参数列表。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">command</span> | xargs [<span class="keyword">option</span>] [<span class="keyword">command</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-n</code></td><td>指定每行最大的参数数量</td></tr><tr><td><code>-d</code></td><td>指定分隔符</td></tr></tbody></table></li><li><p>将多行输入转换为单行输出</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt <span class="string">| xargs</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486436814" alt="img"></p></li><li><p>将单行输入转换为多行输出</p>  <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7&quot; | xargs -n 3</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486477811" alt="img"></p></li><li><p>将单行输入转换为多行输出，指定分隔符为 i</p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cat</span> <span class="selector-tag">b</span><span class="selector-class">.txt</span> | <span class="selector-tag">xargs</span> <span class="selector-tag">-d</span> <span class="selector-tag">i</span> <span class="selector-tag">-n</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486635856" alt="img"></p></li><li><p>查找当前目录下所有 c 代码文件，统计总行数</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="keyword">type</span> <span class="type">f </span>-name <span class="string">&quot;*.c&quot;</span> | xargs wc -l</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486674638" alt="img"></p></li></ul><h3 id="文本切分（cut）">文本切分（cut）</h3><ul><li><p>cut 命令是一个将文本按列进行切分的小工具，它可以指定分隔每列的定界符。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>以字节为单位进行分割</td></tr><tr><td><code>-c</code></td><td>以字符为单位进行分割</td></tr><tr><td><code>-d</code></td><td>自定义分隔符，默认为制表符</td></tr><tr><td><code>-f</code></td><td>自定义字段</td></tr><tr><td><code>--complement</code></td><td>抽取整个文本行，除了那些由 <code>-c</code> 或 <code>-f</code> 选项指定的文本</td></tr></tbody></table></li><li><p>取出<code>/etc/passwd</code>文件中以<code>:</code>为分隔符的第1个字段和第6个字段</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="regexp">/etc/</span>passwd -d <span class="string">&#x27;:&#x27;</span> -f <span class="number">1</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231217204359115.png" alt="image-20231217204359115"></p></li><li><p>取指定数量字符</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前五个（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c -<span class="number">5</span></span><br><span class="line"><span class="comment"># 前五个之后的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span>-</span><br><span class="line"><span class="comment"># 第五个</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span></span><br><span class="line"><span class="comment"># 2到5之间的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">2</span>-<span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="匹配字符串（grep）">匹配字符串（grep）</h3><ul><li><p>grep 用来找到文件中的匹配文本，并且能够接受正则表达式和通配符，同时可以用多个 grep 命令选项来生成各种格式的输出。</p></li><li><p>grep 通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回 0，如果搜索不成功，则返回 1，如果搜索的文件不存在，则返回 2</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> [option] <span class="symbol">&lt;pattern&gt;</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>计算找到‘搜寻字符串’（即 pattern）的次数</td></tr><tr><td><code>-i</code></td><td>忽略大小写的不同，所以大小写视为相同</td></tr><tr><td><code>-n</code></td><td>输出行号</td></tr><tr><td><code>-v</code></td><td>反向选择，打印不匹配的行</td></tr><tr><td><code>-r</code></td><td>递归搜索</td></tr><tr><td><code>--color=auto</code></td><td>将找到的关键词部分加上颜色显示</td></tr></tbody></table></li><li><p>将<code>/etc/passwd</code>文件中出现 root 的行取出来，关键词部分加上颜色显示</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">&quot;root&quot;</span> <span class="regexp">/etc/</span>passwd --color=auto</span><br><span class="line">cat <span class="regexp">/etc/</span>passwd | <span class="keyword">grep</span> <span class="string">&quot;root&quot;</span> --color=auto</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219124625381.png" alt="image-20231219124625381"></p></li><li><p>将<code>/etc/passwd</code>文件中没有出现 root 和 nologin 的行取出来</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -v <span class="string">&quot;root&quot;</span> <span class="regexp">/etc/</span>passwd | <span class="keyword">grep</span> -v <span class="string">&quot;nologin&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219124700264.png" alt="image-20231219124700264"></p></li></ul><h3 id="内容统计（wc）">内容统计（wc）</h3><ul><li><p>wc 命令是一个统计的工具，主要用来显示文件所包含的行、字和字节数。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>统计字节数</td></tr><tr><td><code>-l</code></td><td>统计行数</td></tr><tr><td><code>-m</code></td><td>统计字符数，这个标志不能与 <code>-c</code> 标志一起使用</td></tr><tr><td><code>-w</code></td><td>统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串</td></tr><tr><td><code>-L</code></td><td>打印最长行的长度</td></tr></tbody></table></li><li><p>统计文件数</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计/bin目录下的命令个数，即文件个数</span></span><br><span class="line"><span class="built_in">ls</span> /bin | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li></ul><h3 id="排序（sort）">排序（sort）</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-n</code></td><td>基于字符串的长度来排序，使用此选项允许根据数字值排序，而不是字母值</td></tr><tr><td><code>-k</code></td><td>指定排序关键字</td></tr><tr><td><code>-b</code></td><td>默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略每行开头的空格，从第一个非空白字符开始排序</td></tr><tr><td><code>-m</code></td><td>只合并多个输入文件</td></tr><tr><td><code>-r</code></td><td>按相反顺序排序，结果按照降序排列，而不是升序</td></tr><tr><td><code>-t</code></td><td>自定义分隔符，默认为制表符</td></tr></tbody></table><ul><li><p>列出<code>/usr/share/</code>目录下使用空间最多的前 10 个目录文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -s /usr/share/* | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219130029985.png" alt="image-20231219130029985"></p></li><li><p>对 ls 命令输出信息中的空间使用大小字段进行排序</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /usr/bin/ | <span class="built_in">sort</span> -nr -k 5 | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219130116293.png" alt="image-20231219130116293"></p></li></ul><h3 id="去重（uniq）">去重（uniq）</h3><ul><li><p>uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。</p></li><li><p>uniq 只能用于排过序的数据输入，因此，uniq 要么使用管道，要么将排过序的文件作为输入，并总是以这种方式与 sort 命令结合起来使用。</p>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uni<span class="string">q [option]</span> &lt;file&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>在每行前加上表示相应行目出现次数的前缀编号</td></tr><tr><td><code>-d</code></td><td>只输出重复的行</td></tr><tr><td><code>-u</code></td><td>只显示唯一的行</td></tr><tr><td><code>-D</code></td><td>显示所有重复的行</td></tr><tr><td><code>-f</code></td><td>比较时跳过前 n 列</td></tr><tr><td><code>-i</code></td><td>在比较的时候不区分大小写</td></tr><tr><td><code>-s</code></td><td>比较时跳过前 n 个字符</td></tr><tr><td><code>-w</code></td><td>对每行第 n 个字符以后的内容不作对照</td></tr></tbody></table></li><li><p>找出<code>/bin</code>目录和<code>/usr/bin</code>目录下所有相同的命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -d</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781011797" alt="img"></p></li><li><p>现有文件内容如下，红色方框里的内容表示区号，现在要统计出各个区号的总人数</p><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781055838" alt="img"></p><p>实现思路：首先按区号对每行信息排序，然后使用 uniq 命令对区号进行重复行统计。使用命令如下：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sort</span> -k <span class="number">4</span>.<span class="number">1</span>n,<span class="number">4</span>.<span class="number">1</span>n student.txt | uniq -c -f <span class="number">3</span> -w <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781089813" alt="img"></p></li></ul><h3 id="更改字符（tr）">更改字符（tr）</h3><ul><li><p>tr 命令常被用来更改字符，我们可以把它看作是一种基于字符的查找和替换操作。换字是一种把字符从一个字母转换为另一个字母的过程，tr 可以从标准输入中替换、缩减和删除字符，并将结果写到标准输出。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> <span class="selector-attr">[option]</span> SET1 <span class="selector-attr">[SET2]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td><code>-s</code></td><td>去除set1指定的在输入文本中连续并重复的字符</td></tr></tbody></table></li><li><p>将输入的字符大写转换为小写</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;THIS IS SHIYANLOU!&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219125549403.png" alt="image-20231219125549403"></p></li><li><p>将输入的字符中的数字删除</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;THIS 123 IS S1HIY5ANLOU!&#x27;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;0-9&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219125607524.png" alt="image-20231219125607524"></p></li></ul><h3 id="Tab替换空格（col）">Tab替换空格（col）</h3><ul><li><p><code>col</code>命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">col</span><span class="meta"> [option]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-x</code></td><td>将<code>Tab</code>转换为空格</td></tr><tr><td><code>-h</code></td><td>将空格转换为<code>Tab</code>（默认选项）</td></tr></tbody></table>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看<span class="regexp">/etc/</span>protocols中的不可见字符，可以看到很多^I，这其实就是Tab转义成可见字符的符号</span><br><span class="line">cat -A <span class="regexp">/etc/</span>protocols</span><br><span class="line"># 使用 col -x将<span class="regexp">/etc/</span>protocols中的Tab转换为空格,然后再使用cat查看，发现^I不见了</span><br><span class="line">cat <span class="regexp">/etc/</span>protocols | col -x | cat -A</span><br></pre></td></tr></table></figure></li></ul><h3 id="合并字段（join）">合并字段（join）</h3><ul><li><p>join将两个文件中指定栏位相同的行连接起来，即按照两个文件中共同拥有的某一列，将对应的行拼接成一行</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">join</span> [option] <span class="symbol">&lt;file1&gt;</span> <span class="symbol">&lt;file2&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定分隔符，默认为Tab</td></tr><tr><td><code>-i</code></td><td>忽略大小写的差异</td></tr><tr><td><code>-1</code>（数字1）</td><td>指明第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td><code>-2</code></td><td>指明第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table></li><li><p>将两个文件中的第一个字段作为匹配字段，连接两个文件</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join <span class="selector-tag">a</span><span class="selector-class">.txt</span> <span class="selector-tag">b</span>.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781241207" alt="img"></p></li><li><p>指定两个文件的第三个字段为匹配字段，连接两个文件</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">join</span> -<span class="number">1</span> <span class="number">3</span> -<span class="number">2</span> <span class="number">3</span> c.txt d.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/document-uid370051labid370timestamp1490930024622.png" alt="此处输入图片的描述"></p></li></ul><h3 id="简单合并文件（paste）">简单合并文件（paste）</h3><ul><li><p>paste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;...</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-s</code></td><td>将每个文件合并成行而不是按行粘贴</td></tr><tr><td><code>-d</code></td><td>自定义分隔符，默认为制表符</td></tr></tbody></table></li><li><p>将<code>student.txt</code>和<code>telphone.txt</code>文件中的内容按列拼接</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> student.txt telphone.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid369time1420780031604" alt="img"></p></li><li><p>将<code>student.txt</code>和<code>telphone.txt</code>文件中的内容按列拼接，指定分隔符为<code>:</code></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste student<span class="selector-class">.txt</span> telphone<span class="selector-class">.txt</span> -d <span class="string">&#x27;:&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid369time1420780078087" alt="img"></p></li><li><p>将<code>student.txt</code>和<code>telphone.txt</code>文件中的内容各自拼接成一行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -s student.txt telphone.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid369time1420780124133" alt="img"></p></li></ul><h3 id="比较文本文件（comm）">比较文本文件（comm）</h3><ul><li><p>comm 命令将逐行比较已经排序的两个文件。显示结果包括 3 列：第 1 列为只在第一个文件中找到的行，第 2 列为只在第二个文件中找到的行，第 3 列为两个文件的共有行。</p>  <figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comm [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">file1</span>&gt;</span> </span><span class="language-xml"><span class="tag">&lt;<span class="name">file2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-1</code>（数字1）</td><td>不输出文件 1 特有的行</td></tr><tr><td><code>-2</code></td><td>不输出文件 2 特有的行</td></tr><tr><td><code>-3</code></td><td>不输出两个文件共有的行</td></tr></tbody></table></li><li><p>比较<code>file1.txt</code>和<code>file2.txt</code>两个文件的内容</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">comm</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781783879" alt="img"></p></li><li><p>比较<code>file1.txt</code>和<code>file2.txt</code>两个文件的内容，只显示两个文件共有的内容</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">comm</span> -<span class="number">12</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781829807" alt="img"></p></li></ul><h3 id="监测文件差异（diff）">监测文件差异（diff）</h3><ul><li><p>类似 comm 命令，diff 命令被用来监测文件之间的差异。然而，diff 是一款更加复杂的工具，它支持许多输出格式，并且一次能处理许多文本文件。diff 能够递归地检查源码目录，通常称之为源码树。diff 程序的一个常见用例是创建 diff 文件或者补丁，它会被其它程序使用，例如 patch 程序，来把文件从一个版本转换为另一个版本。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>上下文模式，显示全部内文，并标出不同之处</td></tr><tr><td><code>-u</code></td><td>统一模式，以合并的方式来显示文件内容的不同</td></tr><tr><td><code>-a</code></td><td>只会逐行比较文本文件</td></tr><tr><td><code>-N</code></td><td>在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：Only in 目录。若使用 -N 参数，则 diff 会将文件 A 与一个空白的文件比较</td></tr><tr><td><code>-r</code></td><td>递归比较目录下的文件</td></tr></tbody></table></li><li><p>显示<code>file1.txt</code>和<code>file2.txt</code>两个文件的差异</p>  <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">diff</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781912223" alt="img"></p><p>上面结果显示中的“1d0”表示<code>file1.txt</code>文件比<code>file2.txt</code>文件多了第一行，“4c3,4”表示<code>file1.txt</code>文件的第四行和<code>file2.txt</code>文件的第三、四行不同。</p><blockquote><p>diff 的 normal 显示格式有三种提示:</p><ul><li>a - add</li><li>c - change</li><li>d - delete</li></ul></blockquote></li><li><p>从上面例一的显示结果可以知道，<code>file1.txt</code>和<code>file2.txt</code>两个文件的差异不易直观看出，这时可以使用上下文模式显示</p>  <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff  -<span class="keyword">c</span> file<span class="number">1</span>.txt  file<span class="number">2</span>.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781985260" alt="img"></p><blockquote><p><code>+</code> 添加行，这一行将会出现在第二个文件内，而不是第一个文件内</p><p><code>-</code> 删除行，这一行将会出现在第一个文件中，而不是第二个文件内</p><p><code>!</code> 更改行，将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分</p></blockquote></li><li><p>查看<code>file1.txt</code>和<code>file2.txt</code>两个文件的差异，使用统一模式显示</p>  <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">diff</span> -u file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420782103081" alt="img"></p></li></ul><h3 id="文本中应用更改（patch）">文本中应用更改（patch）</h3><ul><li><p>patch 命令被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p num</code></td><td>忽略几层文件夹</td></tr><tr><td><code>-E</code></td><td>如果发现了空文件，那么就删除它</td></tr><tr><td><code>-R</code></td><td>取消打过的补丁</td></tr></tbody></table></li><li><p>生成<code>file1.txt</code>和<code>file2.txt</code>的 diff 文件，然后应用 patch 命令更新<code>file1.txt</code>文件</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff  -Naur file1<span class="selector-class">.txt</span>  file2<span class="selector-class">.txt</span> &gt; patchdiff<span class="selector-class">.txt</span></span><br><span class="line">patch &lt; patchdiff.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420782242319" alt="img"></p></li><li><p>取消上面打过的补丁</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">patch</span> -R &lt; patchdiff.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420782287649" alt="img"></p></li></ul><h2 id="空间管理">空间管理</h2><h3 id="查看目录结构（tree）">查看目录结构（tree）</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tree</span> &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p>安装方式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install tree</span><br></pre></td></tr></table></figure><h3 id="磁盘占用情况（df）">磁盘占用情况（df）</h3><ul><li><p>df （disk free）命令的功能是用来检查 linux 服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-a</code></td><td>全部文件系统列表</td></tr><tr><td><code>-h</code></td><td>方便阅读方式显示</td></tr><tr><td><code>-i</code></td><td>显示 inode 信息</td></tr><tr><td><code>-T</code></td><td>文件系统类型</td></tr><tr><td><code>-t&lt;文件系统类型&gt;</code></td><td>只显示选定文件系统的磁盘信息</td></tr><tr><td><code>-x&lt;文件系统类型&gt;</code></td><td>不显示选定文件系统的磁盘信息</td></tr></tbody></table></li><li><p>显示磁盘使用情况</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740116614" alt="img"></p></li><li><p>以 inode 模式来显示磁盘使用情况</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -i</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740127431" alt="img"></p></li><li><p>列出文件系统的类型</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -T</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740135464" alt="img"></p></li><li><p>显示指定类型磁盘</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -t ext4</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740147180" alt="img"></p></li></ul><h3 id="查看使用空间（du）">查看使用空间（du）</h3><ul><li><p>du（disk usage）命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示目录中所有文件的大小。</td></tr><tr><td><code>-b</code></td><td>显示目录或文件大小时，以 byte 为单位。</td></tr><tr><td><code>-c</code></td><td>除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</td></tr><tr><td><code>-k</code></td><td>以 KB(1024bytes)为单位输出。</td></tr><tr><td><code>-m</code></td><td>以 MB 为单位输出。</td></tr><tr><td><code>-s</code></td><td>仅显示总计，只列出最后加总的值。</td></tr><tr><td><code>-h</code></td><td>以 K，M，G 为单位，提高信息的可读性。</td></tr></tbody></table></li><li><p>显示指定文件所占空间，以方便阅读的格式显示</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h file1.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740343106" alt="img"></p></li><li><p>显示指定目录所占空间，以方便阅读的格式显示</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h Desktop</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740370569" alt="img"></p></li><li><p>显示几个文件或目录各自占用磁盘空间的大小，并且统计总和</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -ch file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740386138" alt="img"></p></li><li><p>按照空间大小逆序排序显示</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740400752" alt="img"></p></li></ul>]]></content>
    
    
    <summary type="html">Linux中常用的简单操作</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
    <category term="学期总结" scheme="https://www.iuoyt.com/tags/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的进程</title>
    <link href="https://www.iuoyt.com/posts/62cfef17.html"/>
    <id>https://www.iuoyt.com/posts/62cfef17.html</id>
    <published>2023-12-01T11:31:29.000Z</published>
    <updated>2023-12-01T15:06:50.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序与进程">程序与进程</h2><ul><li><p>简单地说，程序就是为了完成某种任务而设计的软件，进程就是运行中的程序。</p></li><li><p>程序只是一些列指令的集合，是一个静止的实体，而进程则有以下特性：</p><ul><li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li><li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li><li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li><li>异步性：进程以不可预知的速度向前推进。</li><li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li></ul></li><li><p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。</p><blockquote><p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p></blockquote></li><li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li></ul><h2 id="进程的属性">进程的属性</h2><h3 id="进程的分类">进程的分类</h3><h4 id="按功能和服务对象">按功能和服务对象</h4><ul><li>从这个角度看，可以将进程分为用户进程与系统进程<ul><li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li><li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li></ul></li></ul><h4 id="按应用程序的服务类型">按应用程序的服务类型</h4><ul><li>从这个角度看，可以将进程分为交互进程、批处理进程、守护进程<ul><li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。</li></ul></li></ul><h3 id="进程的衍生">进程的衍生</h3><h4 id="父进程与子进程">父进程与子进程</h4><ul><li><p>子进程是由父进程开启的，比如在终端中输入<code>bash</code>再启动一个终端，那么新打开的终端则称为子进程，前者则为父进程。关于父进程与子进程便会涉及这两个系统调用 <code>fork()</code> 与 <code>exec()</code>：</p><ul><li><code>fork()</code>：主要作用是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</li><li><code>exec()</code>：作用是切换子进程中的执行程序，也就是替换其从父进程复制过来的代码段与数据段</li></ul></li><li><p>子进程在退出前主函数<code>main()</code>会执行<code>exit(n)</code>或者<code>return n</code>返回一个信号值，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。</p></li></ul><h4 id="僵尸进程">僵尸进程</h4><ul><li>正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 <code>reason for termination</code> 。之后，父进程会使用 <code>wait(&amp;status)</code> 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。</li><li>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。</li></ul><h4 id="孤儿进程">孤儿进程</h4><ul><li>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。</li></ul><h4 id="进程0（内核初始化进程）">进程0（内核初始化进程）</h4><ul><li>进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 <code>fork()</code> 创建出一个子进程运行 <code>/sbin/init</code> 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。</li></ul><h3 id="进程组与Session">进程组与Session</h3><ul><li>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</li><li>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 <code>getpgrp()</code> 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</li><li>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，Session 中的每个进程都称为一个工作(job)。</li></ul><h3 id="工作管理">工作管理</h3><ul><li><p>并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。</p></li><li><p>结束前台进程可以使用<kbd>Ctrl</kbd>+<kbd>C</kbd>，但无法结束后台进程。</p></li><li><p>如果使用<code>&amp;</code>符号，进程则会在后台中运行，查看运行中的进程可以使用<code>ls &amp;</code>，得到序号如<code>[1] 204</code>分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224354846.png" alt="image-20231201224354846"></p></li><li><p>如果希望暂停当前工作并存放到后台可以使用<kbd>Ctrl</kbd>+<kbd>Z</kbd></p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224613524.png" alt="image-20231201224613524"></p></li><li><p>被放置到后台的工作可以使用<code>jobs</code>查看。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224819667.png" alt="image-20231201224819667"></p><p>其中第一列显示的为被放置后台 job 的编号，而第二列的 <code>+</code> 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，<code>-</code> 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令。</p></li><li><p>如果希望将后台的工作拿到前台继续进行，可以使用<code>fg</code>命令：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后面不加参数提取预设工作，加参数提取指定工作的编号</span></span><br><span class="line"><span class="comment">#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</span></span><br><span class="line"><span class="attribute">fg</span><span class="meta"> [%jobnumber]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201225144514.png" alt="image-20231201225144514"></p></li><li><p>而如果希望其在后台继续而不拿到前台，可以使用<code>bg</code>命令：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与fg类似，加参则指定，不加参则取预设</span></span><br><span class="line"><span class="attribute">bg</span><span class="meta"> [%jobnumber]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201225553266.png" alt="image-20231201225553266"></p></li><li><p>如果希望删除后台的工作，可以使用<code>kill</code>命令结束进程：</p>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kill的使用格式如下</span></span><br><span class="line"><span class="keyword">kill</span> -signal %jobnumber</span><br><span class="line"></span><br><span class="line"><span class="comment">#signal从1-64个信号值可以选择，可以这样查看</span></span><br><span class="line"><span class="keyword">kill</span> －l</span><br></pre></td></tr></table></figure><p>其中常用的有这些信号值</p></li></ul><table><thead><tr><th>信号值</th><th>作用</th></tr></thead><tbody><tr><td>-1</td><td>重新读取参数运行，类似与restart</td></tr><tr><td>-2</td><td>如同 ctrl+c 的操作退出</td></tr><tr><td>-9</td><td>强制终止该任务</td></tr><tr><td>-15</td><td>正常的方式终止该任务</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Linux 中也难免遇到某个程序无响应的情况，可以通过一些命令来帮助我们让系统能够更流畅的运行。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下软件安装</title>
    <link href="https://www.iuoyt.com/posts/cf3716a6.html"/>
    <id>https://www.iuoyt.com/posts/cf3716a6.html</id>
    <published>2023-12-01T03:09:15.000Z</published>
    <updated>2023-12-01T15:04:02.973Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Linux上通常有四种方式安装软件：<ul><li>在线安装</li><li>从磁盘安装deb软件包</li><li>从二进制软件包安装</li><li>从源代码编译安装</li></ul></li><li>这篇文章中使用的场景均为Ubuntu下，不一定适用于其他Linux发行版。</li></ul><h2 id="使用apt-get安装软件">使用apt-get安装软件</h2><ul><li><p>现在如果想安装一个名为<code>w3m</code>（命令行的简易网页浏览器），那么可以输入如下命令：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install w3m</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201175216825.png" alt="image-20231201175216825"></p></li><li><p>在软件安装完成后，无法直接使用<kbd>Tab</kbd>补全命令，可以先执行如下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h3 id="apt包管理工具介绍">apt包管理工具介绍</h3><blockquote><p>APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 <code>apt-</code> 开头的多个工具，如 <code>apt-get</code> <code>apt-cache</code> <code>apt-cdrom</code> 等，在Debian系列的发行版中使用。</p></blockquote><ul><li>当在执行安装操作时，首先<code>apt-get</code> 工具会在<strong>本地</strong>的一个数据库中搜索软件的相关信息，并根据这些信息在相关的服务器上下载软件安装。</li><li>我们需要定期从服务器上下载一个软件包列表，系统会使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有<strong>软件依赖</strong>信息的记录，对于软件依赖，比如：安装 <code>w3m</code> 软件的时候，而这个软件需要 <code>libgc1c2</code> 这个软件包才能正常工作，这个时候 <code>apt-get</code> 在安装软件的时候会将其一并安装，以保证 <code>w3m</code> 能正常工作。</li></ul><h3 id="apt-get">apt-get</h3><ul><li><code>apt-get</code> 是用于处理 <code>apt</code>包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些<code>apt-get</code>包含的常用的一些工具：</li></ul><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><code>install</code></td><td>其后加上软件包名，用于安装一个软件包</td></tr><tr><td><code>update</code></td><td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td></tr><tr><td><code>upgrade</code></td><td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次<code>update</code></td></tr><tr><td><code>dist-upgrade</code></td><td>解决依赖关系并升级(存在一定危险性)</td></tr><tr><td><code>remove</code></td><td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td></tr><tr><td><code>autoremove</code></td><td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td></tr><tr><td><code>purge</code></td><td>与remove相同，但会完全移除软件包，包含其配置文件</td></tr><tr><td><code>clean</code></td><td>移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/</td></tr><tr><td><code>autoclean</code></td><td>移除已安装的软件的旧版本软件包</td></tr></tbody></table><ul><li><code>apt-get</code>的常用参数如下：</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-y</code></td><td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td></tr><tr><td><code>-s</code></td><td>模拟安装</td></tr><tr><td><code>-q</code></td><td>静默安装方式，指定多个<code>q</code>或者<code>-q=#</code>,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td></tr><tr><td><code>-f</code></td><td>修复损坏的依赖关系</td></tr><tr><td><code>-d</code></td><td>只下载不安装</td></tr><tr><td><code>--reinstall</code></td><td>重新安装已经安装但可能存在问题的软件包</td></tr><tr><td><code>--install-suggests</code></td><td>同时安装APT给出的建议安装的软件包</td></tr></tbody></table><h3 id="使用apt-get安装软件包">使用apt-get安装软件包</h3><ul><li><p>就像前面演示的一样，只需要执行<code>apt-get install &lt;软件包名&gt;</code>即可。</p></li><li><p>但有时需要重新对软件包进行安装，比如在系统被破坏、软件配置错误等时候，则可以加上<code>--reinstall</code>参数进行重新安装，比如对前面安装的<code>w3m</code>进行重装：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="comment">--reinstall install w3m</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201180918092.png" alt="image-20231201180918092"></p></li></ul><h3 id="更换软件源与软件升级">更换软件源与软件升级</h3><ul><li><p>如果希望更换软件的下载源，可以到<code>/etc/apt</code>目录下修改<code>sources.list</code>文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>apt/sources.list</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201181658888.png" alt="image-20231201181658888"></p></li><li><p>更新软件源可以使用如下命令：</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201181015727.png" alt="image-20231201181015727"></p></li><li><p>对所有没有依赖问题的软件包进行升级：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> upgrade</span><br></pre></td></tr></table></figure></li><li><p>全部升级并解决依赖关系：</p>  <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="built_in">dist</span>-upgrade</span><br></pre></td></tr></table></figure></li></ul><h3 id="卸载软件">卸载软件</h3><ul><li><p>现在想卸载掉<code>w3m</code>这个软件，可以使用同样的命令，带上<code>remove</code>参数即可完成卸载：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="built_in">remove</span> w3m</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201182239343.png" alt="image-20231201182239343"></p></li><li><p>如果希望不保留配置文件的移除，可以使用：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> purge w3m</span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="comment">--purge remove</span></span><br></pre></td></tr></table></figure></li><li><p>同时也可以移除不再需要的被依赖软件包：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> autoremove</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201182505496.png" alt="image-20231201182505496"></p></li></ul><h3 id="软件搜索">软件搜索</h3><ul><li><p>如果不确定需要的软件是否已经安装，可以使用搜索功能：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache search soft<span class="symbol">name1</span> soft<span class="symbol">name2</span> soft<span class="symbol">name3</span>……</span><br></pre></td></tr></table></figure><p><code>apt-cache</code> 命令是针对本地数据进行相关操作的工具，<code>search</code> 顾名思义在本地的数据库中寻找有关 <code>softname1</code> <code>softname2</code> …… 相关软件的信息。</p></li></ul><h2 id="使用dpkd安装">使用dpkd安装</h2><h3 id="安装deb软件包">安装deb软件包</h3><ul><li>我们可以经常在网络上见到以<code>deb</code>形式打包的软件包，这些软件包就需要使用<code>dpkg</code>命令来安装，常用参数如下：</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-i</code></td><td>安装指定deb包</td></tr><tr><td><code>-R</code></td><td>后面加上目录名，用于安装该目录下的所有deb安装包</td></tr><tr><td><code>-r</code></td><td>remove，移除某个已安装的软件包</td></tr><tr><td><code>-I</code></td><td>显示<code>deb</code>包文件的信息</td></tr><tr><td><code>-s</code></td><td>显示已安装软件的信息</td></tr><tr><td><code>-S</code></td><td>搜索已安装的软件包</td></tr><tr><td><code>-L</code></td><td>显示已安装软件包的目录信息</td></tr></tbody></table><ul><li><p>首先使用<code>apt-get</code>加上<code>-d</code>参数只下载不安装，下载<code>emacs</code>编辑器的deb包：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> -d install -y emacs</span><br></pre></td></tr></table></figure></li><li><p>下载完成后，可以在<code>/var/cache/apt/archives/</code>查看下载的内容：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="regexp">/var/</span>cache<span class="regexp">/apt/</span>archives/</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201190916849.png" alt="image-20231201190916849"></p></li><li><p>将第一个文件拷贝到用户目录下，并使用<code>dpkg</code>安装：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cp</span> /var/cache/apt/archives/emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb ~</span><br><span class="line"><span class="attribute">sudo</span> dpkg -I emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201191438879.png" alt="image-20231201191438879"></p></li><li><p>但如果安装的软件包还有额外依赖，那么意味着直接使用<code>dpkg</code>命令会出现一些问题，因为<code>dpkg</code>无法解决依赖关系问题：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dpkg -i emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201191718630.png" alt="image-20231201191718630"></p></li><li><p>为了解决这个问题，可以使用<code>apt-get</code>的<code>-f</code>参数修复依赖关系的安装：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> -f install -y</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看已安装软件包的安装目录">查看已安装软件包的安装目录</h3><ul><li><p>如果希望知道每个软件分别安装到了什么地方，可以使用<code>dpkg</code>的<code>-L</code>参数查看deb包目录信息：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dpkg -L emacs24</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201192702116.png" alt="image-20231201192702116"></p></li></ul>]]></content>
    
    
    <summary type="html">介绍Linux中软件安装的几种方式，及apt、dpkg工具的使用。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux正则表达式相关命令</title>
    <link href="https://www.iuoyt.com/posts/9505e307.html"/>
    <id>https://www.iuoyt.com/posts/9505e307.html</id>
    <published>2023-11-24T10:14:53.000Z</published>
    <updated>2023-11-25T03:20:44.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式">正则表达式</h2><blockquote><p><strong>正则表达式</strong>：计算机科学的一个概念，使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p></blockquote><h3 id="选择">选择</h3><ul><li><code>|</code>竖直分隔符表示选择，例如<code>boy|girl</code>可以匹配<code>boy</code>或者<code>girl</code></li></ul><h3 id="数量限定">数量限定</h3><ul><li><code>+</code>表示前面的字符必须出现至少一次（1次或多次），例如<code>ab+cd</code>，可以匹配<code>abcd</code>，<code>abbcd</code>等</li><li><code>?</code>表示前面的字符最多出现一次（0次或1次），例如<code>colou?r</code>，可以匹配<code>color</code>或者<code>colour</code></li><li><code>*</code>星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、1次或多次），例如<code>0*42</code>可以匹配<code>42</code>、<code>042</code>、<code>0042</code>、<code>00042</code>等</li></ul><h3 id="范围和优先级">范围和优先级</h3><ul><li><code>()</code>圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，<code>gr(a|e)y</code>等价于<code>gray|grey</code>（这里体现了优先级，竖直分隔符用于选择<code>a</code>或者<code>e</code>而不是<code>gra</code>和<code>ey</code>），<code>(grand)?father</code>匹配<code>father</code>和<code>grandfather</code>（这里体现了范围，<code>?</code>将圆括号内容作为一个整体匹配）</li></ul><h3 id="更多语法">更多语法</h3><table><thead><tr><th style="text-align:center">字符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td><strong>将下一个字符标记为一个特殊字符、或一个原义字符。</strong> 例如，<code>n</code>匹配字符<code>n</code>，<code>\n</code>匹配一个换行符，序列<code>\\</code>匹配<code>\</code>而<code>\(</code>则匹配<code>(</code></td></tr><tr><td style="text-align:center">^</td><td><strong>匹配输入字符串的开始位置</strong></td></tr><tr><td style="text-align:center">$</td><td><strong>匹配输入字符串的结束位置</strong></td></tr><tr><td style="text-align:center">{n}</td><td><strong>匹配确定的n次（n为非负整数）</strong>。例如，<code>o&#123;2&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code></td></tr><tr><td style="text-align:center">{n,}</td><td><strong>至少匹配n次（n为非负整数）</strong>。例如，<code>o&#123;2,&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但能匹配<code>foooood</code>中的所有<code>o</code>。<code>o&#123;1,&#125;</code>等价于<code>o+</code>，<code>o&#123;0,&#125;</code>则等价于<code>o*</code></td></tr><tr><td style="text-align:center">{n,m}</td><td><strong>最少匹配n次且最多匹配m次（m和n均为非负整数，其中n&lt;=m）。</strong> 例如，<code>o&#123;1,3&#125;</code>将匹配<code>fooooood</code>中的前三个<code>o</code>。<code>o&#123;0,1&#125;</code>等价于<code>o?</code>。请注意在逗号和两个数之间不能有空格</td></tr><tr><td style="text-align:center">*</td><td><strong>匹配前面的子表达式零次或多次</strong>。例如，<code>zo</code>能匹配<code>z</code>、<code>zo</code>以及<code>zoo</code>。<code>*</code>等价于<code>&#123;0,&#125;</code></td></tr><tr><td style="text-align:center">+</td><td><strong>匹配前面的子表达式一次或多次</strong>。例如，<code>zo+</code>能匹配<code>zo</code>以及<code>zoo</code>，但不能匹配<code>z</code>。<code>+</code>等价于<code>&#123;1,&#125;</code></td></tr><tr><td style="text-align:center">?</td><td><strong>匹配前面的子表达式零次或一次</strong>。例如，<code>do(es)?</code>可以匹配<code>do</code>或<code>does</code>中的<code>do</code>。<code>?</code>等价于<code>&#123;0,1&#125;</code></td></tr><tr><td style="text-align:center">限制符+?</td><td>当该字符紧跟在任何一个其他限制符（<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code>）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串<code>oooo</code>，<code>o+?</code>将匹配单个<code>o</code>，而<code>o+</code>将匹配所有<code>o</code></td></tr><tr><td style="text-align:center">.</td><td><strong>匹配除<code>\n</code>之外的任何单个字符</strong>。要匹配包括<code>\n</code>在内的任何字符，请使用像(.|\n)的模式</td></tr><tr><td style="text-align:center">(pattern)</td><td><strong>匹配pattern并获取这一匹配的子字符串</strong>。该子字符串用于向后引用。要匹配圆括号字符，请使用<code>\(</code>或<code>\)</code></td></tr><tr><td style="text-align:center">x|y</td><td><strong>匹配x或y</strong>。例如z|food能匹配<code>z</code>或<code>food</code>，(z|f)ood则匹配<code>zood</code>或<code>food</code></td></tr><tr><td style="text-align:center">[xyz]</td><td>字符集合，<strong>匹配所包含的任意一个字符</strong>。例如，<code>[abc]</code>可以匹配<code>plain</code>中的<code>a</code>。其中特殊字符仅有反斜线<code>\</code>保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符<code>^</code>如果出现在首位则表示负值字符集合，如果出现在字符串中间就仅作为普通字符。<strong>连字符<code>-</code> 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符</strong></td></tr><tr><td style="text-align:center">[^xyz]</td><td>排除型字符集合，<strong>匹配未列出的任意字符。</strong> 例如，<code>[^abc]</code>可以匹配<code>plain</code>中的<code>plin</code></td></tr><tr><td style="text-align:center">[a-z]</td><td>字符范围，<strong>匹配指定范围内的任意字符。</strong> 例如，<code>[a-z]</code>可以匹配<code>a</code>到<code>z</code>范围内的任意小写字母字符</td></tr><tr><td style="text-align:center">[^a-z]</td><td>排除型的字符范围，<strong>匹配任何不在指定范围内的任意字符</strong>。例如，<code>[^a-z]</code>可以匹配任何不在<code>a</code>到<code>z</code>范围内的任意字符</td></tr></tbody></table><h3 id="优先级">优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>高</td><td>\</td><td>转义符</td></tr><tr><td></td><td>(), (?:), (?=), []</td><td>括号和中括号</td></tr><tr><td></td><td>*、+、?、{n}、{n,}、{n,m}</td><td>限定符</td></tr><tr><td></td><td>^、$、\任何元字符</td><td>定位点和序列</td></tr><tr><td>低</td><td>|</td><td>选择</td></tr></tbody></table><h2 id="相关命令">相关命令</h2><h3 id="grep模式匹配命令">grep模式匹配命令</h3><h4 id="基本操作">基本操作</h4><ul><li><code>grep</code>命令用于打印输出文本中匹配的模式串，使用正则表达式作为匹配的条件。这个命令支持三种正则表达式引擎，用三种参数指定，在不使用perl语言的情况下用的大多数正则表达式都是前两种：</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-E</code></td><td style="text-align:center">POSIX扩展正则表达式，ERE</td></tr><tr><td style="text-align:center"><code>-G</code></td><td style="text-align:center">POSIX基本正则表达式，BRE</td></tr><tr><td style="text-align:center"><code>-P</code></td><td style="text-align:center">Perl正则表达式，PCRE</td></tr></tbody></table><ul><li><code>grep</code>命令有如下常用参数：</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:left">将二进制文件作为文本来进行匹配</td></tr><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:left">统计以模式匹配的数目</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:left">忽略大小写</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:left">显示匹配文本所在行的行号</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:left">反选，输出不匹配行的内容</td></tr><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:left">递归匹配查找</td></tr><tr><td style="text-align:center"><code>-A n</code></td><td style="text-align:left">n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行</td></tr><tr><td style="text-align:center"><code>-B n</code></td><td style="text-align:left">n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行</td></tr><tr><td style="text-align:center"><code>--color=auto</code></td><td style="text-align:left">将输出中的匹配项设置为自动颜色显示</td></tr></tbody></table><h4 id="使用基本正则表达式BRE">使用基本正则表达式BRE</h4><h5 id="位置">位置</h5><ul><li><p>查找<code>/etc/group</code>文件中以<code>shiyanlou</code>开头的行：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">&#x27;shiyanlou&#x27;</span> <span class="regexp">/etc/g</span>roup</span><br><span class="line"><span class="keyword">grep</span> <span class="string">&#x27;^shiyanlou&#x27;</span> <span class="regexp">/etc/g</span>roup</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191055543.png" alt="image-20231124191055543"></p></li></ul><h5 id="数量">数量</h5><ul><li><p>匹配以<code>z</code>开头以<code>o</code>结尾的所有字符串：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;zero</span>\nzo\nzoo&#x27; | grep <span class="symbol">&#x27;z</span>.*o&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191223808.png" alt="image-20231124191223808"></p></li><li><p>将匹配以<code>z</code>开头以<code>o</code>结尾，中间包含一个任意字符的字符串：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;zero</span>\nzo\nzoo&#x27; | grep <span class="symbol">&#x27;z</span>.o&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191353795.png" alt="image-20231124191353795"></p></li><li><p>将匹配以<code>z</code>开头,以任意多个<code>o</code>结尾的字符串：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;zo*&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191447803.png" alt="image-20231124191447803"></p></li></ul><h5 id="选择-2">选择</h5><ul><li><p><code>grep</code>默认是区分大小写的，接下来对字符串<code>1234\nabcd</code>进行如下操作。</p></li><li><p>匹配所有的小写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[a-z]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191630543.png" alt="image-20231124191630543"></p></li><li><p>匹配所有的数字：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[0-9]&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:digit:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191950057.png" alt="image-20231124191950057"></p></li><li><p>匹配所有的小写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:lower:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192147548.png" alt="image-20231124192147548"></p></li><li><p>匹配所有的大写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd\nABCD&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:upper:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192246970.png" alt="image-20231124192246970"></p></li><li><p>匹配所有的字母和数字，包括0-9,a-z,A-Z：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:alnum:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192348521.png" alt="image-20231124192348521"></p></li><li><p>匹配所有的字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:alpha:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192435784.png" alt="image-20231124192435784"></p></li><li><p>完整的特殊符号列表及说明：</p></li></ul><table><thead><tr><th style="text-align:center">特殊符号</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>[:alnum:]</code></td><td>代表英文大小写字母及数字，亦即 0-9, A-Z, a-z</td></tr><tr><td style="text-align:center"><code>[:alpha:]</code></td><td>代表任何英文大小写字母，亦即 A-Z, a-z</td></tr><tr><td style="text-align:center"><code>[:blank:]</code></td><td>代表空白键与 [Tab] 按键两者</td></tr><tr><td style="text-align:center"><code>[:cntrl:]</code></td><td>代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del… 等等</td></tr><tr><td style="text-align:center"><code>[:digit:]</code></td><td>代表数字而已，亦即 0-9</td></tr><tr><td style="text-align:center"><code>[:graph:]</code></td><td>除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键</td></tr><tr><td style="text-align:center"><code>[:lower:]</code></td><td>代表小写字母，亦即 a-z</td></tr><tr><td style="text-align:center"><code>[:print:]</code></td><td>代表任何可以被列印出来的字符</td></tr><tr><td style="text-align:center"><code>[:punct:]</code></td><td>代表标点符号 (punctuation symbol)，亦即：&quot; ’ ? ! ; : # $…</td></tr><tr><td style="text-align:center"><code>[:upper:]</code></td><td>代表大写字母，亦即 A-Z</td></tr><tr><td style="text-align:center"><code>[:space:]</code></td><td>任何会产生空白的字符，包括空白键, [Tab], CR 等等</td></tr><tr><td style="text-align:center"><code>[:xdigit:]</code></td><td>代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</td></tr></tbody></table><h5 id="排除">排除</h5><ul><li><p>在字符串中排除字符：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;geek\ngood&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[^o]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192843061.png" alt="image-20231124192843061"></p>  <div class="tip "><p>当<code>^</code>放到中括号内为排除字符，否则表示行首</p></div></li></ul><h4 id="使用扩展正则表达式ERE">使用扩展正则表达式ERE</h4><div class="tip "><p>通过<code>grep</code>使用扩展正则表达式需要加上<code>-E</code>参数，或使用<code>egrep</code></p></div><h5 id="数量-2">数量</h5><ul><li><p>只匹配<code>zo</code>：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> -E <span class="string">&#x27;zo&#123;1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193420972.png" alt="image-20231124193420972"></p></li><li><p>匹配以<code>zo</code>开头的所有单词：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> -E <span class="string">&#x27;zo&#123;1,&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193513268.png" alt="image-20231124193513268"></p></li></ul><h5 id="选择-3">选择</h5><ul><li><p>匹配<code>www.shiyanlou.com</code>和<code>www.google.com</code>：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27; | grep -<span class="type">E</span> <span class="symbol">&#x27;www</span>\.(shiyanlou|google)\.com&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193714766.png" alt="image-20231124193714766"></p></li><li><p>或者匹配不包含<code>baidu</code>的内容：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27; | grep -<span class="type">Ev</span> <span class="symbol">&#x27;www</span>\.baidu\.com&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193823247.png" alt="image-20231124193823247"></p></li></ul><div class="tip "><p>因为<code>.</code>号有特殊含义，所以需要转义</p></div><h3 id="sed流编辑器">sed流编辑器</h3><ul><li><p><code>sed</code>命令的基本格式如下：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [参数]... [执行命令] [输入文件]...</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用参数">常用参数</h4><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-n</code></td><td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td></tr><tr><td style="text-align:center"><code>-e</code></td><td>用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td></tr><tr><td style="text-align:center"><code>-f filename</code></td><td>指定执行filename文件中的命令</td></tr><tr><td style="text-align:center"><code>-r</code></td><td>使用扩展正则表达式，默认为标准正则表达式</td></tr><tr><td style="text-align:center"><code>-i</code></td><td>将直接修改输入文件内容，而不是打印到标准输出设备</td></tr></tbody></table><h4 id="执行命令">执行命令</h4><ul><li><p><code>sed</code>命令中可以有单条或多条执行命令，每条执行命令之间使用<code>;</code>分隔，执行命令格式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[n1]</span><span class="selector-attr">[,n2]</span>command</span><br><span class="line"><span class="selector-attr">[n1]</span><span class="selector-attr">[~step]</span>command</span><br></pre></td></tr></table></figure><p>其中n1,n2表示输入内容的行号，它们之间为<code>,</code>逗号则表示从n1到n2行，如果为<code>～</code>波浪号则表示从n1开始以step为步进的所有行；command为执行动作。</p></li><li><p>其中一些命令可以在后面加上作用范围，比如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/sad/happy/g&#x27;</span> <span class="built_in">test</span></span><br><span class="line">sed -i <span class="string">&#x27;s/sad/happy/4&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>其中，第一句命令的<code>g</code>表示全局范围，第二句命令的<code>4</code>表示指定行中第四个匹配的字符串，上面两句都是将范围内的<code>sad</code>更改为<code>happy</code>。</p></li><li><p>下面为一些常用动作指令：</p></li></ul><table><thead><tr><th style="text-align:center">命令</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>s</code></td><td>行内替换</td></tr><tr><td style="text-align:center"><code>c</code></td><td>整行替换</td></tr><tr><td style="text-align:center"><code>a</code></td><td>插入到指定行的后面</td></tr><tr><td style="text-align:center"><code>i</code></td><td>插入到指定行的前面</td></tr><tr><td style="text-align:center"><code>p</code></td><td>打印指定行，通常与<code>-n</code>参数配合使用</td></tr><tr><td style="text-align:center"><code>d</code></td><td>删除指定行</td></tr></tbody></table><h4 id="操作举例">操作举例</h4><ul><li><p>首先得到一个用于测试的文本文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/etc/</span>passwd ~</span><br></pre></td></tr></table></figure></li><li><p>打印指定行（2-5）：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nl</span> passwd | sed -n &#x27;<span class="number">2</span>,<span class="number">5</span>p&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195346741.png" alt="image-20231124195346741"></p></li><li><p>打印奇数行：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nl</span> passwd | sed -n &#x27;<span class="number">1</span>~<span class="number">2</span>p&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195457985.png" alt="image-20231124195457985"></p></li><li><p>行内替换，将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;,并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sed</span> -n <span class="string">&#x27;s/shiyanlou/hehe/gp&#x27;</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195627471.png" alt="image-20231124195627471"></p></li><li><p>删除某行（30）：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl passwd <span class="string">| grep &quot;</span>shiyanlou<span class="string">&quot;</span></span><br><span class="line">sed -i &#x27;30d&#x27; passwd</span><br><span class="line">nl passwd <span class="string">| grep &quot;</span>shiyanlou<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195906463.png" alt="image-20231124195906463"></p></li></ul><h3 id="awk文本处理语言">awk文本处理语言</h3><h4 id="简单介绍">简单介绍</h4><blockquote><p><code>AWK</code>是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一，其名称得自于它的创始人Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和Brian Wilson Kernighan（布莱恩·柯林汉）姓氏的首个字母.AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”，它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK是一种用于处理文本的编程语言工具。</p></blockquote><ul><li><p>在大多数linux发行版上面，实际使用的是gawk（GNU awk，awk的GNU版本），在ubuntu环境上，默认提供的是mawk，系统已经创建好了<code>awk</code>指向mawk的符号链接：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll <span class="regexp">/usr/</span>bin/awk</span><br></pre></td></tr></table></figure></li></ul><h4 id="基础概念">基础概念</h4><ul><li><p><code>awk</code>所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：</p>  <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pattern</span> &#123;action&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>awk</code>处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，<code>awk</code>以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符。</p></li></ul><h4 id="基本格式">基本格式</h4><ul><li><p><code>awk</code>命令的基本格式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="selector-attr">[-F fs]</span> <span class="selector-attr">[-v var=value]</span> <span class="selector-attr">[-f prog-file | <span class="string">&#x27;program text&#x27;</span>]</span> <span class="selector-attr">[file...]</span></span><br></pre></td></tr></table></figure><p>其中<code>-F</code>参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，<code>-v</code>用于预先为<code>awk</code>程序指定变量，<code>-f</code>参数用于指定<code>awk</code>命令要执行的程序文件，或者在不加<code>-f</code>参数的情况下直接将程序语句放在这里，最后为<code>awk</code>需要处理的文本输入，且可以同时输入多个文本文件。</p></li></ul><h4 id="具体操作">具体操作</h4><ul><li><p>先用<code>vim</code>新建一个文本文档：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>输入如下内容：</p>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I <span class="keyword">like</span> linux</span><br><span class="line">www.shiyanlou.com</span><br></pre></td></tr></table></figure><p>按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出</p></li><li><p>使用<code>awk</code>将文本内容打印到终端：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print&#125;&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124201201455.png" alt="image-20231124201201455"></p></li><li><p>将test的第一行的每个字段单独显示为一行，其他行则直接显示：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">1</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span> <span class="variable">$2</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span> <span class="variable">$3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">print&#125;</span><br><span class="line">&#125;&#x27; test</span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">OFS</span><span class="operator">=</span><span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">print <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">print&#125;</span><br><span class="line">&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124224624617.png" alt="image-20231124224624617"></p></li><li><p>将test的第二行的以点为分段的字段换成以tab为分隔：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="operator">-</span><span class="type">F</span>&#x27;.&#x27; &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">2</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span> <span class="variable">$2</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span> <span class="variable">$3</span></span><br><span class="line">&#125;&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124224952656.png" alt="image-20231124224952656"></p><p>或者：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;</span><br><span class="line"><span class="type">BEGIN</span>&#123;</span><br><span class="line"><span class="type">FS</span><span class="operator">=</span><span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="type">OFS</span><span class="operator">=</span><span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">&#125;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">2</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span></span><br><span class="line">&#125;&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124225037736.png" alt="image-20231124225037736"></p></li></ul><h4 id="常见内置变量">常见内置变量</h4><table><thead><tr><th style="text-align:center">变量名</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>FILENAME</code></td><td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td></tr><tr><td style="text-align:center"><code>$0</code></td><td>当前记录的内容</td></tr><tr><td style="text-align:center"><code>$N</code></td><td>N表示字段号，最大值为<code>NF</code>变量的值</td></tr><tr><td style="text-align:center"><code>FS</code></td><td>字段分隔符，由正则表达式表示，默认为&quot; &quot;空格</td></tr><tr><td style="text-align:center"><code>RS</code></td><td>输入记录分隔符，默认为<code>\n</code>，即一行为一个记录</td></tr><tr><td style="text-align:center"><code>NF</code></td><td>当前记录字段数</td></tr><tr><td style="text-align:center"><code>NR</code></td><td>已经读入的记录数</td></tr><tr><td style="text-align:center"><code>FNR</code></td><td>当前输入文件的记录数，请注意它与NR的区别</td></tr><tr><td style="text-align:center"><code>OFS</code></td><td>输出字段分隔符，默认为&quot; &quot;空格</td></tr><tr><td style="text-align:center"><code>ORS</code></td><td>输出记录分隔符，默认为<code>\n</code></td></tr></tbody></table><h2 id="实战训练">实战训练</h2><ol><li><p>辨析pattern space和hold space的概念</p><ul><li><p>Pattern space（模式空间）</p><ul><li><p>用于存储当前处理的文本行的缓冲区。在<code>sed</code>的处理过程中，文本逐行读取，每一行都被存储在Pattern space中，然后在Pattern space中进行模式匹配和操作。</p></li><li><p>当<code>sed</code>读取一行文本时，该行文本被放入Pattern space中，然后执行可能的操作，如查找和替换。处理完一行后，Pattern space中的内容可以被输出，也可以保留用于后续处理。</p></li></ul></li><li><p>Hold space（保持空间）</p><ul><li><p>用于在处理多行文本时保存额外的信息。与Pattern space不同，Hold space可以在不同的时刻存储不同的内容，而Pattern space则主要用于当前正在处理的行。</p></li><li><p><code>sed</code>提供的命令允许将Pattern space中的内容移动到Hold space中，反之亦然。这使得在处理多行文本时能够保留和操作先前处理的文本行的信息。</p></li></ul></li><li><p>在<code>sed</code>脚本中，可以使用<code>h</code>或<code>H</code>命令将Pattern space的内容转移到Hold space，使用<code>g</code>或<code>G</code>命令将Hold space的内容转移回Pattern space，区别如下：</p></li></ul></li></ol><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>g</code></td><td>将hold space中的内容拷贝到pattern space中，原来pattern space里的内容被覆盖</td></tr><tr><td><code>G</code></td><td>将hold space中的内容扩充到pattern space最后（换行）</td></tr><tr><td><code>h</code></td><td>将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖</td></tr><tr><td><code>H</code></td><td>将pattern space中的内容扩充到hold space最后（换行）</td></tr><tr><td><code>d</code></td><td>删除pattern space当前行，并读入下一新行到pattern space中</td></tr><tr><td><code>D</code></td><td>删除pattern space中的第一行，不读入下一行</td></tr></tbody></table><ol start="2"><li><p>基于pattern space和hold space实现将一个文本倒序输出</p><ul><li><p>新建一个文本，作为实验内容：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim testfile</span></span><br></pre></td></tr></table></figure></li><li><p>输入以下内容，然后保存文件：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br><span class="line">li<span class="symbol">ne6</span></span><br></pre></td></tr></table></figure></li><li><p>查看写入内容：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">awk</span> <span class="string">&#x27;&#123;print&#125;&#x27;</span> testfile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125004735382.png" alt="image-20231125004735382"></p></li><li><p>我们执行<code>sed</code>命令时能看到的输出都为Pattern space中的内容（当前处理的文本行的缓冲区），因此思路为借助Hold space对Pattern space当前的内容进行操作。</p></li><li><p>那么当前Pattern space在开始执行时依次存储的内容如下：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">line1</span> <span class="comment">#第一次执行</span></span><br><span class="line">line2 <span class="comment">#第二次执行</span></span><br><span class="line">line3 <span class="comment">#第三次执行</span></span><br><span class="line">line4 <span class="comment">#第四次执行</span></span><br></pre></td></tr></table></figure></li><li><p>现在希望将第一行放到第二行的后方，Pattern space变为如下内容：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span> <span class="attr">#第一次执行</span></span><br><span class="line"><span class="attr">line2</span>\<span class="symbol">nline1</span> <span class="attr">#第二次执行</span></span><br><span class="line"><span class="attr">line3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br></pre></td></tr></table></figure></li><li><p>那么经过多次执行操作，最后Pattern space期望变为内容如下：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span> <span class="attr">#第一次执行</span></span><br><span class="line"><span class="attr">line2</span>\<span class="symbol">nline1</span> <span class="attr">#第二次执行</span></span><br><span class="line"><span class="attr">line3</span>\<span class="symbol">nline2</span>\<span class="symbol">nline1</span> <span class="attr">#第三次执行</span></span><br><span class="line"><span class="attr">line4</span>\<span class="symbol">nline3</span>\<span class="symbol">nline2</span>\<span class="symbol">nline1</span> <span class="attr">#第四次执行</span></span><br></pre></td></tr></table></figure><p>如果完成上述操作，则会输出内容如下：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br></pre></td></tr></table></figure><p>由此看来，需要在每次扩展前一行到当前行的同时删除掉前一行的内容，最终仅保留最后一行的内容，即：</p>  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一次执行后当前行被删除</span></span><br><span class="line"><span class="comment">#第二次执行后当前行被删除</span></span><br><span class="line"><span class="comment">#第三次执行后当前行被删除</span></span><br><span class="line">line4<span class="string">\nline3\nline2\nline1</span> <span class="comment">#第四次执行</span></span><br></pre></td></tr></table></figure></li><li><p>整理思路得到对每一行执行的操作如下：</p><ul><li>将当前行扩展到下一行（Pattern space）后方，中间使用<code>\n</code>分隔</li><li>删除当前行，然后读取下一行</li></ul></li><li><p>但是，需要注意以下两个问题：</p><ul><li><code>sed</code>命令中使用分号<code>;</code>分隔的多个语句（①;②;③）如执行顺序为：第一行的 ① -&gt; ② -&gt; ③，然后才是第二行的 ① -&gt; ② -&gt; ③，以此类推。因为Pattern space是逐行读取的。</li><li>使用程序完成第①步操作并非可以只用一步完成，应该是先在下一行后方添加换行符，然后将当前行内容扩展到下一行。</li></ul></li><li><p>但如果对每一行都添加换行符，那么最终在<code>line1</code>的后方会多出一个多余的换行符，因此<code>line1</code>的后方不应该添加换行符。同时“删除当前行”操作在直行道最后一行时，也不应该删除最后一行，否则会丢失所有行的内容。</p></li><li><p>那么最终的操作如下：</p><ul><li>在每一行（除了第一行）后增加一个换行符（可以理解为将空内容换行扩展到当前行后方）</li><li>将当前行内容不换行扩展到下一行后方</li><li>将当前行删除（除非是最后一行），然后移动到下一行</li></ul></li><li><p>这个步骤中的前两步也可以换种思路，其中暂存区借助Hold space实现：</p><ul><li>将暂存区（开始时为空）内容换行扩展到当前行（除了第一行）：<code>1!G</code>，第一行以外的行都执行G操作（将hold space中的内容换行扩充到pattern space最后）</li><li>将当前行内容暂存：<code>h</code>，全部行都执行h操作（将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖）</li><li>删除当前行，移动到下一行（除非是最后一行）：<code>$!d</code>，最后一行以外的行都执行d操作（删除pattern space当前行，并读入下一新行到pattern space中）</li></ul></li><li><p>因此完整命令如下：</p>  <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;<span class="number">1</span><span class="title">!G</span><span class="comment">;h;$!d&#x27; testfile</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125024055225.png" alt="image-20231125024055225"></p></li></ul></li><li><p>基于pattern space和hold space实现交换奇数行和偶数行</p><ul><li><p>将当前行存储到暂存区：<code>h</code>（将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖）</p></li><li><p>如果不是最后一行，那么完成以下两步操作：</p><ul><li>移动到下一行：<code>n</code>（将pattern space中的内容切换到下一行）</li><li>在当前行末尾换行扩展暂存区内容：<code>G</code>（将hold space中的内容换行扩充到pattern space最后）</li></ul></li><li><p>显示当前行：<code>p</code></p></li><li><p>由于已经在命令执行过程中显示了需要的内容，那么无需在执行完成后依次显示Pattern space的内容：<code>-n</code>，否则会显示如下内容：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line5</span></span><br><span class="line">li<span class="symbol">ne6</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line6</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br></pre></td></tr></table></figure></li><li><p>那么完整命令如下：</p>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -<span class="built_in">n</span> &#x27;h;$!&#123;<span class="built_in">n</span>;G&#125;;p&#x27; testfile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125031850044.png" alt="image-20231125031850044"></p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">Linux中匹配正则表达式的相关命令</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux数据流重定向</title>
    <link href="https://www.iuoyt.com/posts/5a9cd021.html"/>
    <id>https://www.iuoyt.com/posts/5a9cd021.html</id>
    <published>2023-11-17T13:56:49.000Z</published>
    <updated>2023-11-25T03:21:37.575Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在之前的Linux笔记中有使用过<code>&gt;</code>、<code>&gt;&gt;</code>，比如如下指令：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; <span class="literal">redirect</span> </span><br><span class="line">echo <span class="string">&#x27;www.shiyanlou.com&#x27;</span> &gt;&gt; <span class="literal">redirect</span></span><br><span class="line">cat <span class="literal">redirect</span></span><br></pre></td></tr></table></figure><p>这部分命令用于将文本字符串 “hello shiyanlou” 输出到（<code>&gt;</code>）<code>redirect</code>文件中，此时文件并不存在，因此将自动创建<code>redirect</code>文件写入字符串，然后再次使用 <code>echo</code> 命令输出字符串<code>www.shiyanlou.com</code>追加到（<code>&gt;&gt;</code>）文件<code>redirect</code>中。</p></li></ul><h3 id="简单的重定向">简单的重定向</h3><ul><li>Linux中默认提供了三种特殊设备，用于终端的显示和输出，分别为<code>stdin</code>（标准输入,对应于你在终端的输入），<code>stdout</code>（标准输出，对应于终端的输出），<code>stderr</code>（标准错误输出，对应于终端的输出）。</li></ul><table><thead><tr><th style="text-align:center">文件描述符</th><th style="text-align:center">设备文件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center"><code>/dev/stdin</code></td><td style="text-align:center">标准输入</td></tr><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center"><code>/dev/stdout</code></td><td style="text-align:center">标准输出</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center"><code>/dev/stderr</code></td><td style="text-align:center">标准错误</td></tr></tbody></table><ul><li><p>可以这样使用文件描述符，比如默认使用终端的标准输入和标准输出作为命令的输入和输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p>此时输入的内容也会在按下<kbd>Enter</kbd>时显示出来。</p><p>（按下<kbd>Ctrl</kbd>+<kbd>C</kbd>退出）</p></li><li><p>将cat的连续输出（heredoc方式）重定向到一个文件：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir Documents</span><br><span class="line">cat &gt; Documents/test.c &lt;&lt;EOF</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>这一段内容的作用是将文件作为标准输出，那么之后输入的内容都会被保存在文件<code>/Documents/test.c</code>中，<code>&lt;&lt;EOF</code>是文本输入的定界符，表示以下内容将作为输入直到遇到 “EOF” 为止。</p></li><li><p>将一个文件作为命令的输入，标准输出作为命令的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193411117.png" alt="image-20231117193411117"></p></li><li><p>将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hi&#x27;</span> | <span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193603353.png" alt="image-20231117193603353"></p></li><li><p>将echo命令的输出从默认的标准输出重定向到一个普通文件：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; <span class="literal">redirect</span></span><br><span class="line">cat <span class="literal">redirect</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193628856.png" alt="image-20231117193628856"></p></li></ul><h3 id="标准错误重定向">标准错误重定向</h3><ul><li><p>有时执行指令得到的输出同事包含了标准输出和标准错误，比如如下操作，使用<code>cat</code>命令同时读取两个文件，其中一个存在，另一个不存在：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c</span><br></pre></td></tr></table></figure><p>可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息.</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117194508097.png" alt="image-20231117194508097"></p></li><li><p>接下来将输出重定向到一个文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c &gt; somefile</span><br></pre></td></tr></table></figure><p>但是依然出现了错误信息，而查看重定指向的文件，已经写入了期望包含的内容</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195102336.png" alt="image-20231117195102336"></p></li><li><p>如果希望将错误或者警告都隐藏，那就可以用到前面提到的文件描述符了。将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> Documents/test.c hello.c &gt;somefile  <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c &amp;&gt;somefilehell</span><br></pre></td></tr></table></figure><p>查看文件内容，可以看到错误信息也被写入到文件中了：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195418320.png" alt="image-20231117195418320"></p></li></ul><h3 id="使用tee命令同时重定向到多个文件">使用tee命令同时重定向到多个文件</h3><ul><li><p>如果既需要将输出重定向到文件，也需要将信息大隐刀终端，那么可以使用<code>tee</code>来实现：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | <span class="built_in">tee</span> hello</span><br></pre></td></tr></table></figure><p>可以看到内容既输出在了终端，同时也被写入到了文件当中：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195716791.png" alt="image-20231117195716791"></p></li></ul><h3 id="永久重定向">永久重定向</h3><ul><li><p>上面的操作完成的重定向只是临时的，如果希望做到永久重定向，可以使用<code>exec</code>命令完成，其作用是使用指定的命令替换当前的Shell，即使用一个进程替换当前进程，或者指定新的重定向。</p></li><li><p>先开启一个子Shell，然后使用exec替换当前进程的重定向，将标准输出重定向到一个文件：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">zsh</span></span><br><span class="line"><span class="attribute">exec</span> <span class="number">1</span>&gt;somefile</span><br></pre></td></tr></table></figure><p>那么后面执行的命令的输出都将被重定向到文件中，,直到退出当前子shell，或取消exec的重定向。</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">cat somefile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117201225039.png" alt="image-20231117201225039"></p></li></ul><h3 id="创建输出文件描述符">创建输出文件描述符</h3><ul><li><p>在Shel 中有9个文件描述符，上面仅仅是使用了默认提供的0、1、2号文件描述符。另外我们还可以使用3-8的文件描述符，只是它们默认没有打开而已。你可以使用下面命令查看当前 Shell 进程中打开的文件描述符：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /dev/fd/;<span class="built_in">ls</span> -Al</span><br></pre></td></tr></table></figure></li><li><p>使用<code>exec</code>命令可以创建新的文件描述并使用：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zsh</span><br><span class="line">exec <span class="number">3</span>&gt;somefile</span><br><span class="line">cd <span class="regexp">/dev/</span>fd/;ls -Al;cd -</span><br><span class="line">echo <span class="string">&quot;this is test&quot;</span> &gt;&amp;<span class="number">3</span></span><br><span class="line">cat somefile</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>  <div class="tip "><p>注意上面的第四句命令中，<code>&gt;</code>与<code>&amp;</code>之间不应该有空格，如果有空格则会出错</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231117202354262.png" alt="image-20231117202354262"></p></li></ul><h3 id="关闭文件描述符">关闭文件描述符</h3><ul><li><p>刚才设置了3号文件描述符，可以使用如下命令将其关闭：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br><span class="line"><span class="built_in">cd</span> /dev/fd;<span class="built_in">ls</span> -Al;<span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117202538761.png" alt="image-20231117202538761"></p></li></ul><h3 id="完全屏蔽命令的输出">完全屏蔽命令的输出</h3><ul><li><p>在Linux中有一个被称为“黑洞”的设备文件，所有导入它的数据都会“消失“</p><blockquote><p>在类UNIX系统中，<code>/dev/null</code>，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。</p></blockquote></li><li><p>我们可以利用<code>/dev/null</code>屏蔽命令的输出：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> Documents/test.c <span class="number">1</span>&gt;/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面这样的操作将使你得不到任何输出结果。</p></li></ul><h3 id="使用-xargs-分割参数列表">使用 xargs 分割参数列表</h3><ul><li><p><code>xargs</code>是一条UNIX和类UNIX操作系统的常用命令，它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p></li><li><p>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果。比如这个命令用于将<code>/etc/passwd</code>文件按<code>:</code>分割取第一个字段排序后，使用<code>echo</code>命令生成一个列表：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> -d: -f1 &lt; <span class="regexp">/etc/</span>passwd | <span class="built_in">sort</span> | xargs echo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117203054249.png" alt="image-20231117203054249"></p></li></ul><h3 id="实战训练">实战训练</h3><blockquote><p>理解下面这段代码的作用，实际这段代码不会正常工作，请结合这一小节的知识分析这段代码没有正确工作的原因，并设法解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">rm</span> -iv <span class="variable">$filename</span></span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>这段代码的作用是将<code>ls</code>命令读取到的全部文件依次删除。</p></li><li><p>但是在删除文件时会提示是否确认删除文件，而输入被<code>ls</code>得到的结果重定向了，因此无法完成确认操作，上述代码无法完成执行。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117214749645.png" alt="image-20231117214749645"></p></li><li><p>因此需要在删除文件时由控制台输入是否确认删除文件，而在读取删除列表时再从重定向中获得输入，修改后代码如下：</p><ul><li><p>将文件描述符3指向标准输入：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">exec</span> <span class="number">3</span>&lt;&amp;<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>删除文件，由文件描述符3提供确认操作给<code>rm</code>命令，使其能够正确执行：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -iv <span class="variable">$filename</span> &lt;&amp;3</span><br></pre></td></tr></table></figure></li><li><p>遍历列表，依次删除文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  &lt;delete operation&gt;</span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>因此，完整代码如下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&lt;&amp;0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">rm</span> -iv <span class="variable">$filename</span> &lt;&amp;3</span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117215259645.png" alt="image-20231117215259645"></p></li></ul>]]></content>
    
    
    <summary type="html">Linux中的数据流重定向是一种通过改变进程的标准输入、标准输出和标准错误的方法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中简单的文本处理</title>
    <link href="https://www.iuoyt.com/posts/d51277ac.html"/>
    <id>https://www.iuoyt.com/posts/d51277ac.html</id>
    <published>2023-11-16T07:02:16.000Z</published>
    <updated>2023-11-25T03:22:30.659Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tr命令">tr命令</h3><ul><li><p><code>tr</code>命令可以用来删除一段文本中的某些文字，或者将其替换。</p></li><li><p>使用方法：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> <span class="selector-attr">[option]</span>..<span class="selector-class">.SET1</span> <span class="selector-attr">[SET2]</span></span><br></pre></td></tr></table></figure></li><li><p>其中常用选项有：</p></li></ul><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-d</code></td><td>删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td style="text-align:center"><code>-s</code></td><td>去除set1指定的在输入文本中连续并重复的字符</td></tr></tbody></table><ul><li><p>比如，删除“hello shiyanlou”字段中的所有o、l、h：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;olh&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141547102.png" alt="image-20231116141547102"></p></li><li><p>再比如，将&quot;hello&quot; 中的“ll”,去重为一个“l”：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27;l&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141658700.png" alt="image-20231116141658700"></p></li><li><p>将输入文本，全部转换为大写或小写输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;input some text here&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[:lower:]&#x27;</span> <span class="string">&#x27;[:upper:]&#x27;</span></span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;input some text here&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141758138.png" alt="image-20231116141758138"></p></li></ul><h3 id="col命令">col命令</h3><ul><li>col命令可以将tab字符换成对等数量的空格键，或者反转这个操作，使用方式为<code>col [option]</code>，常见选项有：</li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center">将<code>Tab</code>转换为空格</td></tr><tr><td style="text-align:center"><code>-h</code></td><td style="text-align:center">将空格转换为<code>Tab</code>（默认选项）</td></tr></tbody></table><ul><li><p>比如，查看<code>/etc/protocols</code>中的不可见字符，可以看到很多 <code>^I</code> ，这其实就是 Tab 转义成可见字符的符号：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -A <span class="regexp">/etc/</span>protocols</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142042116.png" alt="image-20231116142042116"></p></li><li><p>使用<code>col -x</code>将<code>/etc/protocols</code>中的 Tab 转换为空格,然后再使用<code>cat</code>查看，发现<code>^I</code>不见了：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/protocols | col -x | <span class="built_in">cat</span> -A</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142151386.png" alt="image-20231116142151386"></p></li></ul><h3 id="join命令">join命令</h3><ul><li><p><code>join</code>命令用于将两个文件中包含相同内容的那一行合并在一起，使用方法：</p>  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">join</span> [<span class="keyword">option</span>]... file1 file2</span><br></pre></td></tr></table></figure></li><li><p>常用选项有：</p></li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-t</code></td><td style="text-align:center">指定分隔符，默认为空格</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:center">忽略大小写的差异</td></tr><tr><td style="text-align:center"><code>-1</code></td><td style="text-align:center">指明第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td style="text-align:center"><code>-2</code></td><td style="text-align:center">指明第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table><ul><li><p>首先在用户家目录下创建两个文件，然后进行合并：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 hello&#x27;</span> &gt; file1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 shiyanlou&#x27;</span> &gt; file2</span><br><span class="line"><span class="built_in">join</span> file1 file2</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142537075.png" alt="image-20231116142537075"></p></li><li><p>将<code>/etc/passwd</code>与<code>/etc/shadow</code>两个文件合并，指定以’:'作为分隔符：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">join</span> -t<span class="string">&#x27;:&#x27;</span> <span class="regexp">/etc/</span>passwd <span class="regexp">/etc/</span>shadow</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142620545.png" alt="image-20231116142620545"></p></li></ul><h3 id="paste命令">paste命令</h3><ul><li><code>paste</code>与<code>join</code>类似，是在不对比数据的情况下，简单地将多个文件合并起来，并以Tab隔开，格式为<code>paste [option] file...</code>，常用选项有：</li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-d</code></td><td style="text-align:center">指定合并的分隔符，默认为Tab</td></tr><tr><td style="text-align:center"><code>-s</code></td><td style="text-align:center">不合并到一行，每个文件为一行</td></tr></tbody></table><ul><li><p>先创建三个文件，分别存入不同内容：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> hello &gt; file1</span><br><span class="line"><span class="keyword">echo</span> shiyanlou &gt; file2</span><br><span class="line"><span class="keyword">echo</span> www.shiyanlou.<span class="keyword">com</span> &gt; file3</span><br></pre></td></tr></table></figure><p>使用<code>:</code>作为分隔符进行合并：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -d <span class="string">&#x27;:&#x27;</span> file1 file2 file3</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116143257454.png" alt="image-20231116143257454"></p><p>将三个文件内容进行简单合并，每个文件占一行：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -s file1 file2 file3</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116143308307.png" alt="image-20231116143308307"></p></li></ul><h3 id="实战训练">实战训练</h3><blockquote><p>在<a href="/posts/c67b19b2">文件打包与解压缩</a>中提到 Windows/dos 与 Linux/UNIX 文本文件一些特殊字符<code>不一致</code></p><p>如断行符 Windows 为 CR+LF(<code>\r\n</code>)，Linux/UNIX 为 LF(<code>\n</code>)。使用<code>cat -A 文本</code> 可以看到文本中包含的不可见特殊字符。Linux 的<code>\n</code>表现出来就是一个<code>$</code>，而 Windows/dos的表现为<code>^M$</code>，可以直接使用<code>dos2unix</code>和<code>unix2dos</code>工具在两种格式之间进行转换，使用<code>file</code>命令可以查看文件的具体类型。</p><p>不过现在希望<strong>在不使用上述两个转换工具的情况下，使用前面学过的命令手动完成 dos 文本格式到 UNIX 文本格式的转换。</strong></p></blockquote><ul><li><p>Windows的回车符仅比Linux/Unix下多出一个<code>\r</code>那么将Windows文本中的<code>\r</code>全部删除即可实现：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> -d <span class="string">&#x27;\r&#x27;</span> &lt; dos_file<span class="selector-class">.txt</span> &gt; unix_file.txt</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>&lt; dos_file.txt</code>: 从名为<code>dos_file.txt</code>的文件读取输入。</p></li><li><p><code>&gt; unix_file.txt</code>: 将输出写入名为<code>unix_file.txt</code>的文件。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Linux中几个简单的文本处理命令</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令执行顺序控制与管道</title>
    <link href="https://www.iuoyt.com/posts/7ab3ca3a.html"/>
    <id>https://www.iuoyt.com/posts/7ab3ca3a.html</id>
    <published>2023-11-10T11:55:16.000Z</published>
    <updated>2023-11-10T11:57:47.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令执行顺序的控制">命令执行顺序的控制</h2><ul><li><p>通常情况下，使用命令行都是输入完一条指令然后立即执行，然后再输入下一条指令。如果需要一次输入多条指令，再一并执行的话，可以使用<code>;</code>将多条指令隔开来，在一行里写下，那么在按下<kbd>Enter</kbd>的时候，会一次性执行完输入的全部命令。</p></li><li><p>但如果在顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就可能会造成花了时间，最终却得到一个错误结果的情况，并且有时还不能直观的看出是否正确执行。那么这时就需要有选择性地执行命令，比如上一条命令执行成功后才继续执行下一条，否则应该如何处理。比如使用一个<code>witch</code>来做判断，如果安装了<code>cowsay</code>命令就执行，否则什么也不做：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cowsay&gt;<span class="regexp">/dev/</span><span class="literal">null</span> &amp;&amp; cowsay -f head-in ohch~</span><br></pre></td></tr></table></figure><p>其中<code>&amp;&amp;</code>符号前的内容是执行条件，作为<code>&amp;&amp;</code>后语句是否执行的前提判断，如果<code>cowsay&gt;/dev/null</code>执行成功，那么会返回结果<code>0</code>，<code>&amp;&amp;</code>后的语句就会执行。</p></li><li><p>同样的，shell中也有类似于逻辑或的<code>||</code>，在此处与<code>&amp;&amp;</code>做出相反的结果，即当<code>||</code>前的语句执行结果≠0时，才执行后方的语句，比如如果未安装<code>cowsay</code>命令，那么显示出未安装提示：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cowsay&gt;/dev/<span class="literal">null</span> <span class="string">|| echo &quot;</span>cowsay has not been install, please run &#x27;sudo apt-get install cowsay&#x27; to install<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&amp;&amp;</code>和<code>||</code>可以结合起来使用，比如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110180631916.png" alt="image-20231110180631916"></p><p>意思为检查是否安装了<code>cowsay</code>，如果安装了则显示<code>exist</code>，否则显示<code>not exist</code>。上面的语句是先使用<code>&amp;&amp;</code>再使用<code>||</code>，那么如果反过来会出现什么结果呢：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110180645027.png" alt="image-20231110180645027"></p><p>这一次同时输出了<code>not exist</code>和<code>exist</code>的结果，因为<code>&amp;&amp;</code>后的语句执行条件是前一句执行成功，而在执行<code>||</code>判断时返回结果≠0，所以执行了<code>||</code>后的语句，从而也执行了<code>&amp;&amp;</code>后的语句。</p></li></ul><h2 id="管道">管道</h2><ul><li>管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。</li><li>管道又分为匿名管道和具名管道。在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由<code>|</code>分隔符表示，<code>|</code>在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。</li></ul><h3 id="管道的使用">管道的使用</h3><ul><li><p>现在尝试查看<code>/etc</code>下有那些文件和目录：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc</span><br></pre></td></tr></table></figure><p>输出的内容比较多，此时不妨使用管道将<code>ls</code>输出的结果使用<code>less</code>查看：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc | less</span><br></pre></td></tr></table></figure></li></ul><h3 id="cut命令">cut命令</h3><ul><li><p><code>cut</code>命令用于打印每一行的某一字段，比如现在需要打印<code>/etc/passwd</code>文件中以<code>:</code>位分隔符的第一个字段和第六个字段分别作为用户名和其家目录：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="regexp">/etc/</span>passwd -d <span class="string">&#x27;:&#x27;</span> -f <span class="number">1</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110191238613.png" alt="image-20231110191238613"></p></li><li><p>打印<code>/etc/passwd</code>文件中每一行的前N个字符：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前五个（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c -<span class="number">5</span></span><br><span class="line"><span class="comment"># 前五个之后的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span>-</span><br><span class="line"><span class="comment"># 第五个</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span></span><br><span class="line"><span class="comment"># 2到5之间的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">2</span>-<span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="grep命令">grep命令</h3><ul><li><p>grep命令用于在文本中或stdin中查找匹配字符串，如果结合正则表达式可以实现复杂切高效的查找和匹配，一般格式为：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [命令选项]... 用于匹配的表达式 [文件]...</span><br></pre></td></tr></table></figure></li><li><p>比如，搜索<code>/home/shiyanlou</code>目录下所有包含<code>shiyanlou</code>的文本文件，并显示出所在文本中的行号，其中<code>-r</code>表示地柜搜索子目录中的文件，<code>-n</code>表示打印匹配项的行号，<code>-I</code>表示忽略二进制文件：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -rnI <span class="string">&quot;shiyanlou&quot;</span> ~</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110191733110.png" alt="image-20231110191733110"></p></li><li><p>同时也可以使用正则表达式，比如查找以<code>yanlou</code>结尾的字符串：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> | grep <span class="string">&quot;.*yanlou$&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192022608.png" alt="image-20231110192022608"></p></li></ul><h3 id="wc命令">wc命令</h3><ul><li><p><code>wc</code>命令是简单小巧的计数工具，用于统计并输出一个文件中行、单词和字节的数目，比如输出<code>/etc/passwd</code>文件的统计信息：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192208836.png" alt="image-20231110192208836"></p></li><li><p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行数</span></span><br><span class="line">wc -l <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 单词数</span></span><br><span class="line">wc -w <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 字节数</span></span><br><span class="line">wc -c <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 字符数</span></span><br><span class="line">wc -m <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 最长行字节数</span></span><br><span class="line">wc -L <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192540334.png" alt="image-20231110192540334"></p>  <div class="tip info"><p>对于西文字符，一个字符就是一个字节，对于中文字符，一个汉字通常不小于2字节，视编码而定。</p></div></li><li><p>再结合管道，统计<code>/etc</code>下所有目录数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -dl /etc/*/ | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193359731.png" alt="image-20231110193359731"></p></li></ul><h3 id="sort命令">sort命令</h3><ul><li><p><code>sort</code>命令用于排序，即将输入按照一定方式进行排序，然后再输出，支持的排序方式包括但不限于：字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序……</p></li><li><p>默认为字典排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193609728.png" alt="image-20231110193609728"></p></li><li><p>反转排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -r</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193716806.png" alt="image-20231110193716806"></p></li><li><p>按照特定字段排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k 3</span><br></pre></td></tr></table></figure><p><code>-t</code>参数用于指定字段的分隔符，这里是以&quot;:&quot;作为分隔符；<code>-k 字段号</code>用于指定对哪一个字段进行排序。这里<code>/etc/passwd</code>文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上<code>-n</code>参数，此处按照分割后的第三个字段（第二个<code>:</code>后的字段）排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k 3 -n</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193958323.png" alt="image-20231110193958323"></p></li></ul><h3 id="uniq命令">uniq命令</h3><ul><li><p><code>uniq</code>命令用于过滤或者输出重复行。比如使用<code>history</code>查看最近执行过的命令，但只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194319562.png" alt="image-20231110194319562"></p><p>虽然<code>uniq</code>去除了大部分重复行，但可以看出这里仍然存在两条<code>ls</code>的记录，这是因为<code>uniq</code>命令只能去除连续的重复行，而非全文去重，如果需要达到全文去重的效果，那么需要对字段先进行排序操作：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> -u</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194620796.png" alt="image-20231110194620796"></p></li><li><p>如果希望查看重复的行，再分别统计重复次数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -dc</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194746551.png" alt="image-20231110194746551"></p><p>仅查看重复的行，而不统计重复次数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -D</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194831567.png" alt="image-20231110194831567"></p></li></ul>]]></content>
    
    
    <summary type="html">Linux中命令同时执行的方法与管道的相关使用方式。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="https://www.iuoyt.com/posts/f9c29644.html"/>
    <id>https://www.iuoyt.com/posts/f9c29644.html</id>
    <published>2023-11-06T11:37:40.000Z</published>
    <updated>2024-01-03T05:10:42.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a> 📍当前位置</li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a></li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a></li></ol></blockquote><h2 id="概述">概述</h2><ul><li><p>软件的<strong>可维护性</strong><span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">可维护性</span><span class="reference-title">参考资料</span></span></span>和<strong>可复用性</strong><span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">可复用性</span><span class="reference-title">参考资料</span></span></span>是两个非常重要的用于衡量软件质量的属性。</p><table><thead><tr><th>原则名称</th><th>英文名称</th><th>定义</th><th style="text-align:center">使用频率</th></tr></thead><tbody><tr><td>单一职责原则</td><td>Single Responsibility Principle， SRP</td><td>一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中</td><td style="text-align:center">★★★★☆</td></tr><tr><td>开闭原则</td><td>Open-Closed Principle， OCP</td><td>软件实体应当对扩展开放，对修改关闭</td><td style="text-align:center">★★★★★</td></tr><tr><td>里氏代换原则</td><td>Liskov Substitution Principle， LSP</td><td>所有引用基类的地方必须能透明地使用其子类的对象</td><td style="text-align:center">★★★★★</td></tr><tr><td>依赖倒转原则</td><td>Dependence Inversion Principle， DIP</td><td>高层模块不应该以来低层模块，它们都应该依赖抽象；抽象不应该依赖于细节，细节应该依赖于抽象</td><td style="text-align:center">★★★★★</td></tr><tr><td>接口隔离原则</td><td>Interface Segregation Principle， ISP</td><td>客户端不应该依赖那些它不需要的接口</td><td style="text-align:center">★★☆☆☆</td></tr><tr><td>合成复用原则</td><td>Composite Reuse Principle， CRP</td><td>有线使用对象组合，而不是通过继承来打到复用的目的</td><td style="text-align:center">★★★★☆</td></tr><tr><td>迪米特法则</td><td>Law of Demeter， LoD</td><td>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</td><td style="text-align:center">★★★☆☆</td></tr></tbody></table></li></ul><h2 id="单一职责原则">单一职责原则</h2><ul><li><p>定义：<strong>一个对象应该只包含单一的职责</strong>，并且该职责被完整地封装在一个类中。</p></li><li><p>另一种定义方式：就一个类而言，应该仅有一个引起它变化的原因。</p></li><li><p>在软件系统中，一个类承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，相当于将这些职责耦合在一起，当其中一个职责变化时可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将他们封装在同一类中。</p><blockquote><p>在<code>CustomerDataChart</code>类的方法中，<code>getConnection()</code>方法用于连接数据库，<code>findCustomers()</code>用于查询所有的客户信息，<code>createChart()</code>用于创建图表，<code>displayChart()</code>用于显示图表。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231107110617712.png" alt="image-20231107110617712"></p><p><code>CustomerDataChart</code>类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用<code>findCustomers()</code>方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它拥有不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，<code>CustomerDataChart</code>类可拆分为以下3个类。</p><ol><li><code>DBUtil</code>：负责连接数据库，包含数据库连接方法<code>getConnection()</code></li><li><code>CustomerDAO</code>：负责操作数据库中的Customer表，包含对Customer表的增、删、改、查等方法，例如<code>findCustomers()</code></li><li><code>CustomerDataChart</code>：负责图表的生成和显示，包含<code>createChart()</code>和<code>displayChart()</code>方法</li></ol><p>重构后的结构图：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231107110956731.png" alt="image-20231107110956731"></p></blockquote></li></ul><h2 id="开闭原则">开闭原则</h2><ul><li>开闭原则是面向对象的可复用设计的第一块基石，定义：<strong>软件实体应当对扩展开放，对修改关闭</strong>，即软件实体应<strong>尽量在不修改原有代码的情况下进行扩展</strong>。</li><li>任何软件都需要面临一个很重要的问题，即需求会随着时间的推移而发生变化。当软件系统需要面对新的需求时应尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，寿命越来越长，维护成本也越来越高，设计满足开闭原则的软件也变得越来越重要。为了满足开闭原则，需要对系统进行<strong>抽象化设计</strong>，抽象化是开闭原则的关键，定义系统的抽象层，再通过具体的类进行扩展。</li></ul><h2 id="里氏替换原则">里氏替换原则</h2><blockquote><p>如果对每一个类型为S的对象o1都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时程序P的行为没有变化，那么类型S是类型T的子类型。</p></blockquote><ul><li>通俗来说，里氏替换原则即<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>，表明<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常</strong>，反之则不成立。比如：如果我喜欢所有动物，那么我一定喜欢狗，因为狗是动物的子类；但如果我喜欢狗，并不能断定我喜欢所有的动物。</li><li>里氏替换原则是实现开闭原则的重要方法之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时在确定其子类的类型，用子类对象来替换父类对象。</li><li>在运用里氏替换原则时应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现在父类中声明的方法，在运行时子类实例替换父类实例，可以很方便地扩展系统的功能，无需修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</li></ul><h2 id="依赖倒转原则">依赖倒转原则</h2><ul><li><p>依赖倒转原则是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p></li><li><p>依赖倒转原则的定义：<strong>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。<strong>简单地说，依赖倒转原则要求</strong>针对接口编程，不要针对实现编程</strong>。</p></li><li><p>依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而非使用具体类来做这些事情。一个具体类应当只实现接口或者抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p></li><li><p>引入抽象层后，系统具有很好的灵活性，在程序中<strong>尽量使用抽象层进行编程</strong>，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无需修改原有系统的源代码。</p></li><li><p>实现依赖倒转原则需要针对抽象层编程，而将具体类通过依赖注入的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时采用抽象的形式来注入所依赖的对象。</p><blockquote><p>常见的注入方式有3种：</p><ol><li>构造注入：通过构造函数来传入具体类的对象</li><li>设值注入（Setter注入）：通过Setter方法来传入具体类的对象</li><li>接口注入：通过在接口中声明的业务方法来传入具体类的对象</li></ol></blockquote></li></ul><h2 id="接口隔离原则">接口隔离原则</h2><ul><li>接口隔离原则定义：<strong>客户端不应该依赖那些它不需要的接口</strong>。当一个接口太大时需要将它分割成一些更细小的接口，使用该接口的客户端仅需要知道与之相关的方法即可。</li><li>“接口”有两种含义：<ul><li>如果理解为一个类型所提供的所有方法特征的集合的时候，可以将接口理解成角色，一个接口只能代表一个角色，每个角色都有它特地的一个接口，此时这个原则可以叫“角色隔离原则”。</li><li>如果把接口理解成狭义的特定语言的接口，那么接口隔离原则表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li></ul></li></ul><h2 id="合成复用原则">合成复用原则</h2><ul><li>合成复用原则又称组合/聚合复用原则，定义：<strong>优先使用对象组合，而不是通过继承来达到复用的目的</strong>，即在一个新的对象里通过关联关系（包裹组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派<strong>调用已有对象</strong>的方法达到复用功能的目的。</li><li>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的某些内部细节对于子类来说是可见的，因此这种复用又称为“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变。</li><li>组合或聚合关系可以将已有的对象（亦可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使成员对象的内部实现对于新对象不可见，所以这种复用又称为“黑箱”复用。</li></ul><h2 id="迪米特法则">迪米特法则</h2><ul><li><p>迪米特法则定义：<strong>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。其要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统符合迪米特法则，那么当其中的某一个模块发生修改时就会尽量少地影响其他模块，扩展会相对容易。</p></li><li><p>应用迪米特法则可以降低系统的耦合度，使类与类之间保持松散的耦合关系。</p></li><li><p>迪米特法则还有几种定义形式，例如：不要和“陌生人”说话，只与你的直接朋友通信，“朋友”包括如下几类：</p><ol><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ol><p>这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p></li><li><p>迪米特法则还要求在设计系统时应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。</p></li></ul><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="javascript:void">维护性是指软件能够被理解、改正、适应及扩展的难易程度</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="javascript:void">可复用性是指软件能够被重复使用的难易程度</a></div>]]></content>
    
    
    <summary type="html">如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="面向对象设计原则" scheme="https://www.iuoyt.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概述</title>
    <link href="https://www.iuoyt.com/posts/bb7571ed.html"/>
    <id>https://www.iuoyt.com/posts/bb7571ed.html</id>
    <published>2023-11-06T10:45:37.000Z</published>
    <updated>2023-12-28T04:17:08.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a> 📍当前位置</li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a></li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a></li></ol></blockquote><h2 id="什么是设计模式">什么是设计模式</h2><ul><li><p>设计模式是一种用于对软件系统中不断重现的设计问题的解决方案进行文档化的技术，目的是提高代码的可维护性、可扩展性、重用性和可靠性，以及让他人更容易理解代码。</p></li><li><p>GoF对设计模式的定义如下：</p><blockquote><p>设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。</p></blockquote></li></ul><h2 id="设计模式的基本要素">设计模式的基本要素</h2><ol><li><p>模式名称</p><p>每种设计模式都有一个名称来描述模式的问题、解决方案和效果，以便开发人员更好地理解模式并方便沟通交流。</p></li><li><p>问题</p><p>问题描述了应该在何时使用模式，包含了设计中存在的问题以及问题存在的原因。</p></li><li><p>解决方案</p><p>解决方案描述了设计模式的组成成分，以及这些组成成分之间的相互关系、各自的职责和协作方式。</p></li><li><p>效果</p><p>效果描述了模式应用的效果以及在使用模式时应权衡的问题。</p></li></ol><h2 id="设计模式的分类">设计模式的分类</h2><ul><li>通常情况下都是按照目的来划分各种设计模式，可以分为创建型（Creational）、结构性（Structural）和行为型（Behavioral）3类。</li><li>以下23种设计模式并非都是孤立存在的，很多模式之间存在联系，例如访问者模式操作对象结构中的元素时通常需要使用迭代器模式，在解释器模式中定义终结符表达式和非终结符表达式时可以使用组合模式。因此，如果合理搭配不同的设计模式，可以充分发挥每种设计模式的优势，完成一些更复杂的设计工作。</li></ul><h3 id="创建型模式">创建型模式</h3><ul><li>创建型模式主要用于<strong>创建对象</strong>，包括如下5种模式：</li></ul><table><thead><tr><th>模式名称</th><th style="text-align:left">英文名称</th><th>模式说明</th><th style="text-align:center">使用频率</th></tr></thead><tbody><tr><td>抽象工厂模式</td><td style="text-align:left">Abstract Factory</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</td><td style="text-align:center">★★★★★</td></tr><tr><td>建造者模式</td><td style="text-align:left">Builder</td><td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td><td style="text-align:center">★★☆☆☆</td></tr><tr><td>工厂方法模式</td><td style="text-align:left">Factory Method</td><td>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</td><td style="text-align:center">★★★★★</td></tr><tr><td>原型模式</td><td style="text-align:left">Prototype</td><td>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象</td><td style="text-align:center">★★★☆☆</td></tr><tr><td>单例模式</td><td style="text-align:left">Singleton</td><td>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例</td><td style="text-align:center">★★★★☆</td></tr></tbody></table><h3 id="结构型模式">结构型模式</h3><ul><li>结构型模式主要用于<strong>处理类或对象的组合</strong>，包括如下7种模式：</li></ul><table><thead><tr><th>模式名称</th><th>英文名称</th><th>模式说明</th><th>使用频率</th></tr></thead><tbody><tr><td>适配器模式</td><td>Adapter</td><td>将一个类的接口转换成客户希望的另一个接口，让不兼容的类可以一起工作</td><td>★★★★☆</td></tr><tr><td>桥接模式</td><td>Bridge</td><td>将抽象部分与它的实现部分解耦，使得两者都能够独立变化</td><td>★★★☆☆</td></tr><tr><td>组合模式</td><td>Composite</td><td>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构，让客户端可以统一对待单个对象和组合对象</td><td>★★★★☆</td></tr><tr><td>装饰模式</td><td>Decorator</td><td>动态地给一个对象增加一些额外的职责，就扩展功能而言，装饰模式提供可一种比使用子类更加灵活的替代方案</td><td>★★★☆☆</td></tr><tr><td>外观模式</td><td>Facade</td><td>为子系统中的一组接口提供一个统一的入口，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td><td>★★★★★</td></tr><tr><td>享元模式</td><td>Flyweight</td><td>运用共享技术有效地支持大量细粒度对象的复用</td><td>★☆☆☆☆</td></tr><tr><td>代理模式</td><td>Proxy</td><td>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问</td><td>★★★★☆</td></tr></tbody></table><h3 id="行为型模式">行为型模式</h3><ul><li>行为型模式主要用于<strong>描述类或对象怎样交互和怎样分配职责</strong>，包括如下11种模式：</li></ul><table><thead><tr><th>模式名称</th><th>英文名称</th><th>模式说明</th><th>使用频率</th></tr></thead><tbody><tr><td>职责链模式</td><td>Chain of Responsibility</td><td>避免将一个请求的发送者与接受者耦合在一起，让多个对象都有机会处理请求，或接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止</td><td>★★☆☆☆</td></tr><tr><td>命令模式</td><td>Command</td><td>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作</td><td>★★★★☆</td></tr><tr><td>解释器模式</td><td>Interpreter</td><td>给定一个语言，定义它的文法的一种表示，并给定一个解释器，这个解释器使用该表示方法来解释语句中的句子</td><td>★☆☆☆☆</td></tr><tr><td>迭代器模式</td><td>Iterator</td><td>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示</td><td>★★★★★</td></tr><tr><td>中介者模式</td><td>Mediator</td><td>定义一个对象来封装一系列对象的交互，中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</td><td>★★☆☆☆</td></tr><tr><td>备忘录模式</td><td>Memento</td><td>在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</td><td>★★☆☆☆</td></tr><tr><td>观察者模式</td><td>Observer</td><td>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新</td><td>★★★★★</td></tr><tr><td>状态模式</td><td>State</td><td>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎是修改了它的类</td><td>★★★☆☆</td></tr><tr><td>策略模式</td><td>Strategy</td><td>定义一系列算法，将每一个算法封装起来，让他们可以相互替换，使得算法可以独立于使用它的客户而变化</td><td>★★★★☆</td></tr><tr><td>模板方法模式</td><td>Template Method</td><td>定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td><td>★★★☆☆</td></tr><tr><td>访问者模式</td><td>Visitor</td><td>表示一个作用于某对象结构中的各个元素的操作，可以在不改变各个元素的类的前提下定义作用于这些元素的新操作</td><td>★☆☆☆☆</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">设计模式是一种用于对软件系统中不断重现的设计问题的解决方案进行文档化的技术，目的是提高代码的可维护性、可扩展性、重用性和可靠性。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux任务计划crontab</title>
    <link href="https://www.iuoyt.com/posts/b38a663c.html"/>
    <id>https://www.iuoyt.com/posts/b38a663c.html</id>
    <published>2023-11-03T10:18:50.000Z</published>
    <updated>2023-11-25T03:23:38.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="crontab简介">crontab简介</h2><ul><li><p><code>crontab</code>命令用于设置周期性被执行的命令，并将其存放于 crontab 文件中，以供之后读取和执行。</p></li><li><p><code>crontab</code>储存的指令被守护进程激活，<code>crond</code>为其守护进程，<code>crond</code>常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p></li><li><blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="crontab准备">crontab准备</h2><ul><li><p>使用<code>rsyslog</code>可以通过日志中的信息来得知任务是否被执行了：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install -y rsyslog</span><br><span class="line">sudo<span class="built_in"> service </span>rsyslog start</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103174614045.png" alt="image-20231103174614045"></p></li></ul><h2 id="crontab使用">crontab使用</h2><h3 id="新增任务">新增任务</h3><ul><li><p>首先来添加一个计划任务：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -e</span></span><br></pre></td></tr></table></figure><p>如果是第一次启动则会出现如下内容，选择编辑工具，通常使用2号vim工具：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103174813614.png" alt="image-20231103174813614"></p></li><li><p>接下来会进入下面的界面，这个界面就是添加计划的地方：<br><img src="https://oss.iuoyt.com/img/posts/image-20231103175001232.png" alt="image-20231103175001232"></p></li><li><p>接下来按下<kbd>i</kbd>进入编辑模式，在最后一行添加如下内容，作用是每分钟在用户目录下创建一个以当前的年月日时分秒为名字的空白文件：</p>  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">1</span> * * * * touch /home/shiyanlou/$(<span class="keyword">date</span> +\%Y\%m\%d\%H\%M\%S)</span><br></pre></td></tr></table></figure></li><li><p>然后按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出，输入如下指令查看文件内容：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -l</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180017702.png" alt="image-20231103180017702"></p></li><li><p>虽然已经添加了任务，但如果cron的进程并没有启动，那么任务也不会被执行，可以通过如下两种方式确定cron是否已启动：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 第一种</span></span><br><span class="line">ps aux <span class="string">| grep cron</span></span><br><span class="line"><span class="meta"># 第二种</span></span><br><span class="line">pgrep cron</span><br></pre></td></tr></table></figure></li><li><p>如果已经启动，在用户目录下使用<code>ll</code>命令，可以看到：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180524732.png" alt="image-20231103180524732"></p></li><li><p>通过如下命令可以查看到执行任务命令之后在日志中的信息反馈：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tail -f /<span class="keyword">var</span>/<span class="built_in">log</span>/syslog</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180704821.png" alt="image-20231103180704821"></p></li></ul><h3 id="删除任务">删除任务</h3><ul><li><p>当不需要再自动执行任务，可以使用如下命令：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -r</span></span><br></pre></td></tr></table></figure></li><li><p>执行后再查看任务列表，可以看到已经没有正在执行的任务：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180918834.png" alt="image-20231103180918834"></p></li></ul><h3 id="系统级任务">系统级任务</h3><ul><li><p>如果需要定义系统级别定时任务，可以使用sudo权限编辑crontab文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>crontab</span><br></pre></td></tr></table></figure></li><li><p>cron服务的最小检测时间为分钟，所以cron每分钟会去文件中读取一次内容</p></li></ul><h3 id="cron的相关文件">cron的相关文件</h3><ul><li><p>在<code>/etc</code>目录下查看cron相关的文件：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ll</span> /etc | <span class="keyword">grep</span> cron</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103181401458.png" alt="image-20231103181401458"></p></li><li><p>其中部分作用如下：</p></li></ul><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>/etc/cron.daily</code></td><td style="text-align:center">在每天的6点25分时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.hourly</code></td><td style="text-align:center">在每小时的17分钟时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.monthly</code></td><td style="text-align:center">在每月1号的6点52分时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.weekly</code></td><td style="text-align:center">在每周第七天的6点47分时执行一次</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文介绍了如何在Linux中使用crontab进行计划任务</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的帮助命令</title>
    <link href="https://www.iuoyt.com/posts/8039f3ce.html"/>
    <id>https://www.iuoyt.com/posts/8039f3ce.html</id>
    <published>2023-10-27T11:49:12.000Z</published>
    <updated>2023-11-25T03:23:57.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内建命令与外部命令">内建命令与外部命令</h2><h3 id="内建命令">内建命令</h3><ul><li>内建命令是shell的一部分，包含一些比较简单的系统命令，通常在Linux系统加载运行时就会被驻留在内存系统中，因此执行速度比外部命令快。</li></ul><h3 id="外部命令">外部命令</h3><ul><li>外部命令是Linux系统中的实用程序部分，因为功能较为强大，其包含的程序量也会很大，所以不能随着系统启动被加载到内存中。</li></ul><h3 id="查看命令的类型">查看命令的类型</h3><ul><li><p>使用<code>type</code>命令可以查看其为内建或是外部命令：</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;命令&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231027193923068.png" alt="image-20231027193923068"></p></li><li><p>通常会得到如下结果：</p></li></ul><table><thead><tr><th style="text-align:center">结果</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center"><code>xxx is a shell builtin</code></td><td style="text-align:center">内建命令</td></tr><tr><td style="text-align:center"><code>xxx is /usr/bin/xxx</code></td><td style="text-align:center">外部命令</td></tr><tr><td style="text-align:center"><code>xxx is an alias for xx --xxx</code></td><td style="text-align:center">命令别名</td></tr></tbody></table><h2 id="帮助命令的使用">帮助命令的使用</h2><h3 id="help命令">help命令</h3><ul><li><p>help命令是用于显示shell内建命令的简要帮助信息，因此无法得到外部命令或者命令别名的相关帮助，比如输入<code>help ls</code>命令则会得到“无匹配帮助主题”的提示。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231027194155526.png" alt="image-20231027194155526"></p></li><li><p>而对于外部命令，通常带有一个获取帮助的参数<code>--help</code>，输入以获取该命令的帮助文档：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="man命令">man命令</h3><ul><li><p><code>man</code>命令得到的内容比<code>help</code>更多更详细，而且<code>man</code>没有内建命令与外部命令的区分。<code>man</code>命令是显示系统手册页中的内容，通常为对命令的解释信息和相关描述。</p></li><li><p>使用<code>man</code>命令得到的内容第一行会显示出该命令在文档中所处的章节位置，如使用<code>man ls</code>，则会显示<code>LS(1)</code>，其中<code>LS</code>为手册名称，<code>(1)</code>表示位于该手册的第几章节。在<code>man</code>手册中一共有如下章节：</p></li></ul><table><thead><tr><th style="text-align:center">章节数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center">Standard commands （标准命令）</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center">System calls （系统调用）</td></tr><tr><td style="text-align:center"><code>3</code></td><td style="text-align:center">Library functions （库函数）</td></tr><tr><td style="text-align:center"><code>4</code></td><td style="text-align:center">Special devices （设备说明）</td></tr><tr><td style="text-align:center"><code>5</code></td><td style="text-align:center">File formats （文件格式）</td></tr><tr><td style="text-align:center"><code>6</code></td><td style="text-align:center">Games and toys （游戏和娱乐）</td></tr><tr><td style="text-align:center"><code>7</code></td><td style="text-align:center">Miscellaneous （杂项）</td></tr><tr><td style="text-align:center"><code>8</code></td><td style="text-align:center">Administrative Commands （管理员命令）</td></tr><tr><td style="text-align:center"><code>9</code></td><td style="text-align:center">其他（Linux特定的）， 用来存放内核例行程序的文档</td></tr></tbody></table><h3 id="info命令">info命令</h3><ul><li><p>如果环境中没有<code>info</code>命令，那么可以自行手动安装：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 info</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install <span class="built_in">info</span></span><br><span class="line"><span class="comment"># 查看 ls 命令的 info</span></span><br><span class="line"><span class="built_in">info</span> ls</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">本文介绍了如何利用 Linux 系统自带的帮助工具与文档查看命令的用法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件打包与解压缩</title>
    <link href="https://www.iuoyt.com/posts/c67b19b2.html"/>
    <id>https://www.iuoyt.com/posts/c67b19b2.html</id>
    <published>2023-10-13T15:19:13.000Z</published>
    <updated>2023-10-13T15:23:37.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="压缩打包程序">压缩打包程序</h2><h3 id="使用zip打包文件夹">使用zip打包文件夹</h3><ul><li><p>使用<code>zip</code>命令可以将文件夹打包，比如使用下面的命令将目录<code>/home/shiyanlou/Desktop</code>打包成一个文件，并查看打包后文件的大小和类型，其中<code>-r</code>参数表示递归打包包含子目录的全部内容，<code>-q</code>参数表示为安静模式，即不输出信息到屏幕，<code>-o</code>表示输出文件，在后面紧跟上输出的文件名称：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line"><span class="keyword">zip</span> -r -q -o shiyanlou.<span class="keyword">zip</span> /home/shiyanlou/Desktop</span><br><span class="line">du -<span class="keyword">h</span> shiyanlou.<span class="keyword">zip</span></span><br><span class="line"><span class="keyword">file</span> shiyanlou.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221318522.png" alt="image-20231013221318522"></p></li><li><p>为打包设置压缩级别（9：最高压缩度，速度最慢；1：最快速度，压缩率低），进行重新打包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r -<span class="number">9</span> -q -o shiyanlou_9.zip <span class="regexp">/home/</span>shiyanlou<span class="regexp">/Desktop -x ~/</span>*.zip</span><br><span class="line">zip -r -<span class="number">1</span> -q -o shiyanlou_1.zip <span class="regexp">/home/</span>shiyanlou<span class="regexp">/Desktop -x ~/</span>*.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221533479.png" alt="image-20231013221533479"></p></li><li><p>使用<code>du</code>命令再次查看压缩得到的文件，其中<code>-h</code>为以人可读的形式展现，<code>-d</code>表示查看文件的深度：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">du</span> -h -d <span class="number">0</span> <span class="regexp">*.zip</span> <span class="regexp">~ |</span> sort</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221602101.png" alt="image-20231013221602101"></p></li><li><p>注意：压缩文件使用的路径只能使用绝对路径，否则不起作用。理论上默认压缩级别是最高的，但在文件较小时难以看出差别。</p></li><li><p>由于WIndows和Linux/Unix在文本处理格式上存在差异，比如换行符，WIndows上为<code>CR+LF</code>，但Linux/Unix上为<code>LF</code>，所以一些在Linux/Unix上的换行在Windows系统上看起来像是没有换行，为了解决此类问题，还需要在命令中做出一些修改，加上<code>-l</code>参数将<code>LF</code>转换为<code>CR+LF</code>达到上述目的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -l -o shiyanlou.zip <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221943861.png" alt="image-20231013221943861"></p></li></ul><h3 id="创建加密zip包">创建加密zip包</h3><ul><li><p>在打包文件时添加上<code>-e</code>参数可以创建加密压缩包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -e -o shiyanlou_encryption.zip <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222055429.png" alt="image-20231013222055429"></p></li></ul><h2 id="解压缩打包程序">解压缩打包程序</h2><h3 id="解压缩文件">解压缩文件</h3><ul><li><p>将之前打包的<code>shiyanlou.zip</code>解压到当前目录下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unzip</span> shiyanlou.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222137966.png" alt="image-20231013222137966"></p></li><li><p>与之前相同，使用<code>-q</code>参数使用安静模式解压文件，而使用<code>-d</code>参数指定解压目录：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -<span class="selector-tag">q</span> shiyanlou<span class="selector-class">.zip</span> -d ziptest</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222224693.png" alt="image-20231013222224693"></p></li><li><p>如果上面指定的目录不存在，则会直接创建。</p></li><li><p>如果只想查看压缩包的内容，而不进行解压操作，可以使用<code>-l</code>参数：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unzip</span> -l shiyanlou.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222521006.png" alt="image-20231013222521006"></p></li></ul><h3 id="解决解压乱码问题">解决解压乱码问题</h3><ul><li><p>通常在Windows系统上创建的压缩文件，如果包名中含有中文的目录或者以中文作为文件名命名的文件，通常会采用GBK编码，而Linux则是默认使用哪个UTF-8编码，如果不加以处理直接解压，则会出现乱码问题，可以在解压缩时使用<code>-O</code>参数指定文件编码：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK 压缩文件<span class="string">.zip</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="tar打包工具">tar打包工具</h2><h3 id="打包">打包</h3><ul><li><p>比起<code>zip</code>，在Lin上更常使用的是<code>tar</code>工具，<code>tar</code>可以将7z、gzip、xz、bzip2等格式进行打包或者解包，仅仅是参数不同，比起<code>zip</code>使用较为方便。</p></li><li><p>创建一个tar包，使用<code>-P</code>参数保留绝对路径符，<code>-c</code>表示创建一个tar包文件，<code>-f</code>用于指定创建的文件名，其后紧跟文件名称，如果加上<code>-v</code>参数，那么会以可视的形式输出打包的文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">tar -P -cf shiyanlou.tar <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222601275.png" alt="image-20231013222601275"></p><blockquote><p>在使用多个参数时，可以使用连续书写方式：如同时使用<code>-c</code>与<code>-f</code>参数 ，则可以写成<code>-cf</code></p></blockquote></li></ul><h3 id="解包">解包</h3><ul><li><p>同样是使用<code>tar</code>命令，加上<code>-x</code>参数则是对文件进行解包，<code>-C</code>参数指定解压到的目标文件夹：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir tardir</span><br><span class="line">tar -xf shiyanlou.tar -C tardir</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222938219.png" alt="image-20231013222938219"></p></li><li><p>只查看而不解压文件使用<code>-t</code>参数：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -tf shiyanlou.tar</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223001893.png" alt="image-20231013223001893"></p></li><li><p>如果需要在解压时保留文件的属性和跟随链接（符号链接或软连接）可以使用<code>-p</code>参数和<code>-h</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cphf etc.tar /etc</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建其他形式的打包程序">创建其他形式的打包程序</h3><table><thead><tr><th style="text-align:center">压缩文件格式</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:center"><code>*.tar.gz</code></td><td style="text-align:center"><code>-z</code></td></tr><tr><td style="text-align:center"><code>*.tar.xz</code></td><td style="text-align:center"><code>-J</code></td></tr><tr><td style="text-align:center"><code>*tar.bz2</code></td><td style="text-align:center"><code>-j</code></td></tr></tbody></table><ul><li><p>比如创建<code>.tar.gz</code>文件，加上<code>-z</code>参数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf shiyanlou.tar.gz <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223140457.png" alt="image-20231013223140457"></p></li><li><p>解压<code>.tar.gz</code>文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><blockquote><p>创建一个名为 test 的文件，分别用 zip 和 tar 打包成压缩包，再解压到 /home/shiyanlou 目录。</p></blockquote><ul><li><p>创建一个名为 test 的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">touch</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223345818.png" alt="image-20231013223345818"></p></li><li><p>分别用 zip 和 tar 打包成压缩包：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br><span class="line">tar -P -<span class="keyword">cf</span> <span class="keyword">test</span>.tar <span class="keyword">test</span></span><br><span class="line"><span class="keyword">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013230521245.png" alt="image-20231013230521245"></p></li><li><p>再解压到 /home/shiyanlou 目录:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">unzip <span class="keyword">test</span>.<span class="keyword">zip</span></span><br><span class="line">tar -xf <span class="keyword">test</span>.tar</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013230641542.png" alt="image-20231013230641542"></p></li></ul>]]></content>
    
    
    <summary type="html">这篇文章介绍了Linux上常用的压缩/解压工具（zip，tar）的使用。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境变量与文件查找</title>
    <link href="https://www.iuoyt.com/posts/287535e7.html"/>
    <id>https://www.iuoyt.com/posts/287535e7.html</id>
    <published>2023-10-08T15:49:56.000Z</published>
    <updated>2023-11-25T03:24:27.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境变量">环境变量</h2><h3 id="环境变量-2">环境变量</h3><h4 id="变量">变量</h4><ul><li><p>在Shell中创建一个变量可以使用<code>declare</code>命令，但并非任何形式的变量名都是可用的，变量名只能是由英文字母、数字或者下划线组成，且不能由数字开头。比如创建一个tmp变量：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> tmp</span><br></pre></td></tr></table></figure></li><li><p>使用<code>=</code>运算符为变量赋值：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tmp</span><span class="operator">=</span>shiyanlou</span><br></pre></td></tr></table></figure></li><li><p>使用<code>echo</code>和<code>$</code>符号可以查看变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008230724020.png" alt="image-20231008230724020"></p></li></ul><h4 id="环境变量-3">环境变量</h4><ul><li><p>环境变量的作用域比自定义变量要大，比如Shell的环境变量作用于自身和它的子进程</p></li><li><p>有三个和环境变量相关的命令，<code>set</code>、<code>env</code>和<code>export</code>。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。</p></li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>set</code></td><td style="text-align:center">显示当前Shell所有变量，包括内建环境变量、用户自定义变量及导出的环境变量</td></tr><tr><td style="text-align:center"><code>env</code></td><td style="text-align:center">显示与当前用户相关的环境变量，还可以让命令在指定环境中运行</td></tr><tr><td style="text-align:center"><code>export</code></td><td style="text-align:center">显示从Shell中导出成环境变量的变量，能通过它将自定义变量导出为环境变量</td></tr></tbody></table><p><img src="https://doc.shiyanlou.com/linux_base/5-3.png" alt="img"></p><ul><li><p>用<code>export</code>来体验一下环境变量与普通变量的，先在Shell中设置一个变量<code>temp=shiyanlou</code>，然后创建一个子Shell查看temp变量的值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp=shiyanlou</span><br><span class="line">echo <span class="variable">$temp</span></span><br><span class="line">zsh</span><br><span class="line">echo <span class="variable">$temp</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">export temp</span><br><span class="line">zsh</span><br><span class="line">echo <span class="variable">$temp</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008230934536.png" alt="image-20231008230934536"></p></li><li><p>通常为了与普通变量区分，习惯将环境变量名都设为大写</p></li></ul><h4 id="永久生效">永久生效</h4><ul><li><p>在关机之后，或者关闭shell，环境变量就会消失，可以将变量写入存放变量的文件中：<code>/etc/bashrc</code>和<code>/etc/profile</code>，分别存放的是shell变量和环境变量，或者用户目录下的隐藏文件<code>.profile</code>，仅对当前用户生效，可以使用<code>ls -a</code>查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231056722.png" alt=".profile文件"></p></li></ul><h3 id="命令的查找路径与顺序">命令的查找路径与顺序</h3><ul><li><p>在Shell中命令的执行是通过环境变量<code>PATH</code>搜索的，查看<code>PATH</code>环境变量的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231225585.png" alt="image-20231008231225585"></p></li><li><p>系统会从PATH中以此查找，如果存在相同的命令，则执行先找到的那个</p></li><li><p>接下来创建一个最简单的可执行Shell脚本和使用C语言创建的程序：</p><ul><li><p>在家目录创建一个<code>mybin</code>目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> mybin</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231345401.png" alt="image-20231008231345401"></p></li><li><p>进入新创建的目录，创建一个Shell脚本文件并编辑：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> mybin</span><br><span class="line">touch hello_shell.<span class="keyword">sh</span></span><br><span class="line">gedit hello_shell.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><blockquote><p>如果遇到gedit提示：[Unable to init server: 无法连接： 拒绝连接]，可以使用如下命令解决：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">DISPLAY</span>=localhost:1</span><br><span class="line">xhost local:gedit</span><br></pre></td></tr></table></figure><p>若出现以下内容，表示问题解决：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">non-network <span class="keyword">local</span> connections being added <span class="keyword">to</span> <span class="keyword">access</span> control list</span><br></pre></td></tr></table></figure><p>若还无法解决，可以使用vim编辑器</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> hello_shell.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在脚本中写入如下内容（第一行不可省略）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++));<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello shell&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></li><li><p>为文件添加可执行权限：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">chmod</span> <span class="number">755</span> hello_shell.sh</span><br></pre></td></tr></table></figure></li><li><p>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello_shell.sh</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233557594.png" alt="image-20231008233557594"></p></li><li><p>创建一个C语言程序并编辑：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch hello_world.<span class="keyword">c</span></span><br><span class="line">gedit hello_world.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></li><li><p>写入如下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后使用<code>gcc</code>生成可执行文件：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello_world hello_world.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></li><li><p>运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello_world</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233742246.png" alt="image-20231008233742246"></p></li></ul></li><li><p>在返回到家目录后，如果再想运行刚才创建的两个程序，会提示命令找不到，除非加上命令的完整路径。如果希望可以像执行系统命令一样执行运行刚才创建的程序，可以将脚本文件添加到PATH环境变量中。</p></li></ul><h3 id="添加自定义路径到PATH环境变量">添加自定义路径到PATH环境变量</h3><ul><li><p>PATH路径是以<code>:</code>作为分隔符的，如果希望将上面的<code>mybin</code>目录加入PATH路径，则需要写入以下信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:/home/shiyanlou/mybin</span></span><br></pre></td></tr></table></figure></li><li><p><strong>需要注意的是，这里一定要使用绝对路径</strong></p></li><li><p>那么现在就可以直接执行写下的两个命令了：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello<span class="emphasis">_shell.sh</span></span><br><span class="line"><span class="emphasis">hello_</span>world</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233916073.png" alt="image-20231008233916073"></p></li><li><p>但给PATH追加一条路径只会在当前Shell有效，一旦退出终端，再打开就会发现又失效了，那么可以利用用户home目录中一个在启动shell时自动运行的脚本。zsh的配置文件为<code>.zshrc</code>，相应Bash的配置文件为<code>.bashrc</code>，使用命令将路径添加到<code>.zshrc</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PATH=<span class="variable">$PATH</span>:/home/shiyanlou/mybin&quot;</span> &gt;&gt; .zshrc</span><br></pre></td></tr></table></figure><blockquote><p>上面命令中的<code>&gt;&gt;</code>表示将标准输出以追加的方式重定向到一个文件中。</p></blockquote></li></ul><h3 id="修改和删除已有变量">修改和删除已有变量</h3><h4 id="变量修改">变量修改</h4><ul><li>变量修改有如下几种方式：</li></ul><table><thead><tr><th style="text-align:center">变量设置方式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">${变量名#匹配字串}</td><td style="text-align:center">从头向后开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td style="text-align:center">${变量名##匹配字串}</td><td style="text-align:center">从头向后开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td style="text-align:center">${变量名%匹配字串}</td><td style="text-align:center">从尾向前开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td style="text-align:center">${变量名%%匹配字串}</td><td style="text-align:center">从尾向前开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td style="text-align:center">${变量名/旧的字串/新的字串}</td><td style="text-align:center">将符合旧字串的第一个字串替换为新的字串</td></tr><tr><td style="text-align:center">${变量名//旧的字串/新的字串}</td><td style="text-align:center">将符合旧字串的全部字串替换为新的字串</td></tr></tbody></table><ul><li><p>比如要修改前面添加到PATH的环境变量，为了避免误操作导致命令找不到，我们先将PATH赋值给一个新定义的自定义变量：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span>=$<span class="built_in">PATH</span></span><br><span class="line"><span class="built_in">echo</span> $<span class="built_in">path</span></span><br><span class="line"><span class="built_in">path</span>=$&#123;<span class="built_in">path</span><span class="variable">%/home/shiyanlou/mybin&#125;</span></span><br><span class="line"><span class="variable">path=$&#123;path%</span>*/mybin&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除变量">删除变量</h4><ul><li><p>可以使用<code>unset</code>命令删除一个环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> temp</span><br></pre></td></tr></table></figure></li></ul><h3 id="让环境变量立刻生效">让环境变量立刻生效</h3><ul><li><p>在Shell中修改了一个配置脚本文件后，必须要退出终端重新启动才可以生效，如果希望立即生效，可以使用<code>source</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure></li><li><p><code>source</code>命令还有一个别名<code>.</code>，或者使用以下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">. ./.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="搜索文件">搜索文件</h2><h3 id="whereis">whereis</h3><ul><li><p><code>whereis</code>搜索很快，因为并没有从硬盘中依次查找，而是从数据库中查询</p></li><li><p><code>whereis</code>只能搜索二进制文件（-b）、man帮助文件（-m）和源代码文件（-s）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis who</span><br><span class="line">whereis <span class="built_in">find</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008234411280.png" alt="image-20231008234411280"></p></li></ul><h3 id="locate">locate</h3><ul><li><p>通过<code>/var/lib/mlocate/mlocate.db</code>数据库查找，但这个文件只会由系统每天自动执行<code>updatedb</code>命令更新一次</p></li><li><p>查找<code>/usr/share/</code>下的所有jpg文件：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install locate</span><br><span class="line">locate /usr/<span class="keyword">share</span>/\*.jpg</span><br></pre></td></tr></table></figure></li><li><p>如果只想统计数目可以加上<code>-c</code>参数，忽略大小写查找使用<code>-i</code>参数</p></li></ul><h3 id="which">which</h3><ul><li><p>which本身是Shell内建的一个命令，通常用来确定是否安装了某个指定的软件，因为其只通过PATH环境变量指定的路径中查找：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">which</span> <span class="keyword">man</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="find">find</h3><ul><li><p>find命令是四种查找中最强大的，格式为<code>find [path] [option] [action]</code></p></li><li><p>表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">find</span> <span class="regexp">/etc/</span> -name interfaces</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><ul><li><p>找出 /etc/ 目录下的所有以 .list 结尾的文件。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">find</span> <span class="regexp">/etc/</span> -name \*.list </span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008234711794.png" alt="image-20231008234711794"></p></li></ul>]]></content>
    
    
    <summary type="html">本文介绍Linux环境变量的作用与用法，及几种搜索文件的方法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
</feed>
