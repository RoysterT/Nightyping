<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🌙Nightyping</title>
  
  <subtitle>技术，生活与美好</subtitle>
  <link href="https://www.iuoyt.com/atom.xml" rel="self"/>
  
  <link href="https://www.iuoyt.com/"/>
  <updated>2023-12-01T15:06:50.292Z</updated>
  <id>https://www.iuoyt.com/</id>
  
  <author>
    <name>Royster</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux中的进程</title>
    <link href="https://www.iuoyt.com/posts/62cfef17.html"/>
    <id>https://www.iuoyt.com/posts/62cfef17.html</id>
    <published>2023-12-01T11:31:29.000Z</published>
    <updated>2023-12-01T15:06:50.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序与进程">程序与进程</h2><ul><li><p>简单地说，程序就是为了完成某种任务而设计的软件，进程就是运行中的程序。</p></li><li><p>程序只是一些列指令的集合，是一个静止的实体，而进程则有以下特性：</p><ul><li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li><li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li><li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li><li>异步性：进程以不可预知的速度向前推进。</li><li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li></ul></li><li><p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。</p><blockquote><p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p></blockquote></li><li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li></ul><h2 id="进程的属性">进程的属性</h2><h3 id="进程的分类">进程的分类</h3><h4 id="按功能和服务对象">按功能和服务对象</h4><ul><li>从这个角度看，可以将进程分为用户进程与系统进程<ul><li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li><li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li></ul></li></ul><h4 id="按应用程序的服务类型">按应用程序的服务类型</h4><ul><li>从这个角度看，可以将进程分为交互进程、批处理进程、守护进程<ul><li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。</li></ul></li></ul><h3 id="进程的衍生">进程的衍生</h3><h4 id="父进程与子进程">父进程与子进程</h4><ul><li><p>子进程是由父进程开启的，比如在终端中输入<code>bash</code>再启动一个终端，那么新打开的终端则称为子进程，前者则为父进程。关于父进程与子进程便会涉及这两个系统调用 <code>fork()</code> 与 <code>exec()</code>：</p><ul><li><code>fork()</code>：主要作用是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</li><li><code>exec()</code>：作用是切换子进程中的执行程序，也就是替换其从父进程复制过来的代码段与数据段</li></ul></li><li><p>子进程在退出前主函数<code>main()</code>会执行<code>exit(n)</code>或者<code>return n</code>返回一个信号值，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。</p></li></ul><h4 id="僵尸进程">僵尸进程</h4><ul><li>正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 <code>reason for termination</code> 。之后，父进程会使用 <code>wait(&amp;status)</code> 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。</li><li>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。</li></ul><h4 id="孤儿进程">孤儿进程</h4><ul><li>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。</li></ul><h4 id="进程0（内核初始化进程）">进程0（内核初始化进程）</h4><ul><li>进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 <code>fork()</code> 创建出一个子进程运行 <code>/sbin/init</code> 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。</li></ul><h3 id="进程组与Session">进程组与Session</h3><ul><li>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</li><li>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 <code>getpgrp()</code> 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</li><li>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，Session 中的每个进程都称为一个工作(job)。</li></ul><h3 id="工作管理">工作管理</h3><ul><li><p>并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。</p></li><li><p>结束前台进程可以使用<kbd>Ctrl</kbd>+<kbd>C</kbd>，但无法结束后台进程。</p></li><li><p>如果使用<code>&amp;</code>符号，进程则会在后台中运行，查看运行中的进程可以使用<code>ls &amp;</code>，得到序号如<code>[1] 204</code>分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224354846.png" alt="image-20231201224354846"></p></li><li><p>如果希望暂停当前工作并存放到后台可以使用<kbd>Ctrl</kbd>+<kbd>Z</kbd></p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224613524.png" alt="image-20231201224613524"></p></li><li><p>被放置到后台的工作可以使用<code>jobs</code>查看。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224819667.png" alt="image-20231201224819667"></p><p>其中第一列显示的为被放置后台 job 的编号，而第二列的 <code>+</code> 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，<code>-</code> 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令。</p></li><li><p>如果希望将后台的工作拿到前台继续进行，可以使用<code>fg</code>命令：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后面不加参数提取预设工作，加参数提取指定工作的编号</span></span><br><span class="line"><span class="comment">#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</span></span><br><span class="line"><span class="attribute">fg</span><span class="meta"> [%jobnumber]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201225144514.png" alt="image-20231201225144514"></p></li><li><p>而如果希望其在后台继续而不拿到前台，可以使用<code>bg</code>命令：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与fg类似，加参则指定，不加参则取预设</span></span><br><span class="line"><span class="attribute">bg</span><span class="meta"> [%jobnumber]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201225553266.png" alt="image-20231201225553266"></p></li><li><p>如果希望删除后台的工作，可以使用<code>kill</code>命令结束进程：</p>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kill的使用格式如下</span></span><br><span class="line"><span class="keyword">kill</span> -signal %jobnumber</span><br><span class="line"></span><br><span class="line"><span class="comment">#signal从1-64个信号值可以选择，可以这样查看</span></span><br><span class="line"><span class="keyword">kill</span> －l</span><br></pre></td></tr></table></figure><p>其中常用的有这些信号值</p></li></ul><table><thead><tr><th>信号值</th><th>作用</th></tr></thead><tbody><tr><td>-1</td><td>重新读取参数运行，类似与restart</td></tr><tr><td>-2</td><td>如同 ctrl+c 的操作退出</td></tr><tr><td>-9</td><td>强制终止该任务</td></tr><tr><td>-15</td><td>正常的方式终止该任务</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Linux 中也难免遇到某个程序无响应的情况，可以通过一些命令来帮助我们让系统能够更流畅的运行。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下软件安装</title>
    <link href="https://www.iuoyt.com/posts/cf3716a6.html"/>
    <id>https://www.iuoyt.com/posts/cf3716a6.html</id>
    <published>2023-12-01T03:09:15.000Z</published>
    <updated>2023-12-01T15:04:02.973Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Linux上通常有四种方式安装软件：<ul><li>在线安装</li><li>从磁盘安装deb软件包</li><li>从二进制软件包安装</li><li>从源代码编译安装</li></ul></li><li>这篇文章中使用的场景均为Ubuntu下，不一定适用于其他Linux发行版。</li></ul><h2 id="使用apt-get安装软件">使用apt-get安装软件</h2><ul><li><p>现在如果想安装一个名为<code>w3m</code>（命令行的简易网页浏览器），那么可以输入如下命令：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install w3m</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201175216825.png" alt="image-20231201175216825"></p></li><li><p>在软件安装完成后，无法直接使用<kbd>Tab</kbd>补全命令，可以先执行如下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h3 id="apt包管理工具介绍">apt包管理工具介绍</h3><blockquote><p>APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 <code>apt-</code> 开头的多个工具，如 <code>apt-get</code> <code>apt-cache</code> <code>apt-cdrom</code> 等，在Debian系列的发行版中使用。</p></blockquote><ul><li>当在执行安装操作时，首先<code>apt-get</code> 工具会在<strong>本地</strong>的一个数据库中搜索软件的相关信息，并根据这些信息在相关的服务器上下载软件安装。</li><li>我们需要定期从服务器上下载一个软件包列表，系统会使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有<strong>软件依赖</strong>信息的记录，对于软件依赖，比如：安装 <code>w3m</code> 软件的时候，而这个软件需要 <code>libgc1c2</code> 这个软件包才能正常工作，这个时候 <code>apt-get</code> 在安装软件的时候会将其一并安装，以保证 <code>w3m</code> 能正常工作。</li></ul><h3 id="apt-get">apt-get</h3><ul><li><code>apt-get</code> 是用于处理 <code>apt</code>包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些<code>apt-get</code>包含的常用的一些工具：</li></ul><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><code>install</code></td><td>其后加上软件包名，用于安装一个软件包</td></tr><tr><td><code>update</code></td><td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td></tr><tr><td><code>upgrade</code></td><td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次<code>update</code></td></tr><tr><td><code>dist-upgrade</code></td><td>解决依赖关系并升级(存在一定危险性)</td></tr><tr><td><code>remove</code></td><td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td></tr><tr><td><code>autoremove</code></td><td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td></tr><tr><td><code>purge</code></td><td>与remove相同，但会完全移除软件包，包含其配置文件</td></tr><tr><td><code>clean</code></td><td>移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/</td></tr><tr><td><code>autoclean</code></td><td>移除已安装的软件的旧版本软件包</td></tr></tbody></table><ul><li><code>apt-get</code>的常用参数如下：</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-y</code></td><td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td></tr><tr><td><code>-s</code></td><td>模拟安装</td></tr><tr><td><code>-q</code></td><td>静默安装方式，指定多个<code>q</code>或者<code>-q=#</code>,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td></tr><tr><td><code>-f</code></td><td>修复损坏的依赖关系</td></tr><tr><td><code>-d</code></td><td>只下载不安装</td></tr><tr><td><code>--reinstall</code></td><td>重新安装已经安装但可能存在问题的软件包</td></tr><tr><td><code>--install-suggests</code></td><td>同时安装APT给出的建议安装的软件包</td></tr></tbody></table><h3 id="使用apt-get安装软件包">使用apt-get安装软件包</h3><ul><li><p>就像前面演示的一样，只需要执行<code>apt-get install &lt;软件包名&gt;</code>即可。</p></li><li><p>但有时需要重新对软件包进行安装，比如在系统被破坏、软件配置错误等时候，则可以加上<code>--reinstall</code>参数进行重新安装，比如对前面安装的<code>w3m</code>进行重装：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="comment">--reinstall install w3m</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201180918092.png" alt="image-20231201180918092"></p></li></ul><h3 id="更换软件源与软件升级">更换软件源与软件升级</h3><ul><li><p>如果希望更换软件的下载源，可以到<code>/etc/apt</code>目录下修改<code>sources.list</code>文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>apt/sources.list</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201181658888.png" alt="image-20231201181658888"></p></li><li><p>更新软件源可以使用如下命令：</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201181015727.png" alt="image-20231201181015727"></p></li><li><p>对所有没有依赖问题的软件包进行升级：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> upgrade</span><br></pre></td></tr></table></figure></li><li><p>全部升级并解决依赖关系：</p>  <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="built_in">dist</span>-upgrade</span><br></pre></td></tr></table></figure></li></ul><h3 id="卸载软件">卸载软件</h3><ul><li><p>现在想卸载掉<code>w3m</code>这个软件，可以使用同样的命令，带上<code>remove</code>参数即可完成卸载：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="built_in">remove</span> w3m</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201182239343.png" alt="image-20231201182239343"></p></li><li><p>如果希望不保留配置文件的移除，可以使用：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> purge w3m</span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="comment">--purge remove</span></span><br></pre></td></tr></table></figure></li><li><p>同时也可以移除不再需要的被依赖软件包：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> autoremove</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201182505496.png" alt="image-20231201182505496"></p></li></ul><h3 id="软件搜索">软件搜索</h3><ul><li><p>如果不确定需要的软件是否已经安装，可以使用搜索功能：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache search soft<span class="symbol">name1</span> soft<span class="symbol">name2</span> soft<span class="symbol">name3</span>……</span><br></pre></td></tr></table></figure><p><code>apt-cache</code> 命令是针对本地数据进行相关操作的工具，<code>search</code> 顾名思义在本地的数据库中寻找有关 <code>softname1</code> <code>softname2</code> …… 相关软件的信息。</p></li></ul><h2 id="使用dpkd安装">使用dpkd安装</h2><h3 id="安装deb软件包">安装deb软件包</h3><ul><li>我们可以经常在网络上见到以<code>deb</code>形式打包的软件包，这些软件包就需要使用<code>dpkg</code>命令来安装，常用参数如下：</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-i</code></td><td>安装指定deb包</td></tr><tr><td><code>-R</code></td><td>后面加上目录名，用于安装该目录下的所有deb安装包</td></tr><tr><td><code>-r</code></td><td>remove，移除某个已安装的软件包</td></tr><tr><td><code>-I</code></td><td>显示<code>deb</code>包文件的信息</td></tr><tr><td><code>-s</code></td><td>显示已安装软件的信息</td></tr><tr><td><code>-S</code></td><td>搜索已安装的软件包</td></tr><tr><td><code>-L</code></td><td>显示已安装软件包的目录信息</td></tr></tbody></table><ul><li><p>首先使用<code>apt-get</code>加上<code>-d</code>参数只下载不安装，下载<code>emacs</code>编辑器的deb包：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> -d install -y emacs</span><br></pre></td></tr></table></figure></li><li><p>下载完成后，可以在<code>/var/cache/apt/archives/</code>查看下载的内容：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="regexp">/var/</span>cache<span class="regexp">/apt/</span>archives/</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201190916849.png" alt="image-20231201190916849"></p></li><li><p>将第一个文件拷贝到用户目录下，并使用<code>dpkg</code>安装：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cp</span> /var/cache/apt/archives/emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb ~</span><br><span class="line"><span class="attribute">sudo</span> dpkg -I emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201191438879.png" alt="image-20231201191438879"></p></li><li><p>但如果安装的软件包还有额外依赖，那么意味着直接使用<code>dpkg</code>命令会出现一些问题，因为<code>dpkg</code>无法解决依赖关系问题：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dpkg -i emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201191718630.png" alt="image-20231201191718630"></p></li><li><p>为了解决这个问题，可以使用<code>apt-get</code>的<code>-f</code>参数修复依赖关系的安装：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> -f install -y</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看已安装软件包的安装目录">查看已安装软件包的安装目录</h3><ul><li><p>如果希望知道每个软件分别安装到了什么地方，可以使用<code>dpkg</code>的<code>-L</code>参数查看deb包目录信息：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dpkg -L emacs24</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201192702116.png" alt="image-20231201192702116"></p></li></ul>]]></content>
    
    
    <summary type="html">介绍Linux中软件安装的几种方式，及apt、dpkg工具的使用。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux正则表达式相关命令</title>
    <link href="https://www.iuoyt.com/posts/9505e307.html"/>
    <id>https://www.iuoyt.com/posts/9505e307.html</id>
    <published>2023-11-24T10:14:53.000Z</published>
    <updated>2023-11-25T03:20:44.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式">正则表达式</h2><blockquote><p><strong>正则表达式</strong>：计算机科学的一个概念，使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p></blockquote><h3 id="选择">选择</h3><ul><li><code>|</code>竖直分隔符表示选择，例如<code>boy|girl</code>可以匹配<code>boy</code>或者<code>girl</code></li></ul><h3 id="数量限定">数量限定</h3><ul><li><code>+</code>表示前面的字符必须出现至少一次（1次或多次），例如<code>ab+cd</code>，可以匹配<code>abcd</code>，<code>abbcd</code>等</li><li><code>?</code>表示前面的字符最多出现一次（0次或1次），例如<code>colou?r</code>，可以匹配<code>color</code>或者<code>colour</code></li><li><code>*</code>星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、1次或多次），例如<code>0*42</code>可以匹配<code>42</code>、<code>042</code>、<code>0042</code>、<code>00042</code>等</li></ul><h3 id="范围和优先级">范围和优先级</h3><ul><li><code>()</code>圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，<code>gr(a|e)y</code>等价于<code>gray|grey</code>（这里体现了优先级，竖直分隔符用于选择<code>a</code>或者<code>e</code>而不是<code>gra</code>和<code>ey</code>），<code>(grand)?father</code>匹配<code>father</code>和<code>grandfather</code>（这里体现了范围，<code>?</code>将圆括号内容作为一个整体匹配）</li></ul><h3 id="更多语法">更多语法</h3><table><thead><tr><th style="text-align:center">字符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td><strong>将下一个字符标记为一个特殊字符、或一个原义字符。</strong> 例如，<code>n</code>匹配字符<code>n</code>，<code>\n</code>匹配一个换行符，序列<code>\\</code>匹配<code>\</code>而<code>\(</code>则匹配<code>(</code></td></tr><tr><td style="text-align:center">^</td><td><strong>匹配输入字符串的开始位置</strong></td></tr><tr><td style="text-align:center">$</td><td><strong>匹配输入字符串的结束位置</strong></td></tr><tr><td style="text-align:center">{n}</td><td><strong>匹配确定的n次（n为非负整数）</strong>。例如，<code>o&#123;2&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code></td></tr><tr><td style="text-align:center">{n,}</td><td><strong>至少匹配n次（n为非负整数）</strong>。例如，<code>o&#123;2,&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但能匹配<code>foooood</code>中的所有<code>o</code>。<code>o&#123;1,&#125;</code>等价于<code>o+</code>，<code>o&#123;0,&#125;</code>则等价于<code>o*</code></td></tr><tr><td style="text-align:center">{n,m}</td><td><strong>最少匹配n次且最多匹配m次（m和n均为非负整数，其中n&lt;=m）。</strong> 例如，<code>o&#123;1,3&#125;</code>将匹配<code>fooooood</code>中的前三个<code>o</code>。<code>o&#123;0,1&#125;</code>等价于<code>o?</code>。请注意在逗号和两个数之间不能有空格</td></tr><tr><td style="text-align:center">*</td><td><strong>匹配前面的子表达式零次或多次</strong>。例如，<code>zo</code>能匹配<code>z</code>、<code>zo</code>以及<code>zoo</code>。<code>*</code>等价于<code>&#123;0,&#125;</code></td></tr><tr><td style="text-align:center">+</td><td><strong>匹配前面的子表达式一次或多次</strong>。例如，<code>zo+</code>能匹配<code>zo</code>以及<code>zoo</code>，但不能匹配<code>z</code>。<code>+</code>等价于<code>&#123;1,&#125;</code></td></tr><tr><td style="text-align:center">?</td><td><strong>匹配前面的子表达式零次或一次</strong>。例如，<code>do(es)?</code>可以匹配<code>do</code>或<code>does</code>中的<code>do</code>。<code>?</code>等价于<code>&#123;0,1&#125;</code></td></tr><tr><td style="text-align:center">限制符+?</td><td>当该字符紧跟在任何一个其他限制符（<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code>）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串<code>oooo</code>，<code>o+?</code>将匹配单个<code>o</code>，而<code>o+</code>将匹配所有<code>o</code></td></tr><tr><td style="text-align:center">.</td><td><strong>匹配除<code>\n</code>之外的任何单个字符</strong>。要匹配包括<code>\n</code>在内的任何字符，请使用像(.|\n)的模式</td></tr><tr><td style="text-align:center">(pattern)</td><td><strong>匹配pattern并获取这一匹配的子字符串</strong>。该子字符串用于向后引用。要匹配圆括号字符，请使用<code>\(</code>或<code>\)</code></td></tr><tr><td style="text-align:center">x|y</td><td><strong>匹配x或y</strong>。例如z|food能匹配<code>z</code>或<code>food</code>，(z|f)ood则匹配<code>zood</code>或<code>food</code></td></tr><tr><td style="text-align:center">[xyz]</td><td>字符集合，<strong>匹配所包含的任意一个字符</strong>。例如，<code>[abc]</code>可以匹配<code>plain</code>中的<code>a</code>。其中特殊字符仅有反斜线<code>\</code>保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符<code>^</code>如果出现在首位则表示负值字符集合，如果出现在字符串中间就仅作为普通字符。<strong>连字符<code>-</code> 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符</strong></td></tr><tr><td style="text-align:center">[^xyz]</td><td>排除型字符集合，<strong>匹配未列出的任意字符。</strong> 例如，<code>[^abc]</code>可以匹配<code>plain</code>中的<code>plin</code></td></tr><tr><td style="text-align:center">[a-z]</td><td>字符范围，<strong>匹配指定范围内的任意字符。</strong> 例如，<code>[a-z]</code>可以匹配<code>a</code>到<code>z</code>范围内的任意小写字母字符</td></tr><tr><td style="text-align:center">[^a-z]</td><td>排除型的字符范围，<strong>匹配任何不在指定范围内的任意字符</strong>。例如，<code>[^a-z]</code>可以匹配任何不在<code>a</code>到<code>z</code>范围内的任意字符</td></tr></tbody></table><h3 id="优先级">优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>高</td><td>\</td><td>转义符</td></tr><tr><td></td><td>(), (?:), (?=), []</td><td>括号和中括号</td></tr><tr><td></td><td>*、+、?、{n}、{n,}、{n,m}</td><td>限定符</td></tr><tr><td></td><td>^、$、\任何元字符</td><td>定位点和序列</td></tr><tr><td>低</td><td>|</td><td>选择</td></tr></tbody></table><h2 id="相关命令">相关命令</h2><h3 id="grep模式匹配命令">grep模式匹配命令</h3><h4 id="基本操作">基本操作</h4><ul><li><code>grep</code>命令用于打印输出文本中匹配的模式串，使用正则表达式作为匹配的条件。这个命令支持三种正则表达式引擎，用三种参数指定，在不使用perl语言的情况下用的大多数正则表达式都是前两种：</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-E</code></td><td style="text-align:center">POSIX扩展正则表达式，ERE</td></tr><tr><td style="text-align:center"><code>-G</code></td><td style="text-align:center">POSIX基本正则表达式，BRE</td></tr><tr><td style="text-align:center"><code>-P</code></td><td style="text-align:center">Perl正则表达式，PCRE</td></tr></tbody></table><ul><li><code>grep</code>命令有如下常用参数：</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:left">将二进制文件作为文本来进行匹配</td></tr><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:left">统计以模式匹配的数目</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:left">忽略大小写</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:left">显示匹配文本所在行的行号</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:left">反选，输出不匹配行的内容</td></tr><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:left">递归匹配查找</td></tr><tr><td style="text-align:center"><code>-A n</code></td><td style="text-align:left">n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行</td></tr><tr><td style="text-align:center"><code>-B n</code></td><td style="text-align:left">n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行</td></tr><tr><td style="text-align:center"><code>--color=auto</code></td><td style="text-align:left">将输出中的匹配项设置为自动颜色显示</td></tr></tbody></table><h4 id="使用基本正则表达式BRE">使用基本正则表达式BRE</h4><h5 id="位置">位置</h5><ul><li><p>查找<code>/etc/group</code>文件中以<code>shiyanlou</code>开头的行：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">&#x27;shiyanlou&#x27;</span> <span class="regexp">/etc/g</span>roup</span><br><span class="line"><span class="keyword">grep</span> <span class="string">&#x27;^shiyanlou&#x27;</span> <span class="regexp">/etc/g</span>roup</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191055543.png" alt="image-20231124191055543"></p></li></ul><h5 id="数量">数量</h5><ul><li><p>匹配以<code>z</code>开头以<code>o</code>结尾的所有字符串：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;zero</span>\nzo\nzoo&#x27; | grep <span class="symbol">&#x27;z</span>.*o&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191223808.png" alt="image-20231124191223808"></p></li><li><p>将匹配以<code>z</code>开头以<code>o</code>结尾，中间包含一个任意字符的字符串：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;zero</span>\nzo\nzoo&#x27; | grep <span class="symbol">&#x27;z</span>.o&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191353795.png" alt="image-20231124191353795"></p></li><li><p>将匹配以<code>z</code>开头,以任意多个<code>o</code>结尾的字符串：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;zo*&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191447803.png" alt="image-20231124191447803"></p></li></ul><h5 id="选择-2">选择</h5><ul><li><p><code>grep</code>默认是区分大小写的，接下来对字符串<code>1234\nabcd</code>进行如下操作。</p></li><li><p>匹配所有的小写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[a-z]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191630543.png" alt="image-20231124191630543"></p></li><li><p>匹配所有的数字：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[0-9]&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:digit:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191950057.png" alt="image-20231124191950057"></p></li><li><p>匹配所有的小写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:lower:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192147548.png" alt="image-20231124192147548"></p></li><li><p>匹配所有的大写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd\nABCD&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:upper:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192246970.png" alt="image-20231124192246970"></p></li><li><p>匹配所有的字母和数字，包括0-9,a-z,A-Z：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:alnum:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192348521.png" alt="image-20231124192348521"></p></li><li><p>匹配所有的字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:alpha:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192435784.png" alt="image-20231124192435784"></p></li><li><p>完整的特殊符号列表及说明：</p></li></ul><table><thead><tr><th style="text-align:center">特殊符号</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>[:alnum:]</code></td><td>代表英文大小写字母及数字，亦即 0-9, A-Z, a-z</td></tr><tr><td style="text-align:center"><code>[:alpha:]</code></td><td>代表任何英文大小写字母，亦即 A-Z, a-z</td></tr><tr><td style="text-align:center"><code>[:blank:]</code></td><td>代表空白键与 [Tab] 按键两者</td></tr><tr><td style="text-align:center"><code>[:cntrl:]</code></td><td>代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del… 等等</td></tr><tr><td style="text-align:center"><code>[:digit:]</code></td><td>代表数字而已，亦即 0-9</td></tr><tr><td style="text-align:center"><code>[:graph:]</code></td><td>除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键</td></tr><tr><td style="text-align:center"><code>[:lower:]</code></td><td>代表小写字母，亦即 a-z</td></tr><tr><td style="text-align:center"><code>[:print:]</code></td><td>代表任何可以被列印出来的字符</td></tr><tr><td style="text-align:center"><code>[:punct:]</code></td><td>代表标点符号 (punctuation symbol)，亦即：&quot; ’ ? ! ; : # $…</td></tr><tr><td style="text-align:center"><code>[:upper:]</code></td><td>代表大写字母，亦即 A-Z</td></tr><tr><td style="text-align:center"><code>[:space:]</code></td><td>任何会产生空白的字符，包括空白键, [Tab], CR 等等</td></tr><tr><td style="text-align:center"><code>[:xdigit:]</code></td><td>代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</td></tr></tbody></table><h5 id="排除">排除</h5><ul><li><p>在字符串中排除字符：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;geek\ngood&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[^o]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192843061.png" alt="image-20231124192843061"></p>  <div class="tip "><p>当<code>^</code>放到中括号内为排除字符，否则表示行首</p></div></li></ul><h4 id="使用扩展正则表达式ERE">使用扩展正则表达式ERE</h4><div class="tip "><p>通过<code>grep</code>使用扩展正则表达式需要加上<code>-E</code>参数，或使用<code>egrep</code></p></div><h5 id="数量-2">数量</h5><ul><li><p>只匹配<code>zo</code>：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> -E <span class="string">&#x27;zo&#123;1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193420972.png" alt="image-20231124193420972"></p></li><li><p>匹配以<code>zo</code>开头的所有单词：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> -E <span class="string">&#x27;zo&#123;1,&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193513268.png" alt="image-20231124193513268"></p></li></ul><h5 id="选择-3">选择</h5><ul><li><p>匹配<code>www.shiyanlou.com</code>和<code>www.google.com</code>：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27; | grep -<span class="type">E</span> <span class="symbol">&#x27;www</span>\.(shiyanlou|google)\.com&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193714766.png" alt="image-20231124193714766"></p></li><li><p>或者匹配不包含<code>baidu</code>的内容：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27; | grep -<span class="type">Ev</span> <span class="symbol">&#x27;www</span>\.baidu\.com&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193823247.png" alt="image-20231124193823247"></p></li></ul><div class="tip "><p>因为<code>.</code>号有特殊含义，所以需要转义</p></div><h3 id="sed流编辑器">sed流编辑器</h3><ul><li><p><code>sed</code>命令的基本格式如下：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [参数]... [执行命令] [输入文件]...</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用参数">常用参数</h4><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-n</code></td><td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td></tr><tr><td style="text-align:center"><code>-e</code></td><td>用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td></tr><tr><td style="text-align:center"><code>-f filename</code></td><td>指定执行filename文件中的命令</td></tr><tr><td style="text-align:center"><code>-r</code></td><td>使用扩展正则表达式，默认为标准正则表达式</td></tr><tr><td style="text-align:center"><code>-i</code></td><td>将直接修改输入文件内容，而不是打印到标准输出设备</td></tr></tbody></table><h4 id="执行命令">执行命令</h4><ul><li><p><code>sed</code>命令中可以有单条或多条执行命令，每条执行命令之间使用<code>;</code>分隔，执行命令格式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[n1]</span><span class="selector-attr">[,n2]</span>command</span><br><span class="line"><span class="selector-attr">[n1]</span><span class="selector-attr">[~step]</span>command</span><br></pre></td></tr></table></figure><p>其中n1,n2表示输入内容的行号，它们之间为<code>,</code>逗号则表示从n1到n2行，如果为<code>～</code>波浪号则表示从n1开始以step为步进的所有行；command为执行动作。</p></li><li><p>其中一些命令可以在后面加上作用范围，比如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/sad/happy/g&#x27;</span> <span class="built_in">test</span></span><br><span class="line">sed -i <span class="string">&#x27;s/sad/happy/4&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>其中，第一句命令的<code>g</code>表示全局范围，第二句命令的<code>4</code>表示指定行中第四个匹配的字符串，上面两句都是将范围内的<code>sad</code>更改为<code>happy</code>。</p></li><li><p>下面为一些常用动作指令：</p></li></ul><table><thead><tr><th style="text-align:center">命令</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>s</code></td><td>行内替换</td></tr><tr><td style="text-align:center"><code>c</code></td><td>整行替换</td></tr><tr><td style="text-align:center"><code>a</code></td><td>插入到指定行的后面</td></tr><tr><td style="text-align:center"><code>i</code></td><td>插入到指定行的前面</td></tr><tr><td style="text-align:center"><code>p</code></td><td>打印指定行，通常与<code>-n</code>参数配合使用</td></tr><tr><td style="text-align:center"><code>d</code></td><td>删除指定行</td></tr></tbody></table><h4 id="操作举例">操作举例</h4><ul><li><p>首先得到一个用于测试的文本文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/etc/</span>passwd ~</span><br></pre></td></tr></table></figure></li><li><p>打印指定行（2-5）：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nl</span> passwd | sed -n &#x27;<span class="number">2</span>,<span class="number">5</span>p&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195346741.png" alt="image-20231124195346741"></p></li><li><p>打印奇数行：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nl</span> passwd | sed -n &#x27;<span class="number">1</span>~<span class="number">2</span>p&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195457985.png" alt="image-20231124195457985"></p></li><li><p>行内替换，将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;,并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sed</span> -n <span class="string">&#x27;s/shiyanlou/hehe/gp&#x27;</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195627471.png" alt="image-20231124195627471"></p></li><li><p>删除某行（30）：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl passwd <span class="string">| grep &quot;</span>shiyanlou<span class="string">&quot;</span></span><br><span class="line">sed -i &#x27;30d&#x27; passwd</span><br><span class="line">nl passwd <span class="string">| grep &quot;</span>shiyanlou<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195906463.png" alt="image-20231124195906463"></p></li></ul><h3 id="awk文本处理语言">awk文本处理语言</h3><h4 id="简单介绍">简单介绍</h4><blockquote><p><code>AWK</code>是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一，其名称得自于它的创始人Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和Brian Wilson Kernighan（布莱恩·柯林汉）姓氏的首个字母.AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”，它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK是一种用于处理文本的编程语言工具。</p></blockquote><ul><li><p>在大多数linux发行版上面，实际使用的是gawk（GNU awk，awk的GNU版本），在ubuntu环境上，默认提供的是mawk，系统已经创建好了<code>awk</code>指向mawk的符号链接：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll <span class="regexp">/usr/</span>bin/awk</span><br></pre></td></tr></table></figure></li></ul><h4 id="基础概念">基础概念</h4><ul><li><p><code>awk</code>所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：</p>  <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pattern</span> &#123;action&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>awk</code>处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，<code>awk</code>以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符。</p></li></ul><h4 id="基本格式">基本格式</h4><ul><li><p><code>awk</code>命令的基本格式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="selector-attr">[-F fs]</span> <span class="selector-attr">[-v var=value]</span> <span class="selector-attr">[-f prog-file | <span class="string">&#x27;program text&#x27;</span>]</span> <span class="selector-attr">[file...]</span></span><br></pre></td></tr></table></figure><p>其中<code>-F</code>参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，<code>-v</code>用于预先为<code>awk</code>程序指定变量，<code>-f</code>参数用于指定<code>awk</code>命令要执行的程序文件，或者在不加<code>-f</code>参数的情况下直接将程序语句放在这里，最后为<code>awk</code>需要处理的文本输入，且可以同时输入多个文本文件。</p></li></ul><h4 id="具体操作">具体操作</h4><ul><li><p>先用<code>vim</code>新建一个文本文档：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>输入如下内容：</p>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I <span class="keyword">like</span> linux</span><br><span class="line">www.shiyanlou.com</span><br></pre></td></tr></table></figure><p>按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出</p></li><li><p>使用<code>awk</code>将文本内容打印到终端：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print&#125;&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124201201455.png" alt="image-20231124201201455"></p></li><li><p>将test的第一行的每个字段单独显示为一行，其他行则直接显示：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">1</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span> <span class="variable">$2</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span> <span class="variable">$3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">print&#125;</span><br><span class="line">&#125;&#x27; test</span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">OFS</span><span class="operator">=</span><span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">print <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">print&#125;</span><br><span class="line">&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124224624617.png" alt="image-20231124224624617"></p></li><li><p>将test的第二行的以点为分段的字段换成以tab为分隔：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="operator">-</span><span class="type">F</span>&#x27;.&#x27; &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">2</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span> <span class="variable">$2</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span> <span class="variable">$3</span></span><br><span class="line">&#125;&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124224952656.png" alt="image-20231124224952656"></p><p>或者：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;</span><br><span class="line"><span class="type">BEGIN</span>&#123;</span><br><span class="line"><span class="type">FS</span><span class="operator">=</span><span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="type">OFS</span><span class="operator">=</span><span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">&#125;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">2</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span></span><br><span class="line">&#125;&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124225037736.png" alt="image-20231124225037736"></p></li></ul><h4 id="常见内置变量">常见内置变量</h4><table><thead><tr><th style="text-align:center">变量名</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>FILENAME</code></td><td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td></tr><tr><td style="text-align:center"><code>$0</code></td><td>当前记录的内容</td></tr><tr><td style="text-align:center"><code>$N</code></td><td>N表示字段号，最大值为<code>NF</code>变量的值</td></tr><tr><td style="text-align:center"><code>FS</code></td><td>字段分隔符，由正则表达式表示，默认为&quot; &quot;空格</td></tr><tr><td style="text-align:center"><code>RS</code></td><td>输入记录分隔符，默认为<code>\n</code>，即一行为一个记录</td></tr><tr><td style="text-align:center"><code>NF</code></td><td>当前记录字段数</td></tr><tr><td style="text-align:center"><code>NR</code></td><td>已经读入的记录数</td></tr><tr><td style="text-align:center"><code>FNR</code></td><td>当前输入文件的记录数，请注意它与NR的区别</td></tr><tr><td style="text-align:center"><code>OFS</code></td><td>输出字段分隔符，默认为&quot; &quot;空格</td></tr><tr><td style="text-align:center"><code>ORS</code></td><td>输出记录分隔符，默认为<code>\n</code></td></tr></tbody></table><h2 id="实战训练">实战训练</h2><ol><li><p>辨析pattern space和hold space的概念</p><ul><li><p>Pattern space（模式空间）</p><ul><li><p>用于存储当前处理的文本行的缓冲区。在<code>sed</code>的处理过程中，文本逐行读取，每一行都被存储在Pattern space中，然后在Pattern space中进行模式匹配和操作。</p></li><li><p>当<code>sed</code>读取一行文本时，该行文本被放入Pattern space中，然后执行可能的操作，如查找和替换。处理完一行后，Pattern space中的内容可以被输出，也可以保留用于后续处理。</p></li></ul></li><li><p>Hold space（保持空间）</p><ul><li><p>用于在处理多行文本时保存额外的信息。与Pattern space不同，Hold space可以在不同的时刻存储不同的内容，而Pattern space则主要用于当前正在处理的行。</p></li><li><p><code>sed</code>提供的命令允许将Pattern space中的内容移动到Hold space中，反之亦然。这使得在处理多行文本时能够保留和操作先前处理的文本行的信息。</p></li></ul></li><li><p>在<code>sed</code>脚本中，可以使用<code>h</code>或<code>H</code>命令将Pattern space的内容转移到Hold space，使用<code>g</code>或<code>G</code>命令将Hold space的内容转移回Pattern space，区别如下：</p></li></ul></li></ol><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>g</code></td><td>将hold space中的内容拷贝到pattern space中，原来pattern space里的内容被覆盖</td></tr><tr><td><code>G</code></td><td>将hold space中的内容扩充到pattern space最后（换行）</td></tr><tr><td><code>h</code></td><td>将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖</td></tr><tr><td><code>H</code></td><td>将pattern space中的内容扩充到hold space最后（换行）</td></tr><tr><td><code>d</code></td><td>删除pattern space当前行，并读入下一新行到pattern space中</td></tr><tr><td><code>D</code></td><td>删除pattern space中的第一行，不读入下一行</td></tr></tbody></table><ol start="2"><li><p>基于pattern space和hold space实现将一个文本倒序输出</p><ul><li><p>新建一个文本，作为实验内容：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim testfile</span></span><br></pre></td></tr></table></figure></li><li><p>输入以下内容，然后保存文件：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br><span class="line">li<span class="symbol">ne6</span></span><br></pre></td></tr></table></figure></li><li><p>查看写入内容：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">awk</span> <span class="string">&#x27;&#123;print&#125;&#x27;</span> testfile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125004735382.png" alt="image-20231125004735382"></p></li><li><p>我们执行<code>sed</code>命令时能看到的输出都为Pattern space中的内容（当前处理的文本行的缓冲区），因此思路为借助Hold space对Pattern space当前的内容进行操作。</p></li><li><p>那么当前Pattern space在开始执行时依次存储的内容如下：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">line1</span> <span class="comment">#第一次执行</span></span><br><span class="line">line2 <span class="comment">#第二次执行</span></span><br><span class="line">line3 <span class="comment">#第三次执行</span></span><br><span class="line">line4 <span class="comment">#第四次执行</span></span><br></pre></td></tr></table></figure></li><li><p>现在希望将第一行放到第二行的后方，Pattern space变为如下内容：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span> <span class="attr">#第一次执行</span></span><br><span class="line"><span class="attr">line2</span>\<span class="symbol">nline1</span> <span class="attr">#第二次执行</span></span><br><span class="line"><span class="attr">line3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br></pre></td></tr></table></figure></li><li><p>那么经过多次执行操作，最后Pattern space期望变为内容如下：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span> <span class="attr">#第一次执行</span></span><br><span class="line"><span class="attr">line2</span>\<span class="symbol">nline1</span> <span class="attr">#第二次执行</span></span><br><span class="line"><span class="attr">line3</span>\<span class="symbol">nline2</span>\<span class="symbol">nline1</span> <span class="attr">#第三次执行</span></span><br><span class="line"><span class="attr">line4</span>\<span class="symbol">nline3</span>\<span class="symbol">nline2</span>\<span class="symbol">nline1</span> <span class="attr">#第四次执行</span></span><br></pre></td></tr></table></figure><p>如果完成上述操作，则会输出内容如下：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br></pre></td></tr></table></figure><p>由此看来，需要在每次扩展前一行到当前行的同时删除掉前一行的内容，最终仅保留最后一行的内容，即：</p>  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一次执行后当前行被删除</span></span><br><span class="line"><span class="comment">#第二次执行后当前行被删除</span></span><br><span class="line"><span class="comment">#第三次执行后当前行被删除</span></span><br><span class="line">line4<span class="string">\nline3\nline2\nline1</span> <span class="comment">#第四次执行</span></span><br></pre></td></tr></table></figure></li><li><p>整理思路得到对每一行执行的操作如下：</p><ul><li>将当前行扩展到下一行（Pattern space）后方，中间使用<code>\n</code>分隔</li><li>删除当前行，然后读取下一行</li></ul></li><li><p>但是，需要注意以下两个问题：</p><ul><li><code>sed</code>命令中使用分号<code>;</code>分隔的多个语句（①;②;③）如执行顺序为：第一行的 ① -&gt; ② -&gt; ③，然后才是第二行的 ① -&gt; ② -&gt; ③，以此类推。因为Pattern space是逐行读取的。</li><li>使用程序完成第①步操作并非可以只用一步完成，应该是先在下一行后方添加换行符，然后将当前行内容扩展到下一行。</li></ul></li><li><p>但如果对每一行都添加换行符，那么最终在<code>line1</code>的后方会多出一个多余的换行符，因此<code>line1</code>的后方不应该添加换行符。同时“删除当前行”操作在直行道最后一行时，也不应该删除最后一行，否则会丢失所有行的内容。</p></li><li><p>那么最终的操作如下：</p><ul><li>在每一行（除了第一行）后增加一个换行符（可以理解为将空内容换行扩展到当前行后方）</li><li>将当前行内容不换行扩展到下一行后方</li><li>将当前行删除（除非是最后一行），然后移动到下一行</li></ul></li><li><p>这个步骤中的前两步也可以换种思路，其中暂存区借助Hold space实现：</p><ul><li>将暂存区（开始时为空）内容换行扩展到当前行（除了第一行）：<code>1!G</code>，第一行以外的行都执行G操作（将hold space中的内容换行扩充到pattern space最后）</li><li>将当前行内容暂存：<code>h</code>，全部行都执行h操作（将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖）</li><li>删除当前行，移动到下一行（除非是最后一行）：<code>$!d</code>，最后一行以外的行都执行d操作（删除pattern space当前行，并读入下一新行到pattern space中）</li></ul></li><li><p>因此完整命令如下：</p>  <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;<span class="number">1</span><span class="title">!G</span><span class="comment">;h;$!d&#x27; testfile</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125024055225.png" alt="image-20231125024055225"></p></li></ul></li><li><p>基于pattern space和hold space实现交换奇数行和偶数行</p><ul><li><p>将当前行存储到暂存区：<code>h</code>（将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖）</p></li><li><p>如果不是最后一行，那么完成以下两步操作：</p><ul><li>移动到下一行：<code>n</code>（将pattern space中的内容切换到下一行）</li><li>在当前行末尾换行扩展暂存区内容：<code>G</code>（将hold space中的内容换行扩充到pattern space最后）</li></ul></li><li><p>显示当前行：<code>p</code></p></li><li><p>由于已经在命令执行过程中显示了需要的内容，那么无需在执行完成后依次显示Pattern space的内容：<code>-n</code>，否则会显示如下内容：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line5</span></span><br><span class="line">li<span class="symbol">ne6</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line6</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br></pre></td></tr></table></figure></li><li><p>那么完整命令如下：</p>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -<span class="built_in">n</span> &#x27;h;$!&#123;<span class="built_in">n</span>;G&#125;;p&#x27; testfile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125031850044.png" alt="image-20231125031850044"></p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">Linux中匹配正则表达式的相关命令</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux数据流重定向</title>
    <link href="https://www.iuoyt.com/posts/5a9cd021.html"/>
    <id>https://www.iuoyt.com/posts/5a9cd021.html</id>
    <published>2023-11-17T13:56:49.000Z</published>
    <updated>2023-11-25T03:21:37.575Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在之前的Linux笔记中有使用过<code>&gt;</code>、<code>&gt;&gt;</code>，比如如下指令：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; <span class="literal">redirect</span> </span><br><span class="line">echo <span class="string">&#x27;www.shiyanlou.com&#x27;</span> &gt;&gt; <span class="literal">redirect</span></span><br><span class="line">cat <span class="literal">redirect</span></span><br></pre></td></tr></table></figure><p>这部分命令用于将文本字符串 “hello shiyanlou” 输出到（<code>&gt;</code>）<code>redirect</code>文件中，此时文件并不存在，因此将自动创建<code>redirect</code>文件写入字符串，然后再次使用 <code>echo</code> 命令输出字符串<code>www.shiyanlou.com</code>追加到（<code>&gt;&gt;</code>）文件<code>redirect</code>中。</p></li></ul><h3 id="简单的重定向">简单的重定向</h3><ul><li>Linux中默认提供了三种特殊设备，用于终端的显示和输出，分别为<code>stdin</code>（标准输入,对应于你在终端的输入），<code>stdout</code>（标准输出，对应于终端的输出），<code>stderr</code>（标准错误输出，对应于终端的输出）。</li></ul><table><thead><tr><th style="text-align:center">文件描述符</th><th style="text-align:center">设备文件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center"><code>/dev/stdin</code></td><td style="text-align:center">标准输入</td></tr><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center"><code>/dev/stdout</code></td><td style="text-align:center">标准输出</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center"><code>/dev/stderr</code></td><td style="text-align:center">标准错误</td></tr></tbody></table><ul><li><p>可以这样使用文件描述符，比如默认使用终端的标准输入和标准输出作为命令的输入和输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p>此时输入的内容也会在按下<kbd>Enter</kbd>时显示出来。</p><p>（按下<kbd>Ctrl</kbd>+<kbd>C</kbd>退出）</p></li><li><p>将cat的连续输出（heredoc方式）重定向到一个文件：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir Documents</span><br><span class="line">cat &gt; Documents/test.c &lt;&lt;EOF</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>这一段内容的作用是将文件作为标准输出，那么之后输入的内容都会被保存在文件<code>/Documents/test.c</code>中，<code>&lt;&lt;EOF</code>是文本输入的定界符，表示以下内容将作为输入直到遇到 “EOF” 为止。</p></li><li><p>将一个文件作为命令的输入，标准输出作为命令的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193411117.png" alt="image-20231117193411117"></p></li><li><p>将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hi&#x27;</span> | <span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193603353.png" alt="image-20231117193603353"></p></li><li><p>将echo命令的输出从默认的标准输出重定向到一个普通文件：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; <span class="literal">redirect</span></span><br><span class="line">cat <span class="literal">redirect</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193628856.png" alt="image-20231117193628856"></p></li></ul><h3 id="标准错误重定向">标准错误重定向</h3><ul><li><p>有时执行指令得到的输出同事包含了标准输出和标准错误，比如如下操作，使用<code>cat</code>命令同时读取两个文件，其中一个存在，另一个不存在：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c</span><br></pre></td></tr></table></figure><p>可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息.</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117194508097.png" alt="image-20231117194508097"></p></li><li><p>接下来将输出重定向到一个文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c &gt; somefile</span><br></pre></td></tr></table></figure><p>但是依然出现了错误信息，而查看重定指向的文件，已经写入了期望包含的内容</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195102336.png" alt="image-20231117195102336"></p></li><li><p>如果希望将错误或者警告都隐藏，那就可以用到前面提到的文件描述符了。将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> Documents/test.c hello.c &gt;somefile  <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c &amp;&gt;somefilehell</span><br></pre></td></tr></table></figure><p>查看文件内容，可以看到错误信息也被写入到文件中了：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195418320.png" alt="image-20231117195418320"></p></li></ul><h3 id="使用tee命令同时重定向到多个文件">使用tee命令同时重定向到多个文件</h3><ul><li><p>如果既需要将输出重定向到文件，也需要将信息大隐刀终端，那么可以使用<code>tee</code>来实现：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | <span class="built_in">tee</span> hello</span><br></pre></td></tr></table></figure><p>可以看到内容既输出在了终端，同时也被写入到了文件当中：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195716791.png" alt="image-20231117195716791"></p></li></ul><h3 id="永久重定向">永久重定向</h3><ul><li><p>上面的操作完成的重定向只是临时的，如果希望做到永久重定向，可以使用<code>exec</code>命令完成，其作用是使用指定的命令替换当前的Shell，即使用一个进程替换当前进程，或者指定新的重定向。</p></li><li><p>先开启一个子Shell，然后使用exec替换当前进程的重定向，将标准输出重定向到一个文件：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">zsh</span></span><br><span class="line"><span class="attribute">exec</span> <span class="number">1</span>&gt;somefile</span><br></pre></td></tr></table></figure><p>那么后面执行的命令的输出都将被重定向到文件中，,直到退出当前子shell，或取消exec的重定向。</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">cat somefile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117201225039.png" alt="image-20231117201225039"></p></li></ul><h3 id="创建输出文件描述符">创建输出文件描述符</h3><ul><li><p>在Shel 中有9个文件描述符，上面仅仅是使用了默认提供的0、1、2号文件描述符。另外我们还可以使用3-8的文件描述符，只是它们默认没有打开而已。你可以使用下面命令查看当前 Shell 进程中打开的文件描述符：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /dev/fd/;<span class="built_in">ls</span> -Al</span><br></pre></td></tr></table></figure></li><li><p>使用<code>exec</code>命令可以创建新的文件描述并使用：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zsh</span><br><span class="line">exec <span class="number">3</span>&gt;somefile</span><br><span class="line">cd <span class="regexp">/dev/</span>fd/;ls -Al;cd -</span><br><span class="line">echo <span class="string">&quot;this is test&quot;</span> &gt;&amp;<span class="number">3</span></span><br><span class="line">cat somefile</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>  <div class="tip "><p>注意上面的第四句命令中，<code>&gt;</code>与<code>&amp;</code>之间不应该有空格，如果有空格则会出错</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231117202354262.png" alt="image-20231117202354262"></p></li></ul><h3 id="关闭文件描述符">关闭文件描述符</h3><ul><li><p>刚才设置了3号文件描述符，可以使用如下命令将其关闭：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br><span class="line"><span class="built_in">cd</span> /dev/fd;<span class="built_in">ls</span> -Al;<span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117202538761.png" alt="image-20231117202538761"></p></li></ul><h3 id="完全屏蔽命令的输出">完全屏蔽命令的输出</h3><ul><li><p>在Linux中有一个被称为“黑洞”的设备文件，所有导入它的数据都会“消失“</p><blockquote><p>在类UNIX系统中，<code>/dev/null</code>，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。</p></blockquote></li><li><p>我们可以利用<code>/dev/null</code>屏蔽命令的输出：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> Documents/test.c <span class="number">1</span>&gt;/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面这样的操作将使你得不到任何输出结果。</p></li></ul><h3 id="使用-xargs-分割参数列表">使用 xargs 分割参数列表</h3><ul><li><p><code>xargs</code>是一条UNIX和类UNIX操作系统的常用命令，它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p></li><li><p>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果。比如这个命令用于将<code>/etc/passwd</code>文件按<code>:</code>分割取第一个字段排序后，使用<code>echo</code>命令生成一个列表：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> -d: -f1 &lt; <span class="regexp">/etc/</span>passwd | <span class="built_in">sort</span> | xargs echo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117203054249.png" alt="image-20231117203054249"></p></li></ul><h3 id="实战训练">实战训练</h3><blockquote><p>理解下面这段代码的作用，实际这段代码不会正常工作，请结合这一小节的知识分析这段代码没有正确工作的原因，并设法解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">rm</span> -iv <span class="variable">$filename</span></span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>这段代码的作用是将<code>ls</code>命令读取到的全部文件依次删除。</p></li><li><p>但是在删除文件时会提示是否确认删除文件，而输入被<code>ls</code>得到的结果重定向了，因此无法完成确认操作，上述代码无法完成执行。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117214749645.png" alt="image-20231117214749645"></p></li><li><p>因此需要在删除文件时由控制台输入是否确认删除文件，而在读取删除列表时再从重定向中获得输入，修改后代码如下：</p><ul><li><p>将文件描述符3指向标准输入：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">exec</span> <span class="number">3</span>&lt;&amp;<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>删除文件，由文件描述符3提供确认操作给<code>rm</code>命令，使其能够正确执行：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -iv <span class="variable">$filename</span> &lt;&amp;3</span><br></pre></td></tr></table></figure></li><li><p>遍历列表，依次删除文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  &lt;delete operation&gt;</span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>因此，完整代码如下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&lt;&amp;0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">rm</span> -iv <span class="variable">$filename</span> &lt;&amp;3</span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117215259645.png" alt="image-20231117215259645"></p></li></ul>]]></content>
    
    
    <summary type="html">Linux中的数据流重定向是一种通过改变进程的标准输入、标准输出和标准错误的方法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中简单的文本处理</title>
    <link href="https://www.iuoyt.com/posts/d51277ac.html"/>
    <id>https://www.iuoyt.com/posts/d51277ac.html</id>
    <published>2023-11-16T07:02:16.000Z</published>
    <updated>2023-11-25T03:22:30.659Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tr命令">tr命令</h3><ul><li><p><code>tr</code>命令可以用来删除一段文本中的某些文字，或者将其替换。</p></li><li><p>使用方法：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> <span class="selector-attr">[option]</span>..<span class="selector-class">.SET1</span> <span class="selector-attr">[SET2]</span></span><br></pre></td></tr></table></figure></li><li><p>其中常用选项有：</p></li></ul><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-d</code></td><td>删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td style="text-align:center"><code>-s</code></td><td>去除set1指定的在输入文本中连续并重复的字符</td></tr></tbody></table><ul><li><p>比如，删除“hello shiyanlou”字段中的所有o、l、h：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;olh&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141547102.png" alt="image-20231116141547102"></p></li><li><p>再比如，将&quot;hello&quot; 中的“ll”,去重为一个“l”：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27;l&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141658700.png" alt="image-20231116141658700"></p></li><li><p>将输入文本，全部转换为大写或小写输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;input some text here&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[:lower:]&#x27;</span> <span class="string">&#x27;[:upper:]&#x27;</span></span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;input some text here&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141758138.png" alt="image-20231116141758138"></p></li></ul><h3 id="col命令">col命令</h3><ul><li>col命令可以将tab字符换成对等数量的空格键，或者反转这个操作，使用方式为<code>col [option]</code>，常见选项有：</li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center">将<code>Tab</code>转换为空格</td></tr><tr><td style="text-align:center"><code>-h</code></td><td style="text-align:center">将空格转换为<code>Tab</code>（默认选项）</td></tr></tbody></table><ul><li><p>比如，查看<code>/etc/protocols</code>中的不可见字符，可以看到很多 <code>^I</code> ，这其实就是 Tab 转义成可见字符的符号：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -A <span class="regexp">/etc/</span>protocols</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142042116.png" alt="image-20231116142042116"></p></li><li><p>使用<code>col -x</code>将<code>/etc/protocols</code>中的 Tab 转换为空格,然后再使用<code>cat</code>查看，发现<code>^I</code>不见了：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/protocols | col -x | <span class="built_in">cat</span> -A</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142151386.png" alt="image-20231116142151386"></p></li></ul><h3 id="join命令">join命令</h3><ul><li><p><code>join</code>命令用于将两个文件中包含相同内容的那一行合并在一起，使用方法：</p>  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">join</span> [<span class="keyword">option</span>]... file1 file2</span><br></pre></td></tr></table></figure></li><li><p>常用选项有：</p></li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-t</code></td><td style="text-align:center">指定分隔符，默认为空格</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:center">忽略大小写的差异</td></tr><tr><td style="text-align:center"><code>-1</code></td><td style="text-align:center">指明第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td style="text-align:center"><code>-2</code></td><td style="text-align:center">指明第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table><ul><li><p>首先在用户家目录下创建两个文件，然后进行合并：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 hello&#x27;</span> &gt; file1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 shiyanlou&#x27;</span> &gt; file2</span><br><span class="line"><span class="built_in">join</span> file1 file2</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142537075.png" alt="image-20231116142537075"></p></li><li><p>将<code>/etc/passwd</code>与<code>/etc/shadow</code>两个文件合并，指定以’:'作为分隔符：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">join</span> -t<span class="string">&#x27;:&#x27;</span> <span class="regexp">/etc/</span>passwd <span class="regexp">/etc/</span>shadow</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142620545.png" alt="image-20231116142620545"></p></li></ul><h3 id="paste命令">paste命令</h3><ul><li><code>paste</code>与<code>join</code>类似，是在不对比数据的情况下，简单地将多个文件合并起来，并以Tab隔开，格式为<code>paste [option] file...</code>，常用选项有：</li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-d</code></td><td style="text-align:center">指定合并的分隔符，默认为Tab</td></tr><tr><td style="text-align:center"><code>-s</code></td><td style="text-align:center">不合并到一行，每个文件为一行</td></tr></tbody></table><ul><li><p>先创建三个文件，分别存入不同内容：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> hello &gt; file1</span><br><span class="line"><span class="keyword">echo</span> shiyanlou &gt; file2</span><br><span class="line"><span class="keyword">echo</span> www.shiyanlou.<span class="keyword">com</span> &gt; file3</span><br></pre></td></tr></table></figure><p>使用<code>:</code>作为分隔符进行合并：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -d <span class="string">&#x27;:&#x27;</span> file1 file2 file3</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116143257454.png" alt="image-20231116143257454"></p><p>将三个文件内容进行简单合并，每个文件占一行：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -s file1 file2 file3</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116143308307.png" alt="image-20231116143308307"></p></li></ul><h3 id="实战训练">实战训练</h3><blockquote><p>在<a href="/posts/c67b19b2">文件打包与解压缩</a>中提到 Windows/dos 与 Linux/UNIX 文本文件一些特殊字符<code>不一致</code></p><p>如断行符 Windows 为 CR+LF(<code>\r\n</code>)，Linux/UNIX 为 LF(<code>\n</code>)。使用<code>cat -A 文本</code> 可以看到文本中包含的不可见特殊字符。Linux 的<code>\n</code>表现出来就是一个<code>$</code>，而 Windows/dos的表现为<code>^M$</code>，可以直接使用<code>dos2unix</code>和<code>unix2dos</code>工具在两种格式之间进行转换，使用<code>file</code>命令可以查看文件的具体类型。</p><p>不过现在希望<strong>在不使用上述两个转换工具的情况下，使用前面学过的命令手动完成 dos 文本格式到 UNIX 文本格式的转换。</strong></p></blockquote><ul><li><p>Windows的回车符仅比Linux/Unix下多出一个<code>\r</code>那么将Windows文本中的<code>\r</code>全部删除即可实现：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> -d <span class="string">&#x27;\r&#x27;</span> &lt; dos_file<span class="selector-class">.txt</span> &gt; unix_file.txt</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>&lt; dos_file.txt</code>: 从名为<code>dos_file.txt</code>的文件读取输入。</p></li><li><p><code>&gt; unix_file.txt</code>: 将输出写入名为<code>unix_file.txt</code>的文件。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Linux中几个简单的文本处理命令</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令执行顺序控制与管道</title>
    <link href="https://www.iuoyt.com/posts/7ab3ca3a.html"/>
    <id>https://www.iuoyt.com/posts/7ab3ca3a.html</id>
    <published>2023-11-10T11:55:16.000Z</published>
    <updated>2023-11-10T11:57:47.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令执行顺序的控制">命令执行顺序的控制</h2><ul><li><p>通常情况下，使用命令行都是输入完一条指令然后立即执行，然后再输入下一条指令。如果需要一次输入多条指令，再一并执行的话，可以使用<code>;</code>将多条指令隔开来，在一行里写下，那么在按下<kbd>Enter</kbd>的时候，会一次性执行完输入的全部命令。</p></li><li><p>但如果在顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就可能会造成花了时间，最终却得到一个错误结果的情况，并且有时还不能直观的看出是否正确执行。那么这时就需要有选择性地执行命令，比如上一条命令执行成功后才继续执行下一条，否则应该如何处理。比如使用一个<code>witch</code>来做判断，如果安装了<code>cowsay</code>命令就执行，否则什么也不做：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cowsay&gt;<span class="regexp">/dev/</span><span class="literal">null</span> &amp;&amp; cowsay -f head-in ohch~</span><br></pre></td></tr></table></figure><p>其中<code>&amp;&amp;</code>符号前的内容是执行条件，作为<code>&amp;&amp;</code>后语句是否执行的前提判断，如果<code>cowsay&gt;/dev/null</code>执行成功，那么会返回结果<code>0</code>，<code>&amp;&amp;</code>后的语句就会执行。</p></li><li><p>同样的，shell中也有类似于逻辑或的<code>||</code>，在此处与<code>&amp;&amp;</code>做出相反的结果，即当<code>||</code>前的语句执行结果≠0时，才执行后方的语句，比如如果未安装<code>cowsay</code>命令，那么显示出未安装提示：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cowsay&gt;/dev/<span class="literal">null</span> <span class="string">|| echo &quot;</span>cowsay has not been install, please run &#x27;sudo apt-get install cowsay&#x27; to install<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&amp;&amp;</code>和<code>||</code>可以结合起来使用，比如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110180631916.png" alt="image-20231110180631916"></p><p>意思为检查是否安装了<code>cowsay</code>，如果安装了则显示<code>exist</code>，否则显示<code>not exist</code>。上面的语句是先使用<code>&amp;&amp;</code>再使用<code>||</code>，那么如果反过来会出现什么结果呢：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110180645027.png" alt="image-20231110180645027"></p><p>这一次同时输出了<code>not exist</code>和<code>exist</code>的结果，因为<code>&amp;&amp;</code>后的语句执行条件是前一句执行成功，而在执行<code>||</code>判断时返回结果≠0，所以执行了<code>||</code>后的语句，从而也执行了<code>&amp;&amp;</code>后的语句。</p></li></ul><h2 id="管道">管道</h2><ul><li>管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。</li><li>管道又分为匿名管道和具名管道。在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由<code>|</code>分隔符表示，<code>|</code>在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。</li></ul><h3 id="管道的使用">管道的使用</h3><ul><li><p>现在尝试查看<code>/etc</code>下有那些文件和目录：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc</span><br></pre></td></tr></table></figure><p>输出的内容比较多，此时不妨使用管道将<code>ls</code>输出的结果使用<code>less</code>查看：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc | less</span><br></pre></td></tr></table></figure></li></ul><h3 id="cut命令">cut命令</h3><ul><li><p><code>cut</code>命令用于打印每一行的某一字段，比如现在需要打印<code>/etc/passwd</code>文件中以<code>:</code>位分隔符的第一个字段和第六个字段分别作为用户名和其家目录：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="regexp">/etc/</span>passwd -d <span class="string">&#x27;:&#x27;</span> -f <span class="number">1</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110191238613.png" alt="image-20231110191238613"></p></li><li><p>打印<code>/etc/passwd</code>文件中每一行的前N个字符：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前五个（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c -<span class="number">5</span></span><br><span class="line"><span class="comment"># 前五个之后的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span>-</span><br><span class="line"><span class="comment"># 第五个</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span></span><br><span class="line"><span class="comment"># 2到5之间的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">2</span>-<span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="grep命令">grep命令</h3><ul><li><p>grep命令用于在文本中或stdin中查找匹配字符串，如果结合正则表达式可以实现复杂切高效的查找和匹配，一般格式为：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [命令选项]... 用于匹配的表达式 [文件]...</span><br></pre></td></tr></table></figure></li><li><p>比如，搜索<code>/home/shiyanlou</code>目录下所有包含<code>shiyanlou</code>的文本文件，并显示出所在文本中的行号，其中<code>-r</code>表示地柜搜索子目录中的文件，<code>-n</code>表示打印匹配项的行号，<code>-I</code>表示忽略二进制文件：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -rnI <span class="string">&quot;shiyanlou&quot;</span> ~</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110191733110.png" alt="image-20231110191733110"></p></li><li><p>同时也可以使用正则表达式，比如查找以<code>yanlou</code>结尾的字符串：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> | grep <span class="string">&quot;.*yanlou$&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192022608.png" alt="image-20231110192022608"></p></li></ul><h3 id="wc命令">wc命令</h3><ul><li><p><code>wc</code>命令是简单小巧的计数工具，用于统计并输出一个文件中行、单词和字节的数目，比如输出<code>/etc/passwd</code>文件的统计信息：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192208836.png" alt="image-20231110192208836"></p></li><li><p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行数</span></span><br><span class="line">wc -l <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 单词数</span></span><br><span class="line">wc -w <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 字节数</span></span><br><span class="line">wc -c <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 字符数</span></span><br><span class="line">wc -m <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 最长行字节数</span></span><br><span class="line">wc -L <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192540334.png" alt="image-20231110192540334"></p>  <div class="tip info"><p>对于西文字符，一个字符就是一个字节，对于中文字符，一个汉字通常不小于2字节，视编码而定。</p></div></li><li><p>再结合管道，统计<code>/etc</code>下所有目录数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -dl /etc/*/ | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193359731.png" alt="image-20231110193359731"></p></li></ul><h3 id="sort命令">sort命令</h3><ul><li><p><code>sort</code>命令用于排序，即将输入按照一定方式进行排序，然后再输出，支持的排序方式包括但不限于：字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序……</p></li><li><p>默认为字典排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193609728.png" alt="image-20231110193609728"></p></li><li><p>反转排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -r</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193716806.png" alt="image-20231110193716806"></p></li><li><p>按照特定字段排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k 3</span><br></pre></td></tr></table></figure><p><code>-t</code>参数用于指定字段的分隔符，这里是以&quot;:&quot;作为分隔符；<code>-k 字段号</code>用于指定对哪一个字段进行排序。这里<code>/etc/passwd</code>文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上<code>-n</code>参数，此处按照分割后的第三个字段（第二个<code>:</code>后的字段）排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k 3 -n</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193958323.png" alt="image-20231110193958323"></p></li></ul><h3 id="uniq命令">uniq命令</h3><ul><li><p><code>uniq</code>命令用于过滤或者输出重复行。比如使用<code>history</code>查看最近执行过的命令，但只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194319562.png" alt="image-20231110194319562"></p><p>虽然<code>uniq</code>去除了大部分重复行，但可以看出这里仍然存在两条<code>ls</code>的记录，这是因为<code>uniq</code>命令只能去除连续的重复行，而非全文去重，如果需要达到全文去重的效果，那么需要对字段先进行排序操作：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> -u</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194620796.png" alt="image-20231110194620796"></p></li><li><p>如果希望查看重复的行，再分别统计重复次数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -dc</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194746551.png" alt="image-20231110194746551"></p><p>仅查看重复的行，而不统计重复次数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -D</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194831567.png" alt="image-20231110194831567"></p></li></ul>]]></content>
    
    
    <summary type="html">Linux中命令同时执行的方法与管道的相关使用方式。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="https://www.iuoyt.com/posts/f9c29644.html"/>
    <id>https://www.iuoyt.com/posts/f9c29644.html</id>
    <published>2023-11-06T11:37:40.000Z</published>
    <updated>2023-11-11T11:19:47.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><ul><li><p>软件的<strong>可维护性</strong><span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">可维护性</span><span class="reference-title">参考资料</span></span></span>和<strong>可复用性</strong><span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">可复用性</span><span class="reference-title">参考资料</span></span></span>是两个非常重要的用于衡量软件质量的属性。</p><table><thead><tr><th>原则名称</th><th>英文名称</th><th>定义</th><th style="text-align:center">使用频率</th></tr></thead><tbody><tr><td>单一职责原则</td><td>Single Responsibility Principle， SRP</td><td>一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中</td><td style="text-align:center">★★★★☆</td></tr><tr><td>开闭原则</td><td>Open-Closed Principle， OCP</td><td>软件实体应当对扩展开放，对修改关闭</td><td style="text-align:center">★★★★★</td></tr><tr><td>里氏代换原则</td><td>Liskov Substitution Principle， LSP</td><td>所有引用基类的地方必须能透明地使用其子类的对象</td><td style="text-align:center">★★★★★</td></tr><tr><td>依赖倒转原则</td><td>Dependence Inversion Principle， DIP</td><td>高层模块不应该以来低层模块，它们都应该依赖抽象；抽象不应该依赖于细节，细节应该依赖于抽象</td><td style="text-align:center">★★★★★</td></tr><tr><td>接口隔离原则</td><td>Interface Segregation Principle， ISP</td><td>客户端不应该依赖那些它不需要的接口</td><td style="text-align:center">★★☆☆☆</td></tr><tr><td>合成复用原则</td><td>Composite Reuse Principle， CRP</td><td>有线使用对象组合，而不是通过继承来打到复用的目的</td><td style="text-align:center">★★★★☆</td></tr><tr><td>迪米特法则</td><td>Law of Demeter， LoD</td><td>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</td><td style="text-align:center">★★★☆☆</td></tr></tbody></table></li></ul><h2 id="单一职责原则">单一职责原则</h2><ul><li><p>定义：<strong>一个对象应该只包含单一的职责</strong>，并且该职责被完整地封装在一个类中。</p></li><li><p>另一种定义方式：就一个类而言，应该仅有一个引起它变化的原因。</p></li><li><p>在软件系统中，一个类承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，相当于将这些职责耦合在一起，当其中一个职责变化时可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将他们封装在同一类中。</p><blockquote><p>在<code>CustomerDataChart</code>类的方法中，<code>getConnection()</code>方法用于连接数据库，<code>findCustomers()</code>用于查询所有的客户信息，<code>createChart()</code>用于创建图表，<code>displayChart()</code>用于显示图表。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231107110617712.png" alt="image-20231107110617712"></p><p><code>CustomerDataChart</code>类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用<code>findCustomers()</code>方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它拥有不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，<code>CustomerDataChart</code>类可拆分为以下3个类。</p><ol><li><code>DBUtil</code>：负责连接数据库，包含数据库连接方法<code>getConnection()</code></li><li><code>CustomerDAO</code>：负责操作数据库中的Customer表，包含对Customer表的增、删、改、查等方法，例如<code>findCustomers()</code></li><li><code>CustomerDataChart</code>：负责图表的生成和显示，包含<code>createChart()</code>和<code>displayChart()</code>方法</li></ol><p>重构后的结构图：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231107110956731.png" alt="image-20231107110956731"></p></blockquote></li></ul><h2 id="开闭原则">开闭原则</h2><ul><li>开闭原则是面向对象的客服用设计的第一块基石，定义：<strong>软件实体应当对扩展开放，对修改关闭</strong>，即软件实体应<strong>尽量在不修改原有代码的情况下进行扩展</strong>。</li><li>任何软件都需要面临一个很重要的问题，即需求会随着时间的推移而发生变化。当软件系统需要面对新的需求时应尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，寿命越来越长，维护成本也越来越高，设计满足开闭原则的软件也变得越来越重要。为了满足开闭原则，需要对系统进行<strong>抽象化设计</strong>，抽象化是开闭原则的关键，定义系统的抽象层，再通过具体的类进行扩展。</li></ul><h2 id="里氏替换原则">里氏替换原则</h2><blockquote><p>如果对每一个类型为S的对象o1都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时程序P的行为没有变化，那么类型S是类型T的子类型。</p></blockquote><ul><li>通俗来说，里氏替换原则即<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>，表明<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常</strong>，反之则不成立。比如：如果我喜欢所有动物，那么我一定喜欢狗，因为狗是动物的子类；但如果我喜欢狗，并不能断定我喜欢所有的动物。</li><li>里氏替换原则是实现开闭原则的重要方法之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时在确定其子类的类型，用子类对象来替换父类对象。</li><li>在运用历史替换原则时应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现在父类中声明的方法，在运行时子类实例替换父类实例，可以很方便地扩展系统的功能，无需修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</li></ul><h2 id="依赖倒转原则">依赖倒转原则</h2><ul><li><p>依赖倒转原则是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p></li><li><p>依赖倒转原则的定义：<strong>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。<strong>简单地说，依赖倒转原则要求</strong>针对接口编程，不要针对实现编程</strong>。</p></li><li><p>依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而非使用具体类来做这些事情。一个具体类应当只实现接口或者抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p></li><li><p>引入抽象层后，系统具有很好的灵活性，在程序中<strong>尽量使用抽象层进行编程</strong>，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无需修改原有系统的源代码。</p></li><li><p>实现依赖倒转原则需要针对抽象层编程，而将具体类通过依赖注入的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时采用抽象的形式来注入所依赖的对象。</p><blockquote><p>常见的注入方式有3种：</p><ol><li>构造注入：通过构造函数来传入具体类的对象</li><li>设值注入（Setter注入）：通过Setter方法来传入具体类的对象</li><li>接口注入：通过在接口中声明的业务方法来传入具体类的对象</li></ol></blockquote></li></ul><h2 id="接口隔离原则">接口隔离原则</h2><ul><li>接口隔离原则定义：<strong>客户端不应该依赖那些它不需要的接口</strong>。当一个接口太大时需要将它分割成一些更细小的接口，使用该接口的客户端进需要知道与之相关的方法即可。</li><li>“接口”有两种含义：<ul><li>如果理解为一个类型所提供的所有方法特征的集合的时候，可以将接口理解成角色，一个接口只能代表一个角色，每个角色都有它特地的一个接口，此时这个原则可以叫“角色隔离原则”。</li><li>如果把接口理解成狭义的特定语言的接口，那么接口隔离原则表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li></ul></li></ul><h2 id="合成复用原则">合成复用原则</h2><ul><li>合成复用原则又称组合/聚合复用原则，定义：<strong>优先使用对象组合，而不是通过继承来达到复用的目的</strong>，即在一个新的对象里通过关联关系（包裹组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派<strong>调用已有对象</strong>的方法打到复用功能的目的。</li><li>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的某些内部细节对于子类来说是可见的，因此这种复用又称为“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变。</li><li>组合或聚合关系可以将已有的对象（亦可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使成员对象的内部实现对于新对象不可见，所以这种复用又称为“黑箱”复用。</li></ul><h2 id="迪米特法则">迪米特法则</h2><ul><li><p>迪米特法则定义：<strong>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。其要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统符合迪米特法则，那么当其中的某一个模块发生修改时就会尽量少地影响其他模块，扩展会相对容易。</p></li><li><p>应用迪米特法则可以降低系统的耦合度，使类与类之间保持松散的耦合关系。</p></li><li><p>迪米特法则还有几种定义形式，例如：不要和“陌生人”说话，只与你的直接朋友通信，“朋友”包括如下几类：</p><ol><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ol><p>这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p></li><li><p>迪米特法则还要求在设计系统时应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。</p></li></ul><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="javascript:void">维护性是指软件能够被理解、改正、适应及扩展的难易程度</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="javascript:void">可复用性是指软件能够被重复使用的难易程度</a></div>]]></content>
    
    
    <summary type="html">如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="面向对象设计原则" scheme="https://www.iuoyt.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概述</title>
    <link href="https://www.iuoyt.com/posts/bb7571ed.html"/>
    <id>https://www.iuoyt.com/posts/bb7571ed.html</id>
    <published>2023-11-06T10:45:37.000Z</published>
    <updated>2023-11-25T03:23:21.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是设计模式">什么是设计模式</h2><ul><li><p>设计模式是一种用于对软件系统中不断重现的设计问题的解决方案进行文档化的技术，目的是提高代码的可维护性、可扩展性、重用性和可靠性，以及让他人更容易理解代码。</p></li><li><p>GoF对设计模式的定义如下：</p><blockquote><p>设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。</p></blockquote></li></ul><h2 id="设计模式的基本要素">设计模式的基本要素</h2><ol><li><p>模式名称</p><p>每种设计模式都有一个名称来描述模式的问题、解决方案和效果，以便开发人员更好地理解模式并方便沟通交流。</p></li><li><p>问题</p><p>问题描述了应该在何时使用模式，包含了设计中存在的问题以及问题存在的原因。</p></li><li><p>解决方案</p><p>解决方案描述了设计模式的组成成分，以及这些组成成分之间的相互关系、各自的职责和协作方式。</p></li><li><p>效果</p><p>效果描述了模式应用的效果以及在使用模式时应权衡的问题。</p></li></ol><h2 id="设计模式的分类">设计模式的分类</h2><ul><li>通常情况下都是按照目的来划分各种设计模式，可以分为创建型（Creational）、结构性（Structural）和行为型（Behavioral）3类。</li><li>以下23种设计模式并非都是孤立存在的，很多模式之间存在联系，例如访问者模式操作对象结构中的元素时通常需要使用迭代器模式，在解释器模式中定义终结符表达式和非终结符表达式时可以使用组合模式。因此，如果合理搭配不同的设计模式，可以充分发挥每种设计模式的优势，完成一些更复杂的设计工作。</li></ul><h3 id="创建型模式">创建型模式</h3><ul><li>创建型模式主要用于<strong>创建对象</strong>，包括如下5种模式：</li></ul><table><thead><tr><th>模式名称</th><th style="text-align:left">英文名称</th><th>模式说明</th><th style="text-align:center">使用频率</th></tr></thead><tbody><tr><td>抽象工厂模式</td><td style="text-align:left">Abstract Factory</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</td><td style="text-align:center">★★★★★</td></tr><tr><td>建造者模式</td><td style="text-align:left">Builder</td><td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td><td style="text-align:center">★★☆☆☆</td></tr><tr><td>工厂方法模式</td><td style="text-align:left">Factory Method</td><td>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</td><td style="text-align:center">★★★★★</td></tr><tr><td>原型模式</td><td style="text-align:left">Prototype</td><td>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象</td><td style="text-align:center">★★★☆☆</td></tr><tr><td>单例模式</td><td style="text-align:left">Singleton</td><td>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例</td><td style="text-align:center">★★★★☆</td></tr></tbody></table><h3 id="结构型模式">结构型模式</h3><ul><li>结构型模式主要用于<strong>处理类或对象的组合</strong>，包括如下7种模式：</li></ul><table><thead><tr><th>模式名称</th><th>英文名称</th><th>模式说明</th><th>使用频率</th></tr></thead><tbody><tr><td>适配器模式</td><td>Adapter</td><td>将一个类的接口转换成客户希望的另一个接口，让不兼容的类可以一起工作</td><td>★★★★☆</td></tr><tr><td>桥接模式</td><td>Bridge</td><td>将抽象部分与它的实现部分解耦，使得两者都能够独立变化</td><td>★★★☆☆</td></tr><tr><td>组合模式</td><td>Composite</td><td>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构，让客户端可以统一对待单个对象和组合对象</td><td>★★★★☆</td></tr><tr><td>装饰模式</td><td>Decorator</td><td>动态地给一个对象增加一些额外的职责，就扩展功能而言，装饰模式提供可一种比使用子类更加灵活的替代方案</td><td>★★★☆☆</td></tr><tr><td>外观模式</td><td>Facade</td><td>为子系统中的一组接口提供一个统一的入口，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td><td>★★★★★</td></tr><tr><td>享元模式</td><td>Flyweight</td><td>运用共享技术有效地支持大量细粒度对象的复用</td><td>★☆☆☆☆</td></tr><tr><td>代理模式</td><td>Proxy</td><td>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问</td><td>★★★★☆</td></tr></tbody></table><h3 id="行为型模式">行为型模式</h3><ul><li>行为型模式主要用于<strong>描述类或对象怎样交互和怎样分配职责</strong>，包括如下11种模式：</li></ul><table><thead><tr><th>模式名称</th><th>英文名称</th><th>模式说明</th><th>使用频率</th></tr></thead><tbody><tr><td>职责链模式</td><td>Chain of Responsibility</td><td>避免将一个请求的发送者与接受者耦合在一起，让多个对象都有机会处理请求，或接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止</td><td>★★☆☆☆</td></tr><tr><td>命令模式</td><td>Command</td><td>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作</td><td>★★★★☆</td></tr><tr><td>解释器模式</td><td>Interpreter</td><td>给定一个语言，定义它的文法的一种表示，并给定一个解释器，这个解释器使用该表示方法来解释语句中的句子</td><td>★☆☆☆☆</td></tr><tr><td>迭代器模式</td><td>Iterator</td><td>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示</td><td>★★★★★</td></tr><tr><td>中介者模式</td><td>Mediator</td><td>定义一个对象来封装一系列对象的交互，中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</td><td>★★☆☆☆</td></tr><tr><td>备忘录模式</td><td>Memento</td><td>在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</td><td>★★☆☆☆</td></tr><tr><td>观察者模式</td><td>Observer</td><td>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新</td><td>★★★★★</td></tr><tr><td>状态模式</td><td>State</td><td>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎是修改了它的类</td><td>★★★☆☆</td></tr><tr><td>策略模式</td><td>Strategy</td><td>定义一系列算法，将每一个算法封装起来，让他们可以相互替换，使得算法可以独立于使用它的客户而变化</td><td>★★★★☆</td></tr><tr><td>模板方法模式</td><td>Template Method</td><td>定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td><td>★★★☆☆</td></tr><tr><td>访问者模式</td><td>Visitor</td><td>表示一个作用于某对象结构中的各个元素的操作，可以在不改变各个元素的类的前提下定义作用于这些元素的新操作</td><td>★☆☆☆☆</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">设计模式是一种用于对软件系统中不断重现的设计问题的解决方案进行文档化的技术，目的是提高代码的可维护性、可扩展性、重用性和可靠性。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux任务计划crontab</title>
    <link href="https://www.iuoyt.com/posts/b38a663c.html"/>
    <id>https://www.iuoyt.com/posts/b38a663c.html</id>
    <published>2023-11-03T10:18:50.000Z</published>
    <updated>2023-11-25T03:23:38.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="crontab简介">crontab简介</h2><ul><li><p><code>crontab</code>命令用于设置周期性被执行的命令，并将其存放于 crontab 文件中，以供之后读取和执行。</p></li><li><p><code>crontab</code>储存的指令被守护进程激活，<code>crond</code>为其守护进程，<code>crond</code>常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p></li><li><blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="crontab准备">crontab准备</h2><ul><li><p>使用<code>rsyslog</code>可以通过日志中的信息来得知任务是否被执行了：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install -y rsyslog</span><br><span class="line">sudo<span class="built_in"> service </span>rsyslog start</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103174614045.png" alt="image-20231103174614045"></p></li></ul><h2 id="crontab使用">crontab使用</h2><h3 id="新增任务">新增任务</h3><ul><li><p>首先来添加一个计划任务：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -e</span></span><br></pre></td></tr></table></figure><p>如果是第一次启动则会出现如下内容，选择编辑工具，通常使用2号vim工具：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103174813614.png" alt="image-20231103174813614"></p></li><li><p>接下来会进入下面的界面，这个界面就是添加计划的地方：<br><img src="https://oss.iuoyt.com/img/posts/image-20231103175001232.png" alt="image-20231103175001232"></p></li><li><p>接下来按下<kbd>i</kbd>进入编辑模式，在最后一行添加如下内容，作用是每分钟在用户目录下创建一个以当前的年月日时分秒为名字的空白文件：</p>  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">1</span> * * * * touch /home/shiyanlou/$(<span class="keyword">date</span> +\%Y\%m\%d\%H\%M\%S)</span><br></pre></td></tr></table></figure></li><li><p>然后按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出，输入如下指令查看文件内容：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -l</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180017702.png" alt="image-20231103180017702"></p></li><li><p>虽然已经添加了任务，但如果cron的进程并没有启动，那么任务也不会被执行，可以通过如下两种方式确定cron是否已启动：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 第一种</span></span><br><span class="line">ps aux <span class="string">| grep cron</span></span><br><span class="line"><span class="meta"># 第二种</span></span><br><span class="line">pgrep cron</span><br></pre></td></tr></table></figure></li><li><p>如果已经启动，在用户目录下使用<code>ll</code>命令，可以看到：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180524732.png" alt="image-20231103180524732"></p></li><li><p>通过如下命令可以查看到执行任务命令之后在日志中的信息反馈：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tail -f /<span class="keyword">var</span>/<span class="built_in">log</span>/syslog</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180704821.png" alt="image-20231103180704821"></p></li></ul><h3 id="删除任务">删除任务</h3><ul><li><p>当不需要再自动执行任务，可以使用如下命令：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -r</span></span><br></pre></td></tr></table></figure></li><li><p>执行后再查看任务列表，可以看到已经没有正在执行的任务：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180918834.png" alt="image-20231103180918834"></p></li></ul><h3 id="系统级任务">系统级任务</h3><ul><li><p>如果需要定义系统级别定时任务，可以使用sudo权限编辑crontab文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>crontab</span><br></pre></td></tr></table></figure></li><li><p>cron服务的最小检测时间为分钟，所以cron每分钟会去文件中读取一次内容</p></li></ul><h3 id="cron的相关文件">cron的相关文件</h3><ul><li><p>在<code>/etc</code>目录下查看cron相关的文件：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ll</span> /etc | <span class="keyword">grep</span> cron</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103181401458.png" alt="image-20231103181401458"></p></li><li><p>其中部分作用如下：</p></li></ul><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>/etc/cron.daily</code></td><td style="text-align:center">在每天的6点25分时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.hourly</code></td><td style="text-align:center">在每小时的17分钟时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.monthly</code></td><td style="text-align:center">在每月1号的6点52分时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.weekly</code></td><td style="text-align:center">在每周第七天的6点47分时执行一次</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文介绍了如何在Linux中使用crontab进行计划任务</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的帮助命令</title>
    <link href="https://www.iuoyt.com/posts/8039f3ce.html"/>
    <id>https://www.iuoyt.com/posts/8039f3ce.html</id>
    <published>2023-10-27T11:49:12.000Z</published>
    <updated>2023-11-25T03:23:57.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内建命令与外部命令">内建命令与外部命令</h2><h3 id="内建命令">内建命令</h3><ul><li>内建命令是shell的一部分，包含一些比较简单的系统命令，通常在Linux系统加载运行时就会被驻留在内存系统中，因此执行速度比外部命令快。</li></ul><h3 id="外部命令">外部命令</h3><ul><li>外部命令是Linux系统中的实用程序部分，因为功能较为强大，其包含的程序量也会很大，所以不能随着系统启动被加载到内存中。</li></ul><h3 id="查看命令的类型">查看命令的类型</h3><ul><li><p>使用<code>type</code>命令可以查看其为内建或是外部命令：</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;命令&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231027193923068.png" alt="image-20231027193923068"></p></li><li><p>通常会得到如下结果：</p></li></ul><table><thead><tr><th style="text-align:center">结果</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center"><code>xxx is a shell builtin</code></td><td style="text-align:center">内建命令</td></tr><tr><td style="text-align:center"><code>xxx is /usr/bin/xxx</code></td><td style="text-align:center">外部命令</td></tr><tr><td style="text-align:center"><code>xxx is an alias for xx --xxx</code></td><td style="text-align:center">命令别名</td></tr></tbody></table><h2 id="帮助命令的使用">帮助命令的使用</h2><h3 id="help命令">help命令</h3><ul><li><p>help命令是用于显示shell内建命令的简要帮助信息，因此无法得到外部命令或者命令别名的相关帮助，比如输入<code>help ls</code>命令则会得到“无匹配帮助主题”的提示。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231027194155526.png" alt="image-20231027194155526"></p></li><li><p>而对于外部命令，通常带有一个获取帮助的参数<code>--help</code>，输入以获取该命令的帮助文档：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="man命令">man命令</h3><ul><li><p><code>man</code>命令得到的内容比<code>help</code>更多更详细，而且<code>man</code>没有内建命令与外部命令的区分。<code>man</code>命令是显示系统手册页中的内容，通常为对命令的解释信息和相关描述。</p></li><li><p>使用<code>man</code>命令得到的内容第一行会显示出该命令在文档中所处的章节位置，如使用<code>man ls</code>，则会显示<code>LS(1)</code>，其中<code>LS</code>为手册名称，<code>(1)</code>表示位于该手册的第几章节。在<code>man</code>手册中一共有如下章节：</p></li></ul><table><thead><tr><th style="text-align:center">章节数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center">Standard commands （标准命令）</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center">System calls （系统调用）</td></tr><tr><td style="text-align:center"><code>3</code></td><td style="text-align:center">Library functions （库函数）</td></tr><tr><td style="text-align:center"><code>4</code></td><td style="text-align:center">Special devices （设备说明）</td></tr><tr><td style="text-align:center"><code>5</code></td><td style="text-align:center">File formats （文件格式）</td></tr><tr><td style="text-align:center"><code>6</code></td><td style="text-align:center">Games and toys （游戏和娱乐）</td></tr><tr><td style="text-align:center"><code>7</code></td><td style="text-align:center">Miscellaneous （杂项）</td></tr><tr><td style="text-align:center"><code>8</code></td><td style="text-align:center">Administrative Commands （管理员命令）</td></tr><tr><td style="text-align:center"><code>9</code></td><td style="text-align:center">其他（Linux特定的）， 用来存放内核例行程序的文档</td></tr></tbody></table><h3 id="info命令">info命令</h3><ul><li><p>如果环境中没有<code>info</code>命令，那么可以自行手动安装：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 info</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install <span class="built_in">info</span></span><br><span class="line"><span class="comment"># 查看 ls 命令的 info</span></span><br><span class="line"><span class="built_in">info</span> ls</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">本文介绍了如何利用 Linux 系统自带的帮助工具与文档查看命令的用法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件打包与解压缩</title>
    <link href="https://www.iuoyt.com/posts/c67b19b2.html"/>
    <id>https://www.iuoyt.com/posts/c67b19b2.html</id>
    <published>2023-10-13T15:19:13.000Z</published>
    <updated>2023-10-13T15:23:37.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="压缩打包程序">压缩打包程序</h2><h3 id="使用zip打包文件夹">使用zip打包文件夹</h3><ul><li><p>使用<code>zip</code>命令可以将文件夹打包，比如使用下面的命令将目录<code>/home/shiyanlou/Desktop</code>打包成一个文件，并查看打包后文件的大小和类型，其中<code>-r</code>参数表示递归打包包含子目录的全部内容，<code>-q</code>参数表示为安静模式，即不输出信息到屏幕，<code>-o</code>表示输出文件，在后面紧跟上输出的文件名称：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line"><span class="keyword">zip</span> -r -q -o shiyanlou.<span class="keyword">zip</span> /home/shiyanlou/Desktop</span><br><span class="line">du -<span class="keyword">h</span> shiyanlou.<span class="keyword">zip</span></span><br><span class="line"><span class="keyword">file</span> shiyanlou.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221318522.png" alt="image-20231013221318522"></p></li><li><p>为打包设置压缩级别（9：最高压缩度，速度最慢；1：最快速度，压缩率低），进行重新打包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r -<span class="number">9</span> -q -o shiyanlou_9.zip <span class="regexp">/home/</span>shiyanlou<span class="regexp">/Desktop -x ~/</span>*.zip</span><br><span class="line">zip -r -<span class="number">1</span> -q -o shiyanlou_1.zip <span class="regexp">/home/</span>shiyanlou<span class="regexp">/Desktop -x ~/</span>*.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221533479.png" alt="image-20231013221533479"></p></li><li><p>使用<code>du</code>命令再次查看压缩得到的文件，其中<code>-h</code>为以人可读的形式展现，<code>-d</code>表示查看文件的深度：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">du</span> -h -d <span class="number">0</span> <span class="regexp">*.zip</span> <span class="regexp">~ |</span> sort</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221602101.png" alt="image-20231013221602101"></p></li><li><p>注意：压缩文件使用的路径只能使用绝对路径，否则不起作用。理论上默认压缩级别是最高的，但在文件较小时难以看出差别。</p></li><li><p>由于WIndows和Linux/Unix在文本处理格式上存在差异，比如换行符，WIndows上为<code>CR+LF</code>，但Linux/Unix上为<code>LF</code>，所以一些在Linux/Unix上的换行在Windows系统上看起来像是没有换行，为了解决此类问题，还需要在命令中做出一些修改，加上<code>-l</code>参数将<code>LF</code>转换为<code>CR+LF</code>达到上述目的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -l -o shiyanlou.zip <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221943861.png" alt="image-20231013221943861"></p></li></ul><h3 id="创建加密zip包">创建加密zip包</h3><ul><li><p>在打包文件时添加上<code>-e</code>参数可以创建加密压缩包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -e -o shiyanlou_encryption.zip <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222055429.png" alt="image-20231013222055429"></p></li></ul><h2 id="解压缩打包程序">解压缩打包程序</h2><h3 id="解压缩文件">解压缩文件</h3><ul><li><p>将之前打包的<code>shiyanlou.zip</code>解压到当前目录下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unzip</span> shiyanlou.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222137966.png" alt="image-20231013222137966"></p></li><li><p>与之前相同，使用<code>-q</code>参数使用安静模式解压文件，而使用<code>-d</code>参数指定解压目录：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -<span class="selector-tag">q</span> shiyanlou<span class="selector-class">.zip</span> -d ziptest</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222224693.png" alt="image-20231013222224693"></p></li><li><p>如果上面指定的目录不存在，则会直接创建。</p></li><li><p>如果只想查看压缩包的内容，而不进行解压操作，可以使用<code>-l</code>参数：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unzip</span> -l shiyanlou.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222521006.png" alt="image-20231013222521006"></p></li></ul><h3 id="解决解压乱码问题">解决解压乱码问题</h3><ul><li><p>通常在Windows系统上创建的压缩文件，如果包名中含有中文的目录或者以中文作为文件名命名的文件，通常会采用GBK编码，而Linux则是默认使用哪个UTF-8编码，如果不加以处理直接解压，则会出现乱码问题，可以在解压缩时使用<code>-O</code>参数指定文件编码：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK 压缩文件<span class="string">.zip</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="tar打包工具">tar打包工具</h2><h3 id="打包">打包</h3><ul><li><p>比起<code>zip</code>，在Lin上更常使用的是<code>tar</code>工具，<code>tar</code>可以将7z、gzip、xz、bzip2等格式进行打包或者解包，仅仅是参数不同，比起<code>zip</code>使用较为方便。</p></li><li><p>创建一个tar包，使用<code>-P</code>参数保留绝对路径符，<code>-c</code>表示创建一个tar包文件，<code>-f</code>用于指定创建的文件名，其后紧跟文件名称，如果加上<code>-v</code>参数，那么会以可视的形式输出打包的文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">tar -P -cf shiyanlou.tar <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222601275.png" alt="image-20231013222601275"></p><blockquote><p>在使用多个参数时，可以使用连续书写方式：如同时使用<code>-c</code>与<code>-f</code>参数 ，则可以写成<code>-cf</code></p></blockquote></li></ul><h3 id="解包">解包</h3><ul><li><p>同样是使用<code>tar</code>命令，加上<code>-x</code>参数则是对文件进行解包，<code>-C</code>参数指定解压到的目标文件夹：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir tardir</span><br><span class="line">tar -xf shiyanlou.tar -C tardir</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222938219.png" alt="image-20231013222938219"></p></li><li><p>只查看而不解压文件使用<code>-t</code>参数：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -tf shiyanlou.tar</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223001893.png" alt="image-20231013223001893"></p></li><li><p>如果需要在解压时保留文件的属性和跟随链接（符号链接或软连接）可以使用<code>-p</code>参数和<code>-h</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cphf etc.tar /etc</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建其他形式的打包程序">创建其他形式的打包程序</h3><table><thead><tr><th style="text-align:center">压缩文件格式</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:center"><code>*.tar.gz</code></td><td style="text-align:center"><code>-z</code></td></tr><tr><td style="text-align:center"><code>*.tar.xz</code></td><td style="text-align:center"><code>-J</code></td></tr><tr><td style="text-align:center"><code>*tar.bz2</code></td><td style="text-align:center"><code>-j</code></td></tr></tbody></table><ul><li><p>比如创建<code>.tar.gz</code>文件，加上<code>-z</code>参数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf shiyanlou.tar.gz <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223140457.png" alt="image-20231013223140457"></p></li><li><p>解压<code>.tar.gz</code>文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><blockquote><p>创建一个名为 test 的文件，分别用 zip 和 tar 打包成压缩包，再解压到 /home/shiyanlou 目录。</p></blockquote><ul><li><p>创建一个名为 test 的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">touch</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223345818.png" alt="image-20231013223345818"></p></li><li><p>分别用 zip 和 tar 打包成压缩包：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br><span class="line">tar -P -<span class="keyword">cf</span> <span class="keyword">test</span>.tar <span class="keyword">test</span></span><br><span class="line"><span class="keyword">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013230521245.png" alt="image-20231013230521245"></p></li><li><p>再解压到 /home/shiyanlou 目录:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">unzip <span class="keyword">test</span>.<span class="keyword">zip</span></span><br><span class="line">tar -xf <span class="keyword">test</span>.tar</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013230641542.png" alt="image-20231013230641542"></p></li></ul>]]></content>
    
    
    <summary type="html">这篇文章介绍了Linux上常用的压缩/解压工具（zip，tar）的使用。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境变量与文件查找</title>
    <link href="https://www.iuoyt.com/posts/287535e7.html"/>
    <id>https://www.iuoyt.com/posts/287535e7.html</id>
    <published>2023-10-08T15:49:56.000Z</published>
    <updated>2023-11-25T03:24:27.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境变量">环境变量</h2><h3 id="环境变量-2">环境变量</h3><h4 id="变量">变量</h4><ul><li><p>在Shell中创建一个变量可以使用<code>declare</code>命令，但并非任何形式的变量名都是可用的，变量名只能是由英文字母、数字或者下划线组成，且不能由数字开头。比如创建一个tmp变量：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> tmp</span><br></pre></td></tr></table></figure></li><li><p>使用<code>=</code>运算符为变量赋值：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tmp</span><span class="operator">=</span>shiyanlou</span><br></pre></td></tr></table></figure></li><li><p>使用<code>echo</code>和<code>$</code>符号可以查看变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008230724020.png" alt="image-20231008230724020"></p></li></ul><h4 id="环境变量-3">环境变量</h4><ul><li><p>环境变量的作用域比自定义变量要大，比如Shell的环境变量作用于自身和它的子进程</p></li><li><p>有三个和环境变量相关的命令，<code>set</code>、<code>env</code>和<code>export</code>。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。</p></li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>set</code></td><td style="text-align:center">显示当前Shell所有变量，包括内建环境变量、用户自定义变量及导出的环境变量</td></tr><tr><td style="text-align:center"><code>env</code></td><td style="text-align:center">显示与当前用户相关的环境变量，还可以让命令在指定环境中运行</td></tr><tr><td style="text-align:center"><code>export</code></td><td style="text-align:center">显示从Shell中导出成环境变量的变量，能通过它将自定义变量导出为环境变量</td></tr></tbody></table><p><img src="https://doc.shiyanlou.com/linux_base/5-3.png" alt="img"></p><ul><li><p>用<code>export</code>来体验一下环境变量与普通变量的，先在Shell中设置一个变量<code>temp=shiyanlou</code>，然后创建一个子Shell查看temp变量的值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp=shiyanlou</span><br><span class="line">echo <span class="variable">$temp</span></span><br><span class="line">zsh</span><br><span class="line">echo <span class="variable">$temp</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">export temp</span><br><span class="line">zsh</span><br><span class="line">echo <span class="variable">$temp</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008230934536.png" alt="image-20231008230934536"></p></li><li><p>通常为了与普通变量区分，习惯将环境变量名都设为大写</p></li></ul><h4 id="永久生效">永久生效</h4><ul><li><p>在关机之后，或者关闭shell，环境变量就会消失，可以将变量写入存放变量的文件中：<code>/etc/bashrc</code>和<code>/etc/profile</code>，分别存放的是shell变量和环境变量，或者用户目录下的隐藏文件<code>.profile</code>，仅对当前用户生效，可以使用<code>ls -a</code>查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231056722.png" alt=".profile文件"></p></li></ul><h3 id="命令的查找路径与顺序">命令的查找路径与顺序</h3><ul><li><p>在Shell中命令的执行是通过环境变量<code>PATH</code>搜索的，查看<code>PATH</code>环境变量的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231225585.png" alt="image-20231008231225585"></p></li><li><p>系统会从PATH中以此查找，如果存在相同的命令，则执行先找到的那个</p></li><li><p>接下来创建一个最简单的可执行Shell脚本和使用C语言创建的程序：</p><ul><li><p>在家目录创建一个<code>mybin</code>目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> mybin</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231345401.png" alt="image-20231008231345401"></p></li><li><p>进入新创建的目录，创建一个Shell脚本文件并编辑：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> mybin</span><br><span class="line">touch hello_shell.<span class="keyword">sh</span></span><br><span class="line">gedit hello_shell.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><blockquote><p>如果遇到gedit提示：[Unable to init server: 无法连接： 拒绝连接]，可以使用如下命令解决：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">DISPLAY</span>=localhost:1</span><br><span class="line">xhost local:gedit</span><br></pre></td></tr></table></figure><p>若出现以下内容，表示问题解决：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">non-network <span class="keyword">local</span> connections being added <span class="keyword">to</span> <span class="keyword">access</span> control list</span><br></pre></td></tr></table></figure><p>若还无法解决，可以使用vim编辑器</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> hello_shell.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在脚本中写入如下内容（第一行不可省略）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++));<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello shell&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></li><li><p>为文件添加可执行权限：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">chmod</span> <span class="number">755</span> hello_shell.sh</span><br></pre></td></tr></table></figure></li><li><p>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello_shell.sh</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233557594.png" alt="image-20231008233557594"></p></li><li><p>创建一个C语言程序并编辑：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch hello_world.<span class="keyword">c</span></span><br><span class="line">gedit hello_world.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></li><li><p>写入如下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后使用<code>gcc</code>生成可执行文件：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello_world hello_world.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></li><li><p>运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello_world</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233742246.png" alt="image-20231008233742246"></p></li></ul></li><li><p>在返回到家目录后，如果再想运行刚才创建的两个程序，会提示命令找不到，除非加上命令的完整路径。如果希望可以像执行系统命令一样执行运行刚才创建的程序，可以将脚本文件添加到PATH环境变量中。</p></li></ul><h3 id="添加自定义路径到PATH环境变量">添加自定义路径到PATH环境变量</h3><ul><li><p>PATH路径是以<code>:</code>作为分隔符的，如果希望将上面的<code>mybin</code>目录加入PATH路径，则需要写入以下信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:/home/shiyanlou/mybin</span></span><br></pre></td></tr></table></figure></li><li><p><strong>需要注意的是，这里一定要使用绝对路径</strong></p></li><li><p>那么现在就可以直接执行写下的两个命令了：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello<span class="emphasis">_shell.sh</span></span><br><span class="line"><span class="emphasis">hello_</span>world</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233916073.png" alt="image-20231008233916073"></p></li><li><p>但给PATH追加一条路径只会在当前Shell有效，一旦退出终端，再打开就会发现又失效了，那么可以利用用户home目录中一个在启动shell时自动运行的脚本。zsh的配置文件为<code>.zshrc</code>，相应Bash的配置文件为<code>.bashrc</code>，使用命令将路径添加到<code>.zshrc</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PATH=<span class="variable">$PATH</span>:/home/shiyanlou/mybin&quot;</span> &gt;&gt; .zshrc</span><br></pre></td></tr></table></figure><blockquote><p>上面命令中的<code>&gt;&gt;</code>表示将标准输出以追加的方式重定向到一个文件中。</p></blockquote></li></ul><h3 id="修改和删除已有变量">修改和删除已有变量</h3><h4 id="变量修改">变量修改</h4><ul><li>变量修改有如下几种方式：</li></ul><table><thead><tr><th style="text-align:center">变量设置方式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">${变量名#匹配字串}</td><td style="text-align:center">从头向后开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td style="text-align:center">${变量名##匹配字串}</td><td style="text-align:center">从头向后开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td style="text-align:center">${变量名%匹配字串}</td><td style="text-align:center">从尾向前开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td style="text-align:center">${变量名%%匹配字串}</td><td style="text-align:center">从尾向前开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td style="text-align:center">${变量名/旧的字串/新的字串}</td><td style="text-align:center">将符合旧字串的第一个字串替换为新的字串</td></tr><tr><td style="text-align:center">${变量名//旧的字串/新的字串}</td><td style="text-align:center">将符合旧字串的全部字串替换为新的字串</td></tr></tbody></table><ul><li><p>比如要修改前面添加到PATH的环境变量，为了避免误操作导致命令找不到，我们先将PATH赋值给一个新定义的自定义变量：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span>=$<span class="built_in">PATH</span></span><br><span class="line"><span class="built_in">echo</span> $<span class="built_in">path</span></span><br><span class="line"><span class="built_in">path</span>=$&#123;<span class="built_in">path</span><span class="variable">%/home/shiyanlou/mybin&#125;</span></span><br><span class="line"><span class="variable">path=$&#123;path%</span>*/mybin&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除变量">删除变量</h4><ul><li><p>可以使用<code>unset</code>命令删除一个环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> temp</span><br></pre></td></tr></table></figure></li></ul><h3 id="让环境变量立刻生效">让环境变量立刻生效</h3><ul><li><p>在Shell中修改了一个配置脚本文件后，必须要退出终端重新启动才可以生效，如果希望立即生效，可以使用<code>source</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure></li><li><p><code>source</code>命令还有一个别名<code>.</code>，或者使用以下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">. ./.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="搜索文件">搜索文件</h2><h3 id="whereis">whereis</h3><ul><li><p><code>whereis</code>搜索很快，因为并没有从硬盘中依次查找，而是从数据库中查询</p></li><li><p><code>whereis</code>只能搜索二进制文件（-b）、man帮助文件（-m）和源代码文件（-s）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis who</span><br><span class="line">whereis <span class="built_in">find</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008234411280.png" alt="image-20231008234411280"></p></li></ul><h3 id="locate">locate</h3><ul><li><p>通过<code>/var/lib/mlocate/mlocate.db</code>数据库查找，但这个文件只会由系统每天自动执行<code>updatedb</code>命令更新一次</p></li><li><p>查找<code>/usr/share/</code>下的所有jpg文件：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install locate</span><br><span class="line">locate /usr/<span class="keyword">share</span>/\*.jpg</span><br></pre></td></tr></table></figure></li><li><p>如果只想统计数目可以加上<code>-c</code>参数，忽略大小写查找使用<code>-i</code>参数</p></li></ul><h3 id="which">which</h3><ul><li><p>which本身是Shell内建的一个命令，通常用来确定是否安装了某个指定的软件，因为其只通过PATH环境变量指定的路径中查找：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">which</span> <span class="keyword">man</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="find">find</h3><ul><li><p>find命令是四种查找中最强大的，格式为<code>find [path] [option] [action]</code></p></li><li><p>表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">find</span> <span class="regexp">/etc/</span> -name interfaces</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><ul><li><p>找出 /etc/ 目录下的所有以 .list 结尾的文件。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">find</span> <span class="regexp">/etc/</span> -name \*.list </span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008234711794.png" alt="image-20231008234711794"></p></li></ul>]]></content>
    
    
    <summary type="html">本文介绍Linux环境变量的作用与用法，及几种搜索文件的方法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用Github Desktop进行简单的团队合作开发</title>
    <link href="https://www.iuoyt.com/posts/79105230.html"/>
    <id>https://www.iuoyt.com/posts/79105230.html</id>
    <published>2023-09-23T03:56:14.000Z</published>
    <updated>2023-10-08T16:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册Git平台账号">注册Git平台账号</h2><ul><li>首先，创建一个云端的项目仓库。借助Github或者Gitee，可以将你的项目托管在云端，以便团队的各成员都能方便地拉取与提交自己的代码。你可以使用Github，也可以是Gitee，来完成你的云端项目部署。</li><li>如何选择？<ul><li>Github作为全球最大的开源平台，已有许多年的历史。作为老牌开元平台，有着许许多多优秀的代码仓库。但因为网络原因，国内会有无法访问的情况。</li><li>Gitee是由一家中国公司建立的，较新的开源平台，由于服务器设立在境内，因此无须担心网络问题。</li></ul></li></ul><div class="tabs" id="注册git平台账号"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#注册git平台账号-1">Github</button></li><li class="tab"><button type="button" data-href="#注册git平台账号-2">Gitee</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="注册git平台账号-1"><ul><li><p>如果你还没有注册过Github账号，那么需要先前往<a href="https://github.com/signup">Github注册页面</a>注册一个账号。</p></li><li><p>填入你的个人邮箱和密码</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134102664.png" alt="image-20230923134102664"></p></li><li><p>按下<kbd>continue</kbd>进入下一步，填写你的用户名，如果提示<code>Username is not available.  </code>，说明这个用户名被占用了，那么你需要更换一个用户名。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134511421.png" alt="image-20230923134511421"></p></li><li><p>再次按下<kbd>continue</kbd>进入下一步</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134643032.png" alt="image-20230923134643032"></p><blockquote><p>您是否希望通过电子邮件接收产品更新和通知？<br>键入 &quot;y &quot;表示是，键入 &quot;n &quot;表示否</p></blockquote></li><li><p>按下<kbd>continue</kbd>，进入人机验证环节，只需要做<strong>几道十分简单</strong>的计算题。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134933266.png" alt="image-20230923134933266"></p></li><li><p>点击<kbd>Create account</kbd>，进入邮箱验证环节，输入你的邮箱收到的来自Github发送的验证码。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="注册git平台账号-2"><ul><li><p>首先进入<a href="https://gitee.com/signup">Gitee注册页面</a>，填写你的注册信息</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145301278.png" alt="image-20230923145301278"></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145447312.png" alt="image-20230923145447312"></p></li><li><p>点击<kbd>立即注册</kbd>完成注册，然后跳转到开始页面。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145611958.png" alt="image-20230923145611958"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="创建项目仓库">创建项目仓库</h2><p>团队协作中，只需要一个成员创建项目仓库即可，其他成员可以在仓库创建完成后加入合作。</p><div class="tabs" id="创建项目仓库"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#创建项目仓库-1">使用Github创建</button></li><li class="tab"><button type="button" data-href="#创建项目仓库-2">使用Gitee创建</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="创建项目仓库-1"><ul><li><p>注册完账户后，会自动跳转到<a href="https://github.com/join/get-started">开始页面</a>，选择<kbd>Create a repository</kbd>创建你的项目仓库</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923142743690.png" alt="image-20230923142743690"></p></li><li><p>填写项目信息，如果为私密仓库，填写项目名称与选择仓库类型即可，然后点击<kbd>Create repository</kbd>创建仓库。如果选择私密仓库，后面的连接到仓库步骤中则必须登录Github Desktop客户端。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923143955037.png" alt="image-20230923143955037"></p></li><li><p>完成创建后，就会自动跳转到你的仓库页面了。此时，你暂时无需操作任何内容，继续完成后续步骤即可，但不要关闭这个页面，之后的步骤还会用到。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923144222170.png" alt="image-20230923144222170"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="创建项目仓库-2"><ul><li><p>点击开始页面中的<kbd>创建我的仓库</kbd>按钮进入仓库创建页面</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145747679.png" alt="image-20230923145747679"></p></li><li><p>填写仓库信息，点击<kbd>创建</kbd>完成仓库创建</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145955632.png" alt="image-20230923145955632"></p></li><li><p>完成创建后，就会自动跳转到你的仓库页面了。此时，你暂时无需操作任何内容，继续完成后续步骤即可，但不要关闭这个页面，之后的步骤还会用到。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923150036301.png" alt="image-20230923150036301"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="下载Github-Desktop客户端">下载Github Desktop客户端</h2><ul><li><p>借助Github Desktop客户端，团队协作的完成可以无需使用任何Git命令，上手极为容易。</p></li><li><p>首先进入<a href="https://desktop.github.com/">Github Desktop官网</a>下载桌面客户端。</p><blockquote><p>阿里云盘下载：<a href="https://www.aliyundrive.com/s/2s84Cawtt8u">WIndows x64</a></p><p>百度网盘下载：<a href="https://pan.baidu.com/s/1xfTIb5Yw15zLBqTNF--Ypg?pwd=1234">Windows x64</a>  <a href="https://pan.baidu.com/s/1yv82gCEILLTwi8qh4RM8eA?pwd=1234">macOs</a></p><p>夸克网盘下载：<a href="https://pan.quark.cn/s/3d87b87a8738">Windows x64</a>  <a href="https://pan.quark.cn/s/b09b6f32dc84">macOs</a></p></blockquote><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923152058408.png" alt="image-20230923152058408"></p></li><li><p>启动安装程序</p></li></ul><div class="tabs" id="githubdesktop"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#githubdesktop-1">有Github账号</button></li><li class="tab"><button type="button" data-href="#githubdesktop-2">无Github账号</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="githubdesktop-1"><ul><li><p>点击<kbd>Sign in to Github.com</kbd>登录你的Github账户</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923153134.jpg" alt="img_20230923153134"></p></li><li><p>在网页中认证桌面端登录</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923153402.jpg" alt="img_20230923153402"></p></li><li><p>使用你的Github信息作为Git的提交信息（Use my GitHub account name and email address），然后点击<kbd>Finish</kbd></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923153442.jpg" alt="img_20230923153442"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="githubdesktop-2"><ul><li><p>点击安装程序，选择下方的跳过登录（Skip this step）</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923160412584.png" alt="image-20230923160412584"></p></li><li><p>填写你的Git提交信息，这里设置的信息会作为你在Git仓库提交的联系方式，之后也可以进行修改</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923155542.png" alt="img_20230923155542"></p></li><li><p>点击<kbd>Finish</kbd>提交</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="连接到仓库">连接到仓库</h2><p>接下来，只需要将本地仓库连接到你的Git平台账户仓库即可，回到之前新建的的仓库页面。</p><div class="tabs" id="连接到仓库"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#连接到仓库-1">Github</button></li><li class="tab"><button type="button" data-href="#连接到仓库-2">Gitee</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="连接到仓库-1"><ul><li><p>复制仓库的git链接</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923162030088.png" alt="image-20230923162030088"></p></li><li><p>回到Github Desktop客户端，选择克隆一个仓库（Clone a repository)</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923162158.jpg" alt="img_20230923162158"></p></li><li><p>在弹出的窗口中填写刚才复制的链接，选择本地仓库保存的位置（空文件夹），点击<kbd>Clone</kbd>完成连接。如果出现连接错误，注意仓库是否为隐私仓库，如果为隐私仓库，则一定要在Github Desktop中登录你的Github账户。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923162524508.png" alt="image-20230923162524508"></p></li><li><p>在资源管理器中进入你的项目文件夹，现在可以将你的项目文件放到仓库文件夹中了。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="连接到仓库-2"><ul><li><p>复制仓库的Git链接</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923164138920.png" alt="image-20230923164138920"></p></li><li><p>回到Github Desktop客户端，选择克隆一个仓库（Clone a repository)</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923162158.jpg" alt="img_20230923162158"></p></li><li><p>在弹出的窗口中填写刚才复制的链接，选择本地仓库保存的位置（空文件夹），点击<kbd>Clone</kbd>完成连接。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923164615076.png" alt="image-20230923164615076"></p></li><li><p>登录到Gitee，点击<kbd>Save and retry</kbd></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923164733738.png" alt="image-20230923164733738"></p></li><li><p>在资源管理器中进入你的项目文件夹，现在可以将你的项目文件放到仓库文件夹中了。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="提交本地项目">提交本地项目</h2><ul><li><p>如果本地仓库与托管库有内容差异，那么Github Desktop中会显示出所有有差异的项，现在只需要将这些修改项提交到托管库</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923165327854.png" alt="image-20230923165327854"></p></li><li><p>现在已经可以在Git库中看到刚才的提交了</p></li></ul><h2 id="邀请协作">邀请协作</h2><p>邀请别的成员进入项目，即可通过Git平台进行协作</p><div class="tabs" id="邀请协作"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#邀请协作-1">Github</button></li><li class="tab"><button type="button" data-href="#邀请协作-2">Gitee</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="邀请协作-1"><ul><li><p>在网页端的项目页中点击<kbd>Setting</kbd> -&gt; <kbd>Collaborate</kbd> -&gt; <kbd>Add people</kbd>，搜索其他成员的用户名、邮箱等信息</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923165745288.png" alt="image-20230923165745288"></p></li><li><p>选择账号，然后点击”Add to this repository&quot;完成添加成员</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="邀请协作-2"><ul><li><p>在网页端的项目页中点击<kbd>管理</kbd> -&gt; <kbd>仓库成员管理</kbd> -&gt; <kbd>全部</kbd> -&gt; <kbd>添加仓库成员</kbd> -&gt; <kbd>邀请用户</kbd></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923170308310.png" alt="image-20230923170308310"></p></li><li><p>点击<kbd>直接添加</kbd>，选择权限并搜索账户的用户名和邮箱，选择用户完成添加</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923170630827.png" alt="image-20230923170630827"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="从Git获取更新">从Git获取更新</h2><ul><li><p>当其他成员提交了代码后，你进行本地开发前，要从Git平台中拉取更新。打开Github Desktop客户端，点击“Fetch origin”拉取更新</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923171022885.png" alt="image-20230923171022885"></p></li><li><p>此时，本地的项目文件就已经被更新到最新了</p></li></ul><h2 id="内容冲突">内容冲突</h2><ul><li><p>当两个成员先后提交项目到托管库时，可能会出现代码冲突的情况，即两个人都改了同一行内容，这时，后提交的人则需要从代码库先拉取代码到本地，对于有冲突的内容，可以在Github Desktop客户端中手动解决冲突。完成本地的代码合并后，可以再次提交，此时可以提交成功。</p></li><li><p>尽管冲突处理可能并不容易，但尽请在完成一个新任务后尽快提交一次代码。如果一直未将本地的代码与托管库合并，就可能会造成更多的冲突哦。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注册Git平台账号&quot;&gt;注册Git平台账号&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首先，创建一个云端的项目仓库。借助Github或者Gitee，可以将你的项目托管在云端，以便团队的各成员都能方便地拉取与提交自己的代码。你可以使用Github，也可以是Gitee，来完成你的云端</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="https://www.iuoyt.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux目录结构及文件基本操作</title>
    <link href="https://www.iuoyt.com/posts/7c63bae8.html"/>
    <id>https://www.iuoyt.com/posts/7c63bae8.html</id>
    <published>2023-09-23T03:13:32.000Z</published>
    <updated>2023-11-25T03:24:40.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux目录结构">Linux目录结构</h2><ul><li>Windows系统中，存储是以盘符和分区为主，因此在经过一段时间的使用后，文件目录会相对混乱。</li><li>UNIX/Linux则是以目录为主，文件构成树形目录结构。</li></ul><h3 id="FHS标准">FHS标准</h3><ul><li>FHS（FileSystem Hierarchy Standard，文件系统层次结构标准）规定了Linux的部分目录结构，其定义了两层规范：<ul><li>第一层是 <code>/</code>，规定了各文件应该放置的位置，如 <code>/etc</code>应该放置设置文件，<code>/bin</code>应该放置可执行文件。</li><li>第二层则是针对 <code>/usr</code>及 <code>/var</code>两个目录的定义，例如 <code>/var/log</code>用于存放系统日志文件。<br><img src="https://doc.shiyanlou.com/linux_base/4-1.png" alt="FHS标准"></li></ul></li></ul><h3 id="目录路径">目录路径</h3><ul><li><p>在目录中进行切换可以使用 <code>cd</code>命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;<span class="built_in">path</span>&gt;/&lt;to&gt;/&lt;<span class="built_in">dir</span>&gt;</span><br><span class="line"><span class="built_in">cd</span> .. # 进入上一级目录</span><br><span class="line"><span class="built_in">cd</span> ~  # 进入当前用户home目录</span><br></pre></td></tr></table></figure></li><li><p>查看当前位置使用 <code>pwd</code></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103108351.png" alt="image-20230923103108351"></p></li><li><p>如果路径以 <code>/</code>开头，则表示为绝对路径，路径则是从根目录开始查找。否则是相对路径，则是以当前目录作为起点进行查找。</p></li></ul><h2 id="Linux文件的基本操作">Linux文件的基本操作</h2><h3 id="新建文件">新建文件</h3><ul><li><p>使用 <code>touch</code>命令创建空白文件，如下，回到用户目录，然后创建 <code>test</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">touch test</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103135750.png" alt="image-20230923103135750"></p></li></ul><h3 id="新建目录">新建目录</h3><ul><li><p>使用 <code>mkdir</code>创建一个空白目录，创建多级目录，可以使用 <code>-p</code>参数：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mytest</span><br><span class="line"><span class="built_in">mkdir</span> -p father/son/grandson</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103203314.png" alt="image-20230923103203314"></p></li></ul><h3 id="复制">复制</h3><ul><li><p>使用 <code>cp</code>（copy）命令复制一个文件到指定目录下，将之前创建的 <code>test</code>文件复制到刚才创建的多级目录下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp test father/son/grandson</span><br><span class="line"><span class="built_in">cd</span> father/son/grandson</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103323402.png" alt="image-20230923103323402"></p></li></ul><h3 id="复制目录">复制目录</h3><ul><li><p>复制目录仍然使用的是 <code>cp</code>命令，但需要加上 <code>-r</code>或者 <code>-R</code>参数，表示递归复制，如下，将father目录移动到新建的 <code>family</code>目录下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> family</span><br><span class="line">cp -r father family</span><br><span class="line"><span class="built_in">tree</span> family/</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103713970.png" alt="image-20230923103713970"></p></li></ul><h3 id="删除">删除</h3><ul><li><p>使用 <code>rm</code>（remove）命令删除文件或目录，删除 <code>test</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm test</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103742690.png" alt="image-20230923103742690"></p></li><li><p>如果需要删除一些为只读权限的文件，可以使用 <code>-f</code>参数强制删除，强制删除 <code>test</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f test</span><br></pre></td></tr></table></figure></li><li><p>如果需要删除的是目录，则同样需要加上 <code>-r</code>或 <code>-R</code>参数，删除family目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r family</span><br></pre></td></tr></table></figure></li></ul><h3 id="移动文件与文件重命名">移动文件与文件重命名</h3><ul><li><p>使用 <code>mv</code>（move）移动文件（剪切操作），将 <code>file1</code>移动到 <code>Documents</code>目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Documents</span><br><span class="line">touch file1</span><br><span class="line">mv file1 Documents</span><br><span class="line"><span class="built_in">cd</span> Documents</span><br><span class="line"><span class="built_in">tree</span> Documents/</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104045186.png" alt="image-20230923104045186"></p></li><li><p>使用 <code>mv</code>同样可以对文件进行重命名，将文件 <code>file1</code>重命名为 <code>myfile</code>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Documents</span><br><span class="line">mv file1 myfile</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104134698.png" alt="image-20230923104134698"></p></li><li><p>如果需要重命名的文件太多，使用 <code>mv</code>则会非常麻烦，此时可以使用 <code>rename</code>进行批量重命名，其参数则使用perl正则表达式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"># 批量创建<span class="number">5</span>个文件</span><br><span class="line">touch file&#123;<span class="number">1</span>..<span class="number">5</span>&#125;.txt</span><br><span class="line"># 批量修改后缀为.c</span><br><span class="line"><span class="built_in">rename</span> &#x27;s/\.txt/\.c/&#x27; *.txt</span><br><span class="line"># 将文件名称和后缀都改为大写</span><br><span class="line"><span class="built_in">rename</span> &#x27;y/a-z/A-Z/&#x27; *.c</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104411900.png" alt="image-20230923104411900"></p></li></ul><h3 id="查看文件">查看文件</h3><ul><li><p>使用 <code>cat</code>命令正序查看文件，使用 <code>tac</code>倒序查看文件，加上 <code>-n</code>参数则显示行号，使用 <code>cat</code>命令查看 <code>passwd</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">cp /etc/passwd passwd</span><br><span class="line">cat -n passwd</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104503707.png" alt="image-20230923104503707"></p></li><li><p>使用 <code>nl</code>命令与 <code>cat -n</code>相同，都是添加行号并显示，<code>nl</code>命令包括如下参数：</p></li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:center">指定添加行号的方式</td></tr><tr><td style="text-align:center"><code>-b a</code></td><td style="text-align:center">无论是否为空行，都列出行号（<code>cat -n</code>）</td></tr><tr><td style="text-align:center"><code>-b t</code></td><td style="text-align:center">只列出非空行的编号并显示（默认）</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:center">设置行号的样式</td></tr><tr><td style="text-align:center"><code>-n ln</code></td><td style="text-align:center">在行号字段最左边显示</td></tr><tr><td style="text-align:center"><code>-n rn</code></td><td style="text-align:center">在行号字段最右边显示，不补0</td></tr><tr><td style="text-align:center"><code>-n rz</code></td><td style="text-align:center">在行号字段最右边显示，补0</td></tr><tr><td style="text-align:center"><code>-w</code></td><td style="text-align:center">行号字段占用的位数（默认6位）</td></tr></tbody></table><ul><li><p>使用 <code>more</code>和 <code>less</code>可以分页查看文件,打开文件后默认只显示一屏的内容，可以使用<kbd>Enter</kbd>向下滚动一行，使用<kbd>Space</kbd>向下滚动一屏，按下<kbd>h</kbd>显示帮助，按下<kbd>q</kbd>退出。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">more</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104701100.png" alt="image-20230923104701100"></p></li><li><p>使用 <code>head</code>或 <code>tail</code>命令查看文件前几行（默认10）或尾几行，使用 <code>-n</code>参数可以指定查看行数：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head passwd</span><br><span class="line"># 查看最后一行内容</span><br><span class="line">tail -n <span class="number">1</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104730835.png" alt="image-20230923104730835"></p></li><li><p><code>tail</code>命令还有一个 <code>-f</code>参数，这个参数可以不断读取文件内容并显示，从而达到监控文件的作用</p></li></ul><h3 id="查看文件类型">查看文件类型</h3><ul><li><p>使用 <code>file</code>可以查看文件类型：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file /bin/ls</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104951833.png" alt="image-20230923104951833"></p><p>说明这是一个可执行文件，运行在 64 位平台，并使用了动态链接文件（共享库）。</p></blockquote></li></ul><h3 id="编辑文件">编辑文件</h3><ul><li><p>可以使用编辑器编辑文件，比如使用vim编辑器：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim passwd</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><ol><li><p>创建一个 homework 目录，建立名为 1.txt～10.txt 文件，并删除 1.txt～5.txt 。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> homework</span><br><span class="line">touch &#123;<span class="number">1</span>..<span class="number">10</span>&#125;.txt</span><br><span class="line">rm &#123;<span class="number">1</span>..<span class="number">5</span>&#125;.txt</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923105312850.png" alt="image-20230923105312850"></p></li><li><p>Linux 的日志文件在哪个目录？</p><p>日志文件存储在 <code>/var/log</code>目录下</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923105427851.png" alt="image-20230923105427851"></p></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了Linux的文件组织目录结构、相对路径和绝对路径、对文件的移动、复制、重命名、编辑等操作。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux用户及文件权限管理</title>
    <link href="https://www.iuoyt.com/posts/337bc2f3.html"/>
    <id>https://www.iuoyt.com/posts/337bc2f3.html</id>
    <published>2023-09-17T08:13:02.000Z</published>
    <updated>2023-10-08T16:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户操作">用户操作</h2><h3 id="查看用户">查看用户</h3><p>输出当前使用终端的用户名</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937806007" alt="查看用户"></p><h3 id="创建用户">创建用户</h3><p>使用root用户登录，创建新用户。创建用户需要满足以下条件：</p><ul><li><p>知道当前用户的登录密码</p><blockquote><p>重置用户密码：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;sudo passwd &lt;username&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>当前用户必须在sudo用户组</p></li></ul><ol><li>创建一个叫lilei的用户：</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser lilei</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937837548" alt="创建用户"></p><ol start="2"><li>创建好用户后，讲用户添加到系统，并为用户创建<code>home</code>目录</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /home</span><br></pre></td></tr></table></figure><ol start="3"><li>切换到lilei用户，并查看当前用户名：</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su -l lilei</span><br><span class="line">who am i</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937853403" alt="切换用户lilei"></p><h3 id="用户组">用户组</h3><h4 id="查看用户组">查看用户组</h4><h5 id="方法一">方法一</h5><p>使用<code>groups</code>命令查询用户组</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups shiyanlou</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937855752" alt="查看用户组"></p><h5 id="方法二">方法二</h5><p>通过<code>/etc/group</code>文件查看</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | <span class="built_in">sort</span></span><br><span class="line">cat /etc/group | grep -E &quot;shiyanlou&quot;</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937857521" alt="通过/etc/group查看用户组"></p><h4 id="加入用户组">加入用户组</h4><p>默认创建的用户不具有<code>sudo</code>权限，可以加入sudo用户组使其具有<code>sudo</code>权限。使用<code>usermod</code>命令添加权限：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su shiyanlou</span><br><span class="line">groups lilei</span><br><span class="line">sudo usermod -G sudo lilei</span><br><span class="line">groups lilei</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937859202" alt="加入用户组"></p><h3 id="删除用户">删除用户</h3><p>使用<code>deluser</code>命令删除用户：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser lilei --remove-home</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937860913" alt="删除用户"></p><h2 id="Linux文件权限">Linux文件权限</h2><h3 id="列出文件">列出文件</h3><ul><li>使用长格式列出文件：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937863052" alt="长格式列出文件"></p><ul><li>查看全部文件（包括隐藏文件）</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -A</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937865050" alt="查看全部文件"></p><ul><li>使用长格式列出所有文件</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -Al</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937868681" alt="长格式列出所有文件"></p><ul><li>查看目录完整属性</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -dl &lt;dirname&gt;</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937871460" alt="查看目录完整属性"></p><ul><li>显示所有文件大小</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -AsSh</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937873687" alt="显示所有文件大小"></p><h3 id="查看文件">查看文件</h3><p>使用<code>cat &lt;filename&gt;</code>命令读取文件内容</p><h3 id="变更文件所有者">变更文件所有者</h3><ul><li>新建<code>iphone6</code>目录，查看目录创建人</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su lilei</span><br><span class="line"><span class="built_in">cd</span> /home/lilei</span><br><span class="line">touch iphone6</span><br><span class="line">ll iphone6</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937876019" alt="查看文件创建人"></p><ul><li>切换身份，并变更创建人身份</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su shiyanlou</span><br><span class="line"><span class="built_in">cd</span> /home/lilei</span><br><span class="line">ls iphone6</span><br><span class="line">sudo chown shiyanlou iphone6</span><br><span class="line">ll iphone6</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230917153225613.png" alt="变更创建人"></p><h3 id="修改文件权限">修改文件权限</h3><h4 id="方法一-二进制数字表示">方法一 二进制数字表示</h4><blockquote><p>每个文件的三组权限（拥有者，所属用户组，其他用户，<strong>记住这个顺序是一定的</strong>）对应一个 &quot; rwx &quot;，也就是一个 “ 7 ”</p><p><img src="https://doc.shiyanlou.com/linux_base/3-14.png" alt="img"></p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">echo</span> \&quot;hello shiyanlou\&quot;&quot; &gt; iphone6</span><br><span class="line">chmod <span class="number">600</span> iphone6</span><br><span class="line">ll iphone6</span><br><span class="line">su lilei</span><br><span class="line">cat /home/lilei/iphone6</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937882239" alt="修改权限1"></p><h4 id="方法二-加减赋值操作">方法二 加减赋值操作</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod go-rw iphone6</span><br></pre></td></tr></table></figure><h3 id="adduser-useradd">adduser &amp; useradd</h3><blockquote><p>useradd 只创建用户，创建完了用 passwd lilei 去设置新用户的密码。adduser 会创建用户，创建目录，创建密码（提示你设置），做这一系列的操作。其实 useradd、userdel 这类操作更像是一种命令，执行完了就返回。而 adduser 更像是一种程序，需要你输入、确定等一系列操作。</p></blockquote><h2 id="实战训练">实战训练</h2><p><strong>题目</strong></p><blockquote><p>添加一个用户 <code>loutest</code>，使用 <code>sudo</code> 创建文件 <code>/opt/forloutest</code>，设置成用户 <code>loutest</code> 可以读写。</p></blockquote><ol><li><p>添加用户<code>loutest</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser loutest</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937214794" alt="添加用户"></p></li><li><p>创建文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /opt/forloutest</span><br></pre></td></tr></table></figure></li><li><p>设置读写权限并测试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chown loutest:loutest /opt/forloutest</span><br><span class="line">sudo chmod <span class="number">600</span> /opt/forloutest</span><br><span class="line">cat /opt/forloutest</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937457242" alt="权限设置"></p></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了Linux 中创建、删除用户，及用户组等操作，以及Linux 中的文件权限设置。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LC 1. 两数之和</title>
    <link href="https://www.iuoyt.com/posts/d98ef1d2.html"/>
    <id>https://www.iuoyt.com/posts/d98ef1d2.html</id>
    <published>2023-08-20T06:12:26.000Z</published>
    <updated>2023-08-20T11:17:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><ul><li>序号：1</li><li>题目：两数之和</li><li>难度：简单</li><li>标签：数组、哈希表</li></ul><details class="folding-tag" open><summary> 题目描述 </summary>              <div class='content'>              <blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,7,11,15]</span>, target = 9</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br><span class="line">解释：因为 nums<span class="comment">[0]</span> + nums<span class="comment">[1]</span> == 9 ，返回 <span class="comment">[0, 1]</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,2,4]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,3]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>$2 &lt;= nums.length &lt;= 10^4$</li><li>$-10^9 &lt;= nums[i] &lt;= 10^9$</li><li>$-10^9 &lt;= target &lt;= 10^9$</li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong> 你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p></blockquote>              </div>            </details><hr><h2 id="题解-方法1（枚举法）">题解-方法1（枚举法）</h2><h3 id="思路">思路</h3><ul><li>暴力枚举</li><li>遍历数组中所有的数字，查找符合求和满足条件的值。内层循环查找的开始位置可以是外层循环位置的后一位，因为前方的值已经匹配过，无需遍历。</li></ul><h3 id="代码">代码</h3><div class="tabs" id="代码"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#代码-1">Java</button></li><li class="tab"><button type="button" data-href="#代码-2">C++</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="代码-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="代码-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="复杂度分析">复杂度分析</h3><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="题解-方法2（哈希表）">题解-方法2（哈希表）</h2><h3 id="思路-2">思路</h3><ul><li>哈希表</li><li>通过哈希表可以将内层时间复杂度O(n)降为O(1)。在哈希表中询问是否存在<code>target - nums[i]</code>的值，不存在则将当前值存入哈希表。</li></ul><h3 id="代码-2">代码</h3><div class="tabs" id="代码"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#代码-1">Java</button></li><li class="tab"><button type="button" data-href="#代码-2">C++</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="代码-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashTable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashTable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="代码-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashTable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashTable.<span class="built_in">find</span>(target - nums[i]) != hashTable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;hashTable[target - nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="复杂度分析-2">复杂度分析</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul>]]></content>
    
    
    <summary type="html">LeetCode：1. 两数之和</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.iuoyt.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.iuoyt.com/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.iuoyt.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://www.iuoyt.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Git分支管理</title>
    <link href="https://www.iuoyt.com/posts/935337f5.html"/>
    <id>https://www.iuoyt.com/posts/935337f5.html</id>
    <published>2023-08-04T04:24:21.000Z</published>
    <updated>2023-08-04T10:50:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分支创建与切换">分支创建与切换</h2><ul><li><p>创建一个分支可以使用<code>git branch</code>命令，比如可以使用这个语句创建一个testing分支，这会在当前所在的提交对象上创建一个指针：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch testing</span><br></pre></td></tr></table></figure></li><li><p>创建完testing分支后，情况如下：</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="HEAD 指向当前所在的分支。"></p></li><li><p>使用<code>git branch</code>创建好分支后并不会自动切换到新的分支，切换到一个分支，可以使用<code>git checkout</code>命令，比如这条命令将会切换HEAD指针到testing分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure></li><li><p>HEAD指针指向了testing分支</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="HEAD 指向当前所在的分支。"></p></li><li><p>当然，Git也可以在创建分支的同时切换到当前分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="分支提交">分支提交</h2><ul><li><p>HEAD当前指向testing分支，那么现在更新一些内容然后进行提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim test.rb</span><br><span class="line">git commit -a -m &#x27;update testing&#x27;</span><br></pre></td></tr></table></figure></li><li><p>提交完成后，分支情况就变成现在这样：</p><p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" alt="HEAD 分支随着提交操作自动向前移动。"></p></li><li><p>如果现在再将HEAD移动回master分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png" alt="检出时 HEAD 随之移动。"></p><p>这个时候，你的工作目录和你在开始修改tetsing分支之前一模一样。当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p></li><li><p>现在在master分支下再进行一次修改并提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim test.rb</span><br><span class="line">git commit -a -m &#x27;update master&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/advance-master.png" alt="项目分叉历史。"></p></li></ul><h2 id="项目分叉历史">项目分叉历史</h2><ul><li><p>查看当前项目的分叉历史，可以使用<code>git log</code>命令进行查看，它会输出提交历史、各个分支的指向以及项目的分支分叉情况：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate --graph --all</span></span><br><span class="line">* c2b9e (HEAD, master) update master</span><br><span class="line">| * 87ab2 (testing) update testing</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure></li><li><p>Git的分支实质上仅是包含所指对象校验和（长度为40的SHA-1值字符串）的文件，所以创建和销毁分支都可以做到非常的高效。</p></li></ul><h2 id="删除分支">删除分支</h2><ul><li><p>使用带有<code>-d</code>的<code>git branch</code>命令可以删除分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d testing</span><br></pre></td></tr></table></figure></li></ul><h2 id="合并分支">合并分支</h2><ul><li><p>假设当前已有master分支如下：</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-1.png" alt="一个简单的提交历史。"></p></li><li><p>现在，需要解决追踪系统的#53问题，新建了一个iss53分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch iss53</span><br><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" alt="创建一个新分支指针。"></p></li><li><p>现在在iss53分支进行了一些更改：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">git commit -a -m &#x27;added a new footer [issue 53]&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" alt=" 分支随着工作的进展向前推进。"></p></li></ul><h3 id="快进式（fast-forward）合并">快进式（fast-forward）合并</h3><ul><li><p>现在需要对主分支进行一次紧急修复，切换到master分支并进行一次热修复：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b hotfix</span><br><span class="line">vim index.html</span><br><span class="line">git commit -a -m &#x27;fixed the broken email address&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="基于  分支的紧急问题分支（hotfix branch）。"></p></li><li><p>经过检验，热修复分支解决了问题，那么现在需要将master分支与hotfix分支进行合并：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge hotfix</span></span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>由于你想要合并的分支 <code>hotfix</code> 所指向的提交 <code>C4</code> 是你所在的提交 <code>C2</code> 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt=" 被快进到 。"></p></li></ul><h3 id="二路合并">二路合并</h3><ul><li>二路合并是最简单的一种合并方式，将两个文件进行逐行比对，如果行内容有差异就报冲突，这时候就需要人工合并差异了。</li></ul><h3 id="三路合并（递归三路合并）">三路合并（递归三路合并）</h3><ul><li><p>对于较少差异的分支，使用二路合并尚且可以接受，但对于较大差异的分支，使用二路合并就非常麻烦了。因此出现了三路合并方法：首先找到两个分支的共同父节点（Base），如果A分支对某内容进行了修改，B分支对这个内容未进行修改，那么会应用A分支的修改，反之应用B分支的修改。</p><p><img src="https://upload-images.jianshu.io/upload_images/11893784-6b0f41a62e828d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p></li><li><p>回到之前的情景。解决完紧急问题后，需要恢复到之前的工作中，进行后续工作的提交。同时删除hotfix分支，因为已经完成了此次修复，不再需要：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix</span></span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout iss53</span></span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;finished the new footer [issue 53]&#x27;</span></span></span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="继续在  分支上的工作。"></p></li><li><p>现在iss53问题已经被修复，需要与master分支进行合并：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="一次典型合并中所用到的三个快照。"></p></li><li><p>因为master分支并非是iss53分支的父节点，Git会对这两个分支进行一次简单的三路合并。虽然此次合并写作’recursive’策略，但并非递归三路合并，在Git的输出中，三路合并与递归三路合并都是’recursive’策略，递归三路合并策略通常用于更加复杂的合并场景。</p></li></ul><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="一个合并提交。"></p><h2 id="处理合并冲突">处理合并冲突</h2><ul><li><p>如果两个分支都对同一段内容做了更改，Git就无法完成合并操作，在合并时就会报合并冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>可以使用<code>git status</code>查看当前产生冲突而未合并状态的文件</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></li><li><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>手动合并完成后，对冲突文件使用<code>git add</code>将其标记为冲突已解决。</p></li><li><p>如果想使用图形化界面来处理冲突操作，可以使用<code> git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突。退出工具后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决。</p></li></ul><h2 id="分支管理">分支管理</h2><ul><li><p>使用不带参数的<code>git branch</code>命令可以查看当前分支的列表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>其中，带有<code>*</code>的master分支代表当前HEAD指针所指向的分支。</p></li><li><p>如果需要查看每一个分支的最后一次提交，可以使用<code>git branch -v</code>命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure></li><li><p>还可以使用<code>--merged</code>与<code>--no-merged</code>筛选当前已合并或未合并到当前分支的分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>git branch -d</code>删除分支，如果删除分支包含了还未合并的工作，则会删除失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d testing</span></span><br><span class="line">error: The branch &#x27;testing&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D testing&#x27;.</span><br></pre></td></tr></table></figure><p>可以使用<code>-D</code>完成强制删除。</p></li></ul><h2 id="远程分支">远程分支</h2><ul><li><p>假设有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-1.png" alt="克隆之后的服务器与本地仓库。"></p></li><li><p>如果在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-2.png" alt="本地与远程的工作可以分叉。"></p></li><li><p>如果要与远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（本例中为 <code>git fetch origin</code>）。 这个命令查找 ``origin’’ 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-3.png" alt=" 更新你的远程仓库引用。"></p></li></ul><h2 id="变基">变基</h2><h3 id="变基的使用">变基的使用</h3><ul><li><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。假设现在有两个分支分别提交了更新</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-1.png" alt="分叉的提交历史。"></p></li><li><p>如果使用<code>merge</code>合并两个分支，那么会产生一次新的快照。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-2.png" alt="通过合并操作来整合分叉了的历史。"></p></li><li><p>使用另一种方法：提取C4中引入的补丁和修改，然后再C3的基础上应用一次，这种操作称为<strong>变基（rebase）</strong>。比如，检出experiment分支，将其变基到master分支上：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout experiment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-3.png" alt="将  中的修改变基到  上。"></p></li><li><p>现在回到master分支上，进行一次快进合并：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge experiment</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-4.png" alt=" 分支的快进合并。"></p><p>此时的C4’快照就和使用merge合并产生的C5快照一模一样了。这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。例如向某个其他人维护的项目贡献代码时，首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p></li><li><p>对于一个主题分支中再分出一个主题分支的提交，如下图结构</p><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-1.png" alt="从一个主题分支里再分出一个主题分支的提交历史。"></p><p>如果希望合并client到master分支，但不希望将server分支合并，此时就可以使用<code>--onto</code>选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master server client</span><br></pre></td></tr></table></figure><p>这条语句的意思是：取出 <code>client</code> 分支，找出它从 <code>server</code> 分支分歧之后的补丁， 然后把这些补丁在 <code>master</code> 分支上重放一遍，让 <code>client</code> 看起来像直接基于 <code>master</code> 修改一样。</p><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-2.png" alt="截取主题分支上的另一个主题分支，然后变基到其他分支。"></p></li><li><p>那么现在可以使用快进合并合并master分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge client</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-3.png" alt="快进合并  分支，使之包含来自  分支的修改。"></p></li><li><p>如果现在需要将server分支也合并进来，使用变基操作，完成合并，然后删除多余的分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge server</span><br><span class="line">git branch -d client</span><br><span class="line">git branch -d server</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-5.png" alt="最终的提交历史。"></p></li></ul><h3 id="变基的问题">变基的问题</h3><ul><li><p>如果当别人正在基于分支进行开发，那么不应该将分支使用变基合并到主分支上。变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p></li><li><p>比如，现在有一个公开仓库，你从当前仓库克隆到本地并在此基础上进行开发。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-1.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发。"></p></li><li><p>然后，某人向该仓库提交了一些修改，其中还包括一次合并。你抓取了远程分支上的修改，然后合并到你的本地分支上。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-2.png" alt="抓取别人的提交，合并到自己的开发分支。"></p></li><li><p>接下来，这个开发者又决定将合并操作回滚，更换为使用变基合并，并使用<code>git push --force</code>命令覆盖了服务器上的提交历史。然后你向服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-3.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。"></p></li><li><p>此时，如果你执行<code>git pull</code>命令提交，就会将已经抛弃的C4和C6快照恢复，最终仓库会如下图所示，变得混乱。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></p></li></ul><h3 id="解决因变基产生的合并问题">解决因变基产生的合并问题</h3><ul><li><p>假如真的遇到了类似的问题，可以使用一些操作解决。实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p></li><li><p>这种情况下，如果并非执行合并，而是使用<code>git rebase teamone/master</code>，Git就会执行以下操作：</p><ul><li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li><li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li><li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li><li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li></ul><p>那么将会产生如下结构：</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-5.png" alt="在一个被变基然后强制推送的分支上再次执行变基。"></p><p>不过，这种操作需要保证C4’和C4是一样的，否则变基操作将无法识别，并新建另一个类似C4的补丁。</p></li><li><p>还有另一种简单的方法是使用<code>git pull --rebase</code>，或者手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p></li></ul><h2 id="Learn-Git-Branching">Learn Git Branching</h2><ul><li>在<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a>上，可以进行一部分git命令的教学实验，或者使用沙盒进行测试，通过具象化的图形可以帮助对Git操作的理解。</li></ul>]]></content>
    
    
    <summary type="html">使用分支意味着可以将当前的工作从开发主线上分离开来，以免影响开发主线。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="https://www.iuoyt.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git的指令</title>
    <link href="https://www.iuoyt.com/posts/cbbfdcc5.html"/>
    <id>https://www.iuoyt.com/posts/cbbfdcc5.html</id>
    <published>2023-08-04T04:02:07.000Z</published>
    <updated>2023-11-25T03:26:14.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建Git仓库">创建Git仓库</h2><ul><li><p>在需要创建Git仓库的目录下打开Git Bash，使用<code>git init</code>命令来初始化一个Git仓库，在执行完<code>git init</code>命令后，该目录下会生成一个名为.git的隐藏目录，这个目录中包含了资源的所有元数据。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>也可以指定目录作为Git仓库</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init /path/to/your/repo</span><br></pre></td></tr></table></figure></li></ul><h2 id="将文件纳入版本控制">将文件纳入版本控制</h2><h3 id="追踪文件">追踪文件</h3><ul><li><p>在Git仓库目录中，如果有几个文件需要纳入版本控制，需要先使用<code>git add</code>命令告诉Git这些文件需要被追踪。以下命令将README文件提交到仓库中。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure></li><li><p>然后使用<code>git status</code>命令查看当前Git状态，会看到README文件已被跟踪，并处于暂存状态。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure></li><li><p>现在修改一个已经被跟踪的文件“<a href="http://CONTRIBUTING.md">CONTRIBUTING.md</a>”，然后运行<code>git status</code>命令，会看到如下内容：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></li><li><p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></li><li><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></li><li><p>现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。实际上 Git 只暂存了运行 <code>git add</code> 命令时的版本。如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></li></ul><h3 id="状态简览">状态简览</h3><ul><li><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure></li><li><p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。 <code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p></li></ul><h3 id="忽略文件">忽略文件</h3><ul><li><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .gitignore</span></span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure></li><li><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p><blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略所有的 .a 文件</span></span><br><span class="line">*<span class="string">.a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span></span><br><span class="line"><span class="string">/TODO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略任何目录下名为 build 的文件夹</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span></span><br><span class="line">doc/*<span class="string">.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span></span><br><span class="line">doc/**/*<span class="string">.pdf</span></span><br></pre></td></tr></table></figure><p>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表， 你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它。</p></blockquote></li></ul><h3 id="提交更新">提交更新</h3><ul><li><p>现在暂存区已经准备就绪，可以使用<code>git commit</code>提交了。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure></li><li><p>然后会启动你选择的文本编辑器来输入提交说明。编辑器会显示类似下面的文本信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Changes to be committed:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">new file:   README</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">modified:   CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">~</span></span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C</span><br></pre></td></tr></table></figure></li><li><p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。在Vim编辑器中，可以按下<kbd>i</kbd>或者<kbd>Insert</kbd>进入编辑模式。完成编辑后按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出文件，如果需要放弃修改并退出，输入<code>:q!</code>。</p></li></ul><h3 id="移除文件">移除文件</h3><ul><li><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> PROJECTS.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></li><li><p>如果希望Git不再跟踪文件时，文件可以继续保留在磁盘上，使用<code>--cache</code>选项：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached README</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="重命名（移动文件）">重命名（移动文件）</h3><ul><li><p>如果需要在Git跟踪的文件中重命名某个文件，可以使用<code>git mv</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure></li><li><p>运行<code>git mv</code>相当于运行了三条命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用远程仓库">使用远程仓库</h2><h3 id="查看远程仓库">查看远程仓库</h3><ul><li><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into &#x27;ticgit&#x27;...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (772/772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure></li><li><p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure></li><li><p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> grit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure></li><li><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure></li></ul><h3 id="添加远程仓库">添加远程仓库</h3><ul><li><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure></li><li><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取仓库中有但本地没有的信息，可以运行 <code>git fetch pb</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch pb</span></span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure></li></ul><h3 id="重命名与移除">重命名与移除</h3><ul><li><p>你可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote rename pb paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。如果因为一些原因想要移除一个远程仓库，可以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote remove paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure></li><li><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p></li></ul><h2 id="查看提交历史">查看提交历史</h2><ul><li><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。使用“simplegit”项目作为演示，首先运行下面的命令获取项目：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure></li><li><p>获取完毕后，在该项目中运行<code>git log</code>命令，可以看到如下输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。如果希望以补丁的形式查看每次提交所引入的差异，可以使用<code>-p</code>或者<code>--patch</code>，同时可以限制显示的日志条目数量，例如<code>-2</code>代表只显示最近的2次提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -p -2</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require &#x27;rake/gempackagetask&#x27;</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   &quot;simplegit&quot;</span><br><span class="line">-    s.version   =   &quot;0.1.0&quot;</span><br><span class="line">+    s.version   =   &quot;0.1.1&quot;</span><br><span class="line">     s.author    =   &quot;Scott Chacon&quot;</span><br><span class="line">     s.email     =   &quot;schacon@gmail.com&quot;</span><br><span class="line">     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用<code>--stat</code>可以快速浏览每次提交的简略信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure></li><li><p>使用<code>--pretty</code>选项可以选择显示样式，比如在一行内查看每次提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD) changed the verison number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br></pre></td></tr></table></figure></li><li><p>或者使用<code>--pretty=format:</code>来自定义显示样式：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h - %an, %ar : %s&quot;</span></span></span><br><span class="line">ca82a6d - Scott Chacon, 15 years ago : changed the verison number</span><br><span class="line">085bb3b - Scott Chacon, 15 years ago : removed unnecessary test code</span><br><span class="line">a11bef0 - Scott Chacon, 15 years ago : first commit</span><br></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> --pretty=format 常用选项 </summary>              <div class='content'>              <table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>%H</code></td><td style="text-align:left">提交的完整哈希值</td></tr><tr><td style="text-align:left"><code>%h</code></td><td style="text-align:left">提交的简写哈希值</td></tr><tr><td style="text-align:left"><code>%T</code></td><td style="text-align:left">树的完整哈希值</td></tr><tr><td style="text-align:left"><code>%t</code></td><td style="text-align:left">树的简写哈希值</td></tr><tr><td style="text-align:left"><code>%P</code></td><td style="text-align:left">父提交的完整哈希值</td></tr><tr><td style="text-align:left"><code>%p</code></td><td style="text-align:left">父提交的简写哈希值</td></tr><tr><td style="text-align:left"><code>%an</code></td><td style="text-align:left">作者名字</td></tr><tr><td style="text-align:left"><code>%ae</code></td><td style="text-align:left">作者的电子邮件地址</td></tr><tr><td style="text-align:left"><code>%ad</code></td><td style="text-align:left">作者修订日期（可以用 --date=选项 来定制格式）</td></tr><tr><td style="text-align:left"><code>%ar</code></td><td style="text-align:left">作者修订日期，按多久以前的方式显示</td></tr><tr><td style="text-align:left"><code>%cn</code></td><td style="text-align:left">提交者的名字</td></tr><tr><td style="text-align:left"><code>%ce</code></td><td style="text-align:left">提交者的电子邮件地址</td></tr><tr><td style="text-align:left"><code>%cd</code></td><td style="text-align:left">提交日期</td></tr><tr><td style="text-align:left"><code>%cr</code></td><td style="text-align:left">提交日期（距今多长时间）</td></tr><tr><td style="text-align:left"><code>%s</code></td><td style="text-align:left">提交说明</td></tr></tbody></table>              </div>            </details><details class="folding-tag" yellow><summary> git log常用选项 </summary>              <div class='content'>              <table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left">按补丁格式显示每个提交引入的差异。</td></tr><tr><td style="text-align:left"><code>--stat</code></td><td style="text-align:left">显示每次提交的文件修改统计信息。</td></tr><tr><td style="text-align:left"><code>--shortstat</code></td><td style="text-align:left">只显示 --stat 中最后的行数修改添加移除统计。</td></tr><tr><td style="text-align:left"><code>--name-only</code></td><td style="text-align:left">仅在提交信息后显示已修改的文件清单。</td></tr><tr><td style="text-align:left"><code>--name-status</code></td><td style="text-align:left">显示新增、修改、删除的文件清单。</td></tr><tr><td style="text-align:left"><code>--abbrev-commit</code></td><td style="text-align:left">仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</td></tr><tr><td style="text-align:left"><code>--relative-date</code></td><td style="text-align:left">使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。</td></tr><tr><td style="text-align:left"><code>--graph</code></td><td style="text-align:left">在日志旁以 ASCII 图形显示分支与合并历史。</td></tr><tr><td style="text-align:left"><code>--pretty</code></td><td style="text-align:left">使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。</td></tr><tr><td style="text-align:left"><code>--oneline</code></td><td style="text-align:left"><code>--pretty=oneline --abbrev-commit</code> 合用的简写。</td></tr></tbody></table>              </div>            </details><details class="folding-tag" blue><summary> 限制git log输出的选项 </summary>              <div class='content'>              <table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>-&lt;n&gt;</code></td><td style="text-align:left">仅显示最近的 n 条提交。</td></tr><tr><td style="text-align:left"><code>--since</code>, <code>--after</code></td><td style="text-align:left">仅显示指定时间之后的提交。</td></tr><tr><td style="text-align:left"><code>--until</code>, <code>--before</code></td><td style="text-align:left">仅显示指定时间之前的提交。</td></tr><tr><td style="text-align:left"><code>--author</code></td><td style="text-align:left">仅显示作者匹配指定字符串的提交。</td></tr><tr><td style="text-align:left"><code>--committer</code></td><td style="text-align:left">仅显示提交者匹配指定字符串的提交。</td></tr><tr><td style="text-align:left"><code>--grep</code></td><td style="text-align:left">仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td style="text-align:left"><code>-S</code></td><td style="text-align:left">仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table>              </div>            </details></li></ul><h2 id="Git的基本操作">Git的基本操作</h2><ul><li>以下6条命令是Git最常使用的命令：<ul><li>git clone / git fetch</li><li>git pull</li><li>git checkout (git switch / git restore)</li><li>git add</li><li>git commit</li><li>git push</li></ul></li></ul><p><img src="https://s1.vika.cn/space/2023/07/29/f0e889650d7c48c9b66463f0e1d2930c" alt="git-command"></p><ul><li>其中：<ul><li>workspace：工作区</li><li>staging area：暂存区（缓存区）</li><li>local repository：本地仓库（版本库）</li><li>remote repository：远程仓库</li></ul></li></ul><h3 id="git-clone">git clone</h3><ul><li><p>如果需要下载Git仓库到本地目录中，可以使用下面两种指令。第一种将Git仓库克隆到当前执行Git命令的目录下，第二种将Git仓库克隆到指定目录下。当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。其中：</p><ul><li>&lt;repo&gt;：需要克隆的Git仓库</li><li>&lt;directory&gt;：本地目录</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-fetch">git fetch</h3><ul><li><p><code>git fetch</code>用于更新本地仓库，但不会自动合并或修改本地代码，在查看远程仓库最新更新、了解其他开发者的提交或者想手动处理合并时，则使用<code>git fetch</code>操作，然后使用<code>git merge</code>合并分支。其中：</p><ul><li>&lt;alias&gt;：远程仓库的别名，通常是origin</li><li>&lt;branch&gt;：分支名称，如master</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;alias&gt;</span><br><span class="line">git merge &lt;alias&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-pull">git pull</h3><ul><li><p><code>git pull</code>与<code>git clone</code>的作用类似，都是从代码仓库获取代码，不同的是，<code>git clone</code>会覆盖本地仓库中的内容，<code>git pull</code>则是将远程拉取的代码与本地的版本合并，本质是将<code>git fetch</code>和<code>git merge</code>一并完成。<code>git pull</code>有三种写法，第一种是从远程仓库拉取当前所跟踪的分支，第二种则指定远程分支，第三种则指定本地分支。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt;</span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;</span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>在指定本地分支时，远程分支不可以省略，即不可以写成如下样式：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-checkout-git-switch-git-restore">git checkout (git switch + git restore)</h3><ul><li><p><code>git checkout</code>用于切换本地分支，可以从当前分支切换到另一个存在的分支。同时<code>git checkout</code>还可以将文件恢复到最近一次提交的状态，即撤销对文件的修改。如果需要切换分支的同时创建分支，可以使用<code>-b</code>参数</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br><span class="line">git checkout -b &lt;新分支名&gt;</span><br><span class="line">git checkout &lt;文件名&gt;</span><br></pre></td></tr></table></figure></li><li><p>在2.23版本中，Git引入了两个新的指令：switch和restore，替代了部分checkout的功能。其中switch用来切换分支，restore用来恢复文件，但checkout仍然可以继续使用。在使用switch切换分支时，可以使用<code>-c</code>参数同时创建分支</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;分支名&gt;</span><br><span class="line">git switch -c &lt;新分支名&gt;</span><br><span class="line">gitt restore &lt;文件名&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-add">git add</h3><ul><li><p><code>git add</code>命令可将该文件的修改添加到暂存区。通过运行<code>git add</code>命令，你可以告诉 Git 哪些文件的修改应该包含在下一次提交（commit）中。</p></li><li><p>添加一个或多个文件到暂存区：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure><p>添加指定目录到暂存区，包括子目录：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [dir]</span><br></pre></td></tr></table></figure><p>添加当前目录下的所有文件到暂存区：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-commit">git commit</h3><ul><li><p><code>git commit</code>命令将暂存区内容添加到本地仓库中。</p></li><li><p>提交暂存区到本地仓库中，[message] 可以是一些备注信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m<span class="meta"> [message]</span></span><br></pre></td></tr></table></figure><p>提交暂存区的指定文件到仓库区：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit <span class="comment">[file1]</span> <span class="comment">[file2]</span> ... -m <span class="comment">[message]</span></span><br></pre></td></tr></table></figure><p><code>-a</code>参数设置修改文件后不需要执行 git add 命令，直接来提交</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="git-push">git push</h3><ul><li><p>使用<code>git push</code>可以将项目推送到上游，比如想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li><li><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会被拒绝，需要先抓取他们的工作并将其合并进你的工作后才能推送。</p></li></ul><h2 id="为提交结点打上标签">为提交结点打上标签</h2><ul><li>像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ <code>v1.0</code> 、 <code>v2.0</code> 等等）。</li></ul><h3 id="创建标签">创建标签</h3><ul><li><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p><ul><li><p>轻量标签没有保存任何其他信息，只需要提供标签名字：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.4-lw</span><br></pre></td></tr></table></figure></li><li><p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议使用<code>-a</code>创建附注标签，这样你可以拥有以上所有信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.4 -m &quot;my version 1.4&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="标签补打">标签补打</h3><ul><li><p>假设提交历史如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br></pre></td></tr></table></figure></li><li><p>假设在“updated rakefile” 提交时忘记给项目打标签，可以在之后补上标签。 要在哪一次提交上打标签，就需要在命令的末尾指定哪一次提交的校验和（或部分校验和）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.0 9fceb02</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删除标签">删除标签</h3><ul><li><p>要删除掉本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。 例如，可以使用以下命令删除一个轻量标签：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v1.4</span></span><br><span class="line">Deleted tag &#x27;v1.4&#x27; (was e7d5add)</span><br></pre></td></tr></table></figure></li><li><p>上述命令并不会从任何远程仓库中移除这个标签，需要用 <code>git push</code> 来更新远程仓库：</p><ul><li><p><code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> ，这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/v1.4</span></span><br><span class="line">To /git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         v1.4</span><br></pre></td></tr></table></figure></li><li><p>第二种更直观的删除远程标签的方式是：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Git别名">Git别名</h2><ul><li><p>Git可以为命令设置自定义别名，通过<code>git config</code>来为命令设置别名，例如：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure></li><li><p>那么如果需要输入<code>git commit</code>时，就可以通过输入<code>git ci</code>替代</p><p>如果需要输入<code>git reset HEAD -- fileA</code>时，可以用<code>git unstage fileA</code>替代</p></li></ul>]]></content>
    
    
    <summary type="html">Git 的工作就是创建和保存项目的快照及与之后的快照进行对比，这篇文章是对相关的命令的介绍。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="https://www.iuoyt.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>关于Git</title>
    <link href="https://www.iuoyt.com/posts/189553d2.html"/>
    <id>https://www.iuoyt.com/posts/189553d2.html</id>
    <published>2023-07-29T08:51:48.000Z</published>
    <updated>2023-08-04T04:07:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制是什么">版本控制是什么</h2><ul><li><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><blockquote><p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。 但额外增加的工作量却微乎其微。</p></blockquote></li></ul><h2 id="本地版本控制系统">本地版本控制系统</h2><ul><li>为了解决在工作中常常出现的写错文件或者意外覆盖不该覆盖的文件，人们很早就开发了许多本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。但接下来又出现了新的问题，如何让在不同系统的不同开发者协同工作呢？</li></ul><h3 id="集中化的版本控制系统（CVCS）">集中化的版本控制系统（CVCS）</h3><ul><li><p>为了解决协同办公问题，集中化的版本控制系统诞生了，诸如CVS、SVN等，都有一个集中管理的服务器保存所有文件的修订版本。所有的代码都由中央仓库集中管理，每个开发者都使用同一个中央仓库进行开发，这样一来，每个人都可以看到其他人正在做些什么，而管理员也可以轻松地掌控每个开发者的权限，并且管理一个服务器也比管理各个客户端上的数据库更加轻松容易。但是，也有着一个显而易见的缺点，因为必须依靠网络连接来提交和获取代码，因此没有网络时则无法进行版本控制操作。如果服务器发生故障，那么这段时间里谁也无法更新提交，而若中心数据库的磁盘发生故障，而有没有做好备份，那么就会丢失所有数据。</p><p><img src="https://s1.vika.cn/space/2023/07/29/f17c8559b05d4332a9559859e64806bc" alt="centralized"></p></li></ul><h3 id="分布式版本控制系统（DVCS）">分布式版本控制系统（DVCS）</h3><ul><li><p>为了避免文件因为中心数据库的损坏而完全丢失的问题，分布式版本控制系统诞生了，客户端不只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来，每个开发者都可以在本地拥有完整的代码仓库副本。这样一来，客户端可以在没有网络的情况下进行代码修改和版本控制，同时也避免了数据丢失的问题。</p><p><img src="https://s1.vika.cn/space/2023/07/29/16a1ceb2842248e88763ebd6718f52e4" alt="distributed"></p></li></ul><h2 id="Git是什么">Git是什么</h2><ul><li>Git和其他版本控制系统有着一定的差别，尽管有着相同的目的，实现方式却是截然不同的。</li></ul><h3 id="基于差异的版本控制">基于差异的版本控制</h3><ul><li><p>CVS、SVN等系统的你工作方式是基于变更集的，以文件变更列表的方式存储信息，每次提交只记录具有差异的内容，因此一组文件的存储信息则是每个文件随时间逐步积累的差异。</p><p><img src="https://s1.vika.cn/space/2023/07/29/4c7165c1287f497ebc197f833ee33dd9" alt="deltas"></p></li></ul><h3 id="基于快照的版本控制">基于快照的版本控制</h3><ul><li><p>与其他的版本控制系统不同的是，Git 更像是把数据看作是对小型文件系统的一系列快照。在Git中，每次提交更新或者保存项目状态时，就会对现在的全部文件创建一个快照并保存这个快照的索引，对于没有修改的文件，则是保留一个链接指向之前存储的文件。</p><p><img src="https://s1.vika.cn/space/2023/07/29/eb2c04f160cc4fc19875fc0074f79146" alt="snapshots"></p></li><li><p>在使用体验上，Git相较其他版本控制系统有着更好的性能，由于本地存储于快照机制，速度通常更快，同时Git也有着较为强大的分支处理机制，与较为复杂的SVN相比更加灵活与简便。</p></li></ul><h2 id="Git的安装">Git的安装</h2><div class="tabs" id="git的安装"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#git的安装-1">Windows</button></li><li class="tab"><button type="button" data-href="#git的安装-2">Mac</button></li><li class="tab"><button type="button" data-href="#git的安装-3">Linux/Unix</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="git的安装-1"><ol><li><p>进入<a href="https://git-scm.com/download/win">Git下载</a>页面，或者进入<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">国内镜像源</a>，选择安装包文件下载</p></li><li><p>使用安装包安装Git</p></li><li><p>打开控制台（命令提示符），输入以下内容，若显示Git的版本号则安装成功</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="git的安装-2"><div class="tabs" id="mac下git的安装"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mac下git的安装-1">方法一</button></li><li class="tab"><button type="button" data-href="#mac下git的安装-2">方法二</button></li><li class="tab"><button type="button" data-href="#mac下git的安装-3">方法三</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mac下git的安装-1"><p><strong>使用Homebrew安装</strong></p><ol><li><p>打开终端应用程序（Terminal）</p></li><li><p>输入以下指令安装HomeBrew</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>输入以下指令安装Git</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li><li><p>验证Git是否安装成功，若显示Git的版本号，则安装成功</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mac下git的安装-2"><p><strong>使用Xcode Command Line Tools安装</strong></p><ol><li><p>打开终端应用程序（Terminal）</p></li><li><p>输入以下指令安装Xcode Command Line Tools</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li><li><p>验证Git是否安装成功，若显示Git的版本号，则安装成功</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mac下git的安装-3"><p><strong>作为GitHub for macOS的一部分来安装</strong></p><p>在安装软件时，提供了安装命令行工具的选项，可以从<a href="https://mac.github.com/">GitHub for macOS网站</a>下载该安装包。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="git的安装-3"><p><strong>Debian/Ubuntu 使用以下指令</strong></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure><p><strong>CentOS 使用以下指令</strong></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>安装完成后，检查是否安装成功</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="运行Git前的配置">运行Git前的配置</h2><blockquote><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li></ol><p>每一个级别会覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p><p>在 Windows 系统中，Git 会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code> ）的 <code>.gitconfig</code> 文件。 Git 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。 如果你在 Windows 上使用 Git 2.x 以后的版本，那么还有一个系统级的配置文件，Windows XP 上在 <code>C:\Documents and Settings\All Users\Application Data\Git\config</code> ，Windows Vista 及其以后的版本在 <code>C:\ProgramData\Git\config</code> 。此文件只能以管理员权限通过 <code>git config -f &lt;file&gt;</code> 来修改。</p><p>你可以通过以下命令查看所有的配置以及它们所在的文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure></blockquote><ul><li>配置Git的相关内容通常使用的是Git Bash，可以在windows菜单中找到，或者在任意目录下右击鼠标，选择<code>Open Git Bash here</code>打开。如果配置好了Git的环境变量，那么也可以直接在命令行中输入（判断是否可用最简单的办法是在命令行中输入<code>git --version</code>查看是否显示版本号）。</li></ul><h3 id="用户信息">用户信息</h3><ul><li><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中。</p></li><li><p>输入以下内容配置Git的用户名和电子邮件地址。如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email 你的邮箱</span><br></pre></td></tr></table></figure></li></ul><h3 id="文本编辑器">文本编辑器</h3><ul><li><p>当 Git 需要输入信息时会调用文本编辑器。 如果未配置，Git 会使用操作系统默认的文本编辑器。在 Windows 系统上，如果你想要使用别的文本编辑器，那么必须指定可执行文件的完整路径，它可能随你的编辑器的打包方式而不同。如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure><blockquote><p>对于 Notepad++，一个流行的代码编辑器来说，你可能想要使用 32 位的版本， 因为在本书编写时 64 位的版本尚不支持所有的插件。 如果你在使用 32 位的 Windows 系统，或在 64 位系统上使用 64 位的编辑器，那么你需要输入如下命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.editor <span class="string">&quot;&#x27;C:/Program Files/Notepad++/notepad++.exe&#x27; -multiInst -notabbar -nosession -noPlugin&quot;</span></span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="查看配置信息">查看配置信息</h3><ul><li><p>需要检查已有的配置信息时，可以使用如下命令。有时会看到重复的变量名，分别来自不同的配置文件，最终Git实际使用的是最后一条。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li><li><p>也可以直接查阅某个环境变量的设定值，例如使用下面的命令查询配置的用户名和邮箱。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure></li></ul><h2 id="获取帮助">获取帮助</h2><ul><li><p>如果需要获取Git指令的帮助，可以使用如下三种指令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --help</span><br><span class="line">man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure></li><li><p>例如，想要查看<code>git config</code>的手册，可以输入：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help config</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="https://www.iuoyt.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Markdown的扩展语法</title>
    <link href="https://www.iuoyt.com/posts/1a959ff5.html"/>
    <id>https://www.iuoyt.com/posts/1a959ff5.html</id>
    <published>2023-07-19T07:14:22.000Z</published>
    <updated>2023-07-19T08:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表格">表格</h2><p>要添加表格，需要使用三个或多个连字符“<code>---</code>”创建每列的标题，并使用竖线符号分隔每列。即使每一行的竖线分隔并未对齐，Markdown编辑器也可以成功创建表格。但通过以上方法创建表格较为麻烦，大部分的Markdown编辑器都有快速创建表格的方式。同时，可以在连字符的左侧、右侧或者两端添加冒号“<code>:</code>”使该列应用不同的对齐方式。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax | Description | Test Text |</span><br><span class="line">| :--- | :----: | ---: |</span><br><span class="line">| Header | Title | Here&#x27;s this |</span><br><span class="line">| Paragraph | Text | And more |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:center">Description</th><th style="text-align:right">Test Text</th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:center">Title</td><td style="text-align:right">Here’s this</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:center">Text</td><td style="text-align:right">And more</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在表格中，标题、块引用、列表、水平规则、图像或HTML标签并不会被渲染成对应样式，但可以在表格中添加链接、代码（通过反引号包裹）和强调。如果需要在表格中展示竖线符号，需要使用其对应的实体代码，参考<a href="/posts/2023-07/81d4d2a5.html#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BD%AC%E4%B9%89">特殊字符的转义</a></p><h2 id="脚注">脚注</h2><p>为文本添加脚注后，可以在标识符处查看脚注的内容。在对应文本处添加方括号包围的标识符（<code>[^1]</code>），标识符可以是数字或者字符，但不能包含空格及制表符。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Here&#x27;s a simple footnote[^1], and here&#x27;s a longer one[^bignote].</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">This is the first footnote.</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^bignote</span>]: <span class="link">Here&#x27;s one with multiple paragraphs and code.</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><img src="https://s1.vika.cn/space/2023/07/19/7a4f0057bfdd430e997c6b50f7109d06" alt="2023719-15526-HD 00_00_00-00_00_03"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="删除线">删除线</h2><p>分别使用两个波浪线符号“<code>~</code>”包裹内容可以在内容上放置一条水平线。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~世界是平坦的。~~ 我们现在知道世界是圆的。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><s>世界是平坦的。</s> 我们现在知道世界是圆的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="任务列表">任务列表</h2><p>在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] Write the press release</span><br><span class="line"><span class="bullet">-</span> [ ] Update the website</span><br><span class="line"><span class="bullet">-</span> [ ] Contact the media</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>[x] Write the press release</li><li>[ ] Update the website</li><li>[ ] Contact the media</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Emoji表情">Emoji表情</h2><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入简码（<em>emoji shortcodes</em>）。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">去露营了！ :tent: 很快回来。</span><br><span class="line"></span><br><span class="line">真好笑！ :joy:</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>去露营了！ ⛺ 很快回来。</p><p>真好笑！ 😂</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="自动网址链接">自动网址链接</h2><p>许多Markdown处理器会自动将URL转换为链接。这意味着如果输入http://www.example.com，即使未<a href="https://markdown.com.cn/basic-syntax/links.html">使用方括号</a>，Markdown处理器也会自动将其转换为链接。而如果不希望自动链接，则可以通过反引号包裹来删除链接。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com</span><br><span class="line"><span class="code">`http://www.example.com`</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><a href="http://www.example.com">http://www.example.com</a><br><code>http://www.example.com</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="标题链接">标题链接</h2><p>通过创建带有井号“<code>#</code>”和自定义标题ID的<code>[Heading ID](#title)</code>，可以链接到文档中对应的标题。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">标题链接</span>](<span class="link">#标题链接</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><a href="/posts/2023-07/1a959ff5.html#%E6%A0%87%E9%A2%98%E9%93%BE%E6%8E%A5">标题链接</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">基本语法是为了应对大多数日常情况，而有特殊需求的地方就需要用到扩展语法了。</summary>
    
    
    
    <category term="Markdown" scheme="https://www.iuoyt.com/categories/Markdown/"/>
    
    
    <category term="Markdown" scheme="https://www.iuoyt.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
