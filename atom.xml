<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🌙Nightyping</title>
  
  <subtitle>技术，生活与美好</subtitle>
  <link href="https://www.iuoyt.com/atom.xml" rel="self"/>
  
  <link href="https://www.iuoyt.com/"/>
  <updated>2024-06-28T13:46:24.496Z</updated>
  <id>https://www.iuoyt.com/</id>
  
  <author>
    <name>Royster</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络计算题练习</title>
    <link href="https://www.iuoyt.com/posts/9bdadf86.html"/>
    <id>https://www.iuoyt.com/posts/9bdadf86.html</id>
    <published>2024-06-28T06:19:13.000Z</published>
    <updated>2024-06-28T13:46:24.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见单位换算">常见单位换算</h2><ul><li><p>时间转换：</p>  <div class="note info flat"><p>$1s=10^3ms=10^6\mu s(us)$</p></div></li><li><p>数据大小：</p>  <div class="note info flat"><p>$1Byte=8bit$</p><p>$1TB=10^3GB=10^6MB=10^9KB=10^{12}B$</p></div></li></ul><h2 id="第一章-概述">第一章 概述</h2><h3 id="时延">时延</h3><ul><li>时延是指一个报文或分组从网络的一端传送到另一端所需要的时间，其单位是秒（s）、毫秒（ms）、微秒（μs）等。</li><li>总时延=发送时延+传播时延+处理时延+排队时延</li></ul><h4 id="发送时延ts">发送时延ts</h4><ul><li>发送时延（传输时延）：主机或路由器发送数据帧所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</li><li>$发送时延=\frac{数据帧长度(bit)}{发送速率(bps)}$</li></ul><ol><li><p>一个10MB数据块在传输数率为1Mbps的信道上发送，则发送时延为？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>发送时延：$\frac{10\times2^{20}\times8bit}{10^6bps}=83.89s$</p>              </div>            </details></li></ol><h4 id="传播时延tp">传播时延tp</h4><ul><li><p>传播时延：电磁波在信道中传播一定的距离而花费的时间。 信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。</p>  <div class="note info flat"><p>电磁波在真空（空气）中的传播速率为$3\times10^8m/s$，在电缆中的传播速率要比在真空中的略低，约为$2.3\times10^8m/s$，在光纤中的传播速率约为$2.0×10^8m/s$</p></div></li><li><p>$传播时延=\frac{信道长度(m)}{信号在信道上的传播速率(m/s)}$</p></li></ul><ol><li><p>求1000km长的光纤线路带来的传播时延？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>传播时延：$\frac{10^6m}{2.0\times10^8m/s}=5\times10^{-3}s=5ms$</p>              </div>            </details></li><li><p>收发两端之间的传输距离为1000km，信号在媒体上的传播速率为$2×10^8m/s$。试计算以下两种情况的发送时延和传播时延：</p><p>（1） 数据长度为$10^7bit$,数据发送速率为$100kb/s$。</p><p>（2） 数据长度为$10^3bit$,数据发送速率为$1Gb/s$。</p><p>（3）从上面的计算中可以得到什么样的结论？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>发送时延：$ts=\frac{10^7bit}{10^5bps}=100s$</p><p>传播时延：$tp=\frac{10^6m}{2\times10^8m/s}=5\times10^{-3}s=5ms$</p></li><li><p>发送时延：$ts=\frac{10^3bit}{10^9bps}=1\mu s$</p><p>传播时延：$tp=\frac{10^6m}{2\times10^8m/s}=5\times10^{-3}s=5ms$</p></li><li><p>结论：若数据长度大而发送速率低，则总时延中，发送时延往往大于传播时延。但若数据长度短而发送速率高，则传播时延就可能是总时延中的主要成分。</p></li></ol>              </div>            </details></li></ol><h4 id="时延带宽积">时延带宽积</h4><img src="https://oss.iuoyt.com/img/posts/image-20240628140146974.png" alt="时延带宽积" style="zoom:33%;" /><ul><li>$时延带宽积=传播时延\times带宽$</li><li>链路的时延带宽积又称为以比特为单位的链路长度。</li></ul><h3 id="信道利用率">信道利用率</h3><img src="https://oss.iuoyt.com/img/posts/image-20240628143044625.png" alt="信道利用率" style="zoom: 33%;" /><ul><li>$主机甲的信道利用率=\frac{数据帧发送时延}{从发送数据开始到收到确认帧的总时间}=\frac{a}{2a+2b}$</li></ul><h3 id="综合计算题">综合计算题</h3><ol><li><p>假设信号在媒体上的传播速度为$2×10^8m/s$，媒体长度L分别为：</p><p>（1）10cm（网络接口卡）（2）100km（城域网）</p><p>试计算出当数据率为1Mb/s和1Gb/s时在以上媒体中正在传播的比特数。</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>传播时延：$tp=\frac{0.1m}{2\times10^8m/s}=5\times10^{-10}s$</p><p>1Mb/s比特数：$5\times10^{-10}s\times10^6bps=5\times10^{-4}bit$</p><p>1Gb/s比特数：$5\times10^{-10}s\times10^9bps=0.5bit$</p></li><li><p>传播时延：$tp=\frac{10^6m}{2\times10^8m/s}=5\times10^{-4}s$</p><p>1Mb/s比特数：$5\times10^{-4}s\times10^6bps=5\times10^2bit$</p><p>1Gb/s比特数：$5\times10^{-4}s\times10^9bps=5\times10^5bit$</p></li></ol>              </div>            </details></li><li><p>长2KM、数据传输率为10Mbps的基带总线LAN，信号传播速度为200m/us，试计算：1000比特的帧从发送开始到接收信号结束的最大时间是多少？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>发送时延：$ts=\frac{1000bit}{10\times10^6bps}=10^{-4}s=100us$</p><p>传播时延：$tp=\frac{2\times10^3m}{200m/us}=10us$</p><p>总时间：$ts+tp=110us=1.1\times10^{-4}s$</p>              </div>            </details></li><li><p>长度为100字节的应用层数据交给传输层传送，需加上20字节的TCP首部。再交给网络层传送，需加上20字节的IP首部。最后交给数据链路层的以太网传送，加上首部和尾部共18字节。试求数据的传输效率？若应用层数据长度为1000字节，数据的传输效率是多少？</p> <div class="note info flat"><p>数据的传输效率是指发送的应用层数据除以所发送的总数据（即应用数据加上各种首部和尾部的额外开销）。</p></div> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li>$\frac{100}{100+20+20+18}=63.3$%</li><li>$\frac{1000}{1000+20+20+18}=94.5$%</li></ol>              </div>            </details></li><li><p>使用 HTTP、 TCP、 IP 和以太网协议栈的网络发送一个1000字节的用户消息。每个协议头是 20 个字节长。使用此消息将使网络带宽的使用率达到多少？<br>A、7%<br>B、93%<br>C、6%<br>D、94%</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>一共添加四次协议头，$\frac{1000}{1000+20\times4}=92.5$%</p>              </div>            </details></li><li><p>假定1km长的CSMA/CD网络的数据率为1Gb/s。设信号在网络上的传播速率为200000km/s。求能够使用此协议的最短帧长。</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>对于 1km 电缆，单程传播时间为$\frac{1km}{2\times10^5km/s}=5us$，往返传播时间为10us。</p><p>为了能够按照CSMA/CD工作，最小帧的发射时间不能小于10us。</p><p>以1Gb/s速率工作，10us可以发送的比特数等于：$10\times10^{-6}s\times10^9bps=10^4bit$。</p><p>因此，最短帧是10000 位或 1250 字节长</p>              </div>            </details></li><li><p>考虑一个最大距离为2km的局域网，当带宽等于多大时传播时延（传播速度为$2×10^8m/s$）等于100B分组的发送时延？<br>A、20Mbit/s<br>B、80Mbit/s<br>C、40Mbit/s<br>D、160Mbit/s</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>发送时延$ts=\frac{100B\times8}{带宽}$</p><p>传播时延$tp=\frac{2\times10^3m}{2\times10^8m/s}=10^{-5}s$</p><p>由$ts=tp$得带宽为$8\times10^7bps=80Mbps$</p>              </div>            </details></li></ol><h2 id="第二章-物理层">第二章 物理层</h2><ol><li><p>对于某带宽为4000Hz的低通信道，采用16种不同的物理状态来表示数据。按照奈奎斯特定理，信道的最大传输速率是（    ）？<br>A. 4kbit/s<br>B. 8kbit/s<br>C. 16kbit/s<br>D. 32kbit/s</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>D</p><p>根据奈氏定理，本题中$W=4000Hz$，最大码元传输速率$=2W=8000Baud$</p><p>16种不同的物理状态可表示为$\log_216=4bit$数据，即一码元携带4bit数据，所以信道的$最大传输速率=8000\times4=32kbit/s$</p>              </div>            </details></li><li><p>已知某信道的信号传输速率为64kbps，一个载波信号码元有4个有效离散值，则该信道的波特率为（    ）？<br>A. 16kBaud<br>B. 32kBaud<br>C. 64kBaud<br>D. 128kBaud</p> <div class="note info flat"><p>一个码元若取$2^n$个不同离散值，则含有n bit的信息量</p></div> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>一个波信号含有2bit的信息，波特率为$\frac{64}{2}=32kBaud$</p>              </div>            </details></li><li><p>若某通信链路的数据传输速率为2400bit／s，采用4相位调制，则该链路的波特率是（    ）<br>A、4800<br>B、600<br>C、1200<br>D、2400</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>采用4个相位，有4种不同状态组合，则一个码元可携带2bit信息量，波特率为$\frac{2400}{2}=1200Baud$</p>              </div>            </details></li><li><p>电话系统的典型参数是信道带宽为3000Hz，信噪比为30dB，则该系统的最大数据传输速率为（    ）。<br>A. 3kbit/s<br>B. 6kbit/s<br>C. 30kbit/s<br>D. 64kbit/s</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>信噪比$30dB=10\log_{10}(S/N)$，可解出$S/N=1000$。</p><p>根据香农定理$C=W log_2(1+S/N) b/s$</p><p>所以信道的最大数据传输速率：$3000\times log_2(1+1000)\approx30kbit/s$</p>              </div>            </details></li><li><p>若连接R2和R3链路的频率带宽为8kHz，信噪比为30dB，该链路实际数据传输速率约为理论最大数据传输速率的50%，则该链路的实际数据传输速率约是多少？<br>A、20kbps<br>B、40kbps<br>C、80kbps<br>D、8kbps</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>信噪比$30dB=10\log_{10}(S/N)$，所以$S/N=1000$。</p><p>根据香农定理$C=W log_2(1+S/N) b/s$</p><p>所以信道的最大数据传输速率：$8000\times log_2(1+1000)\approx80kbps$​</p><p>实际速率为$40kbps$</p>              </div>            </details></li></ol><h2 id="第三章-数据链路层">第三章 数据链路层</h2><h3 id="首尾标记法中的位填充">首尾标记法中的位填充</h3><ul><li><p>每一帧使用一个特殊的位模式“01111110”作为开始和结束标记。该位模式又称为“flag”。</p></li><li><p>在首尾标记法中，由于数据中可能会出现与标记相同的位串，从而干扰帧的正常定界。比特(位)填充法可用于解决上述问题。即发送端在数据中若遇到5个连续的“1”时，则在其后自动插入一个“0”。该技术简称“逢五1插0”；接收端则忽略5个连续的“1”后面的“0”，简称“逢五1删0” 。</p>  <img src="https://oss.iuoyt.com/img/posts/image-20240628145400494.png" alt="首尾标记法中的位填充" style="zoom:33%;" /></li></ul><ol><li><p>内容：10011 01110 11111 01001 11111 10010，实际发送和实际接收如何做处理？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>在收尾添加开始和结束标记：</p><p><span style="color:blue">01111110</span> 100110111011111010011111110010 <span style="color:blue">01111110</span>（发送数据）</p></li><li><p>0比特插入：</p><p><span style="color:blue">01111110</span> 100110111011111<span style="color:red"><u>0</u></span>010011111<span style="color:red"><u>0</u></span>110010 <span style="color:blue">01111110</span>（实际发送、实际接收）</p></li><li><p>0比特删除：</p><p><span style="color:blue">01111110</span> 100110111011111010011111110010 <span style="color:blue">01111110</span>（接收数据）</p></li></ol>              </div>            </details></li><li><p>在采用零比特填充的链路层传输中，比特串0111101111110装帧发送出去的串为（   ）<br>A、011110111110100<br>B、01111011111010<br>C、0111101111110<br>D、00111101111110</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div></li></ol><h3 id="循环冗余码CRC（多项式校验）">循环冗余码CRC（多项式校验）</h3><ul><li>工作原理：模2除法，将余式作为冗余信息传送（冗余码FCS：帧检验序列）</li><li>选定的生成多项式（生成码）作为除数，在发送序列后添加生成多项式位数减一个0作为被除数，列竖式计算余数，则为冗余码。</li></ul><ol><li><p>发送的二进制序列：110011（$x^5+x^4+x+1$），选取生成多项式：11001（$x^4+x^3+1$）<br>（1）求冗余码和发送序列<br>（2）判断接收码字为1100111001时的正确性</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>①被除式为：1100110000（$x^9+x^8+x^5+x^4$）</p><p>②列式计算</p> <img src="https://oss.iuoyt.com/img/posts/image-20240628153544771.png" alt="image-20240628153544771" style="zoom: 50%;" /><p>③冗余码：1001，发送序列：110011 1001</p><ol start="2"><li>用接收到的帧除以生成码（模2运算），被除数是1100111001，除数P=11001，结果余数为0，所以码字正确。</li></ol></li></ol>              </div>            </details></li><li><p>一串数据10111110111011001使用CRC校验方式，已知校验使用的二进制数为110101，生成多项式是什么？发送序列是什么？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li>$x^5+x^4+x^2+1$</li><li>10111110111011001 <span style="color:red">00101</span></li></ol>              </div>            </details></li></ol><h3 id="交换机的两种用法">交换机的两种用法</h3><img src="https://oss.iuoyt.com/img/posts/image-20240628153801420.png" alt="交换机两种用法" style="zoom:50%;" /><ul><li><p>端口下接站点：站点独占10Mbps带宽</p><p>端口下接网段：网段中所有站点共享10Mbps带宽</p></li></ul><ol><li><p>假如10个站通过一个10Mb/s的集线器相连，每一个站平均得到的带宽为（）bps？如10个站通过一个100Mb/s的交换机相连，每一个站能得到的带宽为（ ）bps？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li>通过集线器相连，各个站共享带宽，分别$1Mbps=10^6bps$</li><li>直连交换机，各个站独享完整带宽，$100Mbps=10^8bps$</li></ol>              </div>            </details></li></ol><h3 id="交换机的自学习算法">交换机的自学习算法</h3><ol><li><p>分析完成如下过程后，S1和S2的交换表内容分别是什么？</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240628153926609.png" alt="自学习算法"></p><ul><li>A 向 B 发送了一帧</li><li>C 向 E 发送了一帧</li><li>E 向 A 发送了一帧</li></ul> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p><img src="https://oss.iuoyt.com/img/posts/image-20240628154053421.png" alt="image-20240628154053421"></p>              </div>            </details></li></ol><h2 id="第四章-网络层">第四章 网络层</h2><h3 id="IP数据报的分片与重组">IP数据报的分片与重组</h3><ol><li><p>一个数据报长度为1420字节（固定首部长度）。现在经过一个网络传送，但此网络能够传送的最大数据长度是620字节。<br>（1）应当划分为几个短些的数据报片<br>（2）各数据报片的数据字段长度、片偏移字段、MF标志和DF标志为何数值？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>分3个数据报片</p></li><li><p>片1数据字段长度600字节，片偏移0，MF=1，DF=0</p><p>片2数据字段长度600字节，片偏移75，MF=1，DF=0</p><p>片3数据字段长度200字节，片偏移150，MF=0，DF=0</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240628155626004.png" alt="image-20240628155626004"></p></li></ol>              </div>            </details></li><li><p>一个数据报长度为4000字节（固定首部长度）。现在经过一个网络传送，但此网络能够传送的最大数据长度是1500字节。<br>（1）应当划分为几个短些的数据报片<br>（2）各数据报片的数据字段长度、片偏移字段和MF标志为何数值？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>分3个数据报片</p></li><li><p>片1数据字段长度1480字节，片偏移0，MF=1</p><p>片2数据字段长度1480字节，片偏移1480/8=185，MF=1</p><p>片3数据字段长度1020字节，片偏移2960/8=370，MF=0</p></li></ol>              </div>            </details></li></ol><h3 id="划分子网">划分子网</h3><ol><li><p>一企业内部网IP为192.168.1.0/24，最大一个部门需要30台主机，请问该如何划分。</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>$2^5-2=30$，所以5位主机位，3位子网划分位。<br>子网掩码为：255.255.255.224<br>$2^3=8$，所以可划分8个子网：<br>192.168.1.0<br>192.168.1.32<br>192.168.1.64<br>192.168.1.96<br>192.168.1.128<br>192.168.1.160<br>192.168.1.192<br>192.168.1.224</p>              </div>            </details></li><li><p>假如正在构建一个有22个子网的B类网络，但不久后该网络有可能会增至80个子网，同时每个子网要求支持至少300个主机，那么应该选择下面哪个子网掩码？（   ）<br>A、255.255.0.0<br>B、 255.255.254.0<br>C、255.255.255.0<br>D、255.255.248.0</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>$2^9-2\gt300$​，所以9位子网位。</p><p>$(11111110)_2=254$</p><p>子网掩码为：255.255.254.0</p>              </div>            </details></li><li><p>IP地址212.110.24.169/27所在子网段的网络地址是（   ）。<br>A、212.110.24.168<br>B、212.110.0.0<br>C、212.110.24.160<br>D、212.110.24.0</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>5位作为主机位，$169=(10101001)_2$，保留前3位后$(10100000)_2=160$</p>              </div>            </details></li><li><p>把网络202.112.78.0划分为多个子网（子网掩码是255.255.255.192），则各子网中可用的主机地址总数是（    ）<br>A、64<br>B、128<br>C、126<br>D、62</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div></li><li><p>某公司申请到一个C类网络，由于有地理位置上的考虑必须切割成5个子网，请问子网掩码要设为（   ）。<br>A、255.255.255.224<br>B、255.255.255.192<br>C、255.255.255.254<br>D、255.285.255.240</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div></li><li><p>IP地址67.198.30.120/30的子网掩码是（  ）。<br>A、255.255.255.252<br>B、255.255.0.0<br>C、255.255.255.240<br>D、255.255.255.0</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>A</p><p>剩余2位用来分配主机，子网分配使用6位，$(11111100)_2=252$</p>              </div>            </details></li><li><p>IP地址40.178.30.120/30的子网号位数是（   ）。<br>A、30<br>B、22<br>C、16<br>D、8</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>A类IP地址的默认掩码是8位，子网号位数为30-8=22位</p>              </div>            </details></li><li><p>某网络192.168.0.0，要划分4个子网，试回答下面问题。</p><p>子网掩码为？</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：255.255.255.192</p></div></div><p>第一个子网地址？</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：192.168.0.0</p></div></div><p>第一个子网的广播地址？</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：192.168.0.63</p></div></div><p>第二个子网地址？</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：192.168.0.64</p></div></div><p>第三个子网的第一个有效IP地址？</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：192.168.0.129</p></div></div></li></ol><h3 id="构造超网">构造超网</h3><ol><li><p>有如下的4个/24地址块，试进行最大可能性的聚合<br>①212.56.132.0/24<br>②212.56.133.0/24<br>③212.56.134.0/24<br>④212.56.135.0/24</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>$212= (11010100)_2，56= (00111000)_2$<br>$132= ($<span style="color:red">$100001$</span>$00)_2$<br>$133= ($<span style="color:red">$100001$</span>$01)_2$<br>$134= ($<span style="color:red">$100001$</span>$10)_2$<br>$135= ($<span style="color:red">$100001$</span>$11)_2$</p><p>所以共同的前缀有22位，即11010100 00111000 100001，聚合的CIDR地址块是： 212.56.132.0/22</p>              </div>            </details></li><li><p>设有2条路由21.1.193.0/24和21.1.194.0/24，如果进行路由汇聚，覆盖这2条路由的地址是（     ）。<br>A、21.1.200.0/22<br>B、21.1.192.0/23<br>C、21.1.192.0/21<br>D、21.1.224.0/20</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>$193=(11000001)_2$<br>$194=(11000010)_2$​​</p><p>$192= ($<span style="color:red">$110000$</span>$00)_2$</p>              </div>            </details></li></ol><h2 id="第五章-运输层">第五章 运输层</h2><ol><li><p>TCP发送一段数据报，其序号是35～150，如果正确到达，接收方对其确认的序号为（    ）。<br>A. 36<br>B. 150<br>C. 35<br>D. 151</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div></li><li><p>主机A通过TCP连接向主机B连续发送两个TCP数据报，第一个数据报序号为20，第一个数据报序号为80，则<br>（1）第一个数据报中有多少数据？<br>（2）假定第一段数据报丢失而第二段报文到达主机B，B发往主机A的确认报文中确认号应该是多少？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li>80-20=60字节</li><li>确认号为20</li></ol>              </div>            </details></li><li><p>主机甲与主机乙之间建立了一个TCP连接，主机甲向主机乙发送了3个连续的TCP段，分别包含300B，400B和500B的有效载荷，第3个段的序号为900，若主机乙仅正确收到第1和第3个段，则主机乙发送给主机甲的确认序号是多少？<br>A、300<br>B、1200<br>C、500<br>D、1400</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>从 “第3个段的序号为900 “，可以推断出初始序列号是$900-(300+400)=200$，所以，第二个数据段的序列号应该是$200+300=500$。第二个数据段没有被B正确接收，所以B的ACK=500，告诉A从500序列号开始传输。</p>              </div>            </details></li><li><p>当 TCP 接收端获得一个有效载荷大小 是1000和序列号为8000 的数据段时，有效载荷中的最后一个字节相关联的序列号是多少？<br>A、9000<br>B、8000<br>C、7999<br>D、8999</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div></li></ol>]]></content>
    
    
    <summary type="html">计算机网络期末考试考点知识总结（计算题）</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学期总结" scheme="https://www.iuoyt.com/tags/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
    <category term="计算机网络" scheme="https://www.iuoyt.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络期末复习</title>
    <link href="https://www.iuoyt.com/posts/4b6174b7.html"/>
    <id>https://www.iuoyt.com/posts/4b6174b7.html</id>
    <published>2024-06-27T01:10:31.000Z</published>
    <updated>2024-06-28T13:28:34.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章">第一章</h2><h3 id="体系结构">体系结构</h3><h3 id="服务与协议">服务与协议</h3><h3 id="交换技术">交换技术</h3><h2 id="物理层">物理层</h2><h3 id="编码-解码">编码-解码</h3><h3 id="调制-解调">调制-解调</h3><h3 id="通信方式">通信方式</h3><h3 id="复用技术">复用技术</h3><h3 id="传输介质">传输介质</h3><h2 id="数据链路层">数据链路层</h2><h3 id="CSMA-CD">CSMA/CD</h3><h3 id="CSMA-CA">CSMA/CA</h3><h3 id="CRC">CRC</h3><h3 id="网卡">网卡</h3><h3 id="交换机（自学习）">交换机（自学习）</h3><h2 id="网络层">网络层</h2><h3 id="ARP">ARP</h3><h3 id="ICMP">ICMP</h3><h3 id="RIP（路由更新）">RIP（路由更新）</h3><h3 id="VPN">VPN</h3><h3 id="NAT">NAT</h3><h3 id="划分子网-构造超网（路由器转发分组）">划分子网-构造超网（路由器转发分组）</h3><h2 id="运输层">运输层</h2><h3 id="TCP">TCP</h3><h3 id="可靠传输">可靠传输</h3><h3 id="拥塞控制">拥塞控制</h3><h2 id="应用层">应用层</h2><h3 id="DNS">DNS</h3><h3 id="HTTP">HTTP</h3><h3 id="电子邮件协议">电子邮件协议</h3><h3 id="WWW">WWW</h3><h3 id="DHCP">DHCP</h3><h2 id="无线局域网">无线局域网</h2><h3 id="WLAN组成">WLAN组成</h3><h3 id="暴露站-隐蔽站问题">暴露站/隐蔽站问题</h3>]]></content>
    
    
    <summary type="html">计算机网络期末考试考点知识总结</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学期总结" scheme="https://www.iuoyt.com/tags/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
    <category term="计算机网络" scheme="https://www.iuoyt.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>大学物理重要概念及考点参考</title>
    <link href="https://www.iuoyt.com/posts/22cfe9dd.html"/>
    <id>https://www.iuoyt.com/posts/22cfe9dd.html</id>
    <published>2024-06-20T03:20:01.000Z</published>
    <updated>2024-06-24T03:33:12.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重要概念及公式">重要概念及公式</h2><h3 id="质点力学与运动学（动量守恒部分）">质点力学与运动学（动量守恒部分）</h3><ul><li><p>位矢[$r$]（矢量）：在空间中任选一点参考点，由参考点引向质点所在位置的矢量</p></li><li><p>位移[$\Delta r$]（矢量）：质点位置变动的大小和方向</p></li><li><p>路程[$S$​]（标量）：质点在其轨迹上经过路径的总长度</p></li><li><p>平均速度[$\bar{v}$]（矢量）：位置矢量对时间的平均变化率</p><p>$\bar{v}=\frac{\Delta r}{\Delta t}$</p></li><li><p>速度/瞬时速度[$v(m/s)$]（矢量）：位矢对时间的变化率或一阶导数</p><p>$v=\lim_{\Delta t \to 0} \frac{\left | \Delta r \right | }{\Delta t}=\left | \frac{\mathrm{d}r}{\mathrm{d}t} \right | $</p></li><li><p>加速度[$\bar{a}(m/s^2)$]（矢量）：反应速度变化快慢</p><p>$\bar{a}=\frac{\Delta v}{\Delta t}$</p></li><li><p>牛顿第一定律：任何物体都保持静止或匀速直线运动状态，直到其他物体所作用的力迫使它改变这种状态为止。</p></li><li><p>牛顿第二定律：物体受到外力作用时，它所获得的加速度的大小与合外力的大小成正比，而与物体的质量成反比；加速度的方向与合外力的方向相同。</p><p>$F=ma$</p></li><li><p>牛顿第三定律：作用力与反作用力，大小相等方向相反，$F=-F’$​</p></li><li><p>万有引力：物体之间的吸引力（引力常量$G=6.67\times10^{-11}N.m^2/kg^2$，质量$m_1,m_2$，距离$r$，单位矢量$e_r$，由$m_1$指向$m_2$为正）</p><p>$F=-G\frac{m_1m_2}{r^2}e_r$</p></li><li><p>重力[$P$]（矢量）：地球对地面附近物体的万有引力，方向指向地球中心</p></li><li><p>重力加速度[$g$]（矢量）：重力作用下物体的加速度</p><p>$g=\frac{P}{m}$，万有引力定律得到=&gt;$g=G\frac{m_E}{R^2}$（地球质量$m_E$，地球半径$R$）</p></li><li><p>弹性力（矢量）：两弹性固体互相接触时施加的作用力</p><p>$F=-kx$（弹簧弹性系数$k$，弹簧伸长量$x$）</p></li><li><p>摩擦力[$F_f$]（矢量）：两个相互接触的物体有相对滑动趋势但还没有相对滑动时产生阻碍相对滑动的力</p><p>$F_f=\mu F_N$（动摩擦因数$\mu$，物体正压力$F_N$​，方向与相对运动方向相反）</p></li><li><p>功[$A(J)$]（标量）：</p><ul><li><p>恒力沿直线路径做功：$A=F\cos\theta\left | \Delta r\right |=F·\Delta r$</p></li><li><p>变力沿曲线路径做功：质点由a到b过程中每一小段做功之和，$A=\int_{a}^{b}\mathrm{d}A =\int_{a}^{b}F·\mathrm{d}r=\int_{a}^{b}F\cos\theta\left | \mathrm{d}r\right |$​</p><p>直角坐标系中：$A=\int_{a}^{b}F·\mathrm{d}r=\int_{a}^{b}F_x\mathrm{d}x+F_y\mathrm{d}y+F_z\mathrm{d}z$</p></li></ul></li><li><p>功率[$P(W)$]（标量）：表示物体做功的快慢</p><p>$\bar{P}=\frac{\Delta A}{\Delta t}$，$P=\lim_{\Delta t \to 0}\frac{\Delta A}{\Delta t}=\frac{\mathrm{d}A}{\mathrm{d}t}=F·v$</p></li><li><p>动能[$E_k(J)$]（标量）：质点运动而具有的能量</p><p>$E_k=\frac{1}{2}mv^2$​</p></li><li><p>动能定理（牛二导出）：F对质点做的功为$A=E_k-E_{k_0}=\frac{1}{2}mv^2-\frac{1}{2}mv_0^2$</p></li><li><p>势能[$E_p(J)$]（标量）：大小是相对的，与选择的零点有关，等于保守力做功的负值</p><p>$\Delta E_p=E_p-E_{p_0}=-A_保$​</p><ul><li>重力势能：$E_p=mgh$​</li><li>弹性势能：$E_p=\frac{1}{2}kx^2$</li><li>引力势能：$E_p=-G\frac{m_1m_2}{r}$​</li></ul></li><li><p>机械能守恒定律：当所有作用于系统的外力对系统所做的功为零且非保守内力所做的功也为零时，系统的机械能恒定不变</p></li><li><p>冲量[$I(N·s)$]（矢量）：恒力与作用时间的乘积</p><p>恒力：$I=F(t-t_0)$</p><p>变力：$I=\lim_{\Delta t_i\to0}\sum F_i\Delta t_i=\int_{t_0}^{t}F\mathrm{d}t$​</p><p>合力：$I=\int_{t_0}^tF\mathrm{d}t=\int_{t_0}^t(\sum_{i=1}^{n}F_i)\mathrm{d}t=\sum_{i=1}^{n}\int_{t_0}^tF_i\mathrm{d}t=\sum_{i=1}^nI_i$（合力在一段作用时间内的冲量等于各分力在同一作用时间内冲量的矢量和，其方向和各分力在同一作用时间内冲量的矢量和的方向相同）</p></li><li><p>动量[$p(kg·m/s)$]（矢量）：$p=mv$​</p></li><li><p>动量定理：作用在质点上的合力$F$在$\mathrm{d}t$​时间间隔内的元冲量等于质点动量的增量</p><p>$\mathrm{d}p=F\mathrm{d}t$​</p></li><li><p>动量守恒定律：在一段时间内作用于质点的合力始终为零时，质点的动量为常矢量</p><p>$\int_{t_0}^t(\sum_iF_{i外})\mathrm{d}t=\sum_ip_i-\sum_ip_{i0}=0$​</p></li><li><p>力矩[$M(N·m)$]（矢量）：位置矢量$r$与力$F$的乘积</p><p>$M=rFsin\theta$​</p></li><li><p>角动量[$L(kg·m^2/s)$]（矢量）：描述圆周运动物体的运动状态</p><p>$L=rmv\sin\theta$​</p></li><li><p>角动量定理：作用于质点的合力对参考点的力矩等于质点对该点的角动量随时间的变化率</p><p>$M=\frac{\mathrm{d}L}{\mathrm{d}t}$​</p></li><li><p>角动量守恒定律：当质点系相对于某一给定参考点的合外力矩为零时，该质点系相对于该给定参考点的角动量矢量保持不变</p></li></ul><h3 id="刚体定轴转动（转动惯量部分）">刚体定轴转动（转动惯量部分）</h3><ul><li><p>角速度[$\omega(rad/s)$]（矢量）：$\omega=\lim_{\Delta t\to 0}\frac{\Delta\theta}{\Delta t}=\frac{\mathrm{d}\theta}{\mathrm{d}t}$，方向：右手螺旋定则​</p></li><li><p>线速度[$v(m/s)$]（标量）：$v=\omega r$</p></li><li><p>角加速度[$\alpha(rad/s^2)$]（标量）：$\omega=\lim_{\Delta t\to 0}\frac{\Delta\omega}{\Delta t}=\frac{\mathrm{d}\omega}{\mathrm{d}t}=\frac{\mathrm{d}^2\theta}{\mathrm{d}t^2}$</p></li><li><p>转动惯量[$I$]：$I=\sum\Delta m_ir_i^2$，积分形式：$I=\int_mr^2\mathrm{d}m$​</p></li><li><p>平行轴定理：若两轴平行，其中一轴过质心，则刚体对两轴的转动惯量的关系为$I=I_c+md^2$​</p></li><li><p>垂直轴定理：无限小厚度的薄板对一与它垂直的坐标轴的转动惯量，等于薄板对板面内另两直角坐标轴的转动惯量之和。若z轴与薄板垂直，Oxy面在薄板内，则有$I_z=I_x+I_y$​</p></li><li><p>组合定理：几个刚体对同一转轴的转动惯量等于各刚体对此转轴的转动惯量之和，即$I=\sum_iI_i$​</p></li><li><p>几种常见刚体的转动惯量</p>  <img src="https://oss.iuoyt.com/img/posts/image-20240623174615431.png" alt="几种常见刚体的转动惯量" style="zoom:50%;" /></li></ul><h3 id="静电场">静电场</h3><ul><li><p>元电荷$e\approx1.602\times10^{-19}C$</p></li><li><p>库仑定律：真空中两个静止的点电荷之间的相互作用力的大小与这两个电荷所带电荷量$q_1$和$q_2$的乘积成正比，与它们之间距离$r$的平方成反比， 作用力的方向沿着两个点电荷的连线，同号电荷相斥，异号电荷相吸。</p><p>$F_{12}=k\frac{q_1q_2}{r_{12}^2}=\frac{q_1q_2}{4\pi\epsilon_0r_{12}^2}e_{r_{12}}$​</p></li><li><p>电场强度[$E(N/C或者V/m)$]：$E=\frac{F}{q_0}$​</p></li></ul><h3 id="简谐振动">简谐振动</h3><ul><li>速度[$v$]：$v=-A\omega\sin(\omega t+\varphi)$，$v=\frac{1}{T}=\frac{\omega}{2\pi}$</li><li>加速度[$a$]：$a=\frac{\mathrm{d}v}{\mathrm{d}t}=-A\omega^2\cos(\omega t+\varphi)=-\omega^2x$</li><li>振幅[$A$]：$A=\sqrt{x_0^2+\frac{v_0^2}{\omega^2}}$</li><li>周期[$T$]：$T=\frac{2\pi}{\omega}$，弹簧振子$T=2\pi\sqrt{\frac{m}{k}}$</li><li>角速度[$\omega$]：$\omega=2\pi v$</li><li>初相[$\varphi$]：$\varphi=\arctan(-\frac{v_0}{\omega x_0})$</li></ul><h2 id="重要考点">重要考点</h2><h3 id="动量守恒（1-5-3）">动量守恒（1.5.3）</h3><ol><li><p>例题1.7（P26）</p><blockquote><p>力$F=6ti$（SI单位）作用在$m=3kg$的质点上，质点沿x轴运动，$t=0$时$v_0=0$，求前2s内力F的冲量和力F对m所做的功。</p></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>由质点动量定理可得，力F的冲量为</p><p>$I=\int_0^tF\mathrm{d}t=\int_0^26t\mathrm{d}t=3t^2\Big|_0^2=12N·s$​</p><p>方向沿x轴正向，因为$I=mv-mv_0=mv$</p><p>所以$v=\frac{I}{m}=\frac{12}{3}m/s=4m/s$</p><p>浴室由质点的动能定理可得，力F对m所做的功为</p><p>$A=E_k-E_{k_0}=\frac{1}{2}mv^2-\frac{1}{2}mv^2_0=\frac{1}{2}mv^2=24J$</p>              </div>            </details></li><li><p>例题1.8（P26）</p><blockquote><p>一静止的物体炸裂成三块，其中两块具有相等的质量，且以相同速率$30m/s$沿相互垂直的方向飞开，第三块的质量恰好等于前两块质量之和，求第三块的速度。</p><img src="https://oss.iuoyt.com/img/posts/image-20240623155358223.png" alt="例题1.8图" style="zoom: 33%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>物体的初动量等于零，炸裂时爆炸力为内力，其远大于重力，所以在爆炸过程中，可以利用动量守恒求其近似解。根据动量守恒定律知道，物体分裂为三块后，这三块碎片的动量总和仍然等于零，即</p><p>$m_1v_1+m_2v_2+m_3v_3=0$</p><p>因此，这三个动量必处于同一个平面内，且第三块的动量必和第一、二块的合动量大小相等、方向相反。</p><p>因为$v_1$和$v_2$相互垂直，所以</p><p>$(m_3v_3)^2=(m_1v_1)^2+(m_2v_2)^2$</p><p>由于$m_1=m_2=m,m_3=2m$，所以$v_3$的大小为</p><p>$v_3=\frac{1}{2}\sqrt{v_1^2+v_2^2}=\frac{1}{2}\sqrt{30^2+30^2}m/s\approx21.2m/s$​</p><p>$v_3$与$v_1$所成之角$\alpha$由$\alpha=180°-\theta$决定，因为$\tan\theta=\frac{v_2}{v_1}=1,\theta=45°$，所以$\alpha=135°$</p><p>即$v_3$与$v_1$及$v_2$都成$135°$角，且三者在同一平面内。</p>              </div>            </details></li><li><p>例题1.9（P30）</p><blockquote><p>如图所示，水平放置的光滑桌面中间有一光滑小孔，轻绳一端伸入孔中，另一端系一质量为$10g$的小球，小球沿半径为$40cm$的园周做匀速圆周运动，此时从小孔下拉绳的力为$10^{-3}N$。如果继续向下拉绳，并使小球沿半径为$10cm$的园周做匀速圆周运动，那么此时小球的速率为多少？拉力所做的功是多少？</p><img src="https://oss.iuoyt.com/img/posts/image-20240623161749283.png" alt="例题1.9" style="zoom:33%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>以小球为研究对象，根据题意，由于轻绳作用在小球上的力始终通过小孔即圆周运动的中心，为有心力，所以小球受轻绳的拉力大小对小孔的力矩始终为零。因此，在小球整个运动过程中角动量守恒。设小球质量为m，圆周运动半径$r_0=40cm$时其运动速率为$v$，则角动量守恒定律可得</p><p>$mv_0r_0=mvr$</p><p>又由于轻绳对小球的拉力等于小球圆周运动的向心力，所以有</p><p>$F=\frac{mv_0^2}{r_0}$</p><p>由以上两式可得</p><p>$v_0=\sqrt{\frac{Fr_0}{m}}=\sqrt{\frac{10^{-3}\times 40\times 10^{-2}}{10\times10^{-3}}}m/s=0.2m/s$</p><p>$v=\frac{r_0}{r}v_0=\frac{40}{10}\times 0.2m/s=0.8m/s$</p><p>再由质点的动能定理可得，轻绳拉力所做的功为</p><p>$A=\frac{1}{2}mv^2-\frac{1}{2}mv_0^2=\frac{1}{2}m(v^2-v_0^2)=\frac{1}{2}\times 10\times 10^{-3}\times(0.8^2-0.2^2)J=3.0\times10^{-3}J$</p>              </div>            </details></li><li><p>例题1.10（P31）</p><blockquote><p>如图所示，我国第一颗人造卫星“东方红”绕地球运行的轨道为一椭圆，地球的中心$O$在椭圆的一个焦点上。已知地球的平均半径为$R=6.371\times10^6m$，卫星在近地点A时，距地面的距离为$l_1=4.39\times10^5$，速率为$v_1=8.1\times10^3m/s$，在远地点B时距离地面的距离$l_2=2.384\times10^6m$，求卫星在远地点B时的速率$v_2$。</p><img src="https://oss.iuoyt.com/img/posts/image-20240623162959885.png" alt="例题1.10" style="zoom: 50%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>由于卫星在轨道上运动受地球的引力始终指向地心$O$，引力对地心$O$的力矩为零，所以卫星对地心$O$的角动量守恒</p><p>卫星在近地点的角动量为$L_1=mv_1(R+l_1)$</p><p>卫星在远地点的角动量为$L_2=mv_2(R+l_2)$​</p><p>因为角动量守恒，所以$mv_1(R+l_1)=mv_2(R+l_2)$</p><p>于是$v_2=v_1\frac{R+l_1}{R+l_2}$</p><p>将$R、l_1、l_2、v_1$代入，得</p><p>$v_2=v_1\frac{R+l_1}{R+l_2}=\frac{(6.371\times10^6+4.39\times10^5)\times8.1\times10^3}{6.371\times10^+2.384\times10^6}m/s\approx6.30\times10^3m/s$</p>              </div>            </details></li><li><p>例题1.11（P34）</p><blockquote><p>如图所示，两个质量均为m的小球A与B分别悬挂在长度为$2l$和$l$的轻质细绳上，两球碰撞时的恢复系数$e=0.414$。球A与竖直方向的夹角为$\theta$位置处静止释放，下落到竖直方向时与球B正碰，刚好使球B到达与竖直方向的夹角为60°的位置处，那么$\theta$应为多大？</p><img src="https://oss.iuoyt.com/img/posts/image-20240623164218976.png" alt="例题1.11" style="zoom:33%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>以地球为参考系，问题可分解为三个过程：</p><p>碰前：球A从$\theta$角位置处静止释放，夏洛到竖直方向还没与球B碰撞的过程。以球A和地球为研究系统，该过程中只有重力做功，系统的机械能守恒。取落至竖直位置时球A的速度大小为$v$，方向水平向左，则由系统的机械能守恒定律得</p><p>$\frac{1}{2}mv^2=mg·2l(1-\cos\theta) ······①$</p><p>碰时：球A与球B碰撞发生非完全弹性碰撞，可以用动量守恒定律近似求解。设碰后球A与球B的速度大小分别为$v_A、v_B$并水平向左，则由动量守恒定律，得</p><p>$mv_A+mv_B=mv······②$</p><p>由碰撞定律可得$e=\frac{v_B-v_A}{v}······③$</p><p>碰后：球B从竖直方向达到与竖直方向呈60°夹角位置处的过程。以球B和地球为研究系统，该过程中只有重力做功，系统的机械能守恒。取竖直位置时球B所在之处为重力势能零点，则由系统的机械能守恒定律得</p><p>$\frac{1}{2}mv_B^2=mg·l(1-\cos60°)······④$</p><p>将式①~④联立代入数据得</p><p>$\cos\theta=1-\frac{1}{(1-e)^2}=1-\frac{1}{(1+0.414)^2}\approx\frac{1}{2}$​</p><p>所以$\theta=60°$</p>              </div>            </details></li></ol><h3 id="转动惯量（2-2-3）">转动惯量（2.2.3）</h3><ol><li><p>例题2.2（P47）</p><blockquote><p>如图所示为质量为$m$，长度为$l$的均匀细棒AB，求该细棒对下两种转轴的转动惯量：</p><ol><li>转轴通过棒的中心并和棒垂直（a）</li><li>转轴通过棒的一端并和棒垂直（b）</li></ol><img src="https://oss.iuoyt.com/img/posts/image-20240623165537774.png" alt="例题2.2" style="zoom: 50%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <ol><li><p>取坐标系如图(a)所示，在棒上距原点$x$处取一长度元$\mathrm{d}x$，设棒的质量线密度为$\lambda$，则该长度元的质量$\mathrm{d}m=\lambda\mathrm{d}x=\frac{m}{l}\mathrm{d}x$。由转动惯量定义，此时棒的转动惯量为</p><p>$I_C=\int_{-\frac{l}{2}}^{\frac{l}{2}}x^2\mathrm{d}m=2\int_{0}^{\frac{l}{2}}x^2\frac{m}{l}\mathrm{d}x=\frac{1}{12}ml^2$​</p></li><li><p>当转轴通过棒的一端并和棒垂直时，取坐标系如(b)所示，此时棒的转动惯量为</p><p>$I_A=\int_0^lx^2\frac{m}{l}\mathrm{d}x=\frac{1}{3}ml^2$</p><p>上述结果表明，同一个物体对于不同的转轴，其转动惯量不同，可见转动惯量与转轴位置有关。由于通过棒的中心并和棒垂直的转轴与通过棒的一端并和棒垂直的转轴之间的垂直距离为$\frac{l}{2}$，应用平行轴定理，有</p><p>$I_A=I_C+m(\frac{l}{2})^2=\frac{1}{12}ml^2+\frac{1}{4}ml^2=\frac{1}{3}ml^2$</p></li></ol>              </div>            </details></li><li><p>例题2.3（P48）</p><blockquote><p>如图所示，求半径为R、质量为m的均匀薄圆环绕垂直环面通过中心转轴的转动惯量。若把圆环改为圆盘，其他条件都不变，试再求之。</p><img src="https://oss.iuoyt.com/img/posts/image-20240623172450461.png" alt="例题2.3" style="zoom:50%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>由于均匀薄圆环中的所有质元都离轴等距离，R为常量。故由转动惯量定义，有</p><p>$I=\int r^2\mathrm{d}m=R^2\int \mathrm{d}m=mR^2$</p><p>若把圆环改为圆盘，由于圆盘可看成由许多半径不同的同心圆环组成，在圆盘上取一半径为$r$，宽度为$\mathrm{d}r$的圆环，其面积$\mathrm{d}S=2\pi r\mathrm{d}r$，其质量$\mathrm{d}m=\sigma\mathrm{d}S$，其中$\sigma=\frac{m}{\pi R^2}$是圆盘的质量面密度。由此，小圆环对转轴的转动惯量为</p><p>$\mathrm{d}I=r^2\mathrm{d}m=r^2\sigma\mathrm{d}S=\frac{2m}{R^2}r^3\mathrm{d}r$</p><p>于是整个圆盘对转轴的转动惯量为</p><p>$I=\int_mr^2\mathrm{d}m=\frac{2m}{R^2}\int_0^Rr^3\mathrm{d}r=\frac{1}{2}mR^2$</p>              </div>            </details> <details class="folding-tag" ><summary> 几种常见刚体的转动惯量 </summary>              <div class='content'>              <img src="https://oss.iuoyt.com/img/posts/image-20240623174615431.png" alt="几种常见刚体的转动惯量" style="zoom:50%;" />              </div>            </details></li></ol><h3 id="简谐振动运动学方程（8-1-2）">简谐振动运动学方程（8.1.2）</h3><ol><li><p>例题8.1(P238)</p><blockquote><p>一物体沿x轴做简谐振动，平衡位置在坐标原点O，振幅$A=0.06m$，周期$T=2s$，当$t=0$时，物体的位移$x=0.03m$，且向x轴正方向运动。求：</p><ol><li>此简谐振动的运动学方程</li><li>$t=0.5s$时物体的位移、速度和加速度</li></ol></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <ol><li><p>设该简谐振动的运动学方程为$x=A\cos(\omega t+\varphi)$</p><p>则速度为$v=-A\omega\sin(\omega t+\varphi)$</p><p>式中，$A=0.06m,\omega=\frac{2\pi}{T}=\pi\mathrm{rad/s}$，将二者与初始条件$t=0$时，$x=0.03m$代入振动的运动学方程得$0.03=0.06\cos\varphi$</p><p>解得$\cos\varphi=\frac{1}{2},\varphi=\pm\frac{\pi}{3}$</p><p>又因为$t=0$时，物体向x轴正方向运动，即$v=-A\omega\sin\varphi\gt0$</p><p>所以初相位应取$\varphi=-\frac{\pi}{3}$</p><p>因此该振动的运动学方程为$x=0.06\cos(\pi t-\frac{\pi}{3})$（SI单位）</p></li><li><p>当$t=0.5s$时，物体的位移为</p><p>$x=0.06\cos(0.5\pi-\frac{\pi}{3})\mathrm{m}=0.03\sqrt{3}\mathrm{m}\approx0.052\mathrm{m}$</p><p>物体的速度为</p><p>$v=-0.06\pi\sin(0.5\pi-\frac{\pi}{3})\mathrm{m/s}=-0.03\pi\mathrm{m/s}\approx-0.094\mathrm{m/s}$</p><p>物体的加速度为</p><p>$a=-0.06\pi^2\cos(0.5\pi-\frac{\pi}{3})\mathrm{m/s^2}=0.03\sqrt{3}\pi^2\mathrm{m/s^2}\approx-0.51\mathrm{m/s^2}$</p></li></ol>              </div>            </details></li><li><p>例题8.2（P241）</p><blockquote><p>质量为0.2kg的物体，以振幅$A=5cm$做简谐振动，其最大加速度$a_{max}=0.2\mathrm{m/s^2}$</p><ol><li>求振动的周期</li><li>求通过平衡位置时的动能</li><li>求总能量</li><li>物体在何处动能和势能相等</li></ol></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <ol><li><p>因为$a_{max}=A\omega^2$，所以</p><p>$\omega=\sqrt{\frac{a_{max}}{A}}=\sqrt{\frac{0.2}{0.05}}\mathrm{rad/s}=2\mathrm{rad/s}$</p><p>浴室振动的周期为$T=\frac{2\pi}{\omega}=\frac{2\pi}{2}\mathrm{s}\approx3.14\mathrm{s}$</p></li><li><p>因为物体通过平衡位置时速度最大，即动能也最大，所以</p><p>$E_{k,max}=\frac{1}{2}m\omega^2A^2=\frac{1}{2}\times0.2\times2^2\times0.05^2\mathrm{J}=10^{-3}\mathrm{J}$</p></li><li><p>总能量为$E=E_{k,max}=10^{-3}\mathrm{J}$</p></li><li><p>当$E_k=E_p$时，有</p><p>$E_k=E_p=\frac{1}{2}E=0.5\times10^{-3}\mathrm{J}$</p><p>而$E_p=\frac{1}{2}kx^2=\frac{1}{2}m\omega^2x^2$</p><p>故$x=\sqrt{\frac{2E_p}{m\omega^2}}=\sqrt{\frac{2\times0.5\times10^{-3}}{0.2\times2^2}}\mathrm{m}=\frac{\sqrt{2}}{4}\times10^{-1}\mathrm{m}\approx0.035\mathrm{m}$</p></li></ol>              </div>            </details></li></ol><h3 id="电偶极子的场强（5-2-1）">电偶极子的场强（5.2.1）</h3><p>例题5.3（P116）</p><blockquote><p>相距为$l$的一对等量异号点电荷系统称为电偶极子。由负电荷指向正电荷的矢量（径矢）作为电偶极子的轴线的正方向，由电荷量$q$与径矢$l$的乘积定义为电偶极矩，简称电距（矢量），用$p$表示，$p=ql$​，求真空中电偶极子轴线延长线和中垂线上的场强。</p><img src="https://oss.iuoyt.com/img/posts/image-20240623175228902.png" alt="例题5.3" style="zoom: 50%;" /></blockquote><details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <ol><li><p>轴线延长线上P点的场强</p><p>如图(a)所示，设点电荷$+q$和$-q$轴线的中点到轴线延长线上一点P点的距离为$r(r\gg l)$，$+q$和$-q$在P点产生的场强大小分别为</p><p>$E_+=\frac{1}{4\pi\epsilon_0}\frac{q}{(r-\frac{l}{2})^2}$（方向向右）</p><p>$E_-=\frac{1}{4\pi\epsilon_0}\frac{q}{(r+\frac{l}{2})^2}$​（方向向左）</p><p>求$E_+$和$E_-$的矢量和就相当于求代数和，因此P点的合场强$E_P$的大小为</p><p>$E_P=E_++E_-=\frac{q}{4\pi\epsilon_0}[\frac{1}{(r-\frac{l}{2})^2}-\frac{1}{(r+\frac{l}{2})^2}]=\frac{1}{4\pi\epsilon_0r^3}\frac{2ql}{(1-\frac{l}{2r})^2(1+\frac{l}{2r})^2}$​</p><p>因为$r&gt;&gt;l$，所以</p><p>$E_P\approx\frac{2ql}{4\pi\epsilon_0r^3}=\frac{2p}{4\pi\epsilon_0r^3}$​（方向向右）</p><p>写成矢量式为$E_P=\frac{2p}{4\pi\epsilon_0r^3}$</p><p>$E_P$的方向与电矩$p$​的方向一致。</p></li><li><p>中垂线上P点的场强</p><p>如图(b)所示，设点电荷$+q$和$-q$轴线的中点到中垂线上一点P点的距离为$r(r\gg l)$，$+q$和$-q$​在P点产生的场强大小分别为</p><p>$E_+=E_-=\frac{1}{4\pi\epsilon_0}\frac{q}{(r^2+\frac{l^2}{4})}$</p><p>合场强的大小为</p><p>$E_P=2E_+\cos\alpha=2\frac{1}{4\pi\epsilon_0}\frac{q}{(r^2+\frac{l^2}{4})}·\frac{\frac{l}{2}}{(r^2+\frac{l^2}{4})^{\frac{1}{2}}}$</p><p>因此，简化为</p><p>$E_P=\frac{1}{4\pi\epsilon_0}\frac{ql}{(r^2+\frac{l^2}{4})^{\frac{3}{2}}}$​</p><p>由于$r\gg l$，所以</p><p>$E_P\approx\frac{ql}{4\pi\epsilon_0r^3}=\frac{1}{4\pi\epsilon_0}\frac{p}{r^3}$​</p><p>$E_P$的方向与电矩的方向相反，故写成矢量式为</p><p>$E_P=-\frac{1}{4\pi\epsilon_0}\frac{p}{r^3}$</p></li></ol>              </div>            </details><h3 id="热力学基础">热力学基础</h3><ol><li><p>例题3.2</p><blockquote><p>设空气可视为各处温度均为T的理想气体,试求大气压强随高度的变化规律.</p></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <img src="https://oss.iuoyt.com/img/posts/62582da19a5aa40cd904c4d8a62ddfc.png" alt="例题3.2" style="zoom:67%;" />              </div>            </details></li></ol><h3 id="电磁感应">电磁感应</h3><ol><li><p>例题7.4</p><blockquote><p>半径为R的圆柱形无限长螺线管中存在均磁场B，而且dB/dt为一大于零的常量，试求螺线管内外感生电场的分布.</p></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <img src="https://oss.iuoyt.com/img/posts/66ee02cd1dd56ae38d41c1986d188b8.png" alt="例题7.4" style="zoom:67%;" />              </div>            </details></li></ol>]]></content>
    
    
    <summary type="html">《大学物理》重要概念及考点参考</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学期总结" scheme="https://www.iuoyt.com/tags/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
    <category term="大学物理" scheme="https://www.iuoyt.com/tags/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>信息安全技术期末复习</title>
    <link href="https://www.iuoyt.com/posts/f546d1cf.html"/>
    <id>https://www.iuoyt.com/posts/f546d1cf.html</id>
    <published>2024-06-20T02:56:31.000Z</published>
    <updated>2024-06-27T04:58:44.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><h3 id="安全攻击">安全攻击</h3><blockquote><p>⭐️被动攻击和主动攻击的分类</p></blockquote><div class="note info simple"><p>安全攻击是危及信息系统安全的活动，即信息在存储、共享和传输中，可能会被非法窃听、截取、篡改和破坏的活动。</p></div><ul><li>安全攻击包括两类：<ul><li>被动攻击<ul><li>目的：获得传输的信息，不对信息作任何改动</li><li>威胁信息的保密性</li><li><strong>举例：消息内容的泄漏、流量分析</strong></li></ul></li><li>主动攻击（主动破坏数据）<ul><li>目的：篡改 / 伪造信息、改变系统的状态和操作</li><li>威胁信息的完整性、可用性和真实性</li><li><strong>举例：伪装、篡改、重放、拒绝服务</strong></li></ul></li></ul></li><li>常见的安全攻击如下：<ul><li>消息内容的泄漏：消息的内容被泄露或透露给某个非授权的实体</li><li>流量分析：通过分析通信双方的标识、通信频度、消息格式等信息来达到自己的目的</li><li>篡改：指对合法用户之间的通信消息进行修改或者改变消息的顺序</li><li>伪装：指一个实体冒充另一个实体</li><li>重放：将获得的信息再次发送以期望获得合法用户的利益</li><li>拒绝服务：指阻止对信息或其他资源的合法访问。</li></ul></li></ul><h3 id="安全服务">安全服务</h3><blockquote><p>⭐️安全服务的分类，CIA（基本）</p></blockquote><p>X.800把安全服务划分为5类服务。</p><ol><li><p>认证：确保通信实体就是它所声称的那个实体</p><ul><li><p>对等实体认证：同逻辑连接一起使用，用以提供对连接双方实体的机密性保证</p></li><li><p>数据源认证：在非连接传输中，确保数据来源与所声称的一致</p></li></ul></li><li><p>访问控制：防止对资源的非授权使用</p></li><li><p>数据机密性：防止非授权的数据泄露</p><ul><li><p>连接机密性：对连接中所有用户的数据的保护</p></li><li><p>无连接机密性：对单一数据块中的所有用户数据的保护</p></li><li><p>选择域机密性：在连接或单一数据块上的用户数据中的选择域的机密性</p></li><li><p>流量机密性：对可能从流量中获取的信息的保护</p></li></ul></li><li><p>数据完整性：确保被认证实体发送的数据与接收到的数据完全相同（无篡改、插入、删除或重放）</p><ul><li><p>带有恢复的连接完整性：确保连接中所有用户数据的完整性，检测实体数据序列中任意的改写、插入、删除或重放，并尝试恢复数据</p></li><li><p>无恢复的连接完整性：检测数据完整性，单不进行恢复操作</p></li><li><p>选择域连接的完整性：在一个连接中，提供对传输数据块中用户数据选择域的完整性保证，并且裁决选择域中的数据是否被篡改、插入、删除或重放</p></li><li><p>无连接的完整性：对单一无连接数据块提供完整性保证并且可能对数据篡改进行检测。此外也可以提供有限的重放数据检测</p></li></ul></li><li><p>不可抵赖性：提供对被全程参与或部分参与通信的实体拒绝的防范</p><ul><li><p>源不可抵赖性：证明消息由特定一方发出</p></li><li><p>目的地不可抵赖性：证明消息由特地一方接收</p></li></ul></li></ol><h3 id="安全机制">安全机制</h3><div class="note info simple"><p>安全机制即阻止安全攻击及恢复系统的机制，OSI 安全框架将安全机制分为特定安全机制和普遍安全机制</p></div><ul><li>特定安全机制：<ul><li>描述：在同一时间只针对一种安全服务实施一种技术或软件</li><li>举例：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制和公证</li></ul></li><li>普遍安全机制：<ul><li>描述：普遍安全机制不能应用到 OSI 参考模型的任一层上</li><li>举例：可信功能机制、安全标签机制、事件检测机制、审计跟踪机制、安全恢复机制</li></ul></li></ul><h2 id="数学基础">数学基础</h2><h3 id="数论">数论</h3><h4 id="扩展欧几里得算法（辗转相除法）">扩展欧几里得算法（辗转相除法）</h4><blockquote><p>（扩展的）欧几里得算法：求模逆元（具体过程不要求）</p></blockquote><p>在密码学特别是非对称密码体制中，常常需要求模逆元，求模逆元就是求乘法逆元。即已知$a$和$b$，寻找一个$x$，使得$a\times x\equiv1\bmod b$成立，即求出可使得$1=a\times x-b\times n$（顺序为$a$在前，$b$在后）成立的$x$。模逆元不一定存在结果，通常用欧几里得算法求出。</p><details class="folding-tag" ><summary> 举例 </summary>              <div class='content'>              <blockquote><p>求$5^{-1}\bmod18$</p></blockquote><p>①求18对5的余数：<i style="color: red">$3$</i>$=18-5\times$<i style="color: red">$3$</i></p><p>②将3作为除数，求5对3的余数：<i style="color: red">$2$</i>$=5-3\times$<i style="color: red">$1$</i></p><p>③将2作为除数，求3对2的余数：<i style="color: red">$1$</i>$=3-2\times$<i style="color: red">$1$</i></p><p>④（已求得余数为1）将③中的非$a,b$的数用①和②表示：</p><p>$1=3-($<i style="color: red">$5-3\times1$</i>$)\times1=($<i style="color: blue">$18-5\times3$</i>$)-[5-($<i style="color:blue">$18-5\times 3$</i>$)\times1]\times1=18\times2-5\times7$</p><p>⑤表示为$ax-bn$形式：$18\times2-5\times7=5\times(-7)-18\times(-2)=5\times11-18\times3$</p><p>⑥则模逆元为11</p>              </div>            </details><details class="folding-tag" ><summary> 更多例题 </summary>              <div class='content'>              <ol><li>$1234^{-1}\bmod 4321$</li><li>$24140^{-1}\bmod40902$</li><li>$550^{-1}\bmod1769$</li></ol>              </div>            </details><h4 id="费马定理">费马定理</h4><div class="note info simple"><p>若$p$是素数，且$a$是正整数，且$gcd(a,p)=1$，则$a^{p-1}\equiv 1(\bmod p)$。</p></div><details class="folding-tag" ><summary> 例$a=7，p=19$ </summary>              <div class='content'>              <p>$a=7,p=19,gcd(a,p)=1$</p><p>$7^2=49\equiv 11\bmod 19$</p><p>$7^4\equiv 121\bmod 19\equiv 7\bmod 19$</p><p>$7^8\equiv49\bmod 19\equiv 11\bmod 19$</p><p>$7^{16}\equiv 121\bmod 19 \equiv 7 \bmod 19$</p><p>$a^{p-1}=7^{18}=7^{16}\times 7^2\equiv 7\times 11\bmod 19\equiv 1\bmod 19$</p>              </div>            </details><p>推论（费马定理另一种表现形式）：</p><div class="note info simple"><p>设$p$是素数，对于任意正整数$a$，则$a^p\equiv a(\bmod p)$。</p></div><p>推论不要求$gcd(a,p)=1$，即$a,p$​互素</p><h4 id="欧拉定理">欧拉定理</h4><div class="note info simple"><p>对于任意互素的两个整数$a,n$，有：$a^{\varphi (n)}\equiv 1\bmod m$​。</p></div><blockquote><p>欧拉函数$\varphi(n)$：</p><div class="note info simple"><p>设$\varphi (m)$为小于或等于$m$且与$m$​互素的正整数个数，则称其为<strong>欧拉(Euler)函数</strong></p></div><details class="folding-tag" ><summary> 欧拉函数举例 </summary>              <div class='content'>              <blockquote><p>$\varphi(1)=1$：1</p><p>$\varphi(2)=1$：1</p><p>$\varphi(3)=2$：1、2</p><p>$\varphi(5)=4$：1、2、3、4</p><p>$\varphi(8)=4$：1、3、5、7</p></blockquote>              </div>            </details></blockquote><details class="folding-tag" ><summary> 欧拉定理举例 </summary>              <div class='content'>              <p>$a=3,n=10$：$\varphi (10)=4,a^{\varphi(n)}=3^4=81\equiv 1\bmod 10=1\bmod n$</p><p>$a=2,n=11$：$\varphi(11)=10,a^{\varphi (n)}=3^{10}=1024\equiv1\bmod 11=1\bmod n$</p>              </div>            </details><p>对于欧拉定理，有：</p><ul><li>当$n=p$时，有$a^{p-1}\equiv 1\bmod p$，为费马定理</li><li>易见$a^{\varphi (n+1)}\equiv a\bmod n$（欧拉定理的另一种形式不要求$a$和$n$互素）</li></ul><details class="folding-tag" ><summary> 求$13^{2001}$被$60$除所得的余数 </summary>              <div class='content'>              <p>$\because gcd(13,60)=1$</p><p>$\therefore 13^{\varphi (60)}\equiv 1(\bmod 60)$</p><p>$\because \varphi (60)=\varphi (2^2\times 3\times 5)=2\times(3-1)\times(5-1)=16$，$2001=125\times 16+1$</p><p>$\therefore 13^{16}\equiv 1(\bmod 60)$，$13^{2001}=(13^{16})^{125}\times 13\equiv 13(\bmod 60)$</p><p>即被60除所得的余数为13</p>              </div>            </details><h4 id="中国剩余定理">中国剩余定理</h4><blockquote><p>中国剩余定理：求解同余方程组</p></blockquote><div class="note info simple"><p>设$m_1,m_2,\dots ,m_k$​是两两互素的正整数，令</p><center>$M=m_1m_2\dots m_k=m_1M_1=m_2M_2=\dots=m_kM_k$</center><p>上式中$M_i=\frac{M}{m_i},i=1,2\dots,k$，则同时满足同余方程组</p><center>$x\equiv b_i\bmod m_i\quad(i=1,2,\dots,k)$</center><p>的唯一正整数解$x_0$是：</p><center>$x_0=(b_1M^{\prime}_{1}M_1+b_2M^{\prime}_{2}M_2+\dots+b_kM^{\prime}_{k}M_k)\bmod M$</center><p>上式中$M^{\prime}_{i}$是$M_i$以$m_i$为模的逆元。</p></div><details class="folding-tag" ><summary> 求解$x$举例 </summary>              <div class='content'>              <blockquote><p>求解满足以下方程的解$x$：</p><center>$x\equiv 1\bmod 2$​</center><center>$x\equiv 2\bmod 3$</center><center>$x\equiv 3\bmod 5$</center><center>$x\equiv 5\bmod 7$</center></blockquote><p>$M=m_1m_2m_3m_4=2\times 3\times 5\times 7=210$</p><p>$M_1=105,M_2=70,M_3=42,M_4=30$</p><p>由扩展欧几里得定理：</p><center>$M^{-1}_{1}\bmod 2\equiv 1\quad M^{-1}_{2}\bmod 3\equiv 1\quad M^{-1}_3\bmod 5\equiv 3\quad M^{-1}_4\bmod 7\equiv 4$</center>​<p>$\therefore x\bmod 210\equiv(1\times 105\times 1+ 2\times 70\times 1+3\times 42\times 3+5\times 30\times 4)\bmod 210\equiv 173$</p><p>即$x\equiv 173\bmod 210$</p>              </div>            </details><h3 id="代数">代数</h3><h4 id="群">群</h4><blockquote><p>群的概念：如$Z_n$​​（n为合数，即非素数）关于模n乘法运算不构成群</p><div class="note info simple"><p>用$Z_m$表示正整数{$0,1,\dots,m-1$}的集合</p></div></blockquote><ul><li>群定义了一个二元运算的集合，这个二维运算可以表示为$\cdot$（具有一般性，可以指任何数学运算），群$G$记作{$G,\cdot$}，$G$中的每一个序偶$(a,b)$通过运算生成$G$中的元素$(a\cdot b)$​。</li><li>如果一个群的元素个数是有限的，则该群称为有限群。并且群的阶等于群中元素的个数。否则，称该群为无限群。</li><li>满足以下原则：<ul><li>封闭性：如果$a$和$b$都属于$G$，则$a\cdot b$也属于$G$</li><li>结合律：对于$G$中的任何元素$a、b、c$都有$a\cdot (b\cdot c)=(a\cdot b)\cdot c$​成立</li><li>单位元：$G$中存在一个元素$e$，对于$G$中任意元素$a$，都有$a\cdot e=e\cdot a=a$成立</li><li>逆元：对于$G$中任意元素$a$，$G$中都存在一个元素$a^{\prime}$，使得式$a\cdot a^{\prime}=a^{\prime}\cdot a=e$​成立</li><li>交换律：对于$G$中的任意元素$a,b$，都有$a\cdot b=b\cdot a$成立</li></ul></li></ul><h4 id="有限域">有限域</h4><blockquote><p>有限域的阶必为素数$p$的幂$p^n$​</p><blockquote><p>判断方法即是否可以表示成$p^n$</p></blockquote></blockquote><div class="note info simple"><p>对任意素数$p$和正整数$n$，存在$p^n$阶的有限域，记为$GF(P^n)$。当$n=1$时有限域$GF§$​也称为素域。</p></div><p>定义：</p><ol><li>有限域中元素的个数称为有限域的阶</li><li>有限域的阶必为素数$p$的幂$p^n$，$n$为正整数</li></ol><h4 id="域上多项式">域上多项式</h4><blockquote><p>如$GF(2^8)$上的运算，对称加密AES</p></blockquote><div class="note info simple"><p>域$F$上的$n(n\ge 0)$​次多项式表示为：</p><center>$f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0=\sum_{i=0}^na_ix^i$</center><p>其中系数$a_i$是域$F$中的元素。</p></div><h2 id="对称加密和消息机密性">对称加密和消息机密性</h2><h3 id="对称加密原理">对称加密原理</h3><ul><li>一对保密密钥相等或互相容易推算，又称为单密钥密码机制。</li><li>（加密和解密采用相同的密钥）</li></ul><h3 id="对称加密算法">对称加密算法</h3><h4 id="Feistel结构">Feistel结构</h4><blockquote><p>了解具体结构图，根据图写出加密过程</p></blockquote><ul><li><p>分组大小：越大的分组意味着越高的安全性，但减小了加密/解密速率（折中128bit）</p></li><li><p>密钥大小：越长的密钥意味着越高的安全性（128bit）</p></li><li><p>迭代轮数：多轮处理能提供更高的安全性。（16轮）</p></li><li><p>子密钥生成算法：此算法复杂度越高，密码破译难度就越高</p></li><li><p>快速软件加密/解密：软件执行速度成为一个重要因素</p></li><li><p>易于分析：便于掌握算法的保密强度以及扩展办法</p><p><img src="https://img-blog.csdnimg.cn/img_convert/18d21b4c5e1416a5df04d88ea64e8702.png" alt="img"></p></li><li><p>过程：</p><ul><li>每一轮的左半部分是上一轮的右半部分<br>每一轮的右半部分是 （上一轮的右半部分进入一个F操作，且要输入这一轮的密钥$K_i$，然后产生的解再与上一轮的左半部分进行异或操作</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/414d676431f8a43926b7832da72db788.png" alt="图片来源：CSDN-Ferry_xie"></p></li></ul><h4 id="分组密码：">分组密码：</h4><h5 id="DES（数据加密标准）">DES（数据加密标准）</h5><ul><li>最广泛使用的加密方案，算法被称为数据加密算法 (DEA) 。DES是一个分组密码，明文长度为64bit，密钥长度为56bit，16轮迭代。</li><li>工作原理：<ul><li>加密：用Key去把数据Data进行加密， 生成Data的密码形式（64位）作为DES的输出结果</li><li>解密：用Key去把密码形式的数据Data解密，还原为Data的明码形式（64位）作为DES的输出结果</li></ul></li></ul><h5 id="AES（高级加密标准）">AES（高级加密标准）</h5><ul><li>和DES有等同或更高的安全强度，并且效率有显著提高</li><li>支持的分组大小为128、192和256bit</li><li>支持密钥长度为128、192和256bit</li></ul><h5 id="IDEA（International-Data-Encryption-Algorithm）">IDEA（International Data Encryption Algorithm）</h5><ul><li>目标：密码强度；使用的方便性。</li><li>密码强度：<ul><li>分组长度：64bit分组</li><li>密钥长度：128bit；</li><li>扰乱：用三种操作达到扰乱的目的；</li><li>扩散：IDEA密码的扩散效果也很有效。</li></ul></li><li>实现方面的考虑：软件和硬件的实现</li></ul><h5 id="SM4（SMS4中国商用密码算法）">SM4（SMS4中国商用密码算法）</h5><ul><li>分组长度：128bit</li><li>密钥长度：128bit</li><li>迭代轮数：32轮</li><li>非对称的Feistel结构</li></ul><h4 id="流密码：RC4">流密码：RC4</h4><ul><li>流密码的设计思想：<ul><li>加密序列应该有一个长周期</li><li>密钥流应该尽可能地接近真随机数的性质</li><li>为了抵抗穷举攻击，密钥必须足够长 （128bit）</li></ul></li><li>RC4：1987，Ron Rivest为RSA Secutity公司设计 的流密码，用于SSL/TLS，IEEE 802.11 WEP和WAP等协议中</li></ul><h3 id="分组密码的工作模式">分组密码的工作模式</h3><h4 id="EC（ECB）">EC（ECB）</h4><p>电子簿模式(electronic codebook mode)，明文一次被处理64bit，而且明文的每一个分组都使用同一密钥加密。（安全性不好，会出错，一般不用）</p><ul><li>相同明文对应相同密文</li><li>同样信息多次出现造成泄漏</li><li>信息块可被替换</li><li>信息块可被重排</li><li>密文块损坏对应明文块损坏</li><li>适合于传输短信 息</li></ul><h4 id="CBC">CBC</h4><p>密码块链接(cipher block chaining)，加密算法的输入是当前明文分组与前一密文分组的异或</p><ul><li>需要共同的初始化向量</li><li>相同明文-&gt;不同密文</li><li>初始化向量可以用来改变第一块</li><li>密文块损坏-&gt;两明文块损坏</li><li>安全性好于ECB</li></ul><h4 id="CFB">CFB</h4><p>密码反馈方式(cipher feedback)，将任意分组密码转化为流密码</p><h4 id="CRT">CRT</h4><p>计数器模式(counter model)</p><ul><li>硬件效率：没有连接，并行执行（效率高）</li><li>预处理：预先准备加密箱的输出</li><li>随机存取</li><li>可证明的安全性：CTR至少与和其他模式一样安全</li><li>简单性：只需要对加密算法执行，不需要解密算法的执行；解密密钥的安排调度不需要执行</li></ul><h2 id="公钥加密和消息认证">公钥加密和消息认证</h2><h3 id="安全Hash函数">安全Hash函数</h3><blockquote><p>Hash函数应满足的性质</p></blockquote><p>一个hash函数H的性质：</p><ul><li>H能应用于任意长度的数据</li><li>H生成固定长度的输出</li><li>对任意的x，H(x)易于计算</li><li>对任意的h，计算x使得H(x)=h是计算上不可行的 （单向性）</li><li>对任意的x，计算y≠x使得H(y)=H(x)是计算上不可 行的（弱抗碰撞性）</li><li>计算任意对(x,y)使得H(x)=H(y)是计算上不可行的 （强抗碰撞性）</li></ul><h3 id="消息认证码-消息鉴别码">消息认证码(消息鉴别码)</h3><p>消息认证码（MAC）是一种使用密钥的认证技术，它利用密钥来生成一个固定长度的短数据块，并将该数据块附加在消息之后，用于保证消息的完整性。</p><h4 id="基于Hash函数构造（HMAC）">基于Hash函数构造（HMAC）</h4><ul><li>HMAC的设计目标：<ol><li>可以直接使用现有的Hash函数</li><li>不针对于某一个Hash函数，可以根据需要更换Hash函数模块</li><li>可保持Hash函数的原有性能，不能过分降低其性能</li><li>对密钥的使用和处理应较简单</li><li>如果已知嵌入的Hash函数的强度，则可以知道认证机制抵抗密码分析的强度</li></ol></li></ul><h4 id="基于分组密码构造">基于分组密码构造</h4><ul><li>使用AES之类的分组密码可以实现消息认证码。</li></ul><h3 id="公钥加密原理">公钥加密原理</h3><blockquote><p>原理：接收者公钥加密</p></blockquote><ul><li>使用两个密钥对于保密性、密钥分发和认证都产生了意义深远的影响</li><li>公钥加密方案由6个部分组成：明文、加密算法、公钥、私钥、密文、解密算法</li></ul><h3 id="公钥加密算法：">公钥加密算法：</h3><h4 id="RSA">RSA</h4><blockquote><p>RSA及其参数设置：基于大整数分解问题（安全性）</p><p>了解具体过程、密钥生成、加密解密、签名</p></blockquote><ol><li><p>密钥的产生</p><ul><li>随机选择两个大的素数$a$和$b$</li><li>计算$n=a\times b$</li><li>计算秘密的欧拉函数$\varphi(n)=(a-1)(b-1)$​</li><li>选择$e$使得$1\lt e\lt\varphi(n)$，且$gcd(e,\varphi(n))=1$</li><li>求$e$的乘法逆元$d$（$ed\equiv 1\bmod\varphi(n),0\le d\le n$​）</li><li>求得公钥$PU={e,N}$</li><li>求得私钥$PR={d,a,b}$​</li></ul></li><li><p>加密过程</p><p>加密时明文以分组为单位进行加密，每个分组m的二进制值均小于n，对明文分组m做加密运算：$c=m^e \bmod n,0\le m\le n$</p></li><li><p>密文解密：$m=c^d\bmod n$</p></li><li><p>计算签名：$s=m^d\bmod n$</p></li><li><p>签名验证：$m=s^e\bmod n$</p></li></ol><h4 id="ElGamal">ElGamal</h4><blockquote><p>ElGamal：基于离散对数问题（具体过程不要求）</p></blockquote><p>ElGamal既能用于数据加密，也能用于数字签名，其安全性是依赖于计算有限域上离散对数这一难题。</p><h3 id="Diffie-Hellman密钥交换">Diffie-Hellman密钥交换</h3><blockquote><p>了解具体过程</p></blockquote><p>Diffie-Hellman算法的唯一目的是使得两个用户能够安全地交换密钥，得到一个共享的会话密钥，算法本身不能用于加密和解密。该算法的安全性基于求离散对数的困难性。</p><ol><li><p>任取一大素数$q$和任一其<a href="https://www.iuoyt.com/posts/215ef6b6.html#%E6%9C%AC%E5%8E%9F%E6%A0%B9%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%89">本原根</a>$a(a\lt q)$</p></li><li><p>用户A选择私钥$X_A(\lt q)$，计算公钥$Y_A=a^{X_A}\bmod q$</p><p>用户B选择私钥$X_B(&lt;q)$，计算公钥$Y_B=a^{X_B}\bmod q$</p></li><li><p>用户A加密密钥$K=(Y_B)^{X_A}\bmod q$</p></li><li><p>用户B的加密密钥$K=(Y_A)^{X_B}\bmod q$</p></li></ol><h3 id="数字签名">数字签名</h3><p>方法：发送者使用私钥签名，验证者用公钥进行验证</p><ol><li>传统签名的基本特点<ul><li>能与被签的文件在物理上不可分割</li><li>签名者不能否认自己的签名</li><li>签名不能被伪造</li><li>容易被验证</li></ul></li><li>数字签名是传统签名的数字化,基本要求<ul><li>能与所签文件“绑定”</li><li>签名者不能否认自己的签名</li><li>签名不能被伪造</li><li>容易被验证</li></ul></li></ol><h2 id="密钥分配和用户认证">密钥分配和用户认证</h2><h3 id="两种分类体制">两种分类体制</h3><ol><li>对称体制（需要保证机密性）<ul><li>优点：速度快，适合做大量数据加密</li><li>缺点：功能有限，只有知道密钥的人才可以验证签名（不满足需求）</li></ul></li><li>公钥体制（公钥可以直接公开，需要保证公钥真实性）<ul><li>优点：功能丰富，可以做加密、签名、密钥交换</li><li>缺点：运算速度慢</li></ul></li></ol><h3 id="对称加密的密钥分配">对称加密的密钥分配</h3><p>在两个用户（主机、进程、应用程序）A和B之间分配密钥的方法有以下几种：</p><ol><li>密钥由A选取，并通过物理手段交给B</li><li>密钥由第三方选取，并由第三方通过物理手段交给A和B</li><li>如果A和B事先已有一密钥，则其中一方选取新密钥后，用已有的密钥加密新密钥并发送给另一方</li><li>如果A和B与可信的第三方C分别有一保密通道，则C为A和B选取密钥后，分别在两个保密信道上发送给A和B</li></ol><h3 id="Kerberos">Kerberos</h3><p>应用层安全协议，需要做配置修改，Kerberos需求：安全性、可靠性、透明性、可伸缩性</p><h4 id="会话过程">会话过程</h4><blockquote><p>6个阶段</p></blockquote><img src="https://oss.iuoyt.com/img/posts/image-20240619152737793.png" alt="image-20240619152737793" style="zoom:50%;" /><ol><li>用户以明文方式向认证服务器AS发出请求，要求获得访问TGS的许可证</li><li>AS以证书作为响应，证书包括访问TGS的许可证和用户与TGS之间的会话密钥，会话密钥以用户的密钥加密后传输</li><li>用户解密得到TGS的响应，然后利用TGS的许可证向TGS申请应用服务器的许可证，该申请包括TGS的许可证和一个带有时间戳的认证符。认证符以用户与TGS间的会话密钥加密。</li><li>TGS从许可证中取出会话密钥、解密认证符，验证认证符中时间戳的有效性，从而确定用户的请求是否合法。TGS确认用户的合法性后，生成所要求的应用服务器的许可证，许可证中含有新产生的用户与应用服务器之间的会话密钥。TGS将应用服务器的许可证和会话密钥传回到用户。</li><li>用户向应用服务器提交应用服务器的许可证和用户新产生的带时间戳的认证符（认证符以用户与应用服务器之间的会话密钥加密）。</li><li>应用服务器从许可证中取出会话密钥、解密认证符，取出时间戳并检验有效性。然后向用户返回一个带时间戳的认证符，该认证符以用户与应用服务器之间的会话密钥进行加密。据此，用户可以验证应用服务器的合法性。</li></ol><h4 id="基于口令">基于口令</h4><p>Kerberos是基于口令的认证协议。</p><h4 id="单点登录">单点登录</h4><p>Kerberos协议的设计使得用户只需在初次认证时输入身份验证信息，之后就可以凭借票据访问多个服务，实现了单点登录的便利性。</p><h4 id="防止重放攻击">防止重放攻击</h4><p>在采用Kerberos系统进行认证时，为了防止重放攻击，可以在报文中加入一个时间戳或随机数。</p><p>时间戳可以确保报文的新鲜性，即只有在规定时间内发送的报文才会被接收并处理。如果攻击者尝试重放旧的报文，由于时间戳已经过期，服务器会拒绝该报文。</p><p>随机数(Nonce)也是一种常用的防止重放攻击的手段。在Kerberos协议中，服务器会为每个会话生成一个唯一的随机数，并将其发送给客户端。客户端在发送后续报文时，必须包含这个随机数。如果攻击者尝试重放报文，由于随机数已经使用过，服务器会检测到并拒绝该报文。</p><h4 id="票据（Ticket）和认证符（Authenticator）">票据（Ticket）和认证符（Authenticator）</h4><blockquote><p>票据：降低用户输入口令次数，如果泄露存在重放攻击</p><p>认证符：防止重放攻击</p></blockquote><ul><li>票据（Ticket）：是一个记录凭证，客户可以用它来向服务器证明自己的身份，其中包括客户的标识、会话密钥、时间戳以及其他一些信息。Ticket中的大多数信息都被加密，密钥为服务器的密钥。</li><li>认证符（Authenticator）：是另一个记录凭证，其中包含一些最近产生的信息，产生这些信息需要用到客户机和服务器之间共享的会话密钥。</li></ul><h3 id="非对称加密的密钥分配">非对称加密的密钥分配</h3><h4 id="X-509公钥证书">X.509公钥证书</h4><blockquote><p>为签名和身份做背书</p></blockquote><p>X.509证书由用户公共密钥和用户标识符组成。此外还包括版本号、证书序列号、CA标识符、签名算法标识、签发者名称、证书有效期等信息。有如下作用：</p><ol><li>身份验证</li><li>安全通信</li><li>数字签名</li><li>访问控制</li><li>代码签名</li><li>电子邮件加密和签名</li><li>身份验证和授权</li></ol><h4 id="公钥基础设施PKI">公钥基础设施PKI</h4><blockquote><p>保证公钥真实性</p></blockquote><ul><li><p>PKI是利用公钥密码技术来实现并提供信息安全服务的基础设施，它能够为所有网络应用透明的提高加密、数字签名等密码服务所需要的密钥和证书管理。</p><img src="https://oss.iuoyt.com/img/posts/image-20240619160422134.png" alt="PKI系统组成" style="zoom:50%;" /></li><li><p>证书机构CA是PKI的信任基础，它管理公钥的整个生命周期，其作用包括：发放证 书、规定证书的有效期和通过发布证书撤销列表来确保在必要时可以撤销证书。</p></li><li><p>注册机构RA提供用户和CA之间的一个接口，它用于获取并认证用户的身份，向CA提出证书请求。</p></li></ul><h3 id="身份认证">身份认证</h3><blockquote><p>What you know/have/are</p><p>通过所知道的、所有的、身份特征</p></blockquote><p>分类方式：</p><ul><li>是否使用硬件：软件认证、硬件认证</li><li>需要验证的条件：单因子认证、双因子认证</li><li>认证信息：静态认证、动态认证</li><li>认证手段：<ul><li>基于用户所知道的（秘密如：密码、个人识别码PIN、密钥……）</li><li>基于用户所拥有的（令牌如：信用卡、智能卡、印章……）</li><li>基于用户本身的（生物特征如：语音、笔迹、指纹……）</li></ul></li></ul><h3 id="访问控制">访问控制</h3><p>访问控制是为了限制访问主体（或称为发起者，是一不主动的实体；如用户、进程和服务等），对访问客体（需要保护的资源）的访问权限，从而使计算机系统在合法范围内使用； 访问控制机制决定用户及代表一定用户利益的程序能做什么，及做到什么程度。</p><h4 id="自主访问控制DAC">自主访问控制DAC</h4><p>自主访问控制是指对某个客体具有拥有权（或控制权）的主体能够将对该客体的一种访问权或多种访问权自主地授予其他主体，并在随后的任何时刻将这些权限回收。这种控制是自主的，也就是指具有授予某种访问权力的主体（用户）能够自己决定是否将访问控制权限的某个子集授予其他的主体或从其他主体那里收回他所授予的访问权限。</p><h4 id="强制访问控制MAC">强制访问控制MAC</h4><blockquote><p>⭐️向下读，向上写</p></blockquote><p>所谓强制访问控制是指计算机系统根据使用系统 的机构事先确定的安全策略，对用户的访问权限进行强制性的控制。</p><img src="https://oss.iuoyt.com/img/posts/image-20240619162107012.png" alt="强制访问控制" style="zoom:50%;" /><p>强制访问控制用来保护系统确定的对象，对此对象用户不能进行更改。也就是说，系统独立于用户行为强制执行访问控制，用户不能改变他们的安全级别或对象的安全属性。这样的访问控制规则通常对数据和用户按照安全等级划分标签，访问控制机制通过比较安全标签来确定授予还是拒绝用户对资源的访问。强制访问控制进行了很强的等级划分，所以经常用于军事用途。</p><h3 id="基于角色的访问控制">基于角色的访问控制</h3><p>基于角色的访问控制的基本思想是在用户和访问权限之间引入角色的概念，将用户和角色联系起来，通过对角色的授权来控制用户对系统资源的访问。这种方法可根据用户的工作职责设置若干角色，不同的用户可以具有相同的角色，在系统中享有相同的权力，同一个用户又可以同时具有多个不同的角色，在系统中行使多个角色的权力。</p><h2 id="传输层安全">传输层安全</h2><h3 id="SSL体系结构">SSL体系结构</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240619162434889.png" alt="SSL的体系结构"></p><h4 id="SSL记录协议">SSL记录协议</h4><blockquote><p>加密、MAC（数据完整性认证）、运行流程</p><p>在传输层，基于TCP，需要按序接收，不能UDP</p></blockquote><p>工作流程（发送方）：</p><ol><li>从上层接受传输的应用报文</li><li>分片：将数据分片成可管理的块，每个上层报文被分成16KB或更小的数据块。</li><li>进行数据压缩（可选）：压缩是可选的，压缩的前提是不能丢失信息，并且增加的内容长度不能超过1024B，默认的压缩算法为空。</li><li>增加MAC：加入信息认证码（MAC），这一步需要用到共享的密钥。</li><li>加密：利用IDEA、DES、3DES或其他加密算法对压缩报文和MAC码进行数据加密。</li><li>增加SSL记录首部：增加由内容类型、主要版本、次要版本和压缩长度组成的首部。</li><li>将结果传输到下层</li></ol><p>接收方：</p><ol><li>从低层接受报文</li><li>解密</li><li>用事先商定的MAC码校验数据</li><li>如果是压缩的数据，则解压缩</li><li>装配数据</li><li>将信息传输到上层</li></ol><h4 id="变更密码规格协议">变更密码规格协议</h4><p>SSL修改密文规约协议用来发送修改密文规约协议信息。任何时候客户都能请求修改密码参数，比如握手密钥交换。在修改密文规约的通告发出以后，客户方就发出一个握手密钥交换信息（如果可得到的话），鉴定认证信息，服务器则在处理了密钥交换信息之后发送 一个修改密文规约信息。此后，新的双方约定的密钥就将一直使用到下次提出修改密钥规约请求为止。</p><h4 id="报警协议">报警协议</h4><p>SSL告警协议是用来将SSL有关的告警传送给对方实体的。和其他使用SSL的情况 一样，告警报文按照当前状态说明被压缩和加密。SSL告警协议的每个报文由两个字节组成。第1个字节的值用来表明告警的级别，第2个字节表示特定告警的代码。如果在通信过程中某一方发现任何异常，就需要给对方发送一条警示消息通告。</p><h4 id="握手协议">握手协议</h4><blockquote><p>防范重放攻击？随机数</p></blockquote><img src="https://oss.iuoyt.com/img/posts/image-20240620144648972.png" alt="SSL握手过程" style="zoom:50%;" /><ol><li><p>客户发出一个带有客户HELLO信息的连接请求。包括如下信息：</p><ul><li>想要使用的SSL版本号</li><li>时间信息，以标准的UNIX 32位格式标识的当前时间和日期</li><li>会话标识（可选），如果没有指定的话，则服务器重用上一次的会话标识或返回一个错误信息</li><li>密文组（客户方所支持的各种加密算法选项清单，包括认证码、密钥交换方法、加密和MAC算法）</li><li>客户方所支持的压缩算法</li><li>随机数</li></ul></li><li><p>服务器评估客户方发来的HELLO信息中的各项参数，并且返回一个服务器方的HELLO信息，其中包含SSL会话的各项参数，具体内容如下：</p><ul><li>版本号</li><li>时间信息，以标准的UNIX 32位格式标识的当前时间和日期</li><li>会话标识</li><li>密文组</li><li>压缩方法</li><li>随机数</li></ul><p>在服务器HELLO消息发送之后，服务器发出如下信息：</p><ul><li>服务器证书，如果服务器需要被鉴别的话。</li><li>服务器密钥交换信息，如果得不到证书或证书仅仅用作签名的话。</li><li>证书请求，如果客户要求被鉴别的话。</li></ul><p>最后，服务器发出一个服务器HELLO DONE信息，开始等待客户的回音。</p></li><li><p>客户发送下列信息：</p><ul><li>如果服务器发出了一个证书请求，那么客户方必须发送一个证书或非证书信息。</li><li>如果服务器发送了一个服务器密钥交换信息，那么客户方就发送一个基于公钥算法的由HELLO信息决定的密钥交换信息。</li><li>如果客户方已经发送了一个证书，那么客户方就需验证服务器方的证书并且发出一个证书验证信息指明结果。</li></ul><p>然后，客户方发出一个结束信息，指出协商过程已经完成。客户方还将发送一个修改密文规约信息来产生共享的常规密钥。应该注意这部分工作不是由握手协议控制，而是由修改密文规约协议管理的。</p></li><li><p>服务器发出一个结束信息，指出协商阶段完成。然后服务器发出一个修改密文规约信息。</p></li><li><p>会话双方分别产生一个加密密钥，然后他们再根据这些密钥导出会话主密钥。握手协议改变状态至连接状态。所有从应用层来的数据传输作为特定信息传输给对方。</p></li></ol><h5 id="暂态Diffie-Hellman">暂态Diffie-Hellman</h5><p>暂态Diffie-Hellman使用临时的公钥。每个协议的实例或运行使用不同的公钥。服务器临时公钥的真实性可以通过检查公钥上的签名来验证。由于公钥是临时的，即使服务器的长期签名密钥被泄露，也不会危及过去会话的隐私。这被称为完美前向保密性（PFS）。</p><h5 id="RSA密钥交换：由客户端选择会话密钥">RSA密钥交换：由客户端选择会话密钥</h5><p>客户端在发起与服务器的连接时，会生成一个对称加密的会话密钥（通常是一个随机数），这个会话密钥用于加密整个会话过程中的数据传输。客户端使用服务器的公钥对会话密钥进行加密，这样，只有服务器的私钥能够解密这个会话密钥，这样可以确保在整个通信过程中，只有服务器和客户端共享相同的会话密钥，其他任何人（包括中间人攻击者）都无法获取会话密钥或解密通信内容。</p><h4 id="SSL如何防范Web安全威胁">SSL如何防范Web安全威胁</h4><blockquote><p>如穷举密码分析攻击、已知明文字典攻击、重放攻击、中间人攻击、口令窃听、IP地址假冒、IP劫持，但无法防范SYN泛滥</p></blockquote><ol><li>穷举密码分析攻击：使用加密算法（如AES）</li><li>已知明文字典攻击：验证对端身份</li><li>重放攻击：使用时间戳和随机数来保护通信的唯一性</li><li>中间人攻击：使用公钥基础设施（PKI）和数字证书来验证通信两端的身份</li><li>口令窃听：使用加密技术（如对称加密和非对称加密）来加密传输的数据</li><li>IP地址假冒和IP劫持：通过加密通信和数字证书验证，SSL可以确保通信的两端确实是预期的合法实体，而不是恶意的IP地址假冒或劫持者</li><li>SYN泛滥：SSL/TLS本身不直接处理TCP层面的SYN泛滥攻击</li></ol><h3 id="HTTPS-HTTP-SSL">HTTPS=HTTP+SSL</h3><p>SSL握手协议用于鉴别初始化和传输密钥，它使得服务器和客户能相互鉴别对方的身份，并保护在SSL记录中发送的数据。因此在传输任何应用数据前，都必须使用握手协议。 一个SSL会话是按以下步骤初始化的：</p><ol><li>客户方，用户用URL发出的请求中，HTTP用HTTPS替代</li><li>客户方的SSL请求通过TCP的443端口与服务器方的SSL进程建立连接</li><li>然后客户方初始化SSL握手状态，用SSL记录协议作为载体。这时，客户/服务器双方的连接中还没有加密和完整性检查的信息。</li></ol><h3 id="SSH协议">SSH协议</h3><p>SSH是一种远程登录安全协议，它提供了一条安全的远程登录通道。</p><h2 id="PGP与电子邮件安全（7-5）">PGP与电子邮件安全（7.5）</h2><h3 id="PGP提供的安全服务">PGP提供的安全服务</h3><h4 id="压缩顺序（签名—压缩—加密）">压缩顺序（签名—压缩—加密）</h4><ul><li>压缩对邮件传输或存储都有节省空间的好处</li><li>签名后压缩的原因：<ul><li>不需要为检验签名而保留压缩版本的消息</li><li>为了检验而再做压缩不能保证一致性，压缩算法的 不同实现版本可能会产生不同的结果</li></ul></li><li>压缩之后再做加密的原因：</li><li>压缩后的消息冗余小，增加密码分析的难度</li><li>若先加密，则压缩难以见效</li></ul><h4 id="4种类型的密钥">4种类型的密钥</h4><ol><li>一次性会话传统密钥</li><li>公钥</li><li>私钥</li><li>基于口令短语的传统密钥</li></ol><h3 id="PGP的信任模型：Web-of-Trust">PGP的信任模型：Web-of-Trust</h3><h4 id="X-509与PGP对用户公钥的信任模型有何不同？">X.509与PGP对用户公钥的信任模型有何不同？</h4><p>X.509采用层次CA的结构，PGP采用Web-of-Trust建立信任。X.509用户只信任CA，而PGP用户可以相信其他用户。</p><h4 id="Owner-trust-field、Key-legitimacy-field">Owner trust field、Key legitimacy field</h4><ul><li>Owner trust field：表明该公钥用于签名其它公钥证书时的信任程度。这个信任程度是由用户给出的。</li><li>Key legitimacy field：合法性或者有效性，表明PGP对“此用户公钥是合法的”的信任程度；信任级别越高，这个userID与该公钥的绑定越强。这个字段是由PGP计算的</li></ul><h2 id="IPSec">IPSec</h2><h3 id="IPSec的好处">IPSec的好处</h3><ul><li>对通过其边界的所有通信流提供了强安全性</li><li>对所有应用透明：位于传输层（TCP，UDP） 之下</li><li>当防火墙或路由器使用IPSec时，没有必要对 用户系统和服务器系统的软件做任何改变</li><li>IPSec对终端用户透明，不需要对用户进行安 全机制的培训</li><li>IPSec能给个人用户提供安全性</li></ul><h3 id="数据结构：安全关联（SA）">数据结构：安全关联（SA）</h3><ul><li>安全关联（SA）是发送者和接收者两个IPSec系统之间的一个简单的单向逻辑连接，是与给定的一个网络连接或一组网络连接相关联的安全信息参数集合。因为SA是单个方向的，所以，对于一个双向通信，则需要两个SA。</li><li>一个安全关联由三个参数唯一确定：<ul><li>Security Parameter Index (SPI)：赋给此SA的一个仅在本地有意义的比特串</li><li>IP Destination address：SA的目的端点地址</li><li>Security Protocol Identifier: AH or ESP：标示SA使用的IPSec协议</li></ul></li></ul><h3 id="两个协议">两个协议</h3><h4 id="AH（7-4-2）">AH（7.4.2）</h4><ul><li><p>AH协议为中通信提供数据源认证、数据完整性和反重播保证，它能保护通信免受篡改，但不能防止窃听，适合用于传输非机密数据。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620115150837.png" alt="AH报头格式" style="zoom:50%;" /></li><li><p>AH的工作原理是在每一个数据包上添加 一个身份验证报头。此报头包含一个带密钥的Hash散列（可以将其当作数字签名，只是它不使用证书），此Hash散列在整个数据包中计算，因此对数据的任何更改将致使散列无效——这样就提供了完整性保护。</p></li></ul><h4 id="ESP（7-4-3）">ESP（7.4.3）</h4><ul><li><p>ESP为IP数据包提供完整性检查、认证和加密。可以将其看作“超级AH”，因为它提供机密性并可防止篡改。ESP服务依据建立的安全关联（SA）是可选的。然而，也有如下一 些限制：</p><ul><li>完整性检查和认证一起进行</li><li>仅当与完整性检查和认证一起时，“重播（Replay）”保护才是可选的</li><li>“重播”保护只能由接收方选择</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240620115416616.png" alt="ESP的格式" style="zoom:50%;" /></li></ul><h4 id="IPSec报头格式（P196）">IPSec报头格式（P196）</h4><blockquote><p>携带安全参数索引SPI（指定SA）、序列号（抗重放）</p></blockquote><ul><li>每个SA用唯一的SPI索引标识，当处理接收数据包时，服务器根据SPI值来决定该使用哪种SA。具体采用什么方式，要由三方面的因素决定：第一个是安全参数索引（SPI），该索引存 在于IPSec协议头内；第二个是IPSec协议值；第三个是要向其应用SA的目标地址。</li><li>序列号是一个无符号单调递增的计数器，从1开始的32位单增序列号，不允许重复，唯一地标识了每一个发送数据包，为安全关联提供反重播保护。接收端将校验序列号为该字段值的数据包是否已经被接收过， 若是，则拒收该数据包。对于一个特定的SA，它用于实现反重传服务。</li></ul><h4 id="AH的认证范围更广，包括IP头">AH的认证范围更广，包括IP头</h4><p>AH协议的认证范围更广泛，包括IP数据报的头部部分。在IPSec中，AH协议提供数据完整性验证和防篡改保护，其作用范围涵盖整个IP数据报，包括其头部信息，这使得AH协议在保护IP数据报完整性方面有更广泛的应用。</p><h3 id="密钥管理IKE">密钥管理IKE</h3><h4 id="中间人攻击：认证">中间人攻击：认证</h4><ul><li><p>中间人攻击是一种间接的攻击方法，假设A和B是需要通信的双方，C则是“中间人”。A和B都以为将消息传送给对方，没有意识到由一个中间人C在转发消息。C不仅可以窃听A和B的通信，还可以对信息进行篡改再传给对方。当然C也可以获得A和B之间通信的敏感信息。<br><img src="https://oss.iuoyt.com/img/posts/image-20240620134747536.png" alt="中间人攻击" style="zoom:33%;" /></p></li><li><p>攻击过程：</p><ol><li>$A\to C$：A的公钥$PU_A$和身份标识$ID_A$</li><li>$C\to B$：C的公钥$PU_C$和身份标识$ID_C$</li><li>$B\to C$：$E_{PU_C}(K_S)$，C因此知道$K_S$</li><li>$C\to A$：$E_{PU_A}(K_S)$</li></ol></li><li><p>改进方式：认证。假设A和B事先可以得到对方的公钥，会话钥分配过程如下：</p><ol><li><p>$A\to B$：$E_{PU_B}(ID_A || N_1)$</p><p>A用B的公钥加密自己的身份$ID_A$和临时交互号$N_1$，然后将消息传送给B，只有B能够打开这个消息</p></li><li><p>$B\to A$：$E_{PU_A}(N_1||N_2)$​</p><p>B用A的公钥加密临时交互号$N_1$和$N_2$，然后将消息传给A，只有A能够打开该消息，通过$N_1$的正确性确认对方身份</p></li><li><p>$A\to B$：$E_{PU_B}(N_2+1)$​</p><p>A用B的公钥加密$N_2+1$，然后将消息传给B，B也可以通过$N_2$认证对方的身份</p></li><li><p>$B\to A$：$E_{PU_A}(E_{PR_B}(K_S))$​</p><p>由B产生一个会话钥，先用私钥$PR_B$加密，再用A的公钥加密，做到既保密又认证</p></li></ol></li></ul><h4 id="拥塞攻击：Cookie交换">拥塞攻击：Cookie交换</h4><ul><li>Cookie交换要求每一方在初始消息中发送一个伪随机数，即cookie，而另一方对此做出相应的应答。</li><li>Cookie的要求：<ul><li>Cookie的值必须依赖于特定的参与方，即与参与方的某种标识关联</li><li>除了产生Cookie的这一方之外，其他人都无法产生出可被他接受的Cookie值，所以，产生和验证Cookie时都会用到本地的秘密信息</li><li>Cookie的产生和验证方法必须足够快速</li></ul></li></ul><h4 id="重放攻击：序列号">重放攻击：序列号</h4><ul><li>重放攻击：攻击者获得经过认证的数据包的一个附本，并在稍后的某个时间发送给目标。接受到重复的，经过认证的数据包可能以某种方式扰乱服务，或者可能产生其他不可预料的后果。</li><li>设计序列号来防范重放攻击：当新的SA建立时，发送者初始化序列号计数器为0，每次SA发送一个数据包，计数器便加1。如果需要抗重放服务，序列号计数器不允许从$2^{32}-1$到0重复循环，如果计数器到达最大值$2^{32}-1$，发送者必须 终止此SA，协商一个新的SA和一个新密钥</li></ul><h3 id="两种工作模式">两种工作模式</h3><h4 id="AH传输模式">AH传输模式</h4><p>传输模式用于两台主机之间，只对上层协议数据（传输层数据）和IP头中的固定字段提供认证，主要保护传输层协议头，实现端到端的安全。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620141101720.png" alt="AH传输模式" style="zoom:50%;" /><p>在传输模式的AH中，封装后的分组IP头仍然是原IP头，只是IP头的协议字段由原来的值变为51，表示IP头后紧接的载荷为AH载荷。</p><h4 id="AH隧道模式">AH隧道模式</h4><p>隧道模式对整个IP数据项提供认证保护，把需要保护的IP包封装在新的IP包中，既可用于主机也可用于安全网关，并且当 AH在安全网关上实现时，必须采用隧道模式。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620141411478.png" alt="AH隧道模式" style="zoom:50%;" /><p>在隧道模式的AH中，不是将原始的IP报头移到最左边然后插入AH报头，而是复制原始IP报头，并将复制的IP报头移到数据报最左边作为新的IP报头。随后在原始IP报头与IP报头的副本之间放置AH报头。原始IP报头保持原封不动，并且整个原始IP报头都被认证或由加密算法进行保护。</p><h4 id="ESP传输模式">ESP传输模式</h4><p>IP报头被调整到数据报左边，并插入ESP报头；ESP报尾以及ICV（完整性校验值，用于认证）被附加在数据报末端。如果需要加密，仅对原始数据和新的ESP报尾进行加密。认证从后ESP报头一直延伸到ESP报尾。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620141655817.png" alt="ESP传输模式" style="zoom:50%;" /><h4 id="ESP隧道模式">ESP隧道模式</h4><p>在ESP隧道模式下，原数据包（包括原IP报头和数据）被封装在ESP报头和ESP报尾之间，外边附上了新的IP报头。在这种模式下，加密部分为原IP数据包和ESP报尾，完整性检查部分为ESP报头、原IP数据包以及ESP报尾。整个原始数据报都可以用这种方法进行加密或认证。如果既选择ESP认证又选择ESP加密， 那么应该首先实现加密。这就允许在传输之前与发送方没有改变数据报的保证一同实现认证,并且接收方在对分组进行解密之前认证数据报。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620141853530.png" alt="ESP隧道模式" style="zoom:50%;" /><h2 id="防火墙">防火墙</h2><h3 id="不同类型防火墙的特点">不同类型防火墙的特点</h3><h4 id="包过滤路由器">包过滤路由器</h4><ol><li>优点:<ul><li>简单</li><li>对用户透明</li><li>高处理速度</li></ul></li><li>缺点:<ul><li>不能阻止利用了特定应用漏洞或功能所进行的攻击。 如，不能阻止特定的应用命令</li><li>日志记录功能有限</li><li>不支持高级的用户认证机制</li><li>对利用TCP/IP规范和协议栈存在的问题进行的攻击没 有很好的应对措施。如，IP地址假冒攻击</li><li>设置包过滤规则比较困难</li></ul></li></ol><h4 id="状态检测防火墙">状态检测防火墙</h4><ul><li>传统的包过滤防火墙不考虑更高层的上下文信息，允许来自基于TCP的所有高端口的入站网络流量</li><li>状态检测防火墙建造了一个出站TCP连接目录，仅当入站数据包符合目录里某个条目时，才允许到达高端口的入站流量通过</li><li>状态检测防火墙在上下文中检查每个IP包</li><li>记录有关TCP连接的信息：TCP序列号轨迹、检查有限的应用层数据</li></ul><h4 id="应用层网关">应用层网关</h4><ol><li>优点<ul><li>比包过滤防火墙更安全</li><li>只需要细查少数可以允许的应用程序</li><li>容易记录和审计所有的入站流量</li></ul></li><li>缺点：带来了对每个连接的额外处理开销（建立两个接合的连接）</li></ol><h3 id="理解简单的包过滤规则">理解简单的包过滤规则</h3><ul><li>包过滤规则是基于网络安全策略（即凡是未被明确许可的就是禁止的或凡是未被明确禁止的就是许可的）的。包过滤规则是在考虑了外部攻击以及服务级别限制和收发双方的通信级别限制等因素后制定的。</li><li>包过滤类型的防火墙要遵循的一条基本原则是“最小特权原则”，即明确允许那些管理员希望通过的数据包，禁止其他数据包</li><li>包过滤可分为静态包过滤和动态包过滤两种。 静态包过滤这种类型的防火墙根据定义好的过滤规则审查每个数据包，以便确定其是否与某一条包过滤规则匹配。动态包过滤采用动态设置包过滤规则的方法，避免了静态包过滤所具有的问题。这种技术后来发展成为所谓包状态监测技术。</li></ul>]]></content>
    
    
    <summary type="html">信息安全技术期末考试复习内容</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学期总结" scheme="https://www.iuoyt.com/tags/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
    <category term="信息安全技术" scheme="https://www.iuoyt.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>大学物理期末复习-分类检测</title>
    <link href="https://www.iuoyt.com/posts/9caf9e2f.html"/>
    <id>https://www.iuoyt.com/posts/9caf9e2f.html</id>
    <published>2024-06-18T08:04:26.000Z</published>
    <updated>2024-06-23T15:17:20.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择题">选择题</h3><ol><li><p>一质点在平面上运动，已知质点位置矢量的表示法为$\vec{r}=at^2\vec{i}+bt^2\vec{j}$（其中a、b为常量），则该质点作（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. 匀速直线运动</p><p>B. 变速直线运动</p><p>C. 抛物线运动</p><p>D. 一般曲线运动</p></li><li><p>质点做曲线运动，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over r}$标识位置矢量，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over v}$表示速度，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over a}$表示加速度，$S$表示路程，$a_t$​表示切向加速度，下列表达式中（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p>①$\frac{dv}{dt}=a$</p><p>②$\frac{dr}{dt}=v$</p><p>③$\frac{dS}{dt}=v$</p><p>④$\left | \frac{d\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over v}}{d\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over t}}  \right | =a_t$</p><p>A. 只有①、④正确</p><p>B. 只有②正确</p><p>C. 只有②、④正确</p><p>D. 只有③正确</p></li><li><p>质量为$20g$的子弹，以$400m/s$的速率沿图示方向射入一原来静止的质量为$980g$​的摆球中，摆线长度不可伸缩，子弹射入后开始与摆球一起运动的速率为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/503d269759ee3d6df4f631ab53166d224f4ade9a.jpg" alt="题图"></p><p>A. 2m/s</p><p>B. 4m/s</p><p>C. 7m/s</p><p>D. 8m/s</p></li><li><p>一质点在几个外力同时作用下运动时，下述哪种说法正确？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 质点的动量改变时，质点的动能一定改变</p><p>B. 质点的动能不变时，质点的动量也一定不变</p><p>C. 外力的冲量是零，外力的功一定为零</p><p>D. 外力的功为零，外力的冲量一定为零</p></li><li><p>有两个力作用在一个有固定转轴的刚体上，在以下说法中（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>①这两个力都平行于轴作用时，它们对轴的合力矩一定是零</p><p>②这两个力都垂直于轴作用时，它们对轴的合力矩可能是零</p><p>③当这两个力的合力为零时，它们对轴的合力矩也一定是零</p><p>④当这两个力对轴的合力矩为零时，它们的合力也一定是零</p><p>A. ①②③④都正确</p><p>B. ①②正确，③④错误</p><p>C. 只有①时正确的</p><p>D. ①②③都正确，④错误</p></li><li><p>一轻绳绕在有水平轴的定滑轮上，滑轮的转动惯量为l，绳下端挂一物体。物体所受重力为G，滑轮的角加速度为b，若将物体去掉而以与G相等的力直接向下拉绳子，滑轮的角加速度b将（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 不变</p><p>B. 变小</p><p>C. 变大</p><p>D. 无法判断</p></li><li><p>一人造地球卫星到地球中心$O$的最大距离和最小距离分别是$R_A$和$R_B$，设卫星对应的角动量分别是$L_A$、$L_B$，动能分别是$E_{KA}$、$E_{KB}$​，则应有（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p>A. $L_B&gt;L_A$，$E_{KA}&gt;E_{KB}$</p><p>B. $L_B&gt;L_A$，$E_{KA}=E_{KB}$</p><p>C. $L_B=L_A$，$E_{KA}=E_{KB}$</p><p>D. $L_B=L_A$，$E_{KA}&lt;E_{KB}$​</p></li><li><p>一圆盘正绕垂直于盘面的水平光滑固定轴$O$转动，如图射来两个质量相同，速度大小相同，方向相反并在一条直线上的子弹，子弹射入圆盘并且留在盘内，则子弹射入后的瞬间，圆盘的角速度$\omega$​将（）</p><p><img src="https://oss.iuoyt.com/img/posts/2e9f00daa6427d28e078913525f6b03e.png" alt="题图"></p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 增大</p><p>B. 不变</p><p>C. 减小</p><p>D. 不能确定</p></li><li><p>已知一定量的某种理想气体，在温度为$T_1$与$T_2$时分子最概然速率分别为$v_{p1}$和$v_{p2}$，分子速率分布函数的最大值分别为$f(v_{p1})$和$f(v_{p2})$若$T_1&gt;T_2$则（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. $v_{p1}&gt;v_{p2},f(v_{p1})&gt;f(v_{p2})$​</p><p>B. $v_{p1}&gt;v_{p2},f(v_{p1})&lt;f(v_{p2})$​</p><p>C. $v_{p1}&lt;v_{p2},f(v_{p1})&gt;f(v_{p2})$</p><p>D. $v_{p1}&lt;v_{p2},f(v_{p1})&lt;f(v_{p2})$​</p></li><li><p>置于容器内的气体，如果气体内各处压强相等，或气体内各处温度相同，则这两种情况下气体的状态（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. 一定都是平衡态</p><p>B. 不一定都是平衡态</p><p>C. 前者一定是平衡态，后者一定不是平衡态</p><p>D. 后者一定时平衡态，前者一定不是平衡态</p></li><li><p>如图所示，一定量理想气体从体积$V_1$，膨胀到体积$V_2$分别经历的过程是：$A\to B$等压过程，$A\to C$等温过程，$A\to D$​绝热过程，其中吸热量最多的过程是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/14c01f1f8b1a632a3a08563ab7bd4798.png" alt="题图"></p><p>A. 是$A\to B$</p><p>B. 是$A\to C$</p><p>C. 是$A\to D$</p><p>D. 既是$A\to B$也是$A\to C$， 两过程吸热一样多</p></li><li><p>有两个相同的容器，容积固定不变，一个盛有氨气，另一个盛有氢气(看成刚性分子的理想气体)，它们的压强和温度都相等，现将$5J$​的热量传给氢气，使氢气温度升高，如果使氨气也升高同样的温度，则应向氨气传递热量是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p>A. $6J$</p><p>B. $5J$</p><p>C. $3J$</p><p>D. $2J$</p></li><li><p>关于可逆过程和不可逆过程的判断:</p><p>①可逆热力学过程一定是准静态过程.</p><p>②准静态过程一定是可逆过程.</p><p>③不可逆过程就是不能向相反方向进行的过程.</p><p>④凡有摩擦的过程,一定是不可逆过程.</p><p>以上四种判断，其中正确的是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p>A. ①②③</p><p>B. ①②④</p><p>C. ②④</p><p>D. ①④</p></li><li><p>坐标原点放一正电荷$Q$，它在$P$点$(x=+1,y=0)$产生的电场强度为$E$。现在，另外有一个负电荷$-2Q$，试问应将它放在什么位置才能使$P$​点的电场强度等于零?（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. x轴上，且x&gt;1</p><p>B. x轴上，且-1&lt;x&lt;0</p><p>C. y轴上，且y&gt;0</p><p>D. yy&lt;0轴上，且x&gt;1</p></li><li><p>电荷$Q$被曲面$S$所包围 ， 从无穷远处引入另一点电荷$q$至曲面外一点，如图所示，则引入前后（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/72bc933c9fdfeca8e0b21d6a55133962.png" alt="题图"></p><p>A. 曲面<em>S</em>的电场强度通量不变，曲面上各点场强不变</p><p>B. 曲面<em>S</em>的电场强度通量变化，曲面上各点场强不变</p><p>C. 曲面<em>S</em>的电场强度通量变化，曲面上各点场强变化</p><p>D. 曲面<em>S</em>的电场强度通量不变，曲面上各点场强变化</p></li><li><p>半径为$R$的“无限长”均匀带电圆柱体的静电场中各点的电场强度的大小$E$与距轴线的距离$r$的关系曲线为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. <img src="https://oss.iuoyt.com/img/posts/6624119458402abcdd0c5395e51afc6c.png" alt="题图"></p><p>B. <img src="https://oss.iuoyt.com/img/posts/4e35ff5abc09dfcbf9ed8e4d28aeeb0f.png" alt="题图"></p><p>C. <img src="https://oss.iuoyt.com/img/posts/851a5d9c00e39fd3d959c5db88e37d8a.png" alt="题图"></p><p>D. <img src="https://oss.iuoyt.com/img/posts/103b340a50f8a37bbeb186c6fd54b337.png" alt="题图"></p></li><li><p>在点电荷$+q$的电场中，若取图中$P$点处为电势零点 ， 则$M$点的电势为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/950aa318927ff1bda52198e09832c895.png" alt="题图"></p><p>A. $\frac{q}{4\pi \epsilon_0a} $</p><p>B. $\frac{q}{8\pi \epsilon_0a} $</p><p>C. $\frac{-q}{4\pi \epsilon_0a} $</p><p>D. $\frac{-q}{8\pi \epsilon_0a} $</p></li><li><p>半径为$r$的均匀带电球面1，带有电荷$q$，其外有一同心的半径为$R$的均匀带电球面2，带有电荷$Q$，则此两球面之间的电势差$U_1-U_2$为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p>A. $\frac{q}{4\pi\epsilon_0}(\frac{1}{r}-\frac{1}{R})$</p><p>B. $\frac{Q}{4\pi\epsilon_0}(\frac{1}{R}-\frac{1}{r})$</p><p>C. $\frac{1}{4\pi\epsilon_0}(\frac{q}{r}-\frac{Q}{R})$</p><p>D. $\frac{q}{4\pi\epsilon_0}$</p></li><li><p>一对等量异种电荷同时在同一点射入匀强磁场。已知正、负电荷的速度大小分别为$2v$和$v$，方向都和磁场$B$垂直，则（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 正电荷先返回到出发点</p><p>B. 负电荷先返回到出发点</p><p>C. 同时返回到出发点</p><p>D. 不知道</p></li><li><p>通有电流<em>I</em>的无限长直导线有如图三种形状，则$P,Q,O$各点磁感强度的大小$B_P，B_Q，B_O$间的关系为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/f010bab0cba00e81ff6d5ecbc5bf60cc.png" alt="题图"></p><p>A. $B_P&gt;B_Q&gt;B_O$</p><p>B. $B_Q&gt;B_P&gt;B_O$</p><p>C. $B_Q&gt;B_O&gt;B_P$</p><p>D. $B_O&gt;B_Q&gt;B_P$</p></li><li><p>如图两个半径为<em>R</em>的相同的金属环在$a、b$两点接触(<em>ab</em>连线为环直径)，并相互垂直放置。电流$I$沿$ab$连线方向由$a$端流入，$b$端流出，则环中心$O$点的磁感强度的大小为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/58e6341f316dfd977b1042652007c76a.png" alt="题图"></p><p>A. 0</p><p>B. $\frac{\mu_0I}{4R} $</p><p>C. $\frac{\mu_0I}{R} $</p><p>D. $\frac{\sqrt{2}\mu_0I}{R} $</p></li><li><p>如图所示，一矩形线圈以匀速自无场区平移进入均匀磁场区，又平移穿出。在(A)、(B)、©、(D)各$I-t$曲线中哪一种符合线圈中的电流随时间的变化关系（取逆时针指向为电流正方向，且不计线圈的自感）?（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/664504909a32680dc5a126b61f8e7474.png" alt="题图"></p><p><img src="https://oss.iuoyt.com/img/posts/217a332d3904ffe04ee36a51d79f8f72.png" alt="题图"><img src="https://oss.iuoyt.com/img/posts/365c866da16ecc11369efb86cfcbb3a2.png" alt="题图"><img src="https://oss.iuoyt.com/img/posts/c1c2f5bf18f9269f9ab0bff5c1b1fd4b.png" alt="题图"><img src="https://oss.iuoyt.com/img/posts/afdde1d2e6140cd6fbb7610d599fdce5.png" alt="题图"></p></li><li><p>轻质弹簧下挂一个小盘，小盘作简谐振动，平衡位置为原点，位移向下为正，并采用余弦表示。小盘处于最低位置时刻有一个小物体不变盘速地粘在盘上，设新的平衡位置相对原平衡位置向下移动的距离小于原振幅，且以小物体与盘相碰为计时零点，那么以新的平衡位置为原点时，新的位移表示式的初相在（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p>A. $0\sim \frac{p}{2}$之间</p><p>B. $\frac{p}{2}\sim p$之间</p><p>C. $p\sim \frac{3p}{2}$之间</p><p>D. $\frac{3p}{2}\sim 2p$之间</p></li><li><p>一质点沿x轴作简谐振动，振动方程为$x=4\times10^{-2}\cos(2\pi t+\frac{\pi}{3})$。从$t = 0$时刻起，到质点位置在$x=-2 cm$处，且向x轴正方向运动的最短时间间隔为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p>A. $\frac{1}{2}s$</p><p>B. $\frac{1}{4}s$</p><p>C. $\frac{1}{6}s$</p><p>D. $\frac{1}{8}s$</p></li><li><p>图中所画的是两个简谐振动的振动曲线.若这两个简谐振动可叠加，则合成的余弦振动的初相为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/f8518150a0292bcf7e59f200ea72aabb-1717664091015-13.png" alt="题图"></p><p>A. $\frac{3}{2}\pi$</p><p>B. $\pi$</p><p>C. $\frac{1}{2}\pi$</p><p>D. 0</p></li><li><p>在下面几种说法中，正确的说法是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 波源不动时，波源的振动周期与波动的周期在数值上是不同的.</p><p>B. 波源振动的速度与波速相同.</p><p>C. 在波传播方向上的任一质点振动相位总是比波源的相位滞后(按差值不大于p计).</p><p>D. 在波传播方向上的任一质点的振动相位总是比波源的相位超前.(按差值不大于p计)</p></li><li><p>图示一沿x轴正向传播的平面简谐波在$t=0$时刻的波形.若振动以余弦函数表示，且此题各点振动初相取$-p$到$p$之间的值，则（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/c6cb7b3f802005f0ee75b8aab8b0741d-1717664107815-22.png" alt="题图"></p><p>A. <em>O</em>点的初相为$\phi_0=-\frac{1}{2}\pi$</p><p>B. <em>1</em>点的初相为$\phi_1=0$</p><p>C. <em>2</em>点的初相为$\phi_2=0$</p><p>D. <em>3</em>点的初相为$\phi_3=0$</p></li></ol><h3 id="填空题">填空题</h3><ol><li><p>（习题1.1）质点x、y、z的分量形式分别为$x=R\cos\omega t,y=R\sin\omega t,z=\frac{h\omega}{2\pi}t$，其中R、h和均为大于零的常量</p><ul><li><p>则质点位矢的表达式为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$r=R\cos\omega ti+R\sin\omega tj+\frac{h\omega t}{2\pi}k$</p></div></div></li><li><p>任意时刻质点的速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$v=-\omega R\sin\omega ti+R\omega\cos \omega tj+\frac{h\omega}{2\pi}k$</p></div></div></li><li><p>任意时刻质点的加速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a=-\omega^2R(\cos\omega ti+\sin \omega tj)$</p></div></div></li></ul></li><li><p>（习题1.2）已知质点的运动方程为$r=t^2i+(t-1)^2j$​（SI单位），则</p><ul><li><p>质点的运动轨迹（仅考虑t-1 s&gt;0的情况）为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\sqrt{y}=\sqrt{x}-1$</p></div></div></li><li><p>从t=1s到t=2s质点的位移为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\Delta r=3i+j$</p></div></div></li><li><p>t=2s时，质点的速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$v_{2s}=4i+2j$</p></div></div></li><li><p>t=2s时，质点的加速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a_{2s}=2i+2j$</p></div></div></li></ul></li><li><p>（习题1.3）一质点做直线运动，其顺时加速度的变化规律为$a=-A\omega^2\cos \omega t$。已知$t=0$时，质点的速度和位移大小分别为$v_0=0$和$x=A$，其中$A$和$\omega$均为大于零的常量，则该质点的运动学方程为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$x=A\cos\omega t$</p></div></div></li><li><p>（习题1.9）一质量为$m$的质点在$Oxy$平面上运动，其位置矢量为$r=a\cos\omega ti+b\sin\omega tj$，其中$a,b,\omega$都是常量，则质点在任一时刻的加速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a=-a\omega^2\cos\omega ti-b\omega^2\sin\omega tj=-\omega^2r$</p></div></div></li><li><p>（习题2.1）一个半径为$R=1m$的飞轮以1500转每分钟的转速绕垂直盘面过圆心的定轴转动，受到制动后均匀减速，经$t=50s$后停止。则</p><ul><li><p>该飞轮的角加速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a=\frac{\omega-\omega_0}{t}=-\pi rad/s^2$</p></div></div></li><li><p>从制动开始到静止转过的圈数为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$N=\frac{\theta}{2\pi}=\frac{\omega_0t+\frac{1}{2}\alpha t^2}{2\pi}=625$</p></div></div></li><li><p>制动开始25s时，飞轮的角速度为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\omega_t=\omega_0+\alpha t=25\pi rad/s$</p></div></div></li></ul></li><li><p>（习题2.6）一根质量为$m$，长度为$l$的匀质细杆AB由一摩擦力可略去的铰链悬挂于某处，现欲使细杆恰好能从竖直位置转至水平位置，则需要给细杆的初角速度应该为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\omega_0=\sqrt{\frac{3g}{l}}$</p></div></div></li><li><p>（习题2.2）质量为$m$，长度为$l$的均匀细棒AB，其转轴到中心点$O$的距离为$\frac{l}{4}$并与棒垂直，该细棒对于该轴的转动惯量为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$I=\frac{7}{48}ml^2$</p></div></div></li><li><p>（P57）在跳水比赛中，运动员为了增加在空中的翻腾速度，他采取的方式是将身体收紧，其目的是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：减小转动惯量</p></div></div></li><li><p>（习题3.1）一定质量的气体在压强保持不变的情况下，温度由$50℃$升高到$100℃$，此时体积改变量为原来体积的（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\frac{\delta V}{V_1}=\frac{373}{323}=115.5%$</p></div></div></li><li><p>（习题3.3）真空设备内部的压强为$1.013\times 10^{-10}$Pa，若系统温度为$300K$，则此时气体分子数密度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$n=\frac{p}{kt}=\frac{1.013\times 10^{-10}}{1.38\times 10^{-23}\times 300}m^{-3}\approx 2.45\times10^{10}m^{-3}$</p></div></div></li><li><p>（习题4.1）一个打足气的自行车内胎，若在$7.0℃$时轮胎中空气的压强为$4.0\times 10^5$Pa，则在温度变为$37℃$时，轮胎中的空气压强为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$p_0=\frac{T_0}{T}p=\frac{310\times 4.0\times 10^5}{280}Pa\approx 4.43\times10^5Pa$</p></div></div></li><li><p>（习题4.3）气缸中贮有$2.0mol$的空气，温度为$27℃$，维持压强不变，而使空气的体积膨胀到原来的3倍，此时空气膨胀时所做的功为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$A=p(V_2-V_1)=2\nu RT_1=9.972\times10^3J$</p></div></div></li><li><p>（习题4.4）一定量的空气，吸收了$1.71\times 10^3J$的热量，并保持在$1.0\times 10^5Pa$下膨胀，体积从$1.0\times 10^{-2} m^3$增加到$1.5\times 10^{-2} m^3$，此时空气对外做功为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$A=\int pdV=p(V_2-V_1)=500J$</p></div></div></li><li><p>（思考8.2）将弹簧振子的弹簧截去一部分，其振动周期将（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：减小</p></div></div></li><li><p>（思考8.4）振幅为$A$的弹簧振子，当位移是振幅的一半时，它的动能占总能量的（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\frac{3}{4}$</p></div></div></li><li><p>（习题8.1）一质点按如下规律沿x轴做简谐振动（$x=0.05\cos[4\pi(t+\frac{1}{6})]$），则加速度的最大值约为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a_{max}=A\omega^2\approx7.89m/s^2$</p></div></div></li><li><p>（习题8.2）设简谐振动的方程为$x=0.02\cos(100\pi t+\frac{\pi}{3})$，则t=1s时相位为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\frac{301}{3}\pi$</p></div></div></li><li><p>（习题8.8.3）质量$m=100g$的小球与弹簧构成的系统，按$x=0.05\cos(4\pi t+\frac{\pi}{3})$的规律做自由振动，则振动的能量是（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$E=\frac{1}{2}m\omega^2A^2=2\pi^2\times10^{-3}J$</p></div></div></li><li><p>（习题1.9）一质量为$m$的质点在$Oxy$平面上运动，其位置矢量为$r=a\cos\omega ti+b\sin\omega tj$，其中$a,b,\omega$都是常量，则质点所受的力对原点$O$的力矩为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$M=r\times F=r\times(-m\omega^2r)=-m\omega^2(r\times r)=0$</p></div></div></li><li><p>（习题5.1）在氢核（质子）与电子之间的最短距离为$5.3\times 10^{-11}m$，氢核与电子之间的静电力大小为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$F=\frac{1}{4\pi\varepsilon _0}\frac{q_1q_2}{r^2}=8.2\times 10^{-8}N$</p></div></div></li><li><p>（习题5.2）如图，真空中的三个点电荷，它们固定在边长为50cm的等边三角形的三个定点上，每个电荷的电荷量都是$2\times 10^{-6}C$​，每个电荷所受到的静电力大小均为​（）</p><p><img src="https://oss.iuoyt.com/img/posts/5599ecd6c68f38da29422892076e9b1c.png" alt="题图"></p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$F=2F_1\cos 30°=2\times \frac{1}{4\pi\varepsilon_0}\frac{q^2}{r^2}=0.25N$</p></div></div></li><li><p>（习题5.5）两个带等量异号电荷的无限大平行平面，电荷的面密度为$\sigma$，则它们之间的电场强度大小为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$E=\frac{\sigma}{2\varepsilon_0}+\frac{\sigma}{2\varepsilon_0}=\frac{\sigma}{\varepsilon_0}$</p></div></div></li><li><p>（习题5.10）一根长为L的细棒，被弯成半圆形，其上均匀带电，电荷线密度为$+\lambda$，则圆心处的电势为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$V=\int \mathrm{d}V=\int_{0}^{L} \frac{\lambda \mathrm{d}l}{4\pi\varepsilon_0R}=\frac{\lambda L}{4\pi\varepsilon_0R}=\frac{\lambda} {4\varepsilon_0}$</p></div></div></li><li><p>（习题5.13）半径为R的均匀带电球面至于真空中，其电荷面密度为$\sigma$​，则球面内的电场强度为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：0</p></div></div></li><li><p>（思考6.1）在磁感强度为$B$的匀强磁场中，作一个半径为$r$的半球面$S$，$S$的边线所在的平面的法线方向单位矢量$e_n$与$B$之间的夹角为$\alpha$，则通过半球面$S$的磁通量为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\int\limits_{S}B\cdot\mathrm{d}S=\pi r^2B\cos \alpha $</p></div></div></li><li><p>当电子沿着（）方向射入匀强磁场中，它所受的磁场力最大</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：垂直</p></div></div></li><li><p>（思考6.4）若一电子以速度$v$射入磁感应强度为$B$​的匀强磁场中，当射入方向（）于磁场时，其不受磁场力的作用。</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：平行</p></div></div></li><li><p>（思考6.6）当载流线圈（）于磁力线时，磁力矩最大。</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：平行</p></div></div></li><li><p>（思考7.1）感应电动势的大小取决于（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：磁通量对时间的变化率</p></div></div></li><li><p>如图所示，当长直导线中的电流逐渐变大时，线圈中的感应电流方向是（）</p><p><img src="https://oss.iuoyt.com/img/posts/cfe4ee4bd5da5097d764d8e5c9ea8b64.png" alt="题图"></p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：逆时针</p></div></div></li><li><p>当导体线圈切割磁力线时，所产生的感应电动势是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：动生电动势</p></div></div></li></ol><h3 id="判断题">判断题</h3><ol><li><p>（思考1.3.1）质点做圆周运动时，加速度一定垂直于速度方向，并指向圆心<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.3.2）加速度始终垂直于速度，则质点一定做圆周运动<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.3.3）质点在做匀速圆周运动过程中，加速度总是不变<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.3.4）只有切向加速度的运动一定是直线运动<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考1.4.1）物体运动方向总和和其所受合外力的方向相同<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.4.2）物体一旦受力就会产生加速度<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.4.3）物体运动的速率不变，则其所受合外力必然为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.1.1）内力矩不会改变刚体对某个定轴的角动量<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考2.1.2）作用力和反作用力对同一轴的力矩之和为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考2.1.3）大小相同、方向相反的两个力对同一轴的力矩之和为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.2.1）作用在定轴转动刚体上的力越大，刚体转动的角加速度越大<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.1.4）质量相等、形状和大小不同的刚体，在相同力矩的作用下，它们的角加速度一定相等<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.2.2）作用在定轴转动刚体上的合力矩越大，刚体转动的角速度越大<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.2.3）作用在定轴转动刚体上的合力矩为零，刚体转动的角速度也为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>作用在定轴转动刚体上的合力矩为零，刚体转动的角加速度也为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考2.5）平行于转轴的力对转轴的力矩一定等于零，而垂直与转轴的力对转轴的力矩一定不为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考3.2.1）当容器内部各部分的压强相等时，系统处于平衡态<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考3.2.2）若容器内各部分的温度相同，则相同处于平衡态<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考3.2.3）容器内各部分的压强相等，并且容器内各部分分子数密度也相同，则系统处于平衡态<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>温度和体积均相同的氧气和氮气具有相同的分子平均平动动能<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考3.7）$1mol$氢气与$1mol$氦气具有相同的内能<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考4.1）系统含有热量即系统含有功<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考4.3）系统吸收了热量，其内能必然增加了<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>系统对外做功其内能必然减少<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考4.10）绝热压缩气体，其内能一定增加<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考4.11）系统的温度升高一定是吸收了热量<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>热量会自动地从高温物体传到低温物体，也可以自动地从低温物体传到高温物体<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考5.1.1）两个完全相同的均匀带电小球分别带电荷量$q_1=2C$(正电荷)，$q_2=4C$(负电荷)，在真空中相距为r且静止，相互作用的静电力为F。当$q_1,q_2,r$都加倍时，作用力不变<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>在真空中相距为$r$且静止，相互作用的静电力为$F$，若两个小球的带电量都增加一倍，则它们之间的力也增加一倍<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考5.7）静电场中的零电势可以随意选择<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>如果通过一个闭合曲面的电场强度通量为0，那么该曲面上的电场强度处处为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考5.6）在电场中，电场强度为零的点，电势也为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考5.6）在静电场中，电势为零的点电场强度也一定为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考6.7）在匀强磁场中，面积相同、通有相同电流的的线圈，它们的磁矩也相等<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考7.1）感应电动势的大小取决于磁场强度<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>感应电荷量与穿过闭合线圈的磁铁速度无关<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>感应电荷量大小与穿越闭合线圈的磁铁的极性无关<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>磁场中的洛伦兹力不做功<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>如图所示，当长直导线中的电流发生变化时，线圈中的感应电动势是感生电动势。</p><p><img src="https://oss.iuoyt.com/img/posts/cfe4ee4bd5da5097d764d8e5c9ea8b64-1717645771981-90.png" alt="题图"></p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></li><li><p>（思考8.1.1）当弹性小球在地面上跳动时，是一种简谐振动。<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考8.1.2）小球在光滑的球形凹槽内进行小幅度摆动时，这是一种简谐振动<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考8.6）阻尼振动也是一种周期性振动<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考8.10.1）同一波线上，相位差为$2\pi$的两个振动质元之间的距离就是在一个周期内振动所传播的距离<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考8.13）机械波可以传递能量，也可以传递动量<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li></ol><h3 id="简答题">简答题</h3><ol><li><p>（习题5.4）如图所示，在真空中有两个点电荷，$Q_1=+3.0×10^{-8}C$，$Q_2=-3.0×10^{-8}C$，两点电荷相距$0.1$m，若电场中的A点与两点电荷之间等距离且$r=0.1m$​时，则A点电场强度的大小为？</p><p><img src="https://oss.iuoyt.com/img/posts/8b82b9014a90f603d0b2f6f33a12b31bb051ed00.jpg" alt="题图"></p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>点电荷$Q_1$和$Q_2$的电场在A点的场强分别为$E_1$和$E_2$，它们大小相等，合场强$E$在$E_1$和$E_2$的夹角平分线上，平分线与$Q_1Q_2$连线平行，方向向右，合场强$E$的大小为：</p><p>$E=E_1\cos 60°+E_2\cos 60°=2E_1\cos 60°=\frac{1}{4\pi\varepsilon_0}\frac{2Q_1}{r^2}\cos 60°=2.7\times 10^4 N/C$</p>              </div>            </details></li><li><p>（思考6.6）当载流线圈（）于磁力线时，磁力矩最小？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>垂直</p>              </div>            </details></li><li><p>（思考8.4）振幅为$A$​的弹簧振子，当位移是振幅的一半时，它的势能占总能量的？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>势能占总能量的$\frac{1}{4}$</p>              </div>            </details></li><li><p>（思考8.4）振幅为$A$​的弹簧振子，当它的动能和势能相等时，振子的位移是？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>位移$x=\frac{\sqrt{2}}{2}A$</p>              </div>            </details></li><li><p>（习题8.1）一质点按如下规律沿x轴做简谐振动（$x=0.05\cos[4\pi(t+\frac{1}{6})]$​），则速度的最大值约为？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>$v_{max}=A\omega=0.05\times4\pi m/s\approx0.628m/s$</p>              </div>            </details></li></ol>]]></content>
    
    
    <summary type="html">按题型分类的大学物理期末复习题</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学期总结" scheme="https://www.iuoyt.com/tags/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
    <category term="大学物理" scheme="https://www.iuoyt.com/tags/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>大学物理期末复习题</title>
    <link href="https://www.iuoyt.com/posts/7199abcd.html"/>
    <id>https://www.iuoyt.com/posts/7199abcd.html</id>
    <published>2024-06-07T15:03:46.000Z</published>
    <updated>2024-06-23T15:18:48.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="质点力学与运动学">质点力学与运动学</h2><h3 id="选择题">选择题</h3><ol><li><p>一质点在平面上运动，已知质点位置矢量的表示法为$\vec{r}=at^2\vec{i}+bt^2\vec{j}$（其中a、b为常量），则该质点作（<strong>B</strong>）</p><p>A. 匀速直线运动</p><p>B. 变速直线运动</p><p>C. 抛物线运动</p><p>D. 一般曲线运动</p></li><li><p>质点做曲线运动，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over r}$标识位置矢量，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over v}$表示速度，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over a}$表示加速度，$S$表示路程，$a_t$表示切向加速度，下列表达式中（<strong>D</strong>）</p><p>①$\frac{dv}{dt}=a$</p><p>②$\frac{dr}{dt}=v$</p><p>③$\frac{dS}{dt}=v$</p><p>④$\left | \frac{d\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over v}}{d\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over t}}  \right | =a_t$</p><p>A. 只有①、④正确</p><p>B. 只有②正确</p><p>C. 只有②、④正确</p><p>D. 只有③正确</p></li><li><p>质量为$20g$的子弹，以$400m/s$的速率沿图示方向射入一原来静止的质量为$980g$的摆球中，摆线长度不可伸缩，子弹射入后开始与摆球一起运动的速率为（<strong>B</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/503d269759ee3d6df4f631ab53166d224f4ade9a.jpg" alt="img"></p><p>A. 2m/s</p><p>B. 4m/s</p><p>C. 7m/s</p><p>D. 8m/s</p></li><li><p>一质点在几个外力同时作用下运动时，下述哪种说法正确？（<strong>C</strong>）</p><p>A. 质点的动量改变时，质点的动能一定改变</p><p>B. 质点的动能不变时，质点的动量也一定不变</p><p>C. 外力的冲量是零，外力的功一定为零</p><p>D. 外力的功为零，外力的冲量一定为零</p></li></ol><h3 id="填空题">填空题</h3><ol><li>（习题1.1）质点x、y、z的分量形式分别为$x=R\cos\omega t,y=R\sin\omega t,z=\frac{h\omega}{2\pi}t$，其中R、h和均为大于零的常量<ul><li>则质点位矢的表达式为：$r=R\cos\omega ti+R\sin\omega tj+\frac{h\omega t}{2\pi}k$​</li><li>任意时刻质点的速度为：$v=-\omega R\sin\omega ti+R\omega\cos \omega tj+\frac{h\omega}{2\pi}k$​</li><li>任意时刻质点的加速度为：$a=-\omega^2R(\cos\omega ti+\sin \omega tj)$</li></ul></li><li>（习题1.2）已知质点的运动方程为$r=t^2i+(t-1)^2j$​（SI单位），则<ul><li>质点的运动轨迹（仅考虑t-1 s&gt;0的情况）为：$\sqrt{y}=\sqrt{x}-1$</li><li>从t=1s到t=2s质点的位移为：$\Delta r=3i+j$</li><li>t=2s时，质点的速度为：$v_{2s}=4i+2j$</li><li>t=2s时，质点的加速度为：$a_{2s}=2i+2j$</li></ul></li><li>（习题1.3）一质点做直线运动，其顺时加速度的变化规律为$a=-A\omega^2\cos \omega t$。已知$t=0$时，质点的速度和位移大小分别为$v_0=0$和$x=A$，其中$A$和$\omega$均为大于零的常量，则该质点的运动学方程为：$x=A\cos\omega t$</li><li>（习题1.9）一质量为$m$的质点在$Oxy$平面上运动，其位置矢量为$r=a\cos\omega ti+b\sin\omega tj$，其中$a,b,\omega$都是常量，则质点在任一时刻的加速度为：$a=-a\omega^2\cos\omega ti-b\omega^2\sin\omega tj=-\omega^2r$</li></ol><h3 id="判断题">判断题</h3><ol><li>（思考1.3.1）质点做圆周运动时，加速度一定垂直于速度方向，并指向圆心（✖）</li><li>（思考1.3.2）加速度始终垂直于速度，则质点一定做圆周运动（✖）</li><li>（思考1.3.3）质点在做匀速圆周运动过程中，加速度总是不变（✖）</li><li>（思考1.3.4）只有切向加速度的运动一定是直线运动（✔）</li><li>（思考1.4.1）物体运动方向总和和其所受合外力的方向相同（✖）</li><li>（思考1.4.2）物体一旦受力就会产生加速度（✖）</li><li>（思考1.4.3）物体运动的速率不变，则其所受合外力必然为零（✖）</li></ol><h2 id="刚体力学">刚体力学</h2><h3 id="选择题-2">选择题</h3><ol><li><p>有两个力作用在一个有固定转轴的刚体上，在以下说法中（<strong>B</strong>）</p><p>①这两个力都平行于轴作用时，它们对轴的合力矩一定是零</p><p>②这两个力都垂直于轴作用时，它们对轴的合力矩可能是零</p><p>③当这两个力的合力为零时，它们对轴的合力矩也一定是零</p><p>④当这两个力对轴的合力矩为零时，它们的合力也一定是零</p><p>A. ①②③④都正确</p><p>B. ①②正确，③④错误</p><p>C. 只有①时正确的</p><p>D. ①②③都正确，④错误</p></li><li><p>一轻绳绕在有水平轴的定滑轮上，滑轮的转动惯量为l，绳下端挂一物体。物体所受重力为G，滑轮的角加速度为b，若将物体去掉而以与G相等的力直接向下拉绳子，滑轮的角加速度b将（<strong>C</strong>）</p><p>A. 不变</p><p>B. 变小</p><p>C. 变大</p><p>D. 无法判断</p></li><li><p>一人造地球卫星到地球中心$O$的最大距离和最小距离分别是$R_A$和$R_B$，设卫星对应的角动量分别是$L_A$、$L_B$，动能分别是$E_{KA}$、$E_{KB}$，则应有（<strong>D</strong>）</p><p>A. $L_B&gt;L_A$，$E_{KA}&gt;E_{KB}$</p><p>B. $L_B&gt;L_A$，$E_{KA}=E_{KB}$</p><p>C. $L_B=L_A$，$E_{KA}=E_{KB}$</p><p>D. $L_B=L_A$，$E_{KA}&lt;E_{KB}$​</p></li><li><p>一圆盘正绕垂直于盘面的水平光滑固定轴$O$转动，如图射来两个质量相同，速度大小相同，方向相反并在一条直线上的子弹，子弹射入圆盘并且留在盘内，则子弹射入后的瞬间，圆盘的角速度$\omega$​将（<strong>C</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/2e9f00daa6427d28e078913525f6b03e.png" alt="题图"></p><p>A. 增大</p><p>B. 不变</p><p>C. 减小</p><p>D. 不能确定</p></li></ol><h3 id="填空题-2">填空题</h3><ol><li>（习题2.1）一个半径为$R=1m$的飞轮以1500转每分钟的转速绕垂直盘面过圆心的定轴转动，受到制动后均匀减速，经$t=50s$后停止。则<ul><li>该飞轮的角加速度为：$a=\frac{\omega-\omega_0}{t}=-\pi rad/s^2$</li><li>从制动开始到静止转过的圈数为：$N=\frac{\theta}{2\pi}=\frac{\omega_0t+\frac{1}{2}\alpha t^2}{2\pi}=625$</li><li>制动开始25s时，飞轮的角速度为：$\omega_t=\omega_0+\alpha t=25\pi rad/s$</li></ul></li><li>（习题2.6）一根质量为$m$，长度为$l$的匀质细杆AB由一摩擦力可略去的铰链悬挂于某处，现欲使细杆恰好能从竖直位置转至水平位置，则需要给细杆的初角速度应该为：$\omega_0=\sqrt{\frac{3g}{l}}$</li><li>（习题2.2）质量为$m$，长度为$l$的均匀细棒AB，其转轴到中心点$O$的距离为$\frac{l}{4}$并与棒垂直，该细棒对于该轴的转动惯量为：$I=\frac{7}{48}ml^2$</li><li>（P57）在跳水比赛中，运动员为了增加在空中的翻腾速度，他采取的方式是将身体收紧，其目的是：减小转动惯量</li></ol><h3 id="判断题-2">判断题</h3><ol><li>（思考2.1.1）内力矩不会改变刚体对某个定轴的角动量（✔）</li><li>（思考2.1.2）作用力和反作用力对同一轴的力矩之和为零（✔）</li><li>（思考2.1.3）大小相同、方向相反的两个力对同一轴的力矩之和为零（✖）</li><li>（思考2.2.1）作用在定轴转动刚体上的力越大，刚体转动的角加速度越大（✖）</li><li>（思考2.1.4）质量相等、形状和大小不同的刚体，在相同力矩的作用下，它们的角加速度一定相等（✖）</li><li>（思考2.2.2）作用在定轴转动刚体上的合力矩越大，刚体转动的角速度越大（✖）</li><li>（思考2.2.3）作用在定轴转动刚体上的合力矩为零，刚体转动的角速度也为零（✖）</li><li>作用在定轴转动刚体上的合力矩为零，刚体转动的角加速度也为零（✔）</li><li>（思考2.5）平行于转轴的力对转轴的力矩一定等于零，而垂直与转轴的力对转轴的力矩一定不为零（✖）</li></ol><h2 id="气体动理论与热力学">气体动理论与热力学</h2><h3 id="选择题-3">选择题</h3><ol><li><p>已知一定量的某种理想气体，在温度为$T_1$与$T_2$时分子最概然速率分别为$v_{p1}$和$v_{p2}$，分子速率分布函数的最大值分别为$f(v_{p1})$和$f(v_{p2})$若$T_1&gt;T_2$则（<strong>B</strong>）<br>A. $v_{p1}&gt;v_{p2},f(v_{p1})&gt;f(v_{p2})$</p><p>B. $v_{p1}&gt;v_{p2},f(v_{p1})&lt;f(v_{p2})$​</p><p>C. $v_{p1}&lt;v_{p2},f(v_{p1})&gt;f(v_{p2})$</p><p>D. $v_{p1}&lt;v_{p2},f(v_{p1})&lt;f(v_{p2})$​</p></li><li><p>置于容器内的气体，如果气体内各处压强相等，或气体内各处温度相同，则这两种情况下气体的状态（<strong>B</strong>）</p><p>A. 一定都是平衡态</p><p>B. 不一定都是平衡态</p><p>C. 前者一定是平衡态，后者一定不是平衡态</p><p>D. 后者一定时平衡态，前者一定不是平衡态</p></li><li><p>如图所示，一定量理想气体从体积$V_1$，膨胀到体积$V_2$分别经历的过程是：$A\to B$等压过程，$A\to C$等温过程，$A\to D$绝热过程，其中吸热量最多的过程（<strong>A</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/14c01f1f8b1a632a3a08563ab7bd4798.png" alt="img"></p><p>A. 是$A\to B$</p><p>B. 是$A\to C$</p><p>C. 是$A\to D$</p><p>D. 既是$A\to B$也是$A\to C$， 两过程吸热一样多</p></li><li><p>有两个相同的容器，容积固定不变，一个盛有氨气，另一个盛有氢气(看成刚性分子的理想气体)，它们的压强和温度都相等，现将$5J$的热量传给氢气，使氢气温度升高，如果使氨气也升高同样的温度，则应向氨气传递热量是（<strong>A</strong>）</p><p>A. $6J$</p><p>B. $5J$</p><p>C. $3J$</p><p>D. $2J$</p></li><li><p>关于可逆过程和不可逆过程的判断:</p><p>①可逆热力学过程一定是准静态过程.</p><p>②准静态过程一定是可逆过程.</p><p>③不可逆过程就是不能向相反方向进行的过程.</p><p>④凡有摩擦的过程,一定是不可逆过程.</p><p>以上四种判断，其中正确的是（<strong>D</strong>）</p><p>A. ①②③</p><p>B. ①②④</p><p>C. ②④</p><p>D. ①④</p></li></ol><h3 id="填空题-3">填空题</h3><ol><li><p>（习题3.1）一定质量的气体在压强保持不变的情况下，温度由$50℃$升高到$100℃$，此时体积变为原来的：$\frac{\delta V}{V_1}=\frac{373}{323}=115.5%$</p></li><li><p>（习题3.3）真空设备内部的压强为$1.013\times 10^{-10}$Pa，若系统温度为$300K$，则此时气体分子数密度为：$n=\frac{p}{kt}=\frac{1.013\times 10^{-10}}{1.38\times 10^{-23}\times 300}m^{-3}\approx 2.45\times10^{10}m^{-3}$</p></li><li><p>（习题4.1）一个打足气的自行车内胎，若在$7.0℃$时轮胎中空气的压强为$4.0\times 10^5$Pa，则在温度变为$37℃$时，轮胎中的空气压强为：$p_0=\frac{T_0}{T}p=\frac{310\times 4.0\times 10^5}{280}Pa\approx 4.43\times10^5Pa$</p></li><li><p>（习题4.3）气缸中贮有$2.0mol$的空气，温度为$27℃$，维持压强不变，而使空气的体积膨胀到原来的3倍，此时空气膨胀时所做的功为：$A=p(V_2-V_1)=2\nu RT_1=9.972\times10^3J$</p></li><li><p>（习题4.4）一定量的空气，吸收了$1.71\times 10^3J$的热量，并保持在$1.0\times 10^5Pa$下膨胀，体积从$1.0\times 10^{-2} m^3$增加到$1.5\times 10^{-2} m^3$，此时空气对外做功为：$A=\int pdV=p(V_2-V_1)=500J$</p></li></ol><h3 id="判断题-3">判断题</h3><ol><li><p>（思考3.2.1）当容器内部各部分的压强相等时，系统处于平衡态（✖）</p></li><li><p>（思考3.2.2）若容器内各部分的温度相同，则相同处于平衡态（✖）</p></li><li><p>（思考3.2.3）容器内各部分的压强相等，并且容器内各部分分子数密度也相同，则系统处于平衡态（✔）</p></li><li><p>温度和体积均相同的氧气和氮气具有相同的分子平均平动动能（✔）</p></li><li><p>（思考3.7）$1mol$氢气与$1mol$氦气具有相同的内能（✖）</p></li><li><p>（思考4.1）系统含有热量即系统含有功（✖）</p></li><li><p>（思考4.3）系统吸收了热量，其内能必然增加了（✖）</p></li><li><p>系统对外做功其内能必然减少（✖）</p></li><li><p>（思考4.10）绝热压缩气体，其内能一定增加（✔）</p></li><li><p>（思考4.11）系统的温度升高一定是吸收了热量（✖）</p></li><li><p>热量会自动地从高温物体传到低温物体，也可以自动地从低温物体传到高温物体（✖）</p></li></ol><h2 id="静电、电磁、稳恒">静电、电磁、稳恒</h2><h3 id="简答题">简答题</h3><ol><li><p>（习题5.4）如图所示，在真空中有两个点电荷，$Q_1=+3.0×10^{-8}C$，$Q_2=-3.0×10^{-8}C$，两点电荷相距$0.1$m，若电场中的A点与两点电荷之间等距离且$r=0.1m$​时，则A点电场强度的大小为？</p><p><img src="https://oss.iuoyt.com/img/posts/8b82b9014a90f603d0b2f6f33a12b31bb051ed00.jpg" alt="img"></p><blockquote><p>点电荷$Q_1$和$Q_2$的电场在A点的场强分别为$E_1$和$E_2$，它们大小相等，合场强$E$在$E_1$和$E_2$的夹角平分线上，平分线与$Q_1Q_2$连线平行，方向向右，合场强$E$的大小为：</p><p>$E=E_1\cos 60°+E_2\cos 60°=2E_1\cos 60°=\frac{1}{4\pi\varepsilon_0}\frac{2Q_1}{r^2}\cos 60°=2.7\times 10^4 N/C$</p></blockquote></li><li><p>（思考6.6）当载流线圈（）于磁力线时，磁力矩最小？</p><blockquote><p>垂直</p></blockquote></li></ol><h3 id="选择题-4">选择题</h3><ol><li><p>坐标原点放一正电荷$Q$，它在$P$点$(x=+1,y=0)$产生的电场强度为$E$。现在，另外有一个负电荷$-2Q$，试问应将它放在什么位置才能使$P$点的电场强度等于零?（<strong>B</strong>）</p><p>A. x轴上，且x&gt;1</p><p>B. x轴上，且-1&lt;x&lt;0</p><p>C. y轴上，且y&gt;0</p><p>D. yy&lt;0轴上，且x&gt;1</p></li><li><p>电荷$Q$被曲面$S$所包围 ， 从无穷远处引入另一点电荷$q$至曲面外一点，如图所示，则引入前后（<strong>D</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/72bc933c9fdfeca8e0b21d6a55133962.png" alt="img"></p><p>A. 曲面<em>S</em>的电场强度通量不变，曲面上各点场强不变</p><p>B. 曲面<em>S</em>的电场强度通量变化，曲面上各点场强不变</p><p>C. 曲面<em>S</em>的电场强度通量变化，曲面上各点场强变化</p><p>D. 曲面<em>S</em>的电场强度通量不变，曲面上各点场强变化</p></li><li><p>半径为$R$的“无限长”均匀带电圆柱体的静电场中各点的电场强度的大小$E$与距轴线的距离$r$的关系曲线为（<strong>B</strong>）</p><p>A. <img src="https://oss.iuoyt.com/img/posts/6624119458402abcdd0c5395e51afc6c.png" alt="img"></p><p>B. <img src="https://oss.iuoyt.com/img/posts/4e35ff5abc09dfcbf9ed8e4d28aeeb0f.png" alt="img"></p><p>C. <img src="https://oss.iuoyt.com/img/posts/851a5d9c00e39fd3d959c5db88e37d8a.png" alt="img"></p><p>D. <img src="https://oss.iuoyt.com/img/posts/103b340a50f8a37bbeb186c6fd54b337.png" alt="img"></p></li><li><p>在点电荷$+q$的电场中，若取图中$P$点处为电势零点 ， 则$M$点的电势为（<strong>D</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/950aa318927ff1bda52198e09832c895.png" alt="img"></p><p>A. $\frac{q}{4\pi \epsilon_0a} $</p><p>B. $\frac{q}{8\pi \epsilon_0a} $</p><p>C. $\frac{-q}{4\pi \epsilon_0a} $</p><p>D. $\frac{-q}{8\pi \epsilon_0a} $</p></li><li><p>半径为$r$的均匀带电球面1，带有电荷$q$，其外有一同心的半径为$R$的均匀带电球面2，带有电荷$Q$，则此两球面之间的电势差$U_1-U_2$为（<strong>A</strong>）</p><p>A. $\frac{q}{4\pi\epsilon_0}(\frac{1}{r}-\frac{1}{R})$</p><p>B. $\frac{Q}{4\pi\epsilon_0}(\frac{1}{R}-\frac{1}{r})$</p><p>C. $\frac{1}{4\pi\epsilon_0}(\frac{q}{r}-\frac{Q}{R})$</p><p>D. $\frac{q}{4\pi\epsilon_0}$</p></li><li><p>一对等量异种电荷同时在同一点射入匀强磁场。已知正、负电荷的速度大小分别为$2v$和$v$，方向都和磁场$B$垂直，则（<strong>C</strong>）</p><p>A. 正电荷先返回到出发点</p><p>B. 负电荷先返回到出发点</p><p>C. 同时返回到出发点</p><p>D. 不知道</p></li><li><p>通有电流<em>I</em>的无限长直导线有如图三种形状，则$P,Q,O$各点磁感强度的大小$B_P，B_Q，B_O$间的关系为（<strong>D</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/f010bab0cba00e81ff6d5ecbc5bf60cc.png" alt="img"></p><p>A. $B_P&gt;B_Q&gt;B_O$</p><p>B. $B_Q&gt;B_P&gt;B_O$</p><p>C. $B_Q&gt;B_O&gt;B_P$</p><p>D. $B_O&gt;B_Q&gt;B_P$</p></li><li><p>如图两个半径为<em>R</em>的相同的金属环在$a、b$两点接触(<em>ab</em>连线为环直径)，并相互垂直放置。电流$I$沿$ab$连线方向由$a$端流入，$b$端流出，则环中心$O$点的磁感强度的大小为（<strong>A</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/58e6341f316dfd977b1042652007c76a.png" alt="img"></p><p>A. 0</p><p>B. $\frac{\mu_0I}{4R} $</p><p>C. $\frac{\mu_0I}{R} $</p><p>D. $\frac{\sqrt{2}\mu_0I}{R} $</p></li><li><p>如图所示，一矩形线圈以匀速自无场区平移进入均匀磁场区，又平移穿出。在(A)、(B)、©、(D)各$I-t$曲线中哪一种符合线圈中的电流随时间的变化关系（取逆时针指向为电流正方向，且不计线圈的自感）?（<strong>D</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/664504909a32680dc5a126b61f8e7474.png" alt="img"></p><p><img src="https://oss.iuoyt.com/img/posts/217a332d3904ffe04ee36a51d79f8f72.png" alt="img"><img src="https://oss.iuoyt.com/img/posts/365c866da16ecc11369efb86cfcbb3a2.png" alt="img"><img src="https://oss.iuoyt.com/img/posts/c1c2f5bf18f9269f9ab0bff5c1b1fd4b.png" alt="img"><img src="https://oss.iuoyt.com/img/posts/afdde1d2e6140cd6fbb7610d599fdce5.png" alt="img"></p></li></ol><h3 id="填空题-4">填空题</h3><ol><li><p>（习题5.1）在氢核（质子）与电子之间的最短距离为$5.3\times 10^{-11}m$，氢核与电子之间的静电力大小为：$F=\frac{1}{4\pi\varepsilon _0}\frac{q_1q_2}{r^2}=8.2\times 10^{-8}N$</p></li><li><p>（习题5.2）如图，真空中的三个点电荷，它们固定在边长为50cm的等边三角形的三个定点上，每个电荷的电荷量都是$2\times 10^{-6}C$，每个电荷所受到的静电力大小均为：$F=2F_1\cos 30°=2\times \frac{1}{4\pi\varepsilon_0}\frac{q^2}{r^2}=0.25N$</p><p><img src="https://oss.iuoyt.com/img/posts/5599ecd6c68f38da29422892076e9b1c.png" alt="img"></p></li><li><p>（习题5.5）两个带等量异号电荷的无限大平行平面，电荷的面密度为$\sigma$，则它们之间的电场强度大小为：$E=\frac{\sigma}{2\varepsilon_0}+\frac{\sigma}{2\varepsilon_0}=\frac{\sigma}{\varepsilon_0}$</p></li><li><p>（习题5.10）一根长为L的细棒，被弯成半圆形，其上均匀带电，电荷线密度为$+\lambda$，则圆心处的电势为：$V=\int \mathrm{d}V=\int_{0}^{L} \frac{\lambda \mathrm{d}l}{4\pi\varepsilon_0R}=\frac{\lambda L}{4\pi\varepsilon_0R}=\frac{\lambda} {4\varepsilon_0}$</p></li><li><p>（习题5.13）半径为R的均匀带电球面至于真空中，其电荷面密度为$\sigma$，则球面内的电场强度为：0</p></li><li><p>（思考6.1）在磁感强度为$B$的匀强磁场中，作一个半径为$r$的半球面$S$，$S$的边线所在的平面的法线方向单位矢量$e_n$与$B$之间的夹角为$\alpha$，则通过半球面$S$的磁通量为：$\int\limits_{S}B\cdot\mathrm{d}S=-\pi r^2B\cos \alpha $</p></li><li><p>当电子沿着【垂直】方向射入匀强磁场中，它所受的磁场力最大</p></li><li><p>（思考6.4）若一电子以速度$v$射入磁感应强度为$B$的匀强磁场中，当射入方向【平行】于磁场时，其不受磁场力的作用。</p></li><li><p>（思考6.6）当载流线圈【平行】于磁力线时，磁力矩最大。</p></li><li><p>（思考7.1）感应电动势的大小取决于【磁通量对时间的变化率】</p></li><li><p>如图所示，当长直导线中的电流逐渐变大时，线圈中的感应电流方向是【逆时针】</p><p><img src="https://oss.iuoyt.com/img/posts/cfe4ee4bd5da5097d764d8e5c9ea8b64.png" alt="img"></p></li><li><p>当导体线圈切割磁力线时，所产生的感应电动势是【动生电动势】</p></li></ol><h3 id="判断题-4">判断题</h3><ol><li><p>（思考5.1.1）两个完全相同的均匀带电小球分别带电荷量$q_1=2C$(正电荷)，$q_2=4C$(负电荷)，在真空中相距为r且静止，相互作用的静电力为F。当$q_1,q_2,r$都加倍时，作用力不变（✔）</p></li><li><p>在真空中相距为$r$且静止，相互作用的静电力为$F$，若两个小球的带电量都增加一倍，则它们之间的力也增加一倍（✖）</p></li><li><p>（思考5.7）静电场中的零电势可以随意选择（✔）</p></li><li><p>如果通过一个闭合曲面的电场强度通量为0，那么该曲面上的电场强度处处为零（✖）</p></li><li><p>（思考5.6）在电场中，电场强度为零的点，电势也为零（✖）</p></li><li><p>（思考5.6）在静电场中，电势为零的点电场强度也一定为零（✖）</p></li><li><p>（思考6.7）在匀强磁场中，面积相同、通有相同电流的的线圈，它们的磁矩也相等（✔）</p></li><li><p>（思考7.1）感应电动势的大小取决于磁场强度（✖）</p></li><li><p>感应电荷量与穿过闭合线圈的磁铁速度无关（✖）</p></li><li><p>感应电荷量大小与穿越闭合线圈的磁铁的极性无关（✔）</p></li><li><p>磁场中的洛伦兹力不做功（✔）</p></li><li><p>如图所示，当长直导线中的电流发生变化时，线圈中的感应电动势是感生电动势。 （✔）</p><p><img src="https://oss.iuoyt.com/img/posts/cfe4ee4bd5da5097d764d8e5c9ea8b64-1717645771981-90.png" alt="img"></p></li></ol><h2 id="简谐振动">简谐振动</h2><h3 id="简答题-2">简答题</h3><ol><li><p>（思考8.4）振幅为$A$的弹簧振子，当位移是振幅的一半时，它的势能占总能量的？</p><blockquote><p>势能占总能量的$\frac{1}{4}$</p></blockquote></li><li><p>（思考8.4）振幅为$A$的弹簧振子，当它的动能和势能相等时，振子的位移是？</p><blockquote><p>位移$x=\frac{\sqrt{2}}{2}A$</p></blockquote></li><li><p>（习题8.1）一质点按如下规律沿x轴做简谐振动（$x=0.05\cos[4\pi(t+\frac{1}{6})]$），则速度的最大值约为？</p><blockquote><p>$v_{max}=A\omega=0.05\times4\pi m/s\approx0.628m/s$</p></blockquote></li></ol><h3 id="选择题-5">选择题</h3><ol><li><p>轻质弹簧下挂一个小盘，小盘作简谐振动，平衡位置为原点，位移向下为正，并采用余弦表示。小盘处于最低位置时刻有一个小物体不变盘速地粘在盘上，设新的平衡位置相对原平衡位置向下移动的距离小于原振幅，且以小物体与盘相碰为计时零点，那么以新的平衡位置为原点时，新的位移表示式的初相在（<strong>D</strong>）</p><p>A. $0\sim \frac{p}{2}$之间</p><p>B. $\frac{p}{2}\sim p$之间</p><p>C. $p\sim \frac{3p}{2}$之间</p><p>D. $\frac{3p}{2}\sim 2p$之间</p></li><li><p>一质点沿<em>x</em>轴作简谐振动，振动方程为$x=4\times10^{-2}\cos(2\pi t+\frac{\pi}{3})$。从$t = 0$时刻起，到质点位置在$x=-2 cm$处，且向x轴正方向运动的最短时间间隔为（<strong>A</strong>）</p><p>A. $\frac{1}{2}s$</p><p>B. $\frac{1}{4}s$</p><p>C. $\frac{1}{6}s$</p><p>D. $\frac{1}{8}s$</p></li><li><p>图中所画的是两个简谐振动的振动曲线。若这两个简谐振动可叠加，则合成的余弦振动的初相为（<strong>B</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/f8518150a0292bcf7e59f200ea72aabb-1717664091015-13.png" alt="img"></p><p>A. $\frac{3}{2}\pi$</p><p>B. $\pi$</p><p>C. $\frac{1}{2}\pi$</p><p>D. 0</p></li><li><p>在下面几种说法中，正确的说法是（<strong>C</strong>）</p><p>A. 波源不动时，波源的振动周期与波动的周期在数值上是不同的.</p><p>B. 波源振动的速度与波速相同.</p><p>C. 在波传播方向上的任一质点振动相位总是比波源的相位滞后(按差值不大于p计).</p><p>D. 在波传播方向上的任一质点的振动相位总是比波源的相位超前.(按差值不大于p计)</p></li><li><p>图示一沿x轴正向传播的平面简谐波在$t=0$时刻的波形.若振动以余弦函数表示，且此题各点振动初相取$-p$到$p$之间的值，则（<strong>B</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/c6cb7b3f802005f0ee75b8aab8b0741d-1717664107815-22.png" alt="img"></p><p>A. <em>O</em>点的初相为$\phi_0=-\frac{1}{2}\pi$</p><p>B. <em>1</em>点的初相为$\phi_1=0$</p><p>C. <em>2</em>点的初相为$\phi_2=0$</p><p>D. <em>3</em>点的初相为$\phi_3=0$</p></li></ol><h3 id="填空题-5">填空题</h3><ol><li>（思考8.2）将弹簧振子的弹簧截去一部分，其振动周期将【减小】</li><li>（思考8.4）振幅为$A$的弹簧振子，当位移是振幅的一半时，它的动能占总能量的：$\frac{3}{4}$</li><li>（习题8.1）一质点按如下规律沿x轴做简谐振动（$x=0.05\cos[4\pi(t+\frac{1}{6})]$），则加速度的最大值约为：$a_{max}=A\omega^2\approx7.89m/s^2$</li><li>（习题8.2）设简谐振动的方程为$x=0.02\cos(100\pi t+\frac{\pi}{3})$，则t=1s时相位为：$\frac{301}{3}\pi$</li><li>（习题8.8.3）质量$m=100g$的小球与弹簧构成的系统，按$x=0.05\cos(4\pi t+\frac{\pi}{3})$的规律做自由振动，则振动的能量是：$E=\frac{1}{2}m\omega^2A^2=2\pi^2\times10^{-3}J$</li><li>（习题1.9）一质量为$m$的质点在$Oxy$平面上运动，其位置矢量为$r=a\cos\omega ti+b\sin\omega tj$，其中$a,b,\omega$都是常量，则质点所受的力对原点$O$的力矩为：$M=r\times F=r\times(-m\omega^2r)=-m\omega^2(r\times r)=0$</li></ol><h3 id="判断题-5">判断题</h3><ol><li>（思考8.1.1）当弹性小球在地面上跳动时，是一种简谐振动。（✖）</li><li>（思考8.1.2）小球在光滑的球形凹槽内进行小幅度摆动时，这是一种简谐振动（✔）</li><li>（思考8.6）阻尼振动也是一种周期性振动（✖）</li><li>（思考8.10.1）同一波线上，相位差为$2\pi$的两个振动质元之间的距离就是在一个周期内振动所传播的距离（✔）</li><li>（思考8.13）机械波可以传递能量，也可以传递动量（✖）</li></ol>]]></content>
    
    
    <summary type="html">大学物理期末复习题</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学期总结" scheme="https://www.iuoyt.com/tags/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
    <category term="大学物理" scheme="https://www.iuoyt.com/tags/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>robots.txt介绍</title>
    <link href="https://www.iuoyt.com/posts/d5315100.html"/>
    <id>https://www.iuoyt.com/posts/d5315100.html</id>
    <published>2024-06-01T08:09:17.000Z</published>
    <updated>2024-06-07T15:10:50.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="robots-txt概述">robots.txt概述</h2><ul><li><p><code>robots.txt</code>是一个存放在网站根目录下的ASCII编码文件，用于告诉搜索引擎爬虫这个站点中有哪些内容是不应该被抓取的，哪些又是可以获取的。在爬取页面之前，爬虫会查看网站的<code>robots.txt</code>文件以确认不应该爬取的页面。<code>robots.txt</code>并非规范，而是约定俗成，有些爬虫机器人会遵守这一规范，有些则并不会。以下是Cloudflare对<code>robots.txt</code>的介绍：</p><blockquote><p>Robots.txt 文件是针对机器人的一组指令。该文件包含在大多数网站的源文件中。Robots.txt 文件主要用于管理 Web 爬网程序类的良性机器人活动。</p></blockquote></li><li><p>每个站点的robots.txt仅适用于所在协议、主机和端口号都相同的页面，Google对其解释如下：</p><blockquote><p>robots.txt 文件仅适用于所在的协议、主机和端口内的路径。也就是说，<code>https://example.com/robots.txt</code> 中的规则仅适用于 <code>https://example.com/</code> 中的文件，而不适用于子网域（如 <code>https://m.example.com/</code>）或备用协议（如 <code>http://example.com/</code>）。</p></blockquote></li></ul><h2 id="robots-txt文件的编写">robots.txt文件的编写</h2><h3 id="文件组成">文件组成</h3><ul><li><p><code>robots.txt</code>文件由一个或多个组组成，每个组都以<code>User-agent</code>开头，内容则由多条规则（指令）组成，每条规则占一行。</p></li><li><p>爬虫会从上到下处理组，一个用户代理（User-agent）仅能匹配一个组，如果同一用户代理有多个组，则会在处理之前讲这些内容合并到一个分组中。</p></li><li><p>规则的内容区分大小写</p><blockquote><ul><li>规则区分大小写。例如，<code>disallow: /file.asp</code> 适用于 <code>https://www.example.com/file.asp</code>，但不适用于 <code>https://www.example.com/FILE.asp</code>。</li></ul></blockquote></li><li><p>以<code>#</code>开头的行即为注释行，处理过程中会忽略这些内容。</p></li></ul><h3 id="User-agent">User-agent</h3><ul><li><p>User-agent（用户代理）既可以是普通用户的浏览器，或是机器人的名称。</p></li><li><p>常见搜索引擎机器人用户代理名称如下：</p><blockquote><p><strong>Google：</strong></p><ul><li>Googlebot</li><li>Googlebot-Image（用于图像）</li><li>Googlebot-News（用于新闻）</li><li>Googlebot-Video（用于视频）</li></ul><p><strong>Bing</strong></p><ul><li>Bingbot</li><li>MSNBot-Media（用于图像和视频）</li></ul><p><strong>Baidu</strong></p><ul><li>Baiduspider</li></ul><p><strong>Yahoo</strong></p><ul><li>Slurp</li></ul></blockquote></li><li><p>使用<code>*</code>作为通配符，可以匹配所有<code>User-agent</code>。</p></li></ul><h3 id="Disallow">Disallow</h3><ul><li><p>配置在<code>Disallow</code>中的内容为不允许机器人爬取的页面，每一行仅可以配置一个目录或页面，多个禁止项可以使用多个<code>Disallow</code>。</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Disallow: <span class="regexp">/cgi-bin/</span></span><br><span class="line">Disallow: <span class="regexp">/images/</span></span><br><span class="line">Disallow: <span class="regexp">/tmp/</span></span><br><span class="line">Disallow: <span class="regexp">/private/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Allow">Allow</h3><ul><li><p>使用<code>Allow</code>配置允许机器人爬取的页面，相应的，没有规定的页面则不允许爬取，可以结合<code>Disallow</code>使用。</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Disallow:</span> /blog</span><br><span class="line"><span class="symbol">Allow:</span> <span class="keyword">/blog/</span>allowed-post</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，搜索引擎可以访问： <code>/blog/allowed-post</code>，但是它不能访问：</p><p><code>/blog/another-post</code></p><p><code>/blog/yet-another-post</code></p><p><code>/blog/download-me.pdf</code></p></blockquote></li><li><p>规则冲突</p><ul><li><p>如果同时在<code>Allow</code>和<code>Disallow</code>中声明了同一个路径，则遵循指令字符较长的那个</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Disallow:</span> <span class="keyword">/blog/</span></span><br><span class="line"><span class="symbol">Allow:</span> /blog</span><br></pre></td></tr></table></figure><p>在这一举例中，<code>Disallow</code>长度为6字符，而<code>Allow</code>则为5字符，那么机器人会遵循<code>Disallow</code></p></li><li><p>如果<code>Disallow</code>和<code>Allow</code>长度相同，那么会使用限制范围较小的指令。</p></li></ul></li></ul><h3 id="Sitemap">Sitemap</h3><ul><li><p>使用<code>Sitemap</code>可以标记网站地图的所在位置，这个xml文件中通常包含需要被搜索引擎抓取、索引的所有页面。</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sitemap: https:<span class="regexp">//</span>www.domain.com/sitemap.xml</span><br></pre></td></tr></table></figure></li><li><p>如果没有向搜索引擎主动提交网站地图，那么机器人可以<code>Sitemap</code>标识的网站地图快速获知需要被爬取的页面。</p></li><li><p><code>Sitemap</code>一般写在<code>robots.txt</code>文件的开头或结尾，可以使用多条<code>Sitemap</code>标识多个<code>sitemap.xml</code>文件的路径。</p></li></ul><h3 id="Crawl-delay（Google不再支持）">Crawl-delay（Google不再支持）</h3><ul><li><p>使用<code>Crawl-delay</code>可以指定抓取的间隔时间，即每次抓取后停止的时间，单位是秒。</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Crawl-<span class="keyword">delay</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Noindex（Google不支持）">Noindex（Google不支持）</h3><ul><li><p>指定搜索引擎不索引的路径</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Noindex: <span class="regexp">/blog/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Nofollow（Google不支持）">Nofollow（Google不支持）</h3><ul><li><p>指定搜索引擎不跟随某个地址</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nofollow: <span class="regexp">/blog/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="robots-txt文件的作用">robots.txt文件的作用</h2><p><code>robots.txt</code>文件的使用有如下好处：</p><ul><li>防止抓取重复页面；</li><li>让网站在某个阶段不公开 (比如：在搭建网站雏形时);</li><li>防止抓取内部搜索页面;</li><li>防止服务器过载;</li><li>防止谷歌浪费crawl budget（抓取预算）;</li><li>防止部分图片、视频及其它资源展示在搜索引擎结果中。</li></ul>]]></content>
    
    
    <summary type="html">Robots.txt文件主要用于管理Web爬网程序类的良性机器人活动。</summary>
    
    
    
    <category term="SEO" scheme="https://www.iuoyt.com/categories/SEO/"/>
    
    
    <category term="SEO" scheme="https://www.iuoyt.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>CSS 实现元素水平垂直居中的方式</title>
    <link href="https://www.iuoyt.com/posts/4b182ac7.html"/>
    <id>https://www.iuoyt.com/posts/4b182ac7.html</id>
    <published>2024-04-27T08:05:35.000Z</published>
    <updated>2024-04-27T14:33:01.725Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>本文使用解结构如下：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="定位-margin-auto（不定宽高可用）">定位+margin:auto（不定宽高可用）</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定位-transform（不定宽高可用）">定位+transform（不定宽高可用）</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定位-margin负值">定位+margin负值</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flex-grid布局（不定宽高可用）">flex/grid布局（不定宽高可用）</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置为flex或grid */</span></span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="table布局">table布局</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CSS 实现元素水平垂直居中的方式</summary>
    
    
    
    <category term="CSS" scheme="https://www.iuoyt.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="https://www.iuoyt.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局与双飞翼布局</title>
    <link href="https://www.iuoyt.com/posts/12149869.html"/>
    <id>https://www.iuoyt.com/posts/12149869.html</id>
    <published>2024-04-27T07:22:00.000Z</published>
    <updated>2024-04-27T14:33:05.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文档结构">文档结构</h2><ul><li><p>本文使用的预设样式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;wrapper&#x27;</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-wrap</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文档四部分分别为：</p><ul><li><code>wrapper</code>：整个文档的容器</li><li><code>main</code>：三栏布局的主要部分，放置在中间</li><li><code>left</code>、<code>right</code>：左栏和右栏</li></ul></li></ul><h2 id="圣杯布局">圣杯布局</h2><h3 id="原理">原理</h3><ul><li>圣杯布局使用浮动+内边距+定位方式实现，父容器设置左右<code>padding</code>为左右两栏宽度，留给左右两栏占据，中间部分自适应宽度。</li><li>优点：主内容区域无需添加一层DOM节点</li><li>缺点：当left部分宽度大于main部分宽度时会出现布局混乱。</li></ul><h3 id="实现">实现</h3><ol><li><p>建立HTML结构如下：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;col main&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;col left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;col right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240427152546392.png" alt="预设布局效果"></p></li><li><p>为了防止wrapper设置好padding会超出原大小，为wrapper设置<code>box-sizing: border-box;</code>，然后设置其内部左右边距大小，此时左栏为200px，右栏为300px：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">300px</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427153921254.png" alt="image-20240427153921254"></p></li><li><p>然后将三个部分使用左浮动：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154106538.png" alt="image-20240427154106538"></p></li><li><p>中间主体部分完整宽度由main占据，再分别为左右两栏设置宽度：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154233087.png" alt="image-20240427154233087"></p></li><li><p>现在使用左右两栏的<code>margin-left</code>将其移动到main的同一行</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154405057.png" alt="image-20240427154405057"></p></li><li><p>再使用定位将左右两栏分别移动到对应位置：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154657499.png" alt="image-20240427154657499"></p></li><li><p>圣杯布局的缺点为在放大到一定尺寸（left部分宽度&gt;main部分宽度）时会出现布局混乱</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154903240.png" alt="image-20240427154903240"></p></li></ol><h2 id="双飞翼布局">双飞翼布局</h2><ul><li>与圣杯布局类似，双飞翼布局则是使用main部分的margin为左右两栏预留空间。</li><li>优点：解决了圣杯布局放大后会混乱的问题。</li><li>缺点：需要增加一层DOM节点</li></ul><h3 id="原理-2">原理</h3><ol><li><p>建立HTML结构如下：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;col main&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-wrap&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;col left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;col right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>为三栏分别设置宽度并向左浮动：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427160131485.png" alt="image-20240427160131485"></p></li><li><p>在main部分设置外边距为左右两栏预留空间：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main-wrap</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">300px</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427160148190.png" alt="image-20240427160148190"></p></li><li><p>再使用<code>margin-left</code>将左右两栏移动到其对应位置：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427160304512.png" alt="image-20240427160304512"></p></li><li><p>双飞翼布局在放大后则不会出现布局混乱</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240427160335359.png" alt="image-20240427160335359"></p></li></ol>]]></content>
    
    
    <summary type="html">介绍 CSS 完成三栏布局方法中的圣杯布局与双飞翼布局。</summary>
    
    
    
    <category term="CSS" scheme="https://www.iuoyt.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="https://www.iuoyt.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个 Vue + TypeScript 的 Webpack 项目</title>
    <link href="https://www.iuoyt.com/posts/c5812c4b.html"/>
    <id>https://www.iuoyt.com/posts/c5812c4b.html</id>
    <published>2024-04-26T11:29:28.000Z</published>
    <updated>2024-04-27T14:32:53.405Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>文章末尾有快速创建步骤，<a href="#%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4">点击前往🔗</a></p></div><h2 id="项目创建">项目创建</h2><h3 id="安装TypeScript环境">安装TypeScript环境</h3><p>首先在系统中和项目中安装相关环境依赖（TS）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br><span class="line">npm i typescript</span><br></pre></td></tr></table></figure><h3 id="创建Webpack项目">创建Webpack项目</h3><p>接下来在搭建项目的目录下打开终端，使用命令初始化构建一个Webpack项空项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>然后为项目配置webpack和cli及Vue：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack</span><br><span class="line">npm i -D webpack-cli</span><br><span class="line">npm i -D vue</span><br></pre></td></tr></table></figure><blockquote><p><code>package.json</code>为Node.js项目的声明文件，声明了模块依赖、脚本定义和版本名称等内容</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20240426184143940.png" alt="项目初始化"></p><p>在项目中创建配置文件和Vue项目文件</p><ul><li><code>dist</code>为Vue代码的编译结果目录，最后的编译结果都是前端静态资源文件，例如JavaScript、CSS和HTML等文件</li><li><code>public</code>为存放<code>index.html</code>挂载Vue节点页面的目录</li><li><code>src</code>为项目的源码目录，主要开发的代码内容都放在这个文件夹里</li><li><code>src/main.ts</code>为项目入口文件</li><li><code>env.d.ts</code>为TypeScript的.vue声明文件</li><li><code>webpack.config.js</code>为Webpack配置文件</li></ul><p>再使用如下命令创建ts配置文件<code>tsconfig.json</code>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240426235814719.png" alt="项目结构"></p><h2 id="项目配置">项目配置</h2><h3 id="main-ts配置">main.ts配置</h3><p>在入口文件<code>src/main.ts</code>中写入如下内容：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="App-vue搭建">App.vue搭建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">    import &#123; ref, reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="index-html挂载">index.html挂载</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置TS的vue声明文件">配置TS的vue声明文件</h3><p>在<code>env.d.ts</code>中写入如下内容，帮助ts认识vue文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;*.vue&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; <span class="title class_">DefineComponent</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">component</span>: <span class="title class_">DefineComponent</span>&lt;&#123;&#125;, &#123;&#125;, <span class="built_in">any</span>&gt;;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Loader配置">Loader配置</h3><p>安装Vue使用相关loader：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D vue-loader css-loader style-loader ts-loader</span><br></pre></td></tr></table></figure><h3 id="Plugin配置">Plugin配置</h3><p>webpack并非会将HTML文件一并在dist中分离，可以添加如下plugin分离HTML：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D html-webpack-plugin</span><br></pre></td></tr></table></figure><p>DevServer可以监听文件的变化并自动刷新网页，做到实时预览，使用如下命令安装：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack-dev-server</span><br></pre></td></tr></table></figure><p>安装每次打包自动删除旧文件组件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D clean-webpack-plugin</span><br></pre></td></tr></table></figure><h3 id="webpack-config-js配置文件">webpack.config.js配置文件</h3><p>在<code>webpack.config.js</code>文件中写入如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/dist/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Configuration</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@type</span> &#123;<span class="type"> Configuration </span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 可选模式： development / production</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.ts&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                <span class="attr">use</span>: <span class="string">&#x27;vue-loader&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                    <span class="attr">appendTsSuffixTo</span>: [<span class="regexp">/\.vue$/</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">htmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">        <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// stats: &quot;errors-only&quot;,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="添加运行命令">添加运行命令</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="项目运行">项目运行</h2><ul><li>打包：<code>webpack</code> / <code>npm run build</code></li><li>运行DevServer：<code>npm run dev</code></li></ul><h2 id="更多可配置">更多可配置</h2><h3 id="CSS分离">CSS分离</h3><p>在配置完CSS-Loader后，webpack会将css封装在js文件中，如果希望将css文件分离，可以安装如下plugin：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D mini-css-extract-plugin</span><br></pre></td></tr></table></figure><p>接下来在配置文件中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;main.css&quot;</span>,</span><br><span class="line">        <span class="attr">chunkFilename</span>: <span class="string">&quot;[id].css&quot;</span></span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>接下来调整Loader部分如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用正则去匹配要用该 loader 转换的 CSS 文件</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="attr">use</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后CSS文件就会分离出来</p><img src="https://oss.iuoyt.com/img/posts/image-20240426192101932.png" alt="image-20240426192101932" style="zoom:67%;" /><h3 id="CSS压缩">CSS压缩</h3><p>如果希望将CSS文件压缩，可以安装如下plugin：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D css-minimizer-webpack-plugin</span><br></pre></td></tr></table></figure><blockquote><p>如果webpack版本为v4，则使用如下plugin替代：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure></blockquote><p>在配置文件中添加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cssMinimizer = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在plugins下增加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">cssMinimizer</span>()</span><br></pre></td></tr></table></figure><p>此时再启动webpack可以发现css文件被完成压缩。</p><h3 id="配置Entry入口">配置Entry入口</h3><p>在配置文件中可以配置项目的入口，可以添加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="Babel兼容低版本ES语法">Babel兼容低版本ES语法</h3><p>Babel是JavaScript编译器，有了它就可以使用下一代版本的JavaScript。安装babel相关依赖使用如下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/core</span><br><span class="line"># 最新转码规则</span><br><span class="line">npm i -D @babel/preset-env</span><br><span class="line"># babel依赖</span><br><span class="line">npm i -D babel-loader</span><br></pre></td></tr></table></figure><p>在项目根目录下，创建<code>.babelrc</code>文件然后，将这些规则加入<code>.babelrc</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@babel/env&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再添加模块规则如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">    <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>接下来再使用webpack就可以为ES6以上语法适配低版本。</p><h2 id="快速创建步骤">快速创建步骤</h2><h3 id="环境配置">环境配置</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br><span class="line">npm init -y</span><br><span class="line">npm i -D typescript webpack webpack-cli vue vue-loader css-loader style-loader ts-loader mini-css-extract-plugin css-minimizer-webpack-plugin @babel/core @babel/preset-env babel-loader html-webpack-plugin webpack-dev-server clean-webpack-plugin</span><br><span class="line">tsc --init</span><br></pre></td></tr></table></figure><h3 id="项目创建-2">项目创建</h3><p>创建项目结构如下</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240426235814719.png" alt="项目结构"></p><ol><li><p>创建<code>dist</code>、<code>src</code>、<code>public</code></p></li><li><p>在<code>src</code>下创建<code>assets</code>、<code>components</code>文件夹</p></li><li><p>创建<code>src/main.ts</code></p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建<code>src/App.vue</code></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">    import &#123; ref, reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>public/index.html</code></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>env.d.ts</code></p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;*.vue&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; <span class="title class_">DefineComponent</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">component</span>: <span class="title class_">DefineComponent</span>&lt;&#123;&#125;, &#123;&#125;, <span class="built_in">any</span>&gt;;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>.babelrc</code></p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;@babel/env&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="项目配置-2">项目配置</h3><ol><li><p>修改<code>package.json</code>中<code>scripts</code>如下：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>webpack.config.js</code>，写入如下内容：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/dist/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Configuration</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cssMinimizer = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@type</span> &#123;<span class="type"> Configuration </span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 可选模式： development / production</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.ts&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                <span class="attr">use</span>: <span class="string">&#x27;vue-loader&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                    <span class="attr">appendTsSuffixTo</span>: [<span class="regexp">/\.vue$/</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">htmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&quot;main.css&quot;</span>,</span><br><span class="line">            <span class="attr">chunkFilename</span>: <span class="string">&quot;[id].css&quot;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">cssMinimizer</span>()</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">        <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// stats: &quot;errors-only&quot;,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">从零开始搭建一个 Vue + TypeScript 的 Webpack 项目</summary>
    
    
    
    <category term="Webpack" scheme="https://www.iuoyt.com/categories/Webpack/"/>
    
    <category term="Vue" scheme="https://www.iuoyt.com/categories/Webpack/Vue/"/>
    
    
    <category term="Webpack" scheme="https://www.iuoyt.com/tags/Webpack/"/>
    
    <category term="Vue" scheme="https://www.iuoyt.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络的物理层</title>
    <link href="https://www.iuoyt.com/posts/81932b36.html"/>
    <id>https://www.iuoyt.com/posts/81932b36.html</id>
    <published>2024-03-16T07:37:03.000Z</published>
    <updated>2024-04-14T12:29:55.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层的基本概念">物理层的基本概念</h2><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。其作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。用于物理层的协议也常称为物理层<strong>规程</strong>（procedure)。</li><li>物理层的四个特性：<ol><li><strong>机械特性</strong>：对接口接线器规格的规定（形状、尺寸、引脚数目……）</li><li><strong>电气特性</strong>：接口电缆上各条线的电压范围</li><li><strong>功能特性</strong>：指明某一条线上出现某一电平的电压的意义</li><li><strong>过程特性</strong>：对于不同功能的各种可能事件的出现顺序</li></ol></li></ul><h2 id="数据通信的基础知识🌟">数据通信的基础知识🌟</h2><h4 id="数据通信系统的模型">数据通信系统的模型</h4><ul><li><p>一个数据通信系统可划分为三大部分：</p><ul><li>源系统（发送端、发送方），包括：<ul><li>源点（source）：远点设备产生要传输的数据</li><li>发送器：将数字比特流编码以在传输系统传输的部分，如调制器</li></ul></li><li>传输系统（传输网络）</li><li>目的系统（接收端、接收方），包括：<ul><li>接收器：将接收到的信号转换为可以被目的设备处理的信息，如解调器</li><li>终点（destination）（目的站、信宿）：重点设备从接收器获取传送来的数字比特流，然后输出信息</li></ul></li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324154950366.png" alt="数据通信系统的模型"></p></li><li><p><strong>数据</strong>（data）式运送消息的实体。<strong>信号</strong>（signal）则是数据的电气或电磁的表现，按照参数的取值方式不同分为两大类：</p><ul><li>模拟信号（连续信号）：消息的参数取值是连续的，可采用电波形式表示，特点为波动性、持续变化、包含无穷多个值。</li><li>数字信号（离散信号）：消息的参数取值是离散的，特点为离散型、跃变性、包含有限个值、设备性能先进、较为便宜。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324155112243.png" alt="模拟信号和数字信号的波形比较"></p></li><li><p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形称为<strong>码元</strong>。</p><p><img src="https://oss.iuoyt.com/img/posts/1711266783120.jpg" alt="码元与信息比特"></p></li><li><p>模拟信道与数字信道：</p><ul><li><strong>模拟信道</strong>是用来传输连续的模拟信号的信道，如果利用模拟信道传送数字数据，则必须经过数字与模拟信号之间的变换（A/D变换器）。</li><li><strong>数字信道</strong>是用来传输离散的数字信号（如脉冲信号）的信道</li></ul></li></ul><h4 id="数据传输的几种形式">数据传输的几种形式</h4><ul><li><p>模拟数据和数字数据之间都可以用模拟信号或数字信号来表示，可以用其中任意一种形式传输。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240324155430823.png" alt="传输形式的转换"></p></li></ul><h4 id="信道的基本概念">信道的基本概念</h4><ul><li><p><strong>信道</strong>表示向某一个方向传送信息的媒体。根据通信双方信息交互方式来看，有如下三种基本方式：</p><ul><li>单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。</li><li>双向交替通信（半双工通信）：通信双方都可以大宋信息，但不能双方同时发送。</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul></li><li><p><strong>基带信号</strong>（基本频带信号）：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号往往包含有较多的低频成分，甚至有直流成分，而<strong>许多信道并不能传输这种低频分量或直流分量</strong>。因此必须对基带信号进行<strong>调制</strong>  (modulation)。调制分为两类：</p><ul><li><strong>基带调制</strong>：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。</li><li><strong>带通调制</strong>：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324161429461.png" alt="基带调制与带通调试"></p></li><li><p>常用的数字信号编码技术：</p><ul><li>不归零制：正电平代表 1，负电平代表 0。</li><li>归零制：正脉冲代表 1，负脉冲代表 0。</li><li>曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。（IEEE 802.3以太局域网标准编码）</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。（IEEE 802.5令牌环局域网标准编码）</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324160652163.png" alt="常用编码方式"></p><p>每个码元中间都要发生跳变，接收端可将此变化提取出来作为同步信号，使接收端的时钟与发送设备的时钟保持一致。曼彻斯特编码也称为自同步码（即有<strong>自同步能力</strong>）。</p></li><li><p>基本的带通调制方法</p><ul><li>调幅(AM)：载波的振幅随基带数字信号而变化。</li><li>调频(FM)：载波的频率随基带数字信号而变化。</li><li>调相(PM) ：载波的初始相位随基带数字信号而变化。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/1711267850240.jpg" alt="带通调制方法"></p></li><li><p>脉冲编码调制（PCM）解调技术三步骤：</p><ul><li>采样：按一定间隔对语音信号进行采样</li><li>量化：对每个样本舍入到量化级别上</li><li>编码：对每个舍入后的样本进行编码</li></ul></li></ul><h3 id="信道的极限容量">信道的极限容量</h3><h4 id="信道能够通过的频率范围">信道能够通过的频率范围</h4><ul><li><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：</p><ul><li>信道能够通过的频率范围</li><li>信噪比</li></ul></li><li><p>理想低通信道的最高码元传输速率B = 2W Baud（W是理想低通信道的带宽，单位为赫(Hz)，Baud 是波特，是码元传输速率的单位，1波特为每秒传送1个码元。）</p></li><li><p>数据传输速率：$C=2W\log_{2}{V}(bps)$</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240324161710880.png" alt="理想低通信道的极限数据传输率"></p></li><li><p>码元传输速率B与信息传输速率C的关系：$C=B\times \log_{2}{V}(bps)$​</p></li></ul><h4 id="信噪比">信噪比</h4><ul><li>信噪比就是信号的平均功率和噪声的平均功率之比。常记为S/N，并用分贝 (dB) 作为度量单位。即：$信噪比=10\log_{10}{(S/N)}(dB)$​</li><li>带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（香农公式）：$C=W\log_{2}{(1+S/N)}(bps)$。（其中：W 为信道的带宽（以 Hz 为单位），S 为信道内所传信号的平均功率，N 为信道内部的高斯噪声功率 ）。</li></ul><h2 id="物理层下面的传输媒体🌟">物理层下面的传输媒体🌟</h2><ul><li><p>传输媒体（传输介质、传输媒介）：数据传输系统中在发送器和接收器之间的物理通路，是通信中实际传输信息的载体。传输媒体分为两大类：</p><ul><li>导引型传输媒体：电磁波被导引沿着固体媒体（铜线或光纤）传播。</li><li>非导引型传输媒体：即自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/1711283357948.jpg" alt="电信领域使用的电磁波的频谱"></p></li></ul><h3 id="导引型传输媒体">导引型传输媒体</h3><h4 id="双绞线">双绞线</h4><ul><li><p>最常用的传输媒体。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。分为<strong>屏蔽双绞线 STP</strong> (Shielded Twisted Pair)和<strong>无屏蔽双绞线 UTP</strong>  (Unshielded Twisted Pair) 两种。</p><p><img src="https://oss.iuoyt.com/img/posts/1711284278292.jpg" alt="双绞线"></p></li></ul><h4 id="同轴电缆">同轴电缆</h4><ul><li><p>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。同轴电缆的带宽取决于电缆的质量。</p><ul><li>50 Ω 同轴电缆 —— LAN / 数字传输常用</li><li>75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用</li></ul>  <img src="https://oss.iuoyt.com/img/posts/image-20240324204830611.png" alt="同轴电缆" style="zoom:50%;" /></li><li><p>50Ω同轴电缆又分为<strong>粗缆</strong>和<strong>细缆</strong>两种。</p><ul><li><p>粗缆传输性能优于细缆。常用于10Base-5的以太网中，单根最大传输距离500米。（10：传输速率10Mbps，base：基带传输，5：最大网段长度500m）</p><ul><li>总线上最多可以连接100个收发器，两个收发器之间的距离不能小于2.5m</li><li>收发器电缆（AUI电缆）长度最多为50m</li><li>物理连接遵循5-4-3规则：最多可用4个中继器，5个网段（其中仅3个网段可接工作站，其余只用于距离加长），最大网络长度2469米。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324205243478.png" alt="粗缆以太网"></p></li><li><p>而细缆常用于10Base-2的以太网中，单根最大传输距离185米。</p></li></ul></li></ul><h4 id="光缆">光缆</h4><ul><li><p>由于可见光的频率非常高，约为 $10^8$​ MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。</p><p><img src="https://oss.iuoyt.com/img/posts/1711284886036.jpg" alt="光纤"></p><p>当光线从高折射率的媒体射向低折射率的媒体时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，光也就沿着光纤传输下去。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240324205629662.png" alt="光波在纤芯中的传播"></p><p>只要从纤芯中射到纤芯表面的光线的入射角大于某个临界角度，就可产生全反射。</p></li><li><p>多模光纤与单模光纤</p><ul><li>多模光纤可以存在多条不同角度入射的光线在一条光纤中传输。</li><li>单模光纤的直径减小到只有一个光的波长，像一根波导那样使光线一直向前传播，而不会产生多次反射。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/1711285131323.jpg" alt="多模光纤与单模光纤"></p></li><li><p>光纤的优点</p><ul><li>通信容量非常大。</li><li>传输损耗小，中继距离长。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好。</li><li>体积小，重量轻。</li></ul></li></ul><h3 id="非导引型传输媒体">非导引型传输媒体</h3><ul><li>无线传输所使用的频段很广。短波通信（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。</li><li>地面微波接力通信<ul><li>原理：<ul><li>在两个微波传送塔之间传输信息（视距传输）。</li><li>通过微波中继站串联使用完成远距离传输。</li></ul></li><li>优点：频带宽、通信容量大、传输质量高、可靠性较好、投资少、见效快、灵活</li><li>缺点：相邻站间必须直视，不能有障碍物；受气候干扰较大、保密性差、中继站的使用与维护问题等。</li></ul></li></ul><h2 id="信道复用技术🌟">信道复用技术🌟</h2><ul><li><strong>频分多路复用FDM</strong> (Frequency Division Multiplexing)，适合于<u>模拟信号的传输</u>，如电话系统、电视系统。</li><li><strong>时分多路复用TDM</strong>(Time Division Multiplexing)，适用于<u>数字信号的传输</u>，计算机网络中的数据突发性，应用异步时分多路复用技术</li><li><strong>波分多路复用WDM</strong> (Wave Division Multiplexing) ，应用于<u>全光纤组成的网络中</u>，传输的是光信号</li><li><strong>码分多路复用CDM</strong>(Code Division Multiplexing)，广泛应用于<u>移动通信和无线局域网</u>中</li></ul><h3 id="频分复用FDM">频分复用FDM</h3><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li>频分复用的所有用户在同样的时间占用不同的带宽资源（频率带宽）。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414161226925.png" alt="频分复用" style="zoom:50%;" /><h3 id="时分复用TDM">时分复用TDM</h3><ul><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙，所有用户在不同的时间占用同样的频带宽度。</li><li>TDM 信号也称为等时 (isochronous) 信号。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414161509993.png" alt="时分复用" style="zoom:50%;" /><h3 id="统计时分复用STDM">统计时分复用STDM</h3><ul><li>按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414162413297.png" alt="image-20240414162413297" style="zoom:50%;" /><h3 id="波分复用WDM">波分复用WDM</h3><ul><li>波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240414162514034.png" alt="波分复用"></p><h3 id="码分复用CDM">码分复用CDM</h3><ul><li>码分复用让每一个用户在同样的时间，使用同样的频带进行通信，各用户使用经过特殊挑选的不同码型（码分多址 CDMA (Code Division Multiple Access)），因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li>每一个比特时间划分为 m 个短的间隔，即“码片”，使用CDMA的每一个站被指派一个唯一的m bit码片序列，一般是64或128。如发送比特1，则发送码片系列，发送0则发送码片序列的二进制反码。</li></ul><div class="note info flat"><p>内容更新中……</p></div><h2 id="数字传输系统">数字传输系统</h2><h2 id="宽带接入技术">宽带接入技术</h2><h3 id="ADSL技术">ADSL技术</h3><h3 id="光纤同轴混合网（HFC网）">光纤同轴混合网（HFC网）</h3><h3 id="FTTx技术">FTTx技术</h3>]]></content>
    
    
    <summary type="html">物理层考虑怎样能在连接各种计算机的传输媒体上传输数据比特流。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://www.iuoyt.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://www.iuoyt.com/posts/7c4ca347.html"/>
    <id>https://www.iuoyt.com/posts/7c4ca347.html</id>
    <published>2024-03-06T09:57:32.000Z</published>
    <updated>2024-03-16T13:57:58.274Z</updated>
    
    <content type="html"><![CDATA[<p>最早有三类网络：电信网络、有线电视网络和计算机网络，后来“三网融合”，将三种网络融合成一种网络就可以提供上述的所有服务。</p><h2 id="互联网概述">互联网概述</h2><h3 id="两个基本特点">两个基本特点</h3><ul><li>互联网有两个重要的基本特点，即<strong>连通性</strong>和<strong>共享</strong>。<ul><li>连通性：用户之间不论相距都远的距离，通过互联网都可以便捷地、经济地交换各种信息。</li><li>共享：也就是资源共享，可以是信息共享、软件共享或者是硬件共享。这些资源就好像在用户身边一样，使用非常方便。</li></ul></li></ul><h3 id="计算机网络">计算机网络</h3><ul><li><p>计算机网络由若干<strong>节点</strong>（node）和连接这些节点的<strong>链路</strong>（link）构成，节点可以是计算机、集线器、交换机、路由器等。所谓互联网也就是将各部分计算机网络连接起来，形成一张更大的网络，即“网络的网络”。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786375427.jpg" alt="1709786375427"></p></li><li><p>网络把计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机（host）。</p></li></ul><h3 id="互联网基础结构发展的三个阶段">互联网基础结构发展的三个阶段</h3><ul><li><p>第一阶段：从单个网络ARPANET向互联网发展的过程。</p><p>1969年美国国防部创建的第一个分组交换网ARPANET最初只是一个单个的分组交换网，各主机都直接与就近的节点交换机相连。后来逐渐应用在民用技术上，互联网络由此出现，成为现今互联网的雏形。</p></li><li><p>第二阶段：建成了三级结构的互联网。</p><p>1985年，美国国家科学基金会NSF围绕六个大型计算机中心建设计算机网络，由三级构成，分别为主干网、地区网和校园网（或企业网），这个网络覆盖了美国主要的大学和研究所。1991年，NSF和其他政府机构认为互联网不应只限于大学和研究机构，于是允许众多公司接入互联网，网络上的信息量急剧增大，使互联网的容量已无法满足需要，政府决定将互联网主干网交给私人公司经营，并开始收费。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240307124029897.png" alt="三级结构"></p></li><li><p>第三阶段：逐渐形成了全球范围的多层次ISP结构的互联网。</p><p>从1993年开始，由美国政府自主的NSFNET逐渐被若干个商用的互联网主干网替代，由此出现了<strong>互联网服务提供者ISP</strong>（Internet Service Provider），例如我国的中国电信、中国联通和中国移动。ISP可以从互联网管理机构申请到很多IP地址，同时拥有通信线路和路由器等联网设备，因此任何个人或机构向ISP缴纳规定费用，就可以从ISP获取到IP地址和租用权，并通过ISP接入互联网。</p></li></ul><h3 id="互联网服务提供者层次">互联网服务提供者层次</h3><ul><li><p>互联网服务提供者ISP也分为多个层次，主干ISP、地区ISP和本地ISP，目前覆盖全世界的互联网，主干ISP只有十几个，但本地ISP数量达到几十万个。</p><ul><li>主干ISP：由特定公司创建和维护，服务面积最大（一般覆盖国家范围），并且拥有高速主干网。不同网络运营商都有自己的主干ISP网络，并且可以彼此互通。</li><li>地区ISP：这些地区ISP通过主干ISP连接起来，数据率也比主干ISP低一些。</li><li>本地ISP：给用户提供直接的服务，可以连接到地区ISP，也可以直接连接到主干ISP。可以是提供互联网服务的公司，或是向内部提供服务的企业，或是运行自己网络的非营利机构（比如学校）。</li></ul></li><li><p>随着互联网数据的急剧增长，以及为了给主干ISP减轻转发分组的压力和提高转发效率，<strong>互联网交换点IXP</strong>（Internet eXchange Point）应运而生。其作用是：允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组，由此，转发分组不必再经过最上层的主干ISP，而是直接在两个地区ISP之间用高速链路对等地交换分组。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786452810.jpg" alt="基于ISP的多层结构的互联网的概念示意图"></p><p>两个主机的信息传递方式：主机A→本地ISP→地区ISP→主干ISP→地区ISP→本地ISP→主机B</p></li></ul><h3 id="互联网标准化">互联网标准化</h3><ul><li>1992年后成立了一个国际性组织互联网协会ISOC（Internet Society）来对互联网进行全面管理以及在世界范围内促进起发展和使用。</li><li>所有的互联网标准都是以RFC（Request For Comments，“请求评论”）的形式在互联网上发表的，指定互联网的正式标准要经过三个阶段：<ul><li>互联网草案（Internet Draft）：六个月有效期，但不算是RFC文档</li><li>建议标准（Proposed Standard）：开始成为RFC文档</li><li>互联网标准（Internet Standard）：如果经过长期的检验，证明某个检疫标准可以成为互联网标准，则为其分配一个标准编号</li></ul></li></ul><h2 id="互联网的组成🌟">互联网的组成🌟</h2><ul><li><p>互联网从工作方式上看可以分为两大模块，边缘部分和核心部分。其核心功能是分组转发。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786671415.jpg" alt="互联网的组成部分"></p></li></ul><h3 id="边缘部分">边缘部分</h3><ul><li><p>边缘部分由所有连接在互联网上的主机（端系统）组成，这部分是用户直接使用的，用来进行通信（传输数据、音频或视频）和资源共享。端系统可以是个人电脑、智能手机、网络摄像头，或者是大型计算机（服务器），拥有者可以是个人或者单位，或者也可以属于某一ISP。</p></li><li><p>端系统之间的通信方式有两大类：</p><ul><li><p>客户-服务器方式（C/S方式）</p><p>互联网上最常用、最传统的方式，<strong>客户（client）是服务请求方，服务器（server）是服务提供方</strong>。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786715452.jpg" alt="客户-服务器方式"></p></li><li><p>对等连接方式（P2P方式）</p><p>对等连接（peer-to-peer）的两台主机通过对等连接软件就可以进行平等的对等连接通信，双方都可以下载对方已经存储在硬盘中的共享文档。这一种连接方式中，<strong>每一台主机既是客户又是服务器</strong>。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786751324.jpg" alt="对等连接方式"></p></li></ul></li></ul><h3 id="核心部分">核心部分</h3><ul><li>核心部分由大量网络和链接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换），使得边缘部分中的任何一台主机都能与其他主机通信。</li><li><strong>网络核心部分起特殊作用的是路由器（router）</strong>，是一种专用计算机，是<strong>实现分组交换（packet switching）的关键构件</strong>，任务是转发收到的分组。路由器和边缘部分的主机有很大不同，主机是为用户进行信息处理的，路由器则是用来转发分组，即进行分组交换。<strong>分组转发是网络核心部分最重要的功能</strong>。</li><li>典型的交换技术包括：电路交换、分组交换和报文交换。</li></ul><h4 id="电路交换">电路交换</h4><ul><li><p>必须经过“建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）”三个步骤的交换方式称为电路交换。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786985605.jpg" alt="电路交换"></p></li><li><p>特点：</p><ul><li>突发性：数据是突发式地出现在传输线路上的</li><li>利用率低：线路上真正用来传送数据的时间往往不到10%甚至1%，已被用户占用的通信线路资源在绝大部分时间里都是空闲的。</li></ul></li></ul><h4 id="分组交换">分组交换</h4><ul><li><p>分组交换采用存储转发技术，把一个报文划分为几个分组后再进行传送。每一个数据段前面都会加上一些必要的控制信息组成首部（header），包括目的地址、源地址等重要信息。</p><p><img src="https://oss.iuoyt.com/img/posts/1709787209313.jpg" alt="分组"></p></li><li><p>分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。每个分组在互联网中独立地选择传输路径。用这样的存储转发方式，最后分组就能到达最终目的地。</p><p><img src="https://oss.iuoyt.com/img/posts/1709787122005.jpg" alt="分组交换"></p></li><li><p>优点：</p><ul><li>高效：再分组传输的过程中动态分配传输带宽，对通信链路逐段占用</li><li>灵活：为每一个分组独立地选择最合适的转发路由</li><li>迅速：以分组作为传送单位，不先建立连接就能向其他主机发送分组</li><li>可靠：保证可靠性的网络协议，分布式多路由的分组交换网使得网络有很好的生存性</li></ul></li><li><p>缺点：</p><ul><li>造成一定的时延：分组在各路由器存储转发时需要排队</li><li>造成一定的开销：数据在转发过程中可能会丢失</li></ul></li></ul><h4 id="交换方式的对比">交换方式的对比</h4><ul><li><p>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。</p></li><li><p>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。</p></li><li><p>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</p></li></ul><p><img src="https://oss.iuoyt.com/img/posts/1709787450436.jpg" alt="三种交换方式"></p><h2 id="计算机网络的类别🌟">计算机网络的类别🌟</h2><h3 id="计算机网络的定义">计算机网络的定义</h3><ul><li>计算机网络主要是由一些通用的、可编程的硬件互联而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的目的和日益增长的应用。</li></ul><h3 id="网络分类">网络分类</h3><h4 id="按照作用范围">按照作用范围</h4><ol><li>广域网WAN（Wide Area Network）：几十到几千公里，可以跨越不同的国家</li><li>城域网MAN（Metropolitan Area Network）：5~50公理，一般覆盖一个城市，或者几个街区</li><li>局域网LAN（Local Area Network）：通常局限在较小范围，满足某个特定区域内的局域互联需求</li><li>个人区域网PAN（Personal Area Network）：10米左右，使用无线技术连接起来的网络</li></ol><h4 id="按照使用者">按照使用者</h4><ol><li>公用网（public network）：即公众网，缴纳费用就可以使用的网络</li><li>专用网（private network）：某个部门为了满足本单位特殊业务需要而建造的网络</li></ol><h4 id="用来把用户接入到互联网的网络">用来把用户接入到互联网的网络</h4><ul><li>接入网AN（Access Network）又称为本地接入网或居民接入网，实际上是本地ISP拥有的网络，借助多种接入网技术可以把用户的端系统连接到互联网。接入网既不是互联网的核心部分，也不是互联网的边缘部分。</li></ul><h4 id="按照拓扑结构">按照拓扑结构</h4><ul><li>广播信道通信子网中的基本拓扑结构：总线型、环型、星型</li><li>点-点线路的通信子网中的基本拓扑结构：环型、星型、网状</li></ul><h5 id="总线型">总线型</h5><p><img src="https://oss.iuoyt.com/img/posts/image-20240307121830974.png" alt="总线型拓扑结构"></p><ul><li><p>总线型适用于计算机数目相对较少的局域网络，网络连接选用同轴电缆，如传统以太网。</p></li><li><p>特点：</p><ul><li>结构简单，可靠性好</li><li>各结点共用总线，广播式传输</li><li>扩充性好，增减结点容易</li><li>总线争用，故障后果严重、诊断困难，传输率低</li></ul></li><li><p>演变结构：树型拓扑</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240307123138338.png" alt="树型拓扑"></p><ul><li>非常适用于构建网络主干，一般采用光纤作为网络主干，用于军事单位、政府单位等上下界限相当严格和层次分明的网络结构</li><li>特点：<ul><li>总线型结构的扩展</li><li>在总线网上加上分支形成</li><li>容错能力较好</li><li>广播式传输</li><li>扩充性好，增减结点容易</li><li>与星型拓扑类似，对根节点要求高</li></ul></li></ul></li></ul><h5 id="星型">星型</h5><p><img src="https://oss.iuoyt.com/img/posts/image-20240307121844393.png" alt="星型拓扑结构"></p><ul><li>星型拓扑结构是局域网普遍采用的一种拓扑结构，一般使用双绞线或光纤作为传输介质。</li><li>特点：<ul><li>所有结点与中央结点连接(switch or hub)</li><li>结构简单、控制简单、稳定</li><li>易于网络的扩展</li><li>结点出现故障易于诊断与隔离</li><li>易于提高网络的传输速度</li><li>中央结点的可靠性、布线费用大、资源共享能力较差</li></ul></li></ul><h5 id="环型">环型</h5><p><img src="https://oss.iuoyt.com/img/posts/image-20240307121856700.png" alt="环型拓扑结构"></p><ul><li>适用于局域网，结点个数有限</li><li>优点：<ul><li>结构简单、传输延时确定</li><li>资源共享性好</li><li>采用令牌控制</li><li>实时控制</li></ul></li><li>缺点：<ul><li>各结点共享环路，结点出现故障，网络瘫痪</li><li>扩展不易</li></ul></li></ul><h5 id="网状">网状</h5><p><img src="https://oss.iuoyt.com/img/posts/image-20240307121927075.png" alt="网状拓扑结构"></p><ul><li>一般用于Internet骨干网上，使用路由算法来计算发送数据的最佳路径。</li><li>特点：<ul><li>端结点之间存在多条通路，需选择路径</li><li>可靠性高、传输速率高、容错性好</li><li>通信控制复杂</li></ul></li></ul><h2 id="计算机网络的性能🌟">计算机网络的性能🌟</h2><div class="note info flat"><ul><li><p>存储容量单位：数据块大小的基本单位B（Byte字节）。</p><p>$1Byte=8bits$</p><p>$1KB=1024B=2^{10}B$</p><p>$1MB=1024KB=2^{20}B$​</p></li></ul></div><div class="note info flat"><ul><li><p>速率基本单位：数据率的单位bit/s（bps，b/s），比特每秒。</p><p>$1kbps=10^3bps$</p><p>$1Mbps=10^6bps$</p><p>$1Gbps=10^9bps$</p></li></ul></div><h3 id="性能指标">性能指标</h3><h4 id="速率">速率</h4><ul><li>速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate) 或比特率 (bit rate)。</li><li>单位：bit/s（bps）、kbit/s、Mbit/s、 Gbit/s……</li><li>速率往往是指额定速率或标称速率，非实际运行速率。</li></ul><h4 id="带宽">带宽</h4><ul><li><p>带宽（bandwidth）用来表示网络中某通道传送数据的能力，表示在单位时间内网络中的某信道所能通过的“最高数据率”。</p></li><li><p>单位：bit/s（bps）、kbit/s、Mbit/s、 Gbit/s……</p><p><img src="https://oss.iuoyt.com/img/posts/1709788462342.jpg" alt="带宽"></p></li></ul><h4 id="吞吐量">吞吐量</h4><ul><li>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</li><li>吞吐量受网络的带宽或网络的额定速率的限制。</li></ul><h4 id="时延">时延</h4><ul><li><p>时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，有时也称为延迟或迟延。时延由四个不同的部分组成：</p><ol><li><a href="#%E5%8F%91%E9%80%81%E6%97%B6%E5%BB%B6">发送时延</a></li><li><a href="#%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6">传播时延</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6">处理时延</a></li><li><a href="#%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6">排队时延</a></li></ol><p><img src="https://oss.iuoyt.com/img/posts/1709788684936.jpg" alt="各部分时延产生的地方"></p></li></ul><h5 id="发送时延ts">发送时延ts</h5><ul><li><p>也称为传输时延。发送数据时，数据帧从结点进入到传输媒体所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p></li><li><p>计算方法：$发送时延=\frac{数据帧长度(bit)}{发送速率(bps)}$​</p><p>对于一定的网络，发送时延并非固定不变，而是与发送的帧长度成正比，与发送速率成反比。</p>  <details class="folding-tag" ><summary> 10MB数据块在传输数率为1Mbps的信道上发送，发送时延为？ </summary>              <div class='content'>              <p>发送时延：$\frac{10\times 2^{20}\times 8}{10^6bps}=83.89s$</p>              </div>            </details></li></ul><h5 id="传播时延tp">传播时延tp</h5><ul><li><p>电磁波在信道中需要传播一定的距离而花费的时间。 发送时延与传播时延有本质上的不同。信号发送速率和信号在信道上的传播速率是完全不同的概念。</p></li><li><p>计算方法：$传播时延=\frac{信道长度(m)}{电磁波在信道上的传播速率(m/s)}$​</p>  <div class="note info flat"><p>电磁波在真空（空气）中的传播速率为$3×10^8m/s$，在电缆中的传播速率要比在真空中的略低，约为$2.3×10^8m/s$，在光纤中的传播速率约为$2.0×10^8m/s$​。</p></div>  <details class="folding-tag" ><summary> 1000km长的光纤线路带来的传播时延 </summary>              <div class='content'>              <p>传播时延：$\frac{10^6m}{2.0\times 10^8m/s}=5ms$</p>              </div>            </details></li></ul><h5 id="处理时延">处理时延</h5><ul><li>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</li></ul><h5 id="排队时延">排队时延</h5><ul><li>分组在路由器输入输出队列中排队等待处理所经历的时延，排队时延的长短往往取决于网络中当时的通信量。</li></ul><h5 id="总时延">总时延</h5><ul><li><p>总时延 = 发送时延  + 传播时延  + 处理时延  + 排队时延。</p>  <details class="folding-tag" ><summary> 综合计算 </summary>              <div class='content'>              <blockquote><p>收发两端之间的传输距离为$1000km$，信号在媒体上的传播速率为$2×10^8m/s$。试计算以下两种情况的发送时延和传播时延：<br>（1） 数据长度为$10^7bit$,数据发送速率为$100kb/s$。<br>（2） 数据长度为$10^3bit$,数据发送速率为$1Gb/s$。<br>（3）从上面的计算中可以得到什么样的结论？</p></blockquote><ol><li>发送时延：$ts=\frac{10^7bit}{10^5bps}=100s$<br>传播时延：$tp=\frac{10^6m}{2×10^8m/s}=0.005s=5ms$</li><li>发送时延：$ts=\frac{10^3bit}{10^9bps}=1μs$<br>传播时延：$tp=\frac{10^6m}{2×10^8m/s}=0.005s=5ms$​</li><li>若数据长度大而发送速率低，则在总的时延中，发送时延往往大于传播时延。<br>但若数据长度短而发送速率高，则传播时延就可能是总时延中的主要成分。</li></ol>              </div>            </details></li><li><p>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。</p></li><li><p>提高链路带宽减小了数据的发送时延。</p></li><li><p>“在高速链路（或高带宽链路）上，比特会传送得更快些”的说法是错误的</p></li></ul><h4 id="时延带宽积">时延带宽积</h4><ul><li><p>链路的时延带宽积又称为以比特为单位的链路长度。 只有在代表链路的管道都充满比特时，链路才得到了充分利用。</p><p><img src="https://oss.iuoyt.com/img/posts/1710255427317.jpg" alt="时延带宽积"></p></li><li><p>$时延带宽积=传播时延\times 带宽$</p></li></ul><h4 id="往返时间RTT">往返时间RTT</h4><ul><li>往返时间 RTT (round-trip time) 表示<strong>从发送方发送数据开始，到发送方收到来自接收方的确认</strong>，总共经历的时间。在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。</li></ul><h4 id="利用率">利用率</h4><ul><li><p>分为<strong>信道利用率</strong>和<strong>网络利用率</strong>。</p><ul><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</li><li>网络利用率则是全网络的信道利用率的加权平均值。</li></ul></li><li><p>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。若令$D_0$表示网络空闲时的时延，$D$表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示$D$和$D_0$之间的关系： $D=\frac{D_0}{1-U}$。其中$U$是网络的利用率，数值在$0\sim 1$​之间。</p><p><img src="https://oss.iuoyt.com/img/posts/1710255712676.jpg" alt="时延与网络利用率的关系"></p></li></ul><h3 id="非性能特征">非性能特征</h3><ul><li>非性能特征主要包括：费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护。</li></ul><h2 id="计算机网络的体系结构🌟">计算机网络的体系结构🌟</h2><h3 id="计算机网络体系结构的形成">计算机网络体系结构的形成</h3><ul><li>为了使不同体系结构的计算机网络都能互连，国际标准化组织 ISO 于 1977 年成立了专门机构研究该问题。他们提出了一个试图使各种计算机在世界范围内互连成网的标准框架，即著名的<strong>开放系统互连基本参考模型OSI/RM</strong> (Open Systems Interconnection Reference Model)，简称为 OSI。</li><li>OSI并没有得到市场的认可，非国际标准 TCP/IP 却获得了最广泛的应用。TCP/IP 常被称为事实上的国际标准。</li><li>OSI失败的原因：<ul><li>OSI 的专家们在完成 OSI 标准时没有商业驱动力；<br>OSI 的协议实现起来过分复杂，且运行效率很低；<br>OSI 标准的制定周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场；<br>OSI 的层次划分也不太合理，有些功能在多个层次中重复出现。</li></ul></li></ul><h3 id="协议与划分层次">协议与划分层次</h3><h4 id="网络协议的三个组成要素">网络协议的三个组成要素</h4><ul><li>语法（数据与控制信息的结构或格式）</li><li>语义（需要发出何种控制信息，完成何种动作以及做出何种响应）</li><li>同步（事件实现顺序的详细说明）</li></ul><h4 id="协议的两种形式">协议的两种形式</h4><ul><li>文字描述：便于人阅读和理解的形式</li><li>程序代码：让计算机能够理解的形式</li><li>这两种不同形式的协议都必须能够对网络上信息交换过程做出精确的解释。</li></ul><h4 id="分层的优缺点">分层的优缺点</h4><ul><li>优点：<ul><li>各层之间是独立的</li><li>灵活性好</li><li>结构上可分割开</li><li>易于实现和维护</li><li>能促进标准化工作</li></ul></li><li>缺点：<ul><li>降低效率</li><li>有些功能会在不同的层次中重复出现，因而产生了额外开销</li></ul></li></ul><h4 id="各层完成的主要功能">各层完成的主要功能</h4><ul><li>差错控制：使相应层次对等方的通信更加可靠。</li><li>流量控制：发送端的发送速率必须使接收端来得及接收，不要太快。</li><li>分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li>复用和分用：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li>连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ul><h2 id="五层体系结构">五层体系结构</h2><ul><li><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</p></li><li><p>TCP/IP 是四层体系结构，但最下面的网络接口层并没有具体内容。</p></li><li><p>在学习计算机网络原理时往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。</p><p><img src="https://oss.iuoyt.com/img/posts/1710256503553.jpg" alt="计算机网络五层体系结构"></p></li></ul><h3 id="OSI七层协议体系结构">OSI七层协议体系结构</h3><ul><li><strong>物理层</strong>：利用传输介质为通信的网络结点之间建立、管理和释放物理连接；实现比特流的透明传输，为数据链路层提供数据传输服务；物理层的数据传输单元是比特。</li><li><strong>数据链路层</strong>：在物理层提供的服务基础上，数据链路层在通信的实体间建立数据链路连接；传输以“帧”为单位的数据包；采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。</li><li><strong>网络层</strong>：通过路由选择算法为分组通过通信子网选择最适当的路径；为数据在结点之间传输创建逻辑链路；实现拥塞控制、网络互连等功能。</li><li><strong>传输层</strong>：可提供可靠端到端（end-to-end）服务；处理数据包错误、数据包次序，以及其他一些关键传输问题；传输层向高层屏蔽了下层数据通信的细节，是计算机通信体系结构中关键的一层。</li><li><strong>会话层</strong>：负责维护两个结点之间的传输链接，以便确保点对点传输不中断，管理数据交换。</li><li><strong>表示层</strong>：用于处理在两个通信系统中交换信息的表示方式，数据格式变换、数据加密与解密、数据压缩与恢复。</li><li><strong>应用层</strong>：为应用程序提供了网络服务；应用层需要识别并保证通信对方的可用性，使得协同工作的应用程序之间的同步；建立传输错误纠正与保证数据完整性的控制机制。</li></ul><h3 id="五层协议">五层协议</h3><p><img src="https://oss.iuoyt.com/img/posts/1710256837540.jpg" alt="发送数据"></p><h2 id="实体、协议、服务和服务访问点">实体、协议、服务和服务访问点</h2><ul><li>实体：任何可发送或接收信息的硬件或软件进程</li><li>协议：控制两个对等实体（或多个实体）进行通信的规则的集合</li><li>在协议的控制下，两个对等实体间的通信使得本层能向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。协议可以向上提供服务，而被服务的实体无法看到具体的协议。即<strong>协议是“水平的”</strong>（控制对等实体之间通信的规则），<strong>服务是“垂直的”</strong>（服务是由下层向上层通过层间接口提供的）。</li><li>上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中被称为<strong>服务原语</strong>。</li><li>在同一系统中相邻两层的实体进行交互的地方被称作<strong>服务访问点SAP</strong>（Service Access Point），层与层之间交换的数据的单位称为<strong>服务数据单元SDU</strong>（Service Data Unit）。</li></ul><h2 id="TCP-IP体系结构">TCP/IP体系结构</h2><ul><li><p>现在的互联网使用的 TCP/IP 体系结构有时已经发生了演变，即某些应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240316153110141.png" alt="TCP/IP体系结构的一种表示方法"></p><p><img src="https://oss.iuoyt.com/img/posts/1710574457212.jpg" alt="沙漏计时器形状的TCP/IP协议族示意"></p><p><img src="https://oss.iuoyt.com/img/posts/1710574181311.jpg" alt="在应用层的客户进程和服务器进程的交互"></p></li></ul>]]></content>
    
    
    <summary type="html">这篇文章介绍了互联网的基本概述、发展过程，计算机网络的组成、类别、性能和体系结构。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://www.iuoyt.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>财经应用文写作方式</title>
    <link href="https://www.iuoyt.com/posts/70666095.html"/>
    <id>https://www.iuoyt.com/posts/70666095.html</id>
    <published>2024-03-05T06:51:57.000Z</published>
    <updated>2024-04-16T07:19:04.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="财经应用文写作概述">财经应用文写作概述</h2><h3 id="应用文写作的特点">应用文写作的特点</h3><ul><li>实用性：为解决实际问题而写作</li><li>程式性：有惯用格式和语体风格</li><li>时效性：在特定时间处理特定问题</li></ul><h3 id="应用文写作要求">应用文写作要求</h3><h4 id="主旨明确单一">主旨明确单一</h4><ul><li><p>主旨即主题，指作者在全部文章内容中表达的基本观点和写作意图的体现，是一篇文章的核心、总纲。</p></li><li><p>特点：</p><ul><li>正确（符合政策）</li><li>单一（一文一旨）</li><li>鲜明</li><li>深刻</li></ul></li><li><p>如何确立与表现主旨？</p><ul><li><p>篇名点旨（标题）</p></li><li><p>篇首亮旨（开头）</p></li><li><p>篇中明旨（各段首句/小标题）</p><p>最常用方法：撮要标目法（起句立意法），将段主旨提炼出为首句或标题</p><p>处理要求：</p><ol><li>观点概括要准确简洁</li><li>几个观点一般要求字数、结构形式的一致</li></ol><p>处理形式：</p><ol><li>小标题形式</li><li>短语句</li></ol></li></ul></li></ul><h4 id="材料真实典型">材料真实典型</h4><ul><li>材料类型：<ul><li>直接材料和间接材料</li><li>历史材料和现实材料</li><li>典型材料和概括材料</li><li>正面材料和反面材料</li><li>文字说明材料和数据统计材料</li></ul></li><li>选材的要求：<ul><li>切题：符合主旨的需要</li><li>真实：合乎实际</li><li>合理：有代表性，说服力强</li></ul></li><li>材料获取的来源：<ul><li>感受和观察</li><li>调查和采访</li><li>检索和阅读</li></ul></li></ul><h4 id="体适恰当规范">体适恰当规范</h4><ul><li><p>注意的三个方面：</p><ol><li>外部结构格式：文章外在各个组成部分</li><li>正文篇章结构</li><li>内部逻辑结构：思路在文章中的反应</li></ol></li><li><p>要求：</p><ol><li>完整严密</li><li>适应文体</li></ol></li><li><p>结构安排的6个方面：</p><ul><li><p>层次：应用文种思想观点或情节的次序和地位</p></li><li><p>段落</p></li><li><p>开头：一要适应主旨要求，自然引发全文；二是自然和谐、凝练明快；三是力争新颖。</p><p>4种方式：①揭示全文内容；②说明发文的背景；③起因和动机；④交代依据</p></li><li><p>结尾：①总结全文式；②呼应开头式；③号召希望式；④表示决心式；⑤提出要求式</p></li><li><p>过渡：上下文之间的衔接转换</p></li><li><p>照应：前后内容的关照呼应</p></li></ul></li></ul><h4 id="语言简明得体">语言简明得体</h4><ul><li>写作一般分为两种文体：<ul><li>文艺语体</li><li>实用语体</li></ul></li><li>应用文的务实功能决定了其篇幅一般较短，要写得简明扼要。尽量用最少的文字，准确、严密地表现最丰富的内容。</li></ul><h3 id="财经应用文的特点">财经应用文的特点</h3><p>（政策性强、专业性强、多用数据）</p><ol><li>真实性：实事求是，如实反映经济实践的过程和需求。解决实际问题。<ul><li>材料绝对真实</li><li>观点结论必须正确真实</li></ul></li><li>政策性：内容上的真实性决定了其政策性，其是在国家财经法规、规章、政策的指导下进行的</li><li>实用性：为了解决财经工作中的实际问而提出意见、措施、办法、对策或设想、建议。</li><li>规范性：格式、文件处理、用语、文种、语体、布局等有要求。</li></ol><h3 id="章节主要知识点总结">章节主要知识点总结</h3><ol><li><details class="folding-tag" ><summary> 应用文的主要作用有 </summary>              <div class='content'>              <p>规范指导作用、联系交流作用、宣传教育作用、凭证资料作用</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 应用文常用的结尾方式有 </summary>              <div class='content'>              <p>总结全文式、呼应开头式、号召希望式、表示决心式、提出要求式</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文写作的特点包括 </summary>              <div class='content'>              <p>真实性、政策性、实用性、规范性</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文写作的结构要求做到 </summary>              <div class='content'>              <ul><li>完整严谨，比例恰当</li><li>层次分明，条理清楚</li><li>前后连贯，首尾圆和</li></ul>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文结构的常式包括 </summary>              <div class='content'>              <p>总分式、并列式、递进式、连贯式</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 什么是财经应用文 </summary>              <div class='content'>              <p>财经应用文是应用文的一个分支。狭义的财经应用文，专指各类只为财经工作所用的财经专业文书，是专门用于经济活动的经济应用文体的统称。广义的财经应用文，是人们在财经工作中所使用的各类反映经济活动内容的文书的统称，既包括财经专业文书，也包括一些同时在其他社会领域或部门广泛应用的文书。</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文有哪些特点 </summary>              <div class='content'>              <ol><li>真实性：实事求是，如实反映经济实践的过程和需求。解决实际问题。<ul><li>材料绝对真实</li><li>观点结论必须正确真实</li></ul></li><li>政策性：内容上的真实性决定了其政策性，其是在国家财经法规、规章、政策的指导下进行的</li><li>实用性：为了解决财经工作中的实际问而提出意见、措施、办法、对策或设想、建议。</li><li>规范性：格式、文件处理、用语、文种、语体、布局等有要求。</li></ol>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文结构的常式有哪些 </summary>              <div class='content'>              <ol><li>总分式：先总后分式、先分后总式、总分总式</li><li>并列式：分条列项式（按性质分成若干条项予以表述，每一条项冠以数目字）、内在法条式（法规、规章类文件）</li><li>递进式：以事物或某种经济现象为脉络，而阐明一定道理或观点的一种结构形态，即各层次之间是“进层”关系，彼此互为因果</li><li>连贯式：以时间为顺序，或者以事情为顺序</li></ol>              </div>            </details></li></ol><h2 id="常用公务文书">常用公务文书</h2><h3 id="公文的特点">公文的特点</h3><ol><li>作者的法定性</li><li>读者的特定性</li><li>法定的权威性</li><li>体式的规范性</li></ol><h3 id="公文的种类">公文的种类</h3><h4 id="公文种类">公文种类</h4><ol><li>决议：会议讨论通过的重大决策事项</li><li>决定：对重要事项的决策和部署等决定事项</li><li>命令（令）（部委级以上，下行文）：公布行政法规和规章、宣布重大措施</li><li>公报：公布重要决定或重大事项</li><li>公告：向国内外宣布重要事项或法定事项</li><li>通告：在一定范围内公布应当遵守或周知的事项</li><li>意见：对重要问题提出见解或处理办法</li><li>通知（下行文）：发布、传达下级机关执行事项，批转/转发公文</li><li>通报（下行文）：表彰先进，批评错误，传达重要精神，告知重要情况</li><li>报告（上行文）：向上级机关汇报工作、反映情况，回复上级机关询问</li><li>请示（上行文）：向上级机关请求指示、批准</li><li>批复（下行文）：答复下级机关请示事项</li><li>议案：各级人民政府向同级人代会/人大常委会提请审议事项</li><li>函（平行文）：不相隶属机关之间商洽工作、询问和答复问题、请求批准和答复审批事项</li><li>纪要：记载会议主要情况和议定事项</li></ol><h4 id="文种的选择">文种的选择</h4><ol><li>发文目的</li><li>行文关系（上下级，平级，不相隶属）</li><li>行文方向<ul><li>上行文：向上级机关发文</li><li>下行文：向下级机关发文</li><li>平行文：不相隶属机关</li><li>泛行文：公告之类，没有明确收方</li></ul></li></ol><h3 id="公文的格式">公文的格式</h3><h4 id="版头">版头</h4><p>公文首页红色分隔线以上的部分</p><h5 id="份号">份号</h5><ul><li>涉密公文顶格编排在版心左上角第一行，用6位阿拉伯数字标注的顺序编号。</li></ul><h5 id="密级和保密期限">密级和保密期限</h5><ul><li>对公文秘密等级及时效的规定，顶格编排在版心左上角第二行，数字用阿拉伯数字，密级和期限用★隔开。</li><li>涉密程度：绝密、机密、秘密</li></ul><h5 id="紧急程度">紧急程度</h5><ul><li>公文送达和办理的时限要求，顶格编排在版心左上角第三行</li><li>紧急程度：特急、加急</li></ul><h5 id="发文机关标志">发文机关标志</h5><ul><li>一般由发文机关全程或者规范化简称加“文件”二字组成，对于上行文可以只标志发文机关全称或规范化简称。</li><li>一般文件缀“文件”，命令缀“命令”，信函缀“函件”或不缀，纪要缀：纪要</li></ul><h5 id="发文字号">发文字号</h5><ul><li>由发文机关代字、年份、年度发文顺序号组成，发文机关标志下空两行居中位置</li><li>全称年份用六角括号“〔〕”，发文序号不加“第”，后加“号”，不编虚位0，</li></ul><h5 id="签发人">签发人</h5><ul><li>上行文需要标注签发人姓名，“签发人：”+名字</li></ul><h4 id="主体">主体</h4><p>首页红色分隔线以下、公文末页首条分隔线以上的部分</p><h5 id="标题">标题</h5><ul><li>由发文机关名称、事由和文种组成，回行需要词义完整，排列对称，长短适宜，间距恰当，排列呈梯形或菱形。</li><li>格式：XX机关+关于+事项+文种</li></ul><h5 id="主送机关">主送机关</h5><ul><li>主要受理机关，使用全称、规范化简称或同类型机关统称（“各有关单位”）</li></ul><h5 id="正文">正文</h5><ul><li>正文“三段式”结构：<ol><li>发文原由</li><li>发文事项</li><li>发文要求</li></ol></li></ul><h5 id="附件说明">附件说明</h5><ul><li><p>公文附件的顺序号和名称，有明确的附件文件时无需单独编排附件部分</p></li><li><p>格式：</p><blockquote><p>附件：1. ××××××（换行需要对齐首字）</p><p>2. ××××××（每行后方不加标点符号）</p></blockquote></li></ul><h5 id="发文机关署名">发文机关署名</h5><ul><li>署发文机关全称或规范化简称</li></ul><h5 id="成文日期">成文日期</h5><ul><li>签发日期，阿拉伯数字，不编虚位0</li></ul><h5 id="印章">印章</h5><ul><li>加盖发文机关印章，与署名机关相符</li></ul><h5 id="附注">附注</h5><ul><li>公文印发穿大范围等需要说明的事项</li></ul><h5 id="附件">附件</h5><ul><li>另面编排，与正文一起装订</li></ul><h4 id="版记">版记</h4><p>公文末页首条分隔线以下、末条分隔线以上的部分</p><h5 id="抄送机关">抄送机关</h5><ul><li>需要执行或者知晓公文内容的其他机关，使用全称、规范化简称或同类型机关统称</li></ul><h5 id="印发机关和印发日期">印发机关和印发日期</h5><h3 id="通知（下行文）">通知（下行文）</h3><ul><li>通知适用于批转下级机关的公文，转发上级机关和不相隶属机关的公文，发布文件；传达要求下级机关办理和需要有关单位周知或者执行的事项；任免人员。</li></ul><h4 id="主要类型">主要类型</h4><ol><li><p>指示性通知</p><p>有关行政法规和规章、办法、措施，不宜用命令发布的。</p></li><li><p>批示性通知（批转、转发、印发性通知）</p><p>用于发布某些行政法规，转发上级、同级或不相隶属机关的公文以及批转下级机关的公文。</p><p>印发标题格式：发文单位+关于印发+事项（方案、意见等）+通知</p><p>转发标题格式：发文单位+关于转发+事项（方案、意见等）+通知</p><p>（转发文也为通知时，去除内层“的通知”后缀，层层转发只标明最初发文单位，仅当转发为条例规章才加书名号）</p></li><li><p>事项性通知（工作通知）</p><p>要求下级机关办理某些事项，提出工作原则和要求等，具有强制性和行政约束力。</p></li><li><p>知照性通知（通常没有受文单位）</p><p>用于告知某一事项或某些信息的通知</p></li></ol><h3 id="请示（上行文）">请示（上行文）</h3><h4 id="适用范围（三“无”-三“请”）">适用范围（三“无”+三“请”）</h4><ul><li>无法——请求解答<ol><li>请求上级机关对方针、政策等作出明确解释和答复的</li><li>需要上级机关对某项政策做出变通处理的请示</li><li>无章可循、无法可依，需要上级机关指示的</li></ol></li><li>无力——请求帮助<ol><li>需要上级解决某一具体问题和实际困难的</li><li>本部门无法独立解决困难和问题的</li></ol></li><li>无权——请求审批<ol><li>按照规定未经有关部门批准无权自行处理的问题</li></ol></li></ul><h4 id="特点">特点</h4><ul><li>陈请性</li><li>期复性</li><li>超前性（事前行文）</li><li>单一性（一文一事）</li></ul><h4 id="主要类型-2">主要类型</h4><ul><li>政策性</li><li>事项性</li></ul><h3 id="函（平行文）">函（平行文）</h3><ul><li>函适用于不相隶属机关指尖商洽工作、询问和答复问题、请求批准和答复审批事项。</li><li>不具有指令性，而是商洽性的。</li><li>按照往来关系可以分为去函和复函（需要引述来文情况，“~~收悉”）</li></ul><h4 id="适用范围">适用范围</h4><ol><li>平级机关或不相隶属机关单位指尖的商洽性、询问性和答复性公务联系。</li><li>向无隶属关系的业务主管部门请求批示有关事项。</li><li>业务主管部门答复或审批无隶属关系的机关请示批准的事项。</li><li>机关单位对个人的公务联系。</li></ol><h4 id="主要类型-3">主要类型</h4><ol><li>商洽函</li><li>询问答复函</li><li>请批、批准函</li></ol><h2 id="市场调研报告">市场调研报告</h2><h3 id="基本类型">基本类型</h3><ol><li>桌面调研和实地调研（问卷式、访问式、观察式）</li><li>内部因素调研（产品、价格……）和外部环境调研（企业宏观环境和企业微观环境）</li><li>全面调研和非全面调研</li></ol><h3 id="调研步骤">调研步骤</h3><ol><li>确定调研目标</li><li>界定调研问题<ol><li>顾客态度、改进意见</li><li>竞争对手特点</li><li>顾客接受的价格范围</li></ol></li><li>调研执行</li><li>调研分析</li></ol><h3 id="正文的前言">正文的前言</h3><p>（概述写法）</p><ol><li>开门见山，揭示主题</li><li>结论先行，逐步论证</li><li>交代背景，逐层分析，得出结论</li><li>提出问题，引入正题</li></ol><h3 id="正文的情况部分">正文的情况部分</h3><ol><li>提出问题（现状、情况）</li><li>分析问题（原因、做法经验）</li><li>解决问题（建议、办法、对策）</li></ol><p>描述方式：叙述（概述）、说明、议论</p><h2 id="日常事务文书">日常事务文书</h2><p>概念：汇总+结论</p><h3 id="内容构成">内容构成</h3><ol><li>过程概述</li><li>成绩归纳</li><li>经验提炼</li><li>问题分析</li></ol><h3 id="结构">结构</h3><ol><li>标题（准确简洁）<ul><li>公文式标题</li><li>文章式标题</li><li>双标题</li></ul></li><li>正文<ul><li>前言<ul><li>概括式（交代情况）</li><li>结论式</li></ul></li><li>主体<ul><li>纵式结构（做了什么/成绩/经验问题）</li><li>横式结构（经验体系）</li></ul></li><li>结论（总结经验）</li></ul></li><li>落款：署名+日期</li></ol>]]></content>
    
    
    <summary type="html">部分常见的财经应用文写作方式介绍</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="应用文写作" scheme="https://www.iuoyt.com/tags/%E5%BA%94%E7%94%A8%E6%96%87%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>信息安全技术数学基础</title>
    <link href="https://www.iuoyt.com/posts/215ef6b6.html"/>
    <id>https://www.iuoyt.com/posts/215ef6b6.html</id>
    <published>2024-02-23T07:16:31.000Z</published>
    <updated>2024-03-05T12:48:00.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数论">数论</h2><h3 id="因子">因子</h3><ul><li><h4 id="因子（定义）">因子（定义）</h4>  <div class="note info simple"><p>设$a, b ∈ Z$，$a ≠ 0$，$c ∈ Z$，使得$b = ac$，则称$a$整除$b$，并称$a$是$b$的<strong>因子</strong>或者<strong>约数</strong>，$b$是$a$的<strong>倍数</strong>，记为$a | b$。</p></div><p>如果整数$a$除整数$b$得到的商$c$是整数，那么称$a$是$b$的因子/约数，$b$是$a$的倍数，记为$a | b$​。</p><p>有如下性质：</p><ul><li>$a|a$</li><li>如果$a|b$，$b|c$，那么$a|c$成立</li><li>如果$a|c$，那么$ab|cb$​成立</li><li>如果$a|b$，$a|c$，那么对于任意整数x、y，$a|(bx+cy)$​成立</li><li>如果$a|b$，$b|a$，那么$a=\pm b$</li></ul></li><li><h4 id="带余除法（定理）">带余除法（定理）</h4>  <div class="note info simple"><p>设$a, b ∈ Z$，$b ≥ 1$，则存在唯一的整数$q$和$r$，使得$a = qb + r$，$0 ≤ r &lt; b$。$q$称$a$除以$b$所得的商，$r$称为$a$除以$b$所得的<strong>最小非负剩余</strong>。</p></div><p>$a$为整数，$b$为正整数，那么$a = qb + r$可以确定唯一的$q$（商）和$r$（最小非负剩余，一定小于$b$）。</p></li><li><h4 id="最大公因子（定义）">最大公因子（定义）</h4>  <div class="note info simple"><p>设$a, b ∈ Z$，$a,b$不全为0，如果$c | a$且$c | b$，则称$c$为$a$和$b$的公因子。特别地，我们把$a$和$b$的所有公因子中最大的，称为$a$和$b$的<strong>最大公因子</strong>，记为$gcd(a,b)$ 或者 (<em>a</em>, <em>b</em>)。</p></div><p>如果$c$为不都为0的整数$a$、$b$的因子，那么$c$为$a$、$b$的公因子，其中最大公因子记作$gcd(a,b)$或$(a,b)$​。</p></li><li><h4 id="欧几里得算法（定理）">欧几里得算法（定理）</h4>  <div class="note info simple"><p>给定整数$a$和$b$，且$b&gt;0$，重复使用带余除法，即每次的余数为除数去除上一次的除数，直到余数为0，这样可以得到下面一组方程：</p><p>​$a = bq_1+r_1$，$0 &lt; r_1 &lt;b$</p><p>​$b = r_1q_2+r_2$，$0 &lt; r_2 &lt; r_1$</p><p>​$r_1 = r_2q_3+r_3$，$0 &lt; r_3 &lt; r_2$</p><p>​……</p><p>​$r_{j-1} = r_jq_{j+1}$</p><p>最后一个不为0的余数$r_j$​就是$a$和$b$的最大公因子</p></div><p>欧几里得算法求$gcd(a,b)$：第一次将两数作为$a$和$b$进行带余除法（$a = qb + r$），在下一次带余除法计算时$b$作为$a$，余数$r$作为$b$，多次计算直到余数为0的$r_j$即最大公因子。</p>  <details class="folding-tag" ><summary> 求$gcd(1970，1066)$ </summary>              <div class='content'>              <p>求$gcd(1970,1066)$：</p><p>$1970 ＝ 1 × 1066 + 904$</p><p>$1066 ＝ 1 × 904 + 162$</p><p>$904 ＝ 5 × 162 + 94$</p><p>$162 = 1 × 94 + 68$</p><p>$94 ＝ 1 × 68 + 26$</p><p>$68 ＝ 2 × 26 + 16$</p><p>$26 ＝ 1 × 16 + 10$</p><p>$16 = 1 × 10 + 6$</p><p>$10 = 1 × 6 + 4$</p><p>$6 = 1 × 4 + 2$</p><p>$4 = 2 × 2 + 0$</p><p>因此$gcd (1970,1066) = 2$</p>              </div>            </details><ul><li><p>推导定理</p>  <div class="note info simple"><p>对任何非负整数$a$和正整数$b$，有$gcd(a,b)=gcd(b, a\bmod b)$。</p></div></li></ul></li></ul><h3 id="素数">素数</h3><ul><li><h4 id="素数（定义）">素数（定义）</h4>  <div class="note info simple"><p>设$p ∈Z$，$p≥2$，如果$p$的正因子只有1和$p$，则称$p$为<strong>素数</strong>，否则为<strong>合数</strong></p></div><p>素数的因子只有1和其本身。</p><p>性质：</p><ul><li>数字越大的区间素数分布越稀疏，对于每个大于等于2的整数$n$，连续$n-1$个整数$n!+2$，$n!+3$，$\dots$，$n!+n$都不是素数</li><li>任意两个相邻的正整数$n$和$n+1$（$n&gt;3$​）中必有一个不是素数</li><li>$n$和$n+2$均为素数的数对称为孪生素数，例如$(3,5)$，$(5,7)$，$(11,13)$，$(29,31)$。</li></ul></li><li><h4 id="素因子（定义）">素因子（定义）</h4>  <div class="note info simple"><p>若正整数$a$有一因子$b$，而$b$又是素数，则称$b$为$a$的<strong>素因子</strong></p></div><p>数的因子也是素数，那么该因子成为素因子。</p><ul><li><p>推导定理</p>  <div class="note info simple"><p>若$a$是大于1的整数，则$a$的大于1的最小因子一定是素数。</p></div><p>本定理说明了任何大于1的整数均可被一素数整除，或者说都至少有一素因子。</p></li><li><p>性质：</p><ul><li>如果$p$是素数，且$p|ab$，则$p|a$或$p|b$</li><li>对于任意大于1的整数$m$，都有唯一分解式：$m=p_{1}^{a_1}p_{2}^{a_2}\dots p_{n}^{a_k}$，其中$p_1$，$p_2$，$\dots$，$p_n$均为素数，$p_i&gt;p_j(i&lt;j)$，且$a_i$​都是正整数</li><li>素数个数有无穷多个</li></ul></li><li><p>素数定理：</p>  <div class="note info simple"><p>设$\pi(x)$表示不大于$x$的素数的数目，则$\lim_{x \to \infty}\frac{\pi(x)\ln x}{x}=1 $。</p></div><p>素数定理表明，对充分大的$x$，$\pi(x)$可用$\frac{x}{\ln x}$近似表示</p></li></ul></li><li><h4 id="互素（定义）">互素（定义）</h4>  <div class="note info simple"><p>如果整数$a$与整数$b$的最大公因子是1，即$gcd (a, b) = 1$​，则称$a$与$b$​​互为素数，简称<strong>互素</strong></p></div><p>互素的正整数中不一定有素数，例如$gcd(25,36)=1$，但25和36均为合数。</p></li><li><h4 id="欧拉函数（定义）">欧拉函数（定义）</h4>  <div class="note info simple"><p>设$\varphi (m)$为小于或等于$m$且与$m$​互素的正整数个数，则称其为<strong>欧拉(Euler)函数</strong></p></div>  <details class="folding-tag" ><summary> 欧拉函数举例 </summary>              <div class='content'>              <p>$\varphi(1)=1$：1​</p><p>$\varphi(2)=1$：1</p><p>$\varphi(3)=2$：1、2</p><p>$\varphi(5)=4$：1、2、3、4</p><p>$\varphi(8)=4$：1、3、5、7</p>              </div>            </details></li></ul><h3 id="同余">同余</h3><blockquote><p>用$Z_m$表示正整数{$0,1,\dots,m-1$}的集合</p></blockquote><ul><li><h4 id="模数（定义）">模数（定义）</h4>  <div class="note info simple"><p>两个整数$a$, $b$分别被$m$除，如果所得的余数相同，则称$a$与$b$对模$m$是<strong>同余</strong>的，记为$a\equiv b(\bmod m)$，正整数$m$​称为<strong>模数</strong>。</p></div><p>性质：</p><ul><li>$a\equiv b(\bmod m) \Leftrightarrow m|(b-a)$</li><li>如果$a=km+b$（k为整数），则$a\equiv b(\bmod m)$</li><li><span class='nota' data-nota='说人话：任意数对m取余一定在0~m-1之间'>每个整数恰与0，1，…，$m-1$这$m$个整数中的某一个对模$m$​同余</span></li><li>同余关系是一种等价关系</li><li>$a\equiv b(\bmod m)$当且仅当$a \bmod m = b \bmod m$</li></ul><p>同余式性质：</p><p>（若$a\equiv b(\bmod m)$，$c\equiv d(\bmod m)$）</p><ul><li>同余式可加：$ax+cy\equiv bx+dy(\bmod m)$</li><li>同余式可乘：$ac\equiv bd(\bmod m)$</li><li>$an\equiv bn(\bmod m)$，$n&gt;0$</li><li>$f(a)\equiv f(b)(\bmod m)$，$f(x)$为任意一个整系数多项式</li></ul><p>（若$a$，$b$，$c$，$d$为整数，$m$为正整数）</p><ul><li><span class='nota' data-nota='将m换为其因子同余式也成立'>若$a\equiv b(\bmod m)$，且$d|m$，则$a\equiv b(\bmod d)$​</span></li><li>若$a\equiv b(\bmod m)$，则$gcd(a,m)=gcd(b,m)$</li></ul></li><li><h4 id="乘法消去律（定理）">乘法消去律（定理）</h4>  <div class="note info simple"><p>对于$ab\equiv ac(\bmod m)$来说，若$gcd(a,m)=1$，则$b\equiv c(\bmod m)$​。</p></div><p>对于$ab\equiv ac(\bmod m)$，若$a$、$m$互素，则可直接消去$a$。</p></li><li><h4 id="加法消去律（定理）">加法消去律（定理）</h4>  <div class="note info simple"><p>如果$a+b\equiv a+c(\bmod m)$，则$b\equiv c(\bmod m)$。​​</p></div></li><li><h4 id="剩余类-同余类（定义）">剩余类/同余类（定义）</h4>  <div class="note info simple"><p>由于模$m$同余关系是一个等价关系，若将$Z$中的同余的树归为一类，不同余的数归为不同的类，则将$Z$分为$m$个类，称为模$m$​的剩余类或同余类。</p></div><p>按照$Z$对$m$取模的余数将数划分为不同的类，称为剩余类（同余类）。</p><p>使用$[r]$表示$r$所属的模$m$的剩余类（$r \bmod m$​）</p></li><li><h4 id="非负最小完全剩余系（定义）">非负最小完全剩余系（定义）</h4>  <div class="note info simple"><p>在模$m$剩余类$[0],[1],\dots,[m-1]$中各取一数$a_0,a_1,\dots,a_{m-1}$，该m个数$a_0,a_1,\dots,a_{m-1}$称为模$m$的一个完全剩余系，将{$0,1,\dots,m-1$}记为$Z_m$，称为模$m$​的非负最小完全剩余系。</p></div></li><li><h4 id="简化剩余系（定义）">简化剩余系（定义）</h4>  <div class="note info simple"><p>若模$m$剩余类中的数与$m$互素，称它为与模$m$互素的剩余类，在与模$m$互素的所有剩余类中各取一数所组成的集合，称为模$m$的一个简化剩余系，$Z_m$的简化剩余系记为$Z^{*}_{m}$​。</p></div></li><li><h4 id="一次同余方程（定义）">一次同余方程（定义）</h4>  <div class="note info simple"><p>若$a$、$b$都是整数，且$m$不能整除$a$，则称$ax\equiv b(\bmod m)$为模$m$​的一次同余方程。</p></div><p>若$x_0$满足$ax_0\equiv b(\bmod m)$，则$x\equiv x_0(\bmod m)$称为它的解，其全部解可以表示为$x_0+mk, k=0,\pm 1, \pm2, \dots$。（不同解指的是互不同余的解）</p></li><li><h4 id="一次同余方程有唯一解（定理）">一次同余方程有唯一解（定理）</h4>  <div class="note info simple"><p>设$a\in Z_m$，对于任意的$b\in Z_m$，同余方程$ax\equiv b(\bmod m)$有唯一解$x\in Z_m$的充分必要条件是$gcd(a,m)=1$</p></div></li><li><h4 id="一次同余方程有解（定理）">一次同余方程有解（定理）</h4>  <div class="note info simple"><p>设$gcd(a,m)=d,m\gt 0$，则$ax\equiv b(\bmod m)$有解，当且仅当$d|b$​</p></div></li></ul><h3 id="模运算">模运算</h3><ul><li><h4 id="性质">性质</h4><ol><li>$(a\pm b) \bmod m = [(a \bmod m)\pm (b\bmod m)] \bmod m$</li><li>$(a\times b) \bmod m = [(a \bmod m)\times (b\bmod m)] \bmod m$</li><li>$[a\times (b + c)] \bmod m = [(a\times b) \bmod m+ (b\times c)\bmod m] \bmod m$</li></ol></li><li><h4 id="加法逆元（定义）">加法逆元（定义）</h4>  <div class="note info simple"><p>对$a\in Z_m$，存在$b\in Z_m$，使得$a+b\equiv 0(\bmod m)$，则$b$是$a$的加法逆元，记$b=-a$​。</p></div><p>加法一定存在逆元。</p></li><li><h4 id="乘法逆元（定义）">乘法逆元（定义）</h4>  <div class="note info simple"><p>对$a\in Z_m$，存在$b\in Z_m$，使得$a\times b\equiv 1(\bmod m)$，则称$b$是$a$​的乘法逆元。</p></div><p>乘法不一定存在逆元。</p><p>在密码学特别是非对称密码体制中，常常需要求模逆元，求模逆元就是求乘法逆元。即寻找一个$x$，使得$a \times x \equiv 1 \bmod m$成立。模逆元不一定存在结果，通常试用欧几里得算法求出。</p><blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20240225163951178.png" alt="模8运算"></p><ul><li>对应每个$x$都有一个对应的$y$使得$x+y\equiv 0 \bmod 8$，则$y$是$x$的加法逆元。如对2，存在加法逆元6使得$2+6\equiv 0 \bmod 8$​。</li><li>对应$x$存在$y$使得$x\times y\equiv 1\bmod 8$，则$y$是$x$的乘法逆元。如对3，存在乘法逆元3使得$3\times 3\equiv 1\bmod 8$。</li></ul></blockquote></li><li><h4 id="快速指数模运算">快速指数模运算</h4><p>求$m^e\bmod n$的方法</p><ul><li><p>常规算法</p><p>原理：模运算性质$(a\times b) \bmod m = [(a \bmod m)\times (b\bmod m)] \bmod m$​</p><p>变换：$a^e\bmod m = [(a \bmod m)^e]\bmod m$​</p></li><li><p>快速求法</p>  <div class="note info simple"><ol><li>$a\gets e$，$b\gets m$，$c\gets 1$， 其中$a$，$b$，$c$为三大整数寄存器。</li><li>如果$a=0$，则输出结果$c$即为所求的模<em>n</em>的大整数次幂。</li><li>如果$a$是奇数，转第5步。</li><li>$a\gets \frac{a}{2}$，$b\gets b\times b\bmod n$，转第3步。</li><li>$a\gets (a-1)$，$c\gets (c\times b) \bmod n$​，转第2步。</li></ol></div>  <details class="folding-tag" ><summary> 计算$30^{37}\bmod 77$​​ </summary>              <div class='content'>              <table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">e</th></tr></thead><tbody><tr><td style="text-align:center">37</td><td style="text-align:center">30</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">36</td><td style="text-align:center">与前一次值相同</td><td style="text-align:center">$(30\times 1)\bmod 77=30$</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">$(30\times 30)\bmod 77=53$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">$(53\times 53)\bmod 77=37$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">与前一次值相同</td><td style="text-align:center">$(37\times 30)\bmod 77=32$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$(37\times 37)\bmod 77=60$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$(60\times 60)\bmod 77=58$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">$(58\times 58)\bmod 77=53$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">与前一次值相同</td><td style="text-align:center">$(53\times 32)\bmod 77=2$</td></tr></tbody></table><p>得$c=2$，即$30^{37}\bmod 77=2$</p>              </div>            </details></li></ul></li></ul><h3 id="费马定理和欧拉定理">费马定理和欧拉定理</h3><ul><li><h4 id="费马定理（定理）">费马定理（定理）</h4>  <div class="note info simple"><p>若$p$是素数，且$a$是正整数，且$gcd(a,p)=1$，则$a^{p-1}\equiv 1(\bmod p)$。</p></div>  <details class="folding-tag" ><summary> 例$a=7，p=19$ </summary>              <div class='content'>              <p>$a=7,p=19,gcd(a,p)=1$</p><p>$7^2=49\equiv 11\bmod 19$</p><p>$7^4\equiv 121\bmod 19\equiv 7\bmod 19$</p><p>$7^8\equiv49\bmod 19\equiv 11\bmod 19$</p><p>$7^{16}\equiv 121\bmod 19 \equiv 7 \bmod 19$</p><p>$a^{p-1}=7^{18}=7^{16}\times 7^2\equiv 7\times 11\bmod 19\equiv 1\bmod 19$</p>              </div>            </details><p>推论（费马定理另一种总表现形式）：</p>  <div class="note info simple"><p>设$p$是素数，对于任意正整数$a$，则$a^p\equiv a(\bmod p)$。</p></div><p>推论不要求$gcd(a,p)=1$，即$a,p$​互素</p></li><li><h4 id="欧拉定理（定理）">欧拉定理（定理）</h4>  <div class="note info simple"><p>对于任意互素的两个整数$a,n$，有：$a^{\varphi (n)}\equiv 1\bmod m$​。</p></div>  <details class="folding-tag" ><summary> 欧拉定理举例 </summary>              <div class='content'>              <p>$a=3,n=10$：$\varphi (10)=4,a^{\varphi(n)}=3^4=81\equiv 1\bmod 10=1\bmod n$</p><p>$a=2,n=11$：$\varphi(11)=10,a^{\varphi (n)}=3^{10}=1024\equiv1\bmod 11=1\bmod n$</p>              </div>            </details><p>对于欧拉定理，有：</p><ul><li>当$n=p$时，有$a^{p-1}\equiv 1\bmod p$，为费马定理</li><li>易见$a^{\varphi (n+1)}\equiv a\bmod n$（欧拉定理的另一种形式不要求$a$和$n$互素）</li></ul>  <details class="folding-tag" ><summary> 求$13^{2001}$被$60$除所得的余数 </summary>              <div class='content'>              <p>$\because gcd(13,60)=1$</p><p>$\therefore 13^{\varphi (60)}\equiv 1(\bmod 60)$</p><p>$\because \varphi (60)=\varphi (2^2\times 3\times 5)=2\times(3-1)\times(5-1)=16$，$2001=125\times 16+1$</p><p>$\therefore 13^{16}\equiv 1(\bmod 60)$，$13^{2001}=(13^{16})^{125}\times 13\equiv 13(\bmod 60)$</p><p>即被60除所得的余数为13</p>              </div>            </details></li></ul><h3 id="素性测试">素性测试</h3><p>素性测试即检验一个大数是否为素数，通常用于密码算法中需要大素数时判断随机生成的数是否为素数。</p><div class="note info simple"><p>如果$p$为大于2的素数，则方程$x^2\equiv 1(\bmod p)$的解只有$x=1$和$x=-1$​。</p></div><p>定理的逆否命题为：如果方程$x^2\equiv 1(\bmod p)$有一个解$x_0\notin$ {$-1,1$}，那么p不是素数。</p><details class="folding-tag" ><summary> Miller-Rabin素性概率检验算法 </summary>              <div class='content'>              <p><img src="https://oss.iuoyt.com/img/posts/image-20240302194925787.png" alt="Miller-Rabin素性概率检验算法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MillerRabinTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">WITNESS</span><span class="params">(BigInteger a, BigInteger n)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算 n-1</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">nMinusOne</span> <span class="operator">=</span> n.subtract(BigInteger.ONE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">d</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">        <span class="comment">// 将 (n-1) 表示为二进制形式 b_k b_&#123;k-1&#125; ... b_0</span></span><br><span class="line">        <span class="keyword">while</span> (d.mod(BigInteger.valueOf(<span class="number">2</span>)).equals(BigInteger.ZERO)) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            d = d.divide(BigInteger.valueOf(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// x←d</span></span><br><span class="line">            <span class="type">BigInteger</span> <span class="variable">x</span> <span class="operator">=</span> d;</span><br><span class="line">            <span class="comment">// d←d^2 mod n</span></span><br><span class="line">            d = d.multiply(d).mod(n);</span><br><span class="line">            <span class="comment">// 如果 d=1 且 x≠1 且 x≠n-1，则 n 可能是合数</span></span><br><span class="line">            <span class="keyword">if</span> (d.equals(BigInteger.ONE) &amp;&amp; !x.equals(BigInteger.ONE) &amp;&amp; !x.equals(nMinusOne)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 b_i=1，则 d←d*a mod n</span></span><br><span class="line">            <span class="keyword">if</span> (nMinusOne.testBit(i)) &#123;</span><br><span class="line">                d = d.multiply(a).mod(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后检查d是否等于1，如果d≠1，则n可能是合数，否则n可能是素数</span></span><br><span class="line">        <span class="keyword">return</span> !d.equals(BigInteger.ONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 小于n的整数</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">// 要检验的数</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;7919&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (WITNESS(a, n)) &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; 可能是合数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; 可能是素数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>算法有两个输入，$n$是待检验的数，$a$是小于<em>n</em>的整数。如果算法的返回值为TRUE，则$n$肯定不是素数，如果返回值为FALSE，则$n$有可能是素数。</p></li><li><p>for循环后，有$d = a^{n-1}\bmod n$，由费马定理可知，若$n$为素数，则$d$为1，因此若$d\ne 1$，则$n$不是素数，所以返回TRUE。</p></li><li><p>因为$n-1\equiv -1\bmod n$，所以$x\ne 1$，$x\ne n-1$，表示$x^2\equiv 1 (\bmod p)$有不在{$-1,1$}中的根，因此$n$不为素数，返回TRUE。</p></li></ul>              </div>            </details><h3 id="中国剩余定理">中国剩余定理</h3><div class="note info simple"><p>设$m_1,m_2,\dots ,m_k$​是两两互素的正整数，令</p><center>$M=m_1m_2\dots m_k=m_1M_1=m_2M_2=\dots=m_kM_k$</center><p>上式中$M_i=\frac{M}{m_i},i=1,2\dots,k$，则同时满足同余方程组</p><center>$x\equiv b_i\bmod m_i\quad(i=1,2,\dots,k)$</center><p>的唯一正整数解$x_0$是：</p><center>$x_0=(b_1M^{\prime}_{1}M_1+b_2M^{\prime}_{2}M_2+\dots+b_kM^{\prime}_{k}M_k)\bmod M$</center><p>上式中$M^{\prime}_{i}$是$M_i$以$m_i$为模的逆元。</p></div><details class="folding-tag" ><summary> 求解$x$举例 </summary>              <div class='content'>              <blockquote><p>求解满足以下方程的解$x$：</p><center>$x\equiv 1\bmod 2$​</center><center>$x\equiv 2\bmod 3$</center><center>$x\equiv 3\bmod 5$</center><center>$x\equiv 5\bmod 7$</center></blockquote><p>$M=m_1m_2m_3m_4=2\times 3\times 5\times 7=210$</p><p>$M_1=105,M_2=70,M_3=42,M_4=30$</p><p>由扩展欧几里得定理：</p><center>$M^{-1}_{1}\bmod 2\equiv 1\quad M^{-1}_{2}\bmod 3\equiv 1\quad M^{-1}_3\bmod 5\equiv 3\quad M^{-1}_4\bmod 7\equiv 4$</center>​<p>$\therefore x\bmod 210\equiv(1\times 105\times 1+ 2\times 70\times 1+3\times 42\times 3+5\times 30\times 4)\bmod 210\equiv 173$</p><p>即$x\equiv 173\bmod 210$</p>              </div>            </details><h3 id="离散对数">离散对数</h3><ul><li><h4 id="本原根（定义）">本原根（定义）</h4>  <div class="note info simple"><p>若$Ord_na=\varphi (n)$，则称$a$是模$n$​的本原根，也称生成元。</p><blockquote><p>指数：假设$gcd(a,n)-1$，如果使$m$是使$a^m\equiv 1\bmod n$成立的最小正整数，则称它是$a$对模$n$的指数，记为$Ord_na$。</p></blockquote></div><p>并非所有的整数都有本原根。模$m$的本原根存在的必要条件是$m=2,4,p^a$或$2p^a$，此处$p$为奇素数。</p>  <details class="folding-tag" ><summary> 求模7和模15的本原根 </summary>              <div class='content'>              <ol><li><p>对于模7：满足$gcd(a,n)=1$的$a$是{$1,2,3,4,5,6$}，指数表如下：</p><table><thead><tr><th style="text-align:center">$a$</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">$Ord_7a$</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr></tbody></table><p>当$a=3$或$5$时，$Ord_7a=\varphi (7)$，因此3和5是模7的本原根。</p></li><li><p>对于模15：满足$gcd(a,n)=1$的$a$是{$1,2,4,7,8,11,13,14$}​，指数表如下：</p><table><thead><tr><th style="text-align:center">$a$</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">4</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">11</th><th style="text-align:center">13</th><th style="text-align:center">14</th></tr></thead><tbody><tr><td style="text-align:center">$Ord_{15}a$</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr></tbody></table><p>从上表中可以看出不存在$a$使得$Ord_{15}a=\varphi (15)$，所以模15没有本原根。</p></li></ol>              </div>            </details></li><li><h4 id="简化剩余系（定理）">简化剩余系（定理）</h4>  <div class="note info simple"><p>若$a$是模$n$的本原根，则$1,a^1,a^2,\dots,a^{\varphi (n)}$构成模$n$​的简化剩余系。</p></div></li><li><h4 id="本原根的测试">本原根的测试</h4>  <div class="note info simple"><p>令$q_1,q_2,\dots,q_n$是$p-1$的素因子，对于所有的$q_1,q_2,\dots,q_n$计算$a^{\frac{p-1}{q}}(\bmod p)$，如果对于某个$q$的某个值其结果为1，那么$a$不是一个本原根。如果对于某个$q$的所有值其结果都不为1，那么$a$​是一个本原根。</p></div>  <details class="folding-tag" ><summary> 假设$p=11$​，检验2和3是否是一个本原根 </summary>              <div class='content'>              <p>当$p=11$时，$p-1=10$，$p-1$有两个素因子2和5</p><ol><li><p>对2判断：</p> <center>$2^{\frac{10-1}{5}}(\bmod 11)=4$</center> <center>$2^{\frac{10-1}{2}}(\bmod 11)=10$</center><p>由于计算结果没有1，故2是本原根。</p></li><li><p>对3判断：</p> <center>$3^{\frac{10-1}{5}}(\bmod 11)=9$</center> <center>$3^{\frac{10-1}{2}}(\bmod 11)=1$</center><p>由于计算结果存在1，故3不是本原根。</p></li></ol>              </div>            </details></li><li><h4 id="离散对数-2">离散对数</h4><p>模运算用于指数计算可以表示为$a^x\bmod n$，称为模指数运算，其逆向问题就是找出一个数的离散对数，即求解$x$，使得：$a^x\equiv b\bmod n$。</p>  <div class="note info simple"><p>对于一个整数$b$和素数$n$的一个本原根$a$，可以找到唯一的指数$x$，使得$b\equiv a^x\bmod n$，其中$0\le x\le n-1$，指数$x$称为$b$的以$a$为基数的模$n$​​的离散对数。</p></div><p>并非所有离散对数都有解。</p><blockquote><p>例如取$n=11$​，有3个本原根2、6、8</p><ol><li><p>求模数：</p><p>当$a=2,x=9$可求出模数$b=6$</p><p>当$a=5,x=7$可求出模数$b=8$</p><p>当$a=8,x=4$可求出模数$b=4$​</p></li><li><p>求离散对数：</p><p>当$a=2,b=3$可求出离散对数$x=8$</p><p>当$a=6,b=5$可求出离散对数$x=6$</p><p>当$a=8,b=10$可求出离散对数$x=5$</p></li></ol></blockquote></li></ul><h3 id="二次剩余">二次剩余</h3><ul><li><p>定义</p>  <div class="note info simple"><p>如果$gcd(a,m)=1$，并且$2^x\equiv a(\bmod m)$有解，则称$a$是$m$的二次剩余（平方剩余），否则称$a$是$m$非二次剩余。满足$x^2\equiv a(\bmod m)$的$x$称为模$m$​的一个平方根。</p></div></li><li><p>性质：</p><ul><li>如果$m$是素数，则整数$1,2,\dots,m-1$中正好有$\frac{m-1}{2}$个是模$m$的二次剩余，其余的$\frac{m-1}{2}$个是模$m$的非二次剩余。</li><li>如果是$a$的模$m$的一个二次剩余，那么$a$恰好有两个平方根，其中一个在$0\sim\frac{m-1}{2}$之间，另一个在$\frac{m-1}{2}\sim m-1$之间。</li><li>如果$m$是两个素数$p$和$q$之积，那么模$m$恰好有$\frac{(p-1)(q-1)}{4}$个二次剩余，有$\frac{3(p-1)(q-1)}{4}$个非二次剩余。</li><li>当$m$是复合数时，如果$m$的分解未知，则求方程$x^2\equiv a(\bmod m)$​的解会很困难。</li></ul>  <details class="folding-tag" ><summary> 求模7的二次剩余 </summary>              <div class='content'>              <p>若$m=7$，模$m$的完全剩余集合为{$1,2,3,4,5,6$}</p><p>$x^2\equiv 1(\bmod 7)$有解，$x=1,x=6$</p><p>$x^2\equiv 2(\bmod 7)$有解，$x=3,x=4$</p><p>$x^2\equiv 3(\bmod 7)$无解</p><p>$x^2\equiv 4(\bmod 7)$有解，$x=2,x=5$</p><p>$x^2\equiv 5(\bmod 7)$无解</p><p>$x^2\equiv 6(\bmod 7)$无解</p><p>由此可见1、2、4为模7的二次剩余，3、5、6是模7的非二次剩余</p>              </div>            </details></li></ul><h2 id="代数基础">代数基础</h2><h3 id="群和环">群和环</h3><h4 id="群">群</h4><ul><li>群定义了一个二元运算的集合，这个二维运算可以表示为$\cdot$（具有一般性，可以指任何数学运算），群$G$记作{$G,\cdot$}，$G$中的每一个序偶$(a,b)$通过运算生成$G$中的元素$(a\cdot b)$​。</li><li>如果一个群的元素个数是有限的，则该群称为有限群。并且群的阶等于群中元素的个数。否则，称该群为无限群。</li><li>满足以下原则：<ul><li>封闭性：如果$a$和$b$都属于$G$，则$a\cdot b$也属于$G$</li><li>结合律：对于$G$中的任何元素$a、b、c$都有$a\cdot (b\cdot c)=(a\cdot b)\cdot c$​成立</li><li>单位元：$G$中存在一个元素$e$，对于$G$中任意元素$a$，都有$a\cdot e=e\cdot a=a$成立</li><li>逆元：对于$G$中任意元素$a$，$G$中都存在一个元素$a^{\prime}$，使得式$a\cdot a^{\prime}=a^{\prime}\cdot a=e$​成立</li><li>交换律：对于$G$中的任意元素$a,b$，都有$a\cdot b=b\cdot a$成立</li></ul></li></ul><h4 id="环">环</h4><ul><li>环是一个有两个二元运算的集合，记作{$R,+,\times$}，这里两个二元运算分别是加法和乘法。从本质上来说，环就是一个集合，可以在其上进行加法、减法和乘法，而不脱离该集合。对于$R$中的任意元素$a、b、c$，满足以下公理：<ul><li>$R$关于加法是一个交换群，即满足<a href="#%E7%BE%A4">群的全部5条原则</a>。对于此种情况下的加法群，用0表示其单位元，$-a$表示$a$的加法逆元。</li><li>乘法的封闭性：如果$a$和$b$都属于$R$，则$ab$也属于$R$</li><li>乘法的结合律：对于$R$中任意元素$a、b、c$，$a(bc)=(ab)c$成立</li><li>分配律：对于$R$中的任意元素$a、b、c$，式$a(b+c)=ab+ac$和式$(a+b)c=ac+bc$总成立</li><li>乘法的交换律：对于$R$中的任意元素$a,b$，有$ab=ba$​成立</li><li>乘法单位元：在$R$中存在元素1，是的对于$R$中的任意元素$a$，有$a1=1a=a$chengli</li><li>无零因子：如果有$R$中元素$a$和$b$，且$ab=0$，则必有$a=0$或$b=0$​</li></ul></li></ul><div class="note info flat"><p>内容更新中……</p></div><h3 id="域和有限域">域和有限域</h3><h4 id="域">域</h4><h4 id="有限域">有限域</h4><h4 id="域上多项式">域上多项式</h4><h4 id="有限域-2">有限域</h4><h2 id="计算复杂性理论">计算复杂性理论</h2><h3 id="问题的复杂性">问题的复杂性</h3><h3 id="算法的复杂性">算法的复杂性</h3><h2 id="单向函数">单向函数</h2>]]></content>
    
    
    <summary type="html">这一部分是信息安全技术的基础，主要包括数论、代数基础、计算复杂性理论和单向函数。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="信息安全技术" scheme="https://www.iuoyt.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>信息安全技术概述</title>
    <link href="https://www.iuoyt.com/posts/cdc0c7d.html"/>
    <id>https://www.iuoyt.com/posts/cdc0c7d.html</id>
    <published>2024-02-22T08:12:54.000Z</published>
    <updated>2024-02-22T09:32:35.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全攻击">安全攻击</h2><ul><li>安全攻击是<strong>危及信息系统安全的活动</strong>，即<strong>信息在存储、共享和传输中，可能会被非法窃听、截取、篡改和破坏的活动</strong>。</li><li>安全攻击包括两类：<ul><li><strong>被动攻击</strong><ul><li>目的：获得传输的信息，不对信息作任何改动</li><li>威胁信息的保密性</li><li>举例：消息内容的泄漏、流量分析</li></ul></li><li><strong>主动攻击</strong><ul><li>目的：篡改/伪造信息、改变系统的状态和操作</li><li>威胁信息的完整性、可用性和真实性</li><li>举例：伪装、篡改、重放、拒绝服务</li></ul></li></ul></li><li>常见的安全攻击如下：<ul><li><strong>消息内容的泄漏</strong>：消息的内容被泄露或透露给某个非授权的实体</li><li><strong>流量分析</strong>：通过分析通信双方的标识、通信频度、消息格式等信息来达到自己的目的</li><li><strong>篡改</strong>：指对合法用户之间的通信消息进行修改或者改变消息的顺序</li><li><strong>伪装</strong>：指一个实体冒充另一个实体</li><li><strong>重放</strong>：将获得的信息再次发送以期望获得合法用户的利益</li><li><strong>拒绝服务</strong>：指阻止对信息或其他资源的合法访问。</li></ul></li></ul><h2 id="安全机制">安全机制</h2><ul><li>安全机制即<strong>阻止安全攻击及恢复系统的机制</strong>，OSI安全框架将安全机制分为两类：<ul><li><strong>特定安全机制</strong>：<ul><li>描述：在同一时间只针对一种安全服务实施一种技术或软件</li><li>举例：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制和公证</li></ul></li><li><strong>普遍安全机制</strong>：<ul><li>描述：普遍安全机制不能应用到OSI参考模型的任一层上</li><li>举例：可信功能机制、安全标签机制、事件检测机制、审计跟踪机制、安全恢复机制</li></ul></li></ul></li></ul><h2 id="安全目标与安全需求">安全目标与安全需求</h2><h3 id="安全目标">安全目标</h3><ul><li><p>信息安全的目标是指能够满足一个组织或者个人的所有安全需求，通常强调CIA三元组的目标：</p><ul><li>保密性(Confidentiality)</li><li>完整性(Integrity)</li><li>可用性(Availability)</li></ul><p>这三者通常互相矛盾，因此需要在三者中找到一个合适的平衡点。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222163636013.png" alt="CIA三元组"></p></li></ul><h3 id="安全需求">安全需求</h3><ul><li><p>安全需求包括“CIA三元组”+可追溯性+保障，即：</p><ul><li><strong>保密性</strong>(Confidentiality)：确保信息只被授权人访问</li><li><strong>完整性</strong>(Integrity)：保护信息和信息处理方法的准确性和原始性</li><li><strong>可用性</strong>(Availability)：确保授权的用户在需要时可以访问信息</li><li><strong>可追溯性</strong>(Accountability)：确保实体的行动可被跟踪</li><li><strong>保障</strong>(Assurance)：是对安全措施信任的基础，保障是指系统具有足够的能力保护无意的错误以及能够抵抗故意渗透</li></ul></li><li><p>安全需求之间的关系：</p><ul><li><strong>保密性依赖于完整性</strong>，如果系统没有完整性，保密性就失去意义</li><li><strong>完整性也依赖于保密性</strong>，如果不能保证保密性，完整性也将不能成立</li><li>可用性和可追溯性都由保密性和完整性支持</li><li>上面提到的这些安全需求都依赖于<strong>保障</strong></li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240222163933079.png" alt="安全需求之间的关系"></p></li></ul><h2 id="安全服务模型">安全服务模型</h2><ul><li><p>安全服务是<strong>加强数据处理系统和信息传输的安全性</strong>的一种服务，是指信息系统为其应用提供的某些功能或者辅助业务。安全机制是安全服务的基础，安全服务<strong>利用一种或多种安全机制阻止安全攻击</strong>，保证系统或者数据传输有足够的安全性</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222165036250.png" alt="综合安全服务模型"></p></li><li><p>模型主要由三个部分组成：<strong>支撑服务</strong>、<strong>预防服务</strong>和<strong>恢复相关服务</strong></p></li></ul><h3 id="支撑服务">支撑服务</h3><ul><li>支撑服务是<strong>其他服务的基础</strong>，主要包括：<ul><li><strong>鉴别</strong>：它表示能够独特地识别系统中所有实体</li><li><strong>密钥管理</strong>：该服务表示以安全的方式管理密钥。密钥常常用于鉴别一个实体</li><li><strong>安全性管理</strong>：系统的所有安全属性必须进行管理。如安装新的服务，更新已有的服务，监控以保证所提供的服务是可操作的</li><li><strong>系统保护</strong>：系统保护通常表示对技术执行的全面信任</li></ul></li></ul><h3 id="预防服务">预防服务</h3><ul><li>预防服务能够<strong>阻止安全漏洞的发生</strong>，包括：<ul><li><strong>受保护的通信</strong>：该服务是保护实体之间的通信</li><li><strong>认证</strong>：保证通信的实体是它所声称的实体，也就是验证实体身份</li><li><strong>授权</strong>：授权表示允许一个实体对一个给定系统作一些行动，如访问一个资源。</li><li><strong>访问控制</strong>：防止非授权使用资源，即控制谁访问资源，在什么条件下访问，能够访问什么等</li><li><strong>不可否认</strong>：它是与责任相关的服务，指发送方和接受方都不能否认发送和接收到的信息。</li><li><strong>交易隐私</strong>：该服务保护任何数字交易的隐私</li></ul></li></ul><h3 id="检测与恢复服务">检测与恢复服务</h3><ul><li><strong>检测与恢复服务</strong>主要是关于安全漏洞的检测，以及采取行动恢复或者降低这些安全漏洞产生的影响，主要包括：<ul><li><strong>审计</strong>：当安全漏洞被检测到时，审计安全相关的事件是非常重要的。它是在系统发现错误或受到攻击时能定位错误和找到攻击成功的原因，以便对系统进行恢复</li><li><strong>入侵检测</strong>：该服务主要监控危害系统安全的可疑行为，以便尽早地采用额外的安全机制来使系统更安全</li><li><strong>整体检验</strong>：整体检验服务主要是检验系统或者数据仍然是否是完整的</li><li><strong>恢复安全状态</strong>：该服务指当安全漏洞发生时，系统必须能够恢复到安全的状态</li></ul></li></ul><h2 id="各部分间的关系">各部分间的关系</h2><h3 id="目标、需求、服务、机制间的关系">目标、需求、服务、机制间的关系</h3><ul><li>全部安全需求的实现才能达到安全目标</li><li>不同的安全服务的联合能够实现不同的安全需求</li><li>一个安全服务可能是多个安全需求的组成要素</li><li>不同的安全机制联合能够完成不同的安全服务</li><li>一个安全机制也可能是多个安全服务的构成要素</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240222165944087.png" alt="安全目标、安全需求、安全服务和安全机制之间的关系"></p><h3 id="服务与需求的关系">服务与需求的关系</h3><ul><li><p>不是所有的安全需求都强制性地要求所有安全服务</p></li><li><p>安全服务并不是完全可以忽略，因为这些安全服务可能间接地使用</p></li><li><p>可用性依赖于完整性和保密性，保障则与可用性、完整性、保密性和可追溯性相关</p></li><li><p>密钥管理服务影响所有的安全需求</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222171527974.png" alt="安全服务和安全需求之间的关系"></p></li></ul><h2 id="信息安全模型">信息安全模型</h2><h3 id="网络安全模型">网络安全模型</h3><ul><li><p>通信一方要通过传输系统将消息传送给另一方，由于传输系统提供的信息传输通道是不安全的，所以在将敏感消息通过不安全的通道传给接收方之前，一般先要对消息进行安全变换，以得到一个秘密的安全消息，这样可以防止攻击者危害消息的保密性和真实性。安全秘密消息到达接收方后，再经过安全变换的逆变换，这样秘密消息可被恢复成原始的消息。在大多数情况下，对消息的安全变换是基于密码算法来实现的，在变换过程中使用的密码算法不能被攻击者窃取。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222171846556.png" alt="网络安全模型"></p></li><li><p>设计安全服务应包括下面四个方面的内容：</p><ul><li>设计一个恰当的安全变换算法，该算法应有足够强安全性，不会被攻击者有效地攻破</li><li>产生安全变换中所需要的秘密信息，如密钥</li><li>设计分配和共享秘密信息的方法</li><li>指明通信双方使用的协议，该协议利用安全算法和秘密信息实现系统所需要安全服务</li></ul></li></ul><h3 id="计算机系统安全模型">计算机系统安全模型</h3><ul><li><p>计算机系统主要存在两类攻击：外部入侵系统、内部对计算机系统的攻击。</p></li><li><p>网络访问信息系统能保护信息系统不受有害的访问，如阻止黑客试图通过网络访问信息系统，或者阻止有意和恶意的破坏，或者阻止恶意软件利用系统的弱点来影响应用程序的正常运行。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222172722756.png" alt="网络访问信息系统的安全模型"></p></li><li><p>对付有害访问的安全机制分为两类。</p><ul><li>一类是具有门卫功能的守卫者，它包含基于认证的登录过程，只允许授权的实体不越权限地合法使用系统资源；</li><li>另一类称为信息系统内部安全机制，它是用于检测和防止入侵者在突破了守卫者之后对信息系统内部的破坏。</li></ul></li></ul><h2 id="网络安全协议">网络安全协议</h2><ul><li>对TCP/IP参考模型各层分别增加一些安全协议来保证安全，这些安全协议主要分布在最高三层，主要的协议有：<ul><li><strong>网络层</strong>：IPSec</li><li><strong>传输层</strong>：SSL/TLS</li><li><strong>应用层</strong>：SHTTP（Web安全协议）、PGP(电子邮件安全协议)、S/MIME(电子邮件安全协议)、MOSS(电子邮件安全协议)、PEM(电子邮件安全协议)、SSH（远程登录安全协议）、Kerberos(网络认证协议)等</li></ul></li></ul>]]></content>
    
    
    <summary type="html">这篇文章为信息安全技术相关内容的介绍及引入</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="信息安全技术" scheme="https://www.iuoyt.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>算法中常见的排序方法</title>
    <link href="https://www.iuoyt.com/posts/d35732cd.html"/>
    <id>https://www.iuoyt.com/posts/d35732cd.html</id>
    <published>2024-02-17T07:51:03.000Z</published>
    <updated>2024-02-22T10:03:37.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能分析">性能分析</h2><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(\log n)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></td><td style="text-align:center">$O(n^{1.3})$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a></td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr></tbody></table><ul><li><strong>稳定性</strong>：在原序列中，<code>r[i]==r[j]</code>且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是稳定的</li></ul><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序（Bubble-Sort）">冒泡排序（Bubble Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>冒泡排序重复地遍历要排序的列表，一次比较相邻两个元素，如果它们的大小顺序错误则进行交换。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// i表示完成排序数字的个数，每一轮排序确认第i+1大的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 每一轮冒泡排序</span></span><br><span class="line">        <span class="comment">// j控制每次比较的元素位置，每轮排序都会把当前最大的数沉底</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果前一个数大于后一个数，则交换它们</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="快速排序（Quick-Sort）">快速排序（Quick Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(\log n)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>快速排序是一种常用的排序算法，采用了分治的思想。其基本思路是选择一个基准元素，将小于基准的元素放到基准元素的左边，将大于基准的元素放到基准元素的右边，然后对左右两个子序列分别进行递归排序。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  数组的起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数组的结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 若右边界大于等于左边界，即还存在需要排序的元素</span></span><br><span class="line">    <span class="keyword">if</span> (right &gt;= left) &#123;</span><br><span class="line">        <span class="comment">// 选择基准值为左边界元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">basic</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="comment">// 定义左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="comment">// 循环直到左右指针相遇</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 从右向左找到第一个小于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; basic) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左指针小于右指针，将右指针所指的值赋给左指针，并将左指针右移</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从左向右找到第一个大于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; basic) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左指针小于右指针，将左指针所指的值赋给右指针，并将右指针左移</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准值放入指针相遇的位置</span></span><br><span class="line">        arr[i] = basic;</span><br><span class="line">        <span class="comment">// 递归调用，对基准值左侧的子数组进行排序</span></span><br><span class="line">        quickSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归调用，对基准值右侧的子数组进行排序</span></span><br><span class="line">        quickSort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="选择排序">选择排序</h2><h3 id="简单选择排序（Selection-Sort）">简单选择排序（Selection Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>选择排序每次从待排序的数据元素中选择最小（或最大）的一个元素，放到已排好序的数列的最后（或最前），直到所有元素均排好序。</p><p><img src="https://oss.iuoyt.com/img/posts/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// 如果数组长度为0，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外层循环控制每次选择的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 最小索引初始化为i</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 在剩余元素中找到最小值的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 找到最小的数</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换当前位置i和最小值的位置minIndex的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[minIndex];</span><br><span class="line">        array[minIndex] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="堆排序（Heap-Sort）">堆排序（Heap Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>堆排序利用了堆的数据结构，将待排序的序列构建成一个最大堆（大顶堆或最小堆），然后依次取出堆顶元素（最大值或最小值），并调整剩余元素使之满足堆的性质，最终得到一个有序序列。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     数组大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] array, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 构建最大堆（Max Heap）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(array, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从堆中提取元素，逐步将最大值放到数组末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将堆顶元素（当前最大值）与数组末尾元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新构建堆，排除已排序部分</span></span><br><span class="line">        heapify(array, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建最大堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待构建堆的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i   当前节点索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化最大值索引为当前节点索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右子节点索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于当前节点，则更新最大值索引为左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于当前节点，则更新最大值索引为右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值索引不等于当前节点索引，则交换当前节点与最大值节点的值，并继续构建堆</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用，对受影响的子树进行堆构建</span></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="插入排序">插入排序</h2><h3 id="直接插入排序（Insertion-Sort）">直接插入排序（Insertion Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>插入排序将待排序的数组分成已排序和未排序两部分，初始时已排序部分只有一个元素（即数组的第一个元素），然后依次将未排序部分的元素插入到已排序部分的适当位置，直到全部元素都被插入到已排序部分，从而得到一个有序数组。</p><p><img src="https://oss.iuoyt.com/img/posts/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的整数数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 将当前元素插入到已排序部分的适当位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 向右移动已排序部分中大于当前元素的元素，为当前元素腾出插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入当前元素到适当位置</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="希尔排序（Shell-Sort）">希尔排序（Shell Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^{1.3})$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>希尔排序是插入排序的一种改进版本，也称为缩小增量排序。它的基本思想是将待排序的数组按照一定的增量分割成若干个子序列，对每个子序列分别进行插入排序，随着增量逐渐减小，每个子序列包含的元素越来越多，当增量减小至1时，整个数组被分成了一个子序列，此时进行的插入排序就是对整个数组的排序。希尔排序的关键在于选择增量序列，常用的增量序列有希尔增量序列、Hibbard增量序列等。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始增量设为数组长度的一半，逐渐减小增量直至1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对每个子序列进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 插入排序的过程，插入的间隔为当前增量gap</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="更多排序算法">更多排序算法</h2><h3 id="归并排序（Merge-Sort）">归并排序（Merge Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>归并排序将待排序数组分成两个子数组，对每个子数组进行递归地归并排序，然后将已排序的子数组合并成一个有序数组。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用辅助函数进行归并排序</span></span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，对指定范围的数组进行归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  数组的起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数组的结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 计算中间位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对左半部分进行归并排序</span></span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        <span class="comment">// 对右半部分进行归并排序</span></span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 合并左右两部分</span></span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，合并两个已排序的子数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  左子数组的起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid   左子数组的结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右子数组的结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算左右两部分的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> right - mid;</span><br><span class="line">    <span class="comment">// 创建临时数组存放左右两部分的元素</span></span><br><span class="line">    <span class="type">int</span>[] leftPart = <span class="keyword">new</span> <span class="title class_">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>[] rightPart = <span class="keyword">new</span> <span class="title class_">int</span>[n2];</span><br><span class="line">    <span class="comment">// 将元素拷贝到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">        leftPart[i] = arr[left + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n2; ++j) &#123;</span><br><span class="line">        rightPart[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftPart[i] &lt;= rightPart[j]) &#123;</span><br><span class="line">            arr[k] = leftPart[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = rightPart[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余元素拷贝到数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = leftPart[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = rightPart[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基数排序（Radix-Sort）">基数排序（Radix Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>基数排序按照低位先排序，然后收集；再按照高位排序，然后再次收集；依次类推，直到最高位。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数组中的最大值，用于确定排序的轮数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每一位进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">        countingSort(arr, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，获取数组中的最大值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，计数排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exp 当前位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> exp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j : arr) &#123;</span><br><span class="line">        count[(j / exp) % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将计数数组转换为前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前遍历原数组，根据计数数组将元素放到正确的位置上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        output[count[(arr[i] / exp) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[(arr[i] / exp) % <span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排好序的数组复制回原数组</span></span><br><span class="line">    System.arraycopy(output, <span class="number">0</span>, arr, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="桶排序（Bucket-Sort）">桶排序（Bucket Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>桶排序将待排序数组分割成若干个桶，然后对每个桶中的元素进行排序，最后按照顺序合并每个桶得到有序数组。</p><p><img src="https://oss.iuoyt.com/img/posts/%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="桶排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最大值和最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算桶的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> (max - min) / n + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (num - min) / n;</span><br><span class="line">        buckets.get(index).add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个桶中的元素进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        Collections.sort(bucket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将各个桶中的元素按照顺序依次取出，组成有序序列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : bucket) &#123;</span><br><span class="line">            arr[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">一些在算法中经常见到的使用的排序方法。</summary>
    
    
    
    <category term="算法" scheme="https://www.iuoyt.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://www.iuoyt.com/tags/Java/"/>
    
    <category term="算法" scheme="https://www.iuoyt.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://www.iuoyt.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Stable Diffusion】如何借助AI完成绘画？</title>
    <link href="https://www.iuoyt.com/posts/731a4ede.html"/>
    <id>https://www.iuoyt.com/posts/731a4ede.html</id>
    <published>2024-01-28T02:53:44.000Z</published>
    <updated>2024-02-01T05:29:57.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AI绘画概述">AI绘画概述</h2><h3 id="绘图过程（Diffusion扩散）">绘图过程（Diffusion扩散）</h3><ol><li><p>条件输入</p><p>常用的文生图（txt2img）中首先要做的就是输入提示词了，这些输入的提示词会在SD WebUI内置的文本编码器（TextEncoder）中被编码为数字，使其可以被AI看懂，然后送入Text Transformer得到生图条件。</p></li><li><p>随机种子</p><p>开始生成前会随机获得一串数字，用于形成一幅随机的噪声图，作为AI绘图的“画板”。如下是一张256×256的RGB随机噪声图。</p><p><img src="https://oss.iuoyt.com/img/posts/20210520111319319.jpg" alt="随机噪声图"></p></li><li><p>图像生成（去噪）</p><p>在潜空间（Latent Space）中，AI会根据输入条件对噪声图进行去噪，即“采样”，经过多次的反复去噪，最后形成一张压缩过的“成品图”。</p><p><img src="https://oss.iuoyt.com/img/posts/92cd2b8f466bd891f92dd7ac4e8d33a57b1c42ca.png@1256w_170h_!web-article-pic.avif" alt="图像采样"></p></li><li><p>变分自编码器（VAE）</p><p>这一步是将潜空间中被压缩的“成品图”扩大成为我们可以看到的正常图片</p></li></ol><blockquote><p><img src="https://oss.iuoyt.com/img/posts/e541253f8201748cffeb3850ffeb2a4bbe866f7f.png@1256w_706h_!web-article-pic.avif" alt="img"></p><p>图源：<a href="https://www.bilibili.com/read/cv21564981">秋葉aaaki - Bilibili</a></p></blockquote><h3 id="Stable-Diffusion">Stable Diffusion</h3><p>目前市面上已经有了许多的用于AI绘画的平台，例如DALL·E、MidJourney、NovelAI，2022年8月，Stable Diffusion诞生了，无需极为强劲的性能就可以运行在日常使用的电脑上。并且由于其全面开源的特性，你可以在自己的电脑上直接完成部署，以及免费、不限量地生成AI绘画图片。</p><p>AUTOMATIC1111将开源的Stable Diffusion做成了一款可以在浏览器中直接操作的“应用”，即<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">Stable Diffusion web UI</a>，借助它，可以将原本繁琐的代码层面的参数调校集成到一个Web页面中，通过WebUI，还可以使用到许多已发布的拓展插件。</p><h3 id="安装">安装</h3><p>B站的<a href="https://space.bilibili.com/12566101">秋葉aaaki</a>老师将Stable Diffusion WebUI以及其所需环境都合并为了整合包，无需安装git、python、cuda等任何内容，无需任何配置，解压就可以使用，安装方式详见视频：<a href="https://www.bilibili.com/video/BV1iM4y1y7oA">秋葉aaaki - Stable Diffusion整合包</a></p><p>安装完成WebUI本体，以及后续可能会用到的模型等，占用空间可能达到甚至150-200G，所以要注意存放位置哦。</p><h2 id="一些概念">一些概念</h2><h3 id="模型（Model）">模型（Model）</h3><p>模型是AI在绘画过程中的参考，是由大量的图像经由AI深度学习训练得出的成果。借助模型，可以让AI完成某一类效果的绘制实现，是AI绘图过程中极其重要的一个部分。文件大小一般在几个G不等，文件后缀为<code>.safetensors</code>、<code>.ckpt</code>。</p><p>国内外有许多优秀的模型站点，诸如<a href="https://huggingface.co/">Hugging Face</a>、<a href="https://civitai.com/">Civitai</a>，都是囊括了大量模型的宝库。</p><blockquote><p>一些常见实用模型：</p><ul><li><p>二次元风格</p><p>关键词：illustration, painting, sketch, drawing, painting, comic, anime, catoon</p><ul><li><a href="https://civitai.com/models/9409">Anything</a></li><li><a href="https://civitai.com/models/1274">Dreamlike Diffusion</a></li><li><a href="https://civitai.com/models/4468">Counterfeit</a></li><li><a href="https://civitai.com/models/4437">AbyssOrangeMix2</a></li></ul></li><li><p>2.5D风格</p><p>关键词：photography, photo, realistic, photorealistic, RAW photo</p><ul><li><a href="https://civitai.com/models/10415">国风3 GuoFeng3</a></li><li><a href="https://civitai.com/models/3816/protogen-x53-photorealism-official-release">Protogen</a></li><li><a href="https://civitai.com/models/10028">NeverEnding Dream (NED)</a></li></ul></li><li><p>真实系风格</p><p>关键词：3D, render, chibi, digital art, concept art, {realistic}</p><ul><li><a href="https://civitai.com/models/9052">LOFI</a></li><li><a href="https://civitai.com/models/5585/deliberate-for-invoke">Deliberate for Invoke</a></li><li><a href="https://civitai.com/models/4201">Realistic Vision</a></li></ul></li><li><p>其他</p><ul><li><a href="https://civitai.com/models/50696">QteaMix 通用Q版模型</a></li></ul></li></ul></blockquote><h3 id="词嵌入（Embeddings）">词嵌入（Embeddings）</h3><p>也写作Textual Inversion（文本倒置），作用是给AI解释部分字、词的含义。这些内容可能是难以理解的多词组合，或者是特定形象的呈现描述，可以理解为用已知的内容描述未知的内容，或者一个字典的书签，一个数据的指针。文件大小通常在20~100K，文件后缀为<code>.pt</code>、<code>.safetensors</code>。</p><p>比如解决AI不会画手的问题，可以使用这些Embeddings处理：</p><ul><li><a href="https://civitai.com/models/7808">EasyNegative</a>（二次元）</li><li><a href="https://civitai.com/models/55700">bad_prompt Negative</a>（二次元）</li><li><a href="https://civitai.com/models/4629">Deep Negative</a>（真人）</li></ul><h3 id="低秩适应模型（LoRA）">低秩适应模型（LoRA）</h3><p>LoRA（Low-Rank Adaptation Models），用于向AI传递、描述一个特征准确、主体清晰的形象，可以理解为一张彩页，上面详细记载了某个特定呈现的细节、特点。文件大小通常在200M以内，文件后缀为<code>.safetensors</code>。</p><p>触发LoRA的方法：<code>&lt;lora:LoRA名称&gt;</code>，设置权重在0.5-0.8可以保留确切特征但减弱对画面风格的影响。某些LoRA还提供了特定的提示词以强化调用的效果，可以一并写在提示词内。</p><h3 id="超网络（Hypernetwork）">超网络（Hypernetwork）</h3><p>与LoRa类似，HyperNetwork一般用于改善生成图像的整体风格（画风），大小在200M以内，文件后缀为<code>.pt</code>。Hypernetwork与LoRA很像，它们都很小且仅修改cross-attention模块，区别在于后者是通过改变权重修改，而Hypernetwork则是通过插入额外的网络改动cross-attention模块。</p><h2 id="书写提示词">书写提示词</h2><ul><li>提示词（Prompt），可以让AI知道你希望它完成什么内容。尽管称为AI绘画，但它其实无法理解你与它描述的自然语言是什么意思，因此，需要给AI提供的内容则需要通过它可以理解的方式。</li><li>在SD中，提示词分为两个部分：正向提示词与反向提示词，顾名思义，AI会按照正向提示词去完成创作，但会尽量避免反向提示词中出现的内容。</li><li>提示词需要使用英文书写，并且是以词组构成，因此并非像是与人描述一样使用长的复杂句。词组之间使用半角逗号分隔。</li></ul><h3 id="正向提示词">正向提示词</h3><blockquote><p>注：以下内容均整理自<a href="https://www.bilibili.com/video/BV12X4y1r7QB/?p=2">20分钟搞懂Prompt与参数设置，你的AI绘画“咒语”学明白了吗？</a></p></blockquote><h4 id="内容型提示词">内容型提示词</h4><ol><li><p>人物及主题特征</p><ul><li><p>服饰穿搭：white dress</p></li><li><p>发型发色：blonde hair, long hair</p></li><li><p>五官特点：small eyes, big mouth</p></li><li><p>面部表情：smiling</p></li><li><p>肢体动作：stretching arms</p></li></ul></li><li><p>场景特征</p><ul><li><p>室内/室外：indoor / outdoor</p></li><li><p>大场景：forest, city, street</p></li><li><p>小细节：tree, bush, white flower</p></li></ul></li><li><p>环境光照</p><ul><li><p>白天/黑夜：day / night</p></li><li><p>特定时段：morning, sunset</p></li><li><p>光环境：sunlight, bright, dark</p></li><li><p>天空：blue sky, starry sky</p></li></ul></li><li><p>画幅视角</p><ul><li><p>距离：close-up, distant</p></li><li><p>人物比例：fullbody, upper body</p></li><li><p>观察视角：from above,view of back</p></li><li><p>镜头类型：wide angle, Sony A7 III</p></li></ul></li><li><p>其他画面要素</p></li><li><p>通用内容：</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SFW</span>, (masterpiece:<span class="number">1</span>,<span class="number">2</span>), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:<span class="number">1</span>.<span class="number">2</span>),</span><br></pre></td></tr></table></figure></li></ol><h4 id="标准化提示词">标准化提示词</h4><ol><li><p>画质</p><ul><li><p>通用高画质：best quality, ultra-detailed, masterpiece, hires, 8k</p></li><li><p>特定高分辨率类型：extremely detailed CG unity 8k wallpaper（超精细的8KUnity游戏CG），unreal engine rendered（虚幻引擎渲染）</p></li></ul></li><li><p>画风提示词</p><ul><li><p>插画风：llustration, painting, paintrush</p></li><li><p>二次元：anime, comic, game CG</p></li><li><p>写实系：photorealistic, realistic, photograph</p></li></ul></li><li><p>其他特殊要求</p></li></ol><h3 id="反向提示词">反向提示词</h3><blockquote><p>通用内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSFW</span>, (worst quality:<span class="number">2</span>), (low quality:<span class="number">2</span>), (normal quality:<span class="number">2</span>), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:<span class="number">1</span>.<span class="number">331</span>), (duplicate:<span class="number">1</span>.<span class="number">331</span>), (morbid:<span class="number">1</span>.<span class="number">21</span>), (mutilated:<span class="number">1</span>.<span class="number">21</span>), (tranny:<span class="number">1</span>.<span class="number">331</span>), mutated hands, (poorly drawn hands:<span class="number">1</span>.<span class="number">5</span>), blurry, (bad anatomy:<span class="number">1</span>.<span class="number">21</span>), (bad proportions:<span class="number">1</span>.<span class="number">331</span>), extra limbs, (disfigured:<span class="number">1</span>.<span class="number">331</span>), (missing arms:<span class="number">1</span>.<span class="number">331</span>), (extra legs:<span class="number">1</span>.<span class="number">331</span>), (fused fingers:<span class="number">1</span>.<span class="number">61051</span>), (too many fingers:<span class="number">1</span>.<span class="number">61051</span>), (unclear eyes:<span class="number">1</span>.<span class="number">331</span>), lowers, bad hands, missing fingers, extra digit,bad hands, missing fingers, (((extra arms and legs))),</span><br></pre></td></tr></table></figure></blockquote><ol><li><strong>图像质量描述：</strong><ul><li>Worst quality: 最差质量</li><li>Low quality: 低质量</li><li>Normal quality: 正常质量</li><li>Lowres: 低分辨率</li><li>Blurry: 模糊</li><li>Unclear eyes: 眼睛不清晰</li></ul></li><li><strong>皮肤瑕疵：</strong><ul><li>Skin spots: 皮肤斑点</li><li>Acnes: 痘痘</li><li>Skin blemishes: 皮肤瑕疵</li><li>Age spot: 老年斑</li></ul></li><li><strong>审美负面描述：</strong><ul><li>Ugly: 丑陋</li><li>Morbid: 病态</li><li>Mutilated: 残缺</li><li>Tranny: 涉及性别问题（潜在冒犯性）</li></ul></li><li><strong>绘画技巧问题：</strong><ul><li>Duplicate: 重复</li><li>Poorly drawn hands: 手绘不好</li><li>Bad anatomy: 解剖结构不准确</li><li>Bad proportions: 比例不准确</li><li>Extra limbs: 多余肢体</li><li>Disfigured: 形象被扭曲</li><li>Missing arms: 缺失手臂</li><li>Extra legs: 多余腿</li><li>Fused fingers: 手指融合</li><li>Too many fingers: 手指过多</li><li>Missing fingers: 缺失手指</li><li>Extra digit: 额外数字或手指</li><li>Bad hands: 手部描绘不好</li><li>Extra arms and legs: 额外手臂和腿</li></ul></li></ol><h3 id="权重配置">权重配置</h3><h4 id="基础设置">基础设置</h4><ul><li>圆括号<code>(prompt)</code>：×1.1（可叠加，每层叠加都 ×1.1）</li><li>括号+数字<code>(prompt:1.5)</code>：指定权重倍数</li><li>大括号<code>&#123;prompt&#125;</code>：×1.05（可叠加，每层叠加都 ×1.05）</li><li>中括号<code>[prompt]</code>：×0.9（可叠加，每层叠加都 ×0.9）</li></ul><h4 id="进阶设置">进阶设置</h4><ul><li><p>混合<code> a|b</code>：混合两个描述同一对象的提示词要素</p><p>【例】<code>white|yellow flower</code>：生成黄色和白色混合的花</p></li><li><p>迁移<code>[|]</code>：连续生成具有多个不同特征的对象，不断迁移</p><p>【例】<code>[white|red|blue] flower</code>：先生成白花，再生成红花，再生成蓝花。</p></li><li><p>迭代<code>(::)</code>：与采样进程关联，一定阶段以后再生成特定对象。</p><p>【例】<code>(white flower:bush:0.8)</code>：进程到达80%（0.8）之前生成白花，80%之后再生成灌木。</p><p>【例】<code>(white flower::0.8)</code>：进程到达80%（0.8）之前生成白花，80%之后删除该提示词。</p></li></ul><h2 id="生图配置">生图配置</h2><h3 id="采样迭代步数（Steps）">采样迭代步数（Steps）</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128162027645.png" alt="迭代步数"></p><p>如前面所说，AI在进行图像创作的过程中是经过了多次迭代的，这里设置的步数即是AI生图的迭代次数，一般设置在20-40，不同的模型、LoRA等一般有不同的推荐步数。通常迭代次数越多，产出的图像就会越清晰/细致，但生图时间也会更长。</p><h3 id="采样方法（Sampler）">采样方法（Sampler）</h3><p>采样方法就是AI生成图像时的特定算法，同样的种子和提示词在不同的采样方法下生出的图会也出现不同，通常模型、LoRA的作者会提供建议使用的采样方法，以达到可以实现的最好效果。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240128145326350.png" alt="采样方法"></p><ul><li>Euler系列（欧拉方法）：<ul><li>Euler：中规中矩、简单直接、不易出错</li><li>Euler a：Euler的前代，多样性较高</li><li>LMS：Euler的衍生版本，但容易出现色块</li></ul></li><li>Heun：Eular的改进算法，在每一步中预测两次噪声，速度比Eular慢一倍</li><li>DPM系列：<ul><li>DPM fast：细节少，质量较低</li><li>DPM adaptive：无视迭代步数，质量较高但时间较长</li><li>DPM2：DPM的2代算法，质量比1代高但速度很慢，可以使用1代增加迭代步数替代</li><li>后缀：<ul><li>a：前代算法，祖先采样器，每一步都会产生新的噪点，生成更多样</li><li>2S：单步算法</li><li>2M：二阶多步采样算法，相当于2S的进阶</li><li>3M：与2M类似，但需要更多的迭代步数，效果会更好一些</li><li>SDE：将OED（常微分方程）求解器更换为SDE（随机微分方程）的版本</li><li>Karras：Karras算法，噪点收敛速度不断降低（收敛步长缩短），可以在更高迭代数量下提高图像质量</li><li>Huen：Euler改进算法，质量更好，但速度慢</li><li>Exponential：画面更柔和，但细节更少</li></ul></li></ul></li><li>UniPC：2023年新推出的算法，10步以内即可生成高质量图像</li></ul><p>总结：</p><ol><li>简单快捷：Eular、Heun</li><li>性价比高（兼顾质量和速度）：DPM++ 2M Karras (20 -30步) 、UNIPC （15-25步）</li><li>质量较高：DPM++ SDE Karras</li><li>稳定复现：不选后缀a / SDE，反之则追求多样性</li></ol><h3 id="提示词相关性（CFG-Scale）">提示词相关性（CFG Scale）</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161245013.png" alt="提示词相关性"></p><p>引导AI按照提示词绘制的程度，推荐7~12，如果过高会出现变形。</p><h3 id="种子（Seed）">种子（Seed）</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161429602.png" alt="随机种子"></p><p>控制噪声图的产生，以控制画面内容一致性</p><h3 id="出图尺寸">出图尺寸</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128160404946.png" alt="出图分辨率"></p><p>即生成图像的分辨率，默认为512×512，对设备（显存）要求较高。由于模型训练数据都比较小，因此将尺寸设置过高会出现多人的情况，最高在1000上下即可。这样生成的图像较为模糊，可以通过高清修复、后期处理、图生图等方式放大图像。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161005363.png" alt="高清修复"></p><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161040438.png" alt="后期处理"></p><h3 id="生成批次">生成批次</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161630533.png" alt="生成批次"></p><p>AI绘画具有不确定性，可以让AI在一组提示词下一次性生成多张图片。（来一发十连抽）</p><blockquote><h2 id="参考资料">参考资料</h2><ol><li><a href="https://www.bilibili.com/read/cv21564981">【AI绘画】大魔导书：AI 是如何绘画的？Stable Diffusion 原理全解（一）</a></li><li><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">What are Diffusion Models?</a></li><li><a href="https://space.bilibili.com/1814756990/channel/collectiondetail?sid=1285674">合集·B站第一套Stable Diffusion系统课程，来了！</a></li><li><a href="https://www.bilibili.com/read/cv26536525/">Stable Diffusion 30种采样方法全解析</a></li><li><a href="https://blog.csdn.net/lizhong2008/article/details/132278253">AI 绘画Stable Diffusion 研究（八）sd采样方法详解_sd采样方法有什么区别-CSDN博客</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">Stable Diffusion是一款开源AI绘画工具，这篇文章介绍了部分AI绘画的原理和概念。</summary>
    
    
    
    <category term="AI绘画" scheme="https://www.iuoyt.com/categories/AI%E7%BB%98%E7%94%BB/"/>
    
    
    <category term="Stable Diffusion" scheme="https://www.iuoyt.com/tags/Stable-Diffusion/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-行为型模式</title>
    <link href="https://www.iuoyt.com/posts/3194e4c1.html"/>
    <id>https://www.iuoyt.com/posts/3194e4c1.html</id>
    <published>2023-12-29T06:06:54.000Z</published>
    <updated>2023-12-29T10:03:50.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a></li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a> 📍当前位置</li></ol></blockquote><h2 id="职责链模式-Chain-of-Responsibility">职责链模式(Chain of Responsibility)</h2><div class="tip "><p><strong>定义</strong>：</p><p>避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。</p></div><h3 id="模式结构">模式结构</h3><h4 id="结构图">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155049439.png" alt="image-20231229155049439"></p><h4 id="实现代码">实现代码</h4><ul><li><p>抽象处理者（Handler）</p><p>它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。每一个处理者的下家还是一个处理者，故在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor）作为其对下家的引用，通过该引用处理者可以连成一条链。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">//维持对下家的引用</span></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor=successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体处理者（ConcreteHandler）</p><p>它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中的下一个对象，以便请求的转发。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (请求满足条件) &#123;</span><br><span class="line">            <span class="comment">//处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//转发请求</span></span><br><span class="line">            <span class="built_in">this</span>.successor.handleRequest(request); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例">应用实例</h3><blockquote><p>某企业的SCM(供应链管理)系统中包含一个采购审批子系统。该企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元及以上的采购单就需要开董事会讨论决定。如下图所示：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155356119.png" alt="采购单分级审批示意图"></p><p>现使用职责链模式设计并实现该系统。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155417392.png" alt="image-20231229155417392"></p><ul><li>抽象处理者（抽象传递者）：<code>PurchaseRequest</code></li><li>具体处理者（具体传递者）：<code>Director</code>、<code>VicePresident</code>、<code>President</code>、<code>Congress</code></li><li>请求类：<code>PurchaseRequest</code></li></ul><h3 id="特点及使用环境">特点及使用环境</h3><h4 id="优点">优点</h4><ol><li>使得一个对象无须知道是其他哪一个对象处理其请求，降低了系统的耦合度</li><li>可简化对象之间的相互连接</li><li>给对象职责的分配带来更多的灵活性</li><li>增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可</li></ol><h4 id="缺点">缺点</h4><ol><li>不能保证请求一定会被处理</li><li>对于比较长的职责链，系统性能将受到一定影响，在进行代码调试时不太方便</li><li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环</li></ol><h4 id="适用环境">适用环境</h4><ol><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li><li>可动态指定一组对象处理请求</li></ol><h2 id="命令模式-Command">命令模式(Command)</h2><div class="tip "><p><strong>定义</strong>：</p><p>将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155739538.png" alt="image-20231229155739538"></p><h3 id="模式结构-2">模式结构</h3><h4 id="结构图-2">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155808876.png" alt="image-20231229155808876"></p><h4 id="实现代码-2">实现代码</h4><ul><li><p>抽象命令类（Command）</p><p>抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体命令类（ConcreteCommand）</p><p>具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现<code>execute()</code>方法时将调用接收者对象的相关操作(Action)。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver; <span class="comment">//维持一个对请求接收者对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action(); <span class="comment">//调用请求接收者的业务处理方法action()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用者（Invoker）</p><p>调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的<code>execute()</code>方法，从而实现间接调用请求接收者的相关操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设值注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务方法，用于调用命令类的execute()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收者（Receiver）</p><p>接收者执行与请求相关的操作，具体实现对请求的业务处理。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-2">应用实例</h3><blockquote><p>为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton可以用于退出系统（由SystemExitClass类来实现），也可以用于显示帮助文档（由DisplayHelpClass类来实现）。</p><p>用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229160222136.png" alt="image-20231229160222136"></p><ul><li>请求调用者：<code>FunctionButton</code></li><li>请求接收者：<code>SystemExitClass</code>、<code>DisplayHelpClass</code></li><li>抽象命令类：<code>Command</code></li><li>具体命令者：<code>ExitCommand</code>、<code>HelpCommand</code></li></ul><h3 id="模式变化">模式变化</h3><h4 id="实现命令队列">实现命令队列</h4><ul><li>实现动机：<ul><li>当一个请求发送者发送一个请求时，有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理</li><li>增加一个CommandQueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者</li><li>批处理</li></ul></li></ul><h4 id="记录请求日志">记录请求日志</h4><ul><li><p>实现动机：</p><p>将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中</p><ul><li>为系统提供一种恢复机制</li><li>可以用于实现批处理</li><li>防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行</li></ul></li></ul><h4 id="实现撤销操作">实现撤销操作</h4><ul><li>可以通过对命令类进行修改使得系统支持撤销(Undo)操作和恢复(Redo)操作</li></ul><h4 id="宏命令">宏命令</h4><ul><li>宏命令又称为组合命令，它是组合模式和命令模式联用的产物</li><li>宏命令是一个具体命令类，它拥有一个集合，在该集合中包含了对其他命令对象的引用</li><li>当调用宏命令的<code>execute()</code>方法时，将递归调用它所包含的每个成员命令的<code>execute()</code>方法。一个宏命令的成员可以是简单命令，还可以继续是宏命令</li><li>执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理</li></ul><h3 id="特点及使用环境-2">特点及使用环境</h3><h4 id="优点-2">优点</h4><ol><li>降低系统的耦合度</li><li>新的命令可以很容易地加入到系统中，符合开闭原则</li><li>可以比较容易地设计一个命令队列或宏命令（组合命令）</li><li>为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案</li></ol><h4 id="缺点-2">缺点</h4><ol><li>使用命令模式可能会导致某些系统有过多的具体命令类（针对每一个对请求接收者的调用操作都需要设计一个具体命令类）</li></ol><h4 id="适用环境-2">适用环境</h4><ol><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作</li><li>系统需要将一组操作组合在一起形成宏命令</li></ol><h2 id="解释器模式-Interpreter">解释器模式(Interpreter)</h2><div class="tip "><p><strong>定义</strong>：</p><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></div><h3 id="模式结构-3">模式结构</h3><h4 id="结构图-3">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229175727479.png" alt="image-20231229175727479"></p><h4 id="实现代码-3">实现代码</h4><ul><li><p>抽象表达式（AbstractExpression）</p><p>在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>终结符表达式（TerminalExpression）</p><p>终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminalExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;</span><br><span class="line">        <span class="comment">//终结符表达式的解释操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非终结符表达式（NonterminalExpression）</p><p>非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式完成。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NonterminalExpression</span><span class="params">(AbstractExpression left,AbstractExpression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left=left;</span><br><span class="line">        <span class="built_in">this</span>.right=right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;</span><br><span class="line">        <span class="comment">//递归调用每一个组成部分的interpret()方法</span></span><br><span class="line">        <span class="comment">//在递归调用时指定组成部分的连接方式，即非终结符的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环境类（Context）</p><ul><li>用于存储一些全局信息，一般包含一个HashMap或ArrayList等类型的集合对象（也可以直接由HashMap等集合类充当环境类），存储一系列公共信息，例如变量名与值的映射关系(key/value)等，用于在执行具体的解释操作时从中获取相关信息</li><li>可以在环境类中增加一些所有表达式解释器都共有的功能，以减轻解释器的职责</li><li>当系统无须提供全局公共信息时可以省略环境类，根据实际情况决定是否需要环境类</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="comment">//往环境类中设值</span></span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">lookup</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">//获取存储在环境类中的值</span></span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-3">应用实例</h3><blockquote><p>某软件公司要开发一套机器人控制程序，在该机器人控制程序中包含一些简单的英文控制指令，每一个指令对应一个表达式(expression)，该表达式可以是简单表达式也可以是复合表达式。每一个简单表达式由移动方向(direction)，移动方式(action)和移动距离(distance)三部分组成，其中，移动方向包括向上(up)、向下(down)、向左(left)、向右(right)；移动方式包括移动(move)和快速移动(run)；移动距离为一个正整数。两个表达式之间可以通过与(and)连接，形成复合(composite)表达式。</p><p>用户通过对图形化的设置界面进行操作可以创建一个机器人控制指令，机器人在收到指令后将按照指令的设置进行移动，例如输入控制指令“up move 5”将“向上移动5个单位”；输入控制指令“down run 10 and left move 20”将“向下快速移动10个单位再向左移动20个单位”。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229180138141.png" alt="image-20231229180138141"></p><ul><li>抽象表达式角色：<code>AbstractNode</code></li><li>终结符表达式角色：<code>DirectionNode</code>、<code>ActionNode</code>、<code>DistanceNode</code></li><li>非终结符表达式角色：<code>AndNode</code>、<code>SentenceNode</code></li></ul><h3 id="特点及使用环境-3">特点及使用环境</h3><h4 id="优点-3">优点</h4><ol><li>易于改变和扩展文法</li><li>可以方便地实现一个简单的语言</li><li>实现文法较为容易（有自动生成工具）</li><li>增加新的解释表达式较为方便</li></ol><h4 id="缺点-3">缺点</h4><ol><li>对于复杂文法难以维护</li><li>执行效率较低</li></ol><h4 id="适用环境-3">适用环境</h4><ol><li>可以将一个需要解释执行的语言中的句子表示为一棵抽象语法树</li><li>一些重复出现的问题可以用一种简单的语言来进行表达</li><li>一个语言的文法较为简单</li><li>执行效率不是关键问题</li></ol><h2 id="迭代器模式★-Iterator">迭代器模式★(Iterator)</h2><div class="tip "><p><strong>定义</strong>：</p><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示。</p></div><h3 id="模式结构-4">模式结构</h3><h4 id="结构图-4">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229140926871.png" alt="image-20231229140926871"></p><h4 id="实现代码-4">实现代码</h4><ul><li><p>抽象迭代器（Iterator）</p><p>它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如用于获取第一个元素的<code>first()</code>方法、用于访问下一个元素的<code>next()</code>方法、用于判断是否还有下一个元素的<code>hasNext()</code>方法、用于获取当前元素的<code>currentItem()</code>方法等， 在具体迭代器中将实现这些方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">//将游标指向第一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//将游标指向下一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//判断是否存在下一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取游标指向的当前元素</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体迭代器（ConcreteIterator）</p><p>它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时游标通常是一个表示位置的非负整数。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据</span></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate objects; </span><br><span class="line">    <span class="comment">//定义一个游标，用于记录当前访问位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(ConcreteAggregate objects)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.objects=objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象聚合类（Aggregate）</p><p>它用于存储和管理元素对象，声明一个<code>createlterator() </code>方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    Iterator <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体聚合类（ConcreteAggregate）</p><p>它是抽象聚合类的子类，实现了在抽象聚合类中声明的<code>createlterator()</code>方法，该方法返回一个与该具体聚合类对应的具体迭代器 ConcreteIterator 实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-4">应用实例</h3><blockquote><p>某软件公司为某商场开发了一套销售管理系统，在对该系统进行分析和设计时，开发人员发现经常需要对系统中的商品数据、客户数据等进行遍历，为了复用这些遍历代码，开发人员设计了一个抽象的数据集合类AbstractObjectList，将存储商品和客户等数据的类作为其子类，AbstractObjectList类结构如下图所示：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229142811224.png" alt="AbstractObjectList类结构图"></p><p>在图中，List类型的对象objects用于存储数据，其方法与说明如下表所示：</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>方法说明</strong></th></tr></thead><tbody><tr><td>AbstractObjectList()</td><td>构造方法，用于给objects对象赋值</td></tr><tr><td>addObject()</td><td>增加元素</td></tr><tr><td>removeObject()</td><td>删除元素</td></tr><tr><td>getObjects()</td><td>获取所有元素</td></tr><tr><td>next()</td><td>移至下一个元素</td></tr><tr><td>isLast()</td><td>判断当前元素是否是最后一个元素</td></tr><tr><td>previous()</td><td>移至上一个元素</td></tr><tr><td>isFirst()</td><td>判断当前元素是否是第一个元素</td></tr><tr><td>getNextItem()</td><td>获取下一个元素</td></tr><tr><td>getPreviousItem()</td><td>获取上一个元素</td></tr></tbody></table><p>AbstractObjectList类的子类ProductList和CustomerList分别用于存储商品数据和客户数据。</p><p>通过分析，发现AbstractObjectList类的职责非常重，它既负责存储和管理数据，又负责遍历数据，违背了单一职责原则，实现代码将非常复杂。因此，开发人员决定使用迭代器模式对AbstractObjectList类进行重构，将负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，还可以给不同的具体数据集合类提供不同的遍历方式。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229143108928.png" alt="image-20231229143108928"></p><ul><li>抽象聚合类：<code>AbstractObjectList</code></li><li>具体聚合类：<code>ProductList</code></li><li>抽象迭代器：<code>AbstractIterator</code></li><li>具体迭代器：<code>ProductIterator</code></li></ul><h3 id="特点及使用环境-4">特点及使用环境</h3><h4 id="优点-4">优点</h4><ol><li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式</li><li>简化了聚合类</li><li>由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则</li></ol><h4 id="缺点-4">缺点</h4><ol><li>在增加新的聚合类时需要对应地增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是一件很容易的事情</li></ol><h4 id="适用环境-4">适用环境</h4><ol><li>访问一个聚合对象的内容而无须暴露它的内部表示</li><li>需要为一个聚合对象提供多种遍历方式</li><li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口</li></ol><h2 id="中介者模式✲">中介者模式✲</h2><h2 id="备忘录模式✲">备忘录模式✲</h2><h2 id="观察者模式★-Observer">观察者模式★(Observer)</h2><div class="tip "><p><strong>定义</strong>：</p><p>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。</p></div><h3 id="模式结构-5">模式结构</h3><h4 id="结构图-5">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229143706930.png" alt="image-20231229143706930"></p><h4 id="实现代码-5">实现代码</h4><ul><li><p>目标（Subject）</p><p>目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法<code>notify()</code>。目标类可以是接口，也可以是抽象类或具体类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个观察者集合用于存储所有观察者对象</span></span><br><span class="line">    <span class="keyword">protected</span> ArrayList observers&lt;Observer&gt; = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//注册方法，用于向观察者集合中增加一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注销方法，用于在观察者集合中删除一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象通知方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体目标（ConcreteSubject）</p><p>具体目标是目标类的子类，它通常包含有经常发生改变的数据，当它的状态发生改变时将向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有）。如果无须扩展目标类，则具体目标类可以省略。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//实现通知方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//遍历观察者集合，调用每一个观察者的响应方法</span></span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers) &#123;</span><br><span class="line">            ((Observer)obs).update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>观察者（Observer）</p><p>观察者将对观察目标的改变作出反应，观察者一般定义为接口，该接口声明了更新数据的方法<code>update()</code>，因此又称为抽象观察者。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//声明响应方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体观察者（ConcreteObserver）</p><p>在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的<code>update()</code>方法。通常在实现时可以调用具体目标类的<code>attach()</code>方法将自己添加到目标类的集合中或通过<code>detach()</code>方法将自己从目标类的集合中 删除。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//实现响应方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体响应代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-5">应用实例</h3><blockquote><p>在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。</p><p>现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229144428657.png" alt="image-20231229144428657"></p><ul><li>抽象目标类：<code>AllyCOntrolCenter</code></li><li>具体目标类：<code>ConcreteAllyControlCenter</code></li><li>抽象观察者：<code>Observer</code></li><li>具体观察者：<code>Player</code></li></ul><h3 id="特点及使用环境-5">特点及使用环境</h3><h4 id="优点-5">优点</h4><ol><li>可以实现表示层和数据逻辑层的分离</li><li>在观察目标和观察者之间建立一个抽象的耦合</li><li>支持广播通信，简化了一对多系统设计的难度</li><li>符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便</li></ol><h4 id="缺点-5">缺点</h4><ol><li>将所有的观察者都通知到会花费很多时间</li><li>如果存在循环依赖时可能导致系统崩溃</li><li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化</li></ol><h4 id="适用环境-5">适用环境</h4><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用</li><li>一个对象的改变将导致一个或多个其他对象发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁</li><li>需要在系统中创建一个触发链</li></ol><h2 id="状态模式☒">状态模式☒</h2><h2 id="策略模式☒">策略模式☒</h2><h2 id="模板方法模式☒">模板方法模式☒</h2><h2 id="访问者模式✲">访问者模式✲</h2>]]></content>
    
    
    <summary type="html">行为型模式关注对象之间的责任分配和通信。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-结构型模式</title>
    <link href="https://www.iuoyt.com/posts/b6c6dbc4.html"/>
    <id>https://www.iuoyt.com/posts/b6c6dbc4.html</id>
    <published>2023-12-29T04:51:37.000Z</published>
    <updated>2024-02-22T10:03:07.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a> 📍当前位置</li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a></li></ol></blockquote><h2 id="结构型模式">结构型模式</h2><ul><li>结构型模式关注如何将现有类或对象组织在一起形成更加强大的结构。</li><li>不同的结构型模式从不同的角度组合类或对象，它们在尽可能满足各种面向对象设计原则的同时为类或对象的组合提供一系列巧妙的解决方案。</li></ul><h2 id="适配器模式-Adapter">适配器模式(Adapter)</h2><div class="tip "><p><strong>定义</strong>：</p><p>将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p></div><h3 id="模式结构">模式结构</h3><h4 id="结构图">结构图</h4><ul><li><p>类适配器</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229132413600.png" alt="类适配器"></p></li><li><p>对象适配器</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229132448870.png" alt="对象适配器"></p></li></ul><h4 id="实现代码">实现代码</h4><ul><li><p>目标抽象类（Target）</p><p>目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。在类适配器中，由于Java语言不支持多重继承，它只能是接口。</p></li><li><p>适配器类（Adapter）</p><p>它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器Adapter是适配器模式的核心，在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p><ul><li><p>类适配器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象适配器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个对适配者对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//转发调用</span></span><br><span class="line">        adaptee.specificRequest(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>适配者类（Adaptee）</p><p>适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的源代码。</p></li></ul><h3 id="应用实例">应用实例</h3><blockquote><p>某公司欲开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁（例如警灯闪烁）和声音提示（例如警笛音效）的程序，为了重用先前的代码并且使得汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229133559453.png" alt="image-20231229133559453"></p><ul><li>抽象目标：<code>CarController</code></li><li>适配者：<code>PoliceSound</code>、<code>PoliceLamp</code></li><li>适配器：<code>PoliceCarAdapter</code></li></ul><h3 id="特点及使用环境">特点及使用环境</h3><h4 id="优点">优点</h4><ol><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li><li>增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li><li>灵活性和扩展性非常好</li><li>类适配器模式：置换一些适配者的方法很方便</li><li>对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类</li></ol><h4 id="缺点">缺点</h4><ol><li>类适配器模式：<ol><li>一次最多只能适配一个适配者类，不能同时适配多个适配者</li><li>适配者类不能为最终类</li><li>目标抽象类只能为接口，不能为类</li></ol></li><li>对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦</li></ol><h4 id="适用环境">适用环境</h4><ol><li>系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码</li><li>创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作</li></ol><h2 id="桥接模式☒">桥接模式☒</h2><h2 id="组合模式★-Composite">组合模式★(Composite)</h2><div class="tip "><p><strong>定义</strong>：</p><p>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。</p></div><h3 id="模式结构-2">模式结构</h3><h4 id="结构图-2">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229125805145.png" alt="image-20231229125805145"></p><h4 id="实现代码-2">实现代码</h4><ul><li><p>抽象构件（Component）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">//增加成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span>; </span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span>;</span><br><span class="line">    <span class="comment">//获取成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>; </span><br><span class="line">    <span class="comment">// 业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>叶子构件（Leaf）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">( <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//叶子构件具体业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>容器构件（Composite）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.* ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList &lt;Component&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span> &lt;Component&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Component)list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//容器构件具体业务方法的实现，将递归调用成员构件的业务方法</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj:list) &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-2">应用实例</h3><blockquote><p>某软件公司欲开发一个杀毒(Antivirus)软件，该软件既可以对某个文件夹(Folder)杀毒，也可以对某个指定的文件(File)进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件(ImageFile)和文本文件(TextFile)的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229130502078.png" alt="image-20231229130502078"></p><ul><li>抽象构件：<code>AbstractFile</code></li><li>容器构件：<code>Folder</code></li><li>叶子构件：<code>ImageFile</code>、<code>TextFile</code>、<code>VideoFile</code></li></ul><h3 id="模式变化">模式变化</h3><h4 id="透明组合模式">透明组合模式</h4><ul><li><p>抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getChild()等方法</p></li><li><p>在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象</p></li><li><p>缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229130843722.png" alt="image-20231229130843722"></p></li></ul><h4 id="安全组合模式">安全组合模式</h4><ul><li><p>抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法</p></li><li><p>对于叶子对象，客户端不可能调用到这些方法</p></li><li><p>缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229130915270.png" alt="image-20231229130915270"></p></li></ul><h3 id="特点及使用环境-2">特点及使用环境</h3><h4 id="优点-2">优点</h4><ol><li>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码</li><li>增加新的容器构件和叶子构件都很方便，符合开闭原则</li><li>为树形结构的面向对象实现提供了一种灵活的解决方案</li></ol><h4 id="缺点-2">缺点</h4><ol><li>在增加新构件时很难对容器中的构件类型进行限制</li></ol><h4 id="适用环境-2">适用环境</h4><ol><li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们</li><li>在一个使用面向对象语言开发的系统中需要处理一个树形结构</li><li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型</li></ol><h2 id="装饰模式✲">装饰模式✲</h2><h2 id="外观模式★-Facade">外观模式★(Facade)</h2><div class="tip "><p><strong>定义</strong>：</p><p>为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231229131346810.png" alt="image-20231229131346810"></p><h3 id="模式结构-3">模式结构</h3><h4 id="结构图-3">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229131357167.png" alt="image-20231229131357167"></p><h4 id="实现代码-3">实现代码</h4><ul><li><p>外观角色（Facade）</p><p>在客户端可以调用它的方法，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemA</span> <span class="variable">objl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemB</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemC</span> <span class="variable">obj3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemC</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        objl.methodA();</span><br><span class="line">        obj2.methodB();</span><br><span class="line">        obj3.methodC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子系统角色（SubSystem）</p><p>在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-3">应用实例</h3><blockquote><p>某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229131857710.png" alt="image-20231229131857710"></p><ul><li>外观类：<code>EncryptFacade</code></li><li>子系统类：<code>FileReader</code>、<code>CipherMachine</code>、<code>FileWriter</code></li></ul><h3 id="特点及使用环境-3">特点及使用环境</h3><h4 id="优点-3">优点</h4><ol><li>它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易</li><li>它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li><li>一个子系统的修改对其他子系统没有任何影响，而且子系统的内部变化也不会影响到外观对象</li></ol><h4 id="缺点-3">缺点</h4><ol><li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则</li></ol><h4 id="适用环境-3">适用环境</h4><ol><li>要为访问一系列复杂的子系统提供一个简单入口</li><li>客户端程序与多个子系统之间存在很大的依赖性</li><li>在层次化结构中，可以使用外观模式的定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度</li></ol><h2 id="享元模式☒">享元模式☒</h2><h2 id="代理模式-Proxy">代理模式(Proxy)</h2><div class="tip "><p><strong>定义</strong>：</p><p>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p></div><h3 id="模式结构-4">模式结构</h3><h4 id="结构图-4">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229144858539.png" alt="image-20231229144858539"></p><h4 id="实现代码-4">实现代码</h4><ul><li><p>抽象主题角色（Subject）</p><p>它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理主题角色（Proxy）</p><p>它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个对真实主题对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RealSubject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        preRequest();</span><br><span class="line">        <span class="comment">//调用真实主题对象的方法</span></span><br><span class="line">        realSubject.request();  </span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真实主题角色（RealSubject）</p><p>它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法具体实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-4">应用实例</h3><blockquote><p>某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本需求如下：</p><p>(1) 在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统；</p><p>(2) 在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。</p><p>该软件公司开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229145241223.png" alt="image-20231229145241223"></p><ul><li>抽象主题角色：<code>Searcher</code></li><li>真实主题角色：<code>RealSearcher</code></li><li>代理主题角色：<code>ProxySearcher</code></li><li>其他业务类：<ul><li><code>AccessValidator</code>：验证用户身份</li><li><code>Logger</code>：记录用户查询日志</li></ul></li></ul><h3 id="模式变化-2">模式变化</h3><h4 id="远程代理">远程代理</h4><ul><li><p>客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速地响应并处理客户端的请求</p></li><li><p>可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在</p></li><li><p>客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229145646331.png" alt="image-20231229145646331"></p></li></ul><h4 id="虚拟代理">虚拟代理</h4><ul><li>对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理</li><li>在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象</li><li>使用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能</li></ul><h4 id="Java动态代理">Java动态代理</h4><ul><li>动态代理可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法</li><li>Java语言提供了对动态代理的支持，Java语言实现动态代理时需要用到位于<code>java.lang.reflect</code>包中的一些类<ul><li>Proxy类<ul><li><code>public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code>：该方法用于返回一个Class类型的代理类，在参数中需要提供类加载器并需要指定代理的接口数组（与真实主题类的接口列表一致）</li><li><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>：该方法用于返回一个动态创建的代理类的实例，方法中第一个参数loader表示代理类的类加载器，第二个参数interfaces表示代理类所实现的接口列表（与真实主题类的接口列表一致），第三个参数h表示所指派的调用处理程序类</li></ul></li><li>InvocationHandler接口<ul><li>InvocationHandler接口是代理处理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用处理者（InvocationHandler接口的子类）</li><li><code>public Object invoke(Object proxy, Method method, Object[] args)</code>：该方法用于处理对代理类实例的方法调用并返回相应的结果，当一个代理实例中的业务方法被调用时将自动调用该方法。invoke()方法包含三个参数，其中第一个参数proxy表示代理类的实例，第二个参数method表示需要代理的方法，第三个参数args表示代理方法的参数数组</li></ul></li></ul></li><li>动态代理类需要在运行时指定所代理真实主题类的接口，客户端在调用动态代理对象的方法时，调用请求会将请求自动转发给InvocationHandler对象的<code>invoke()</code>方法，由<code>invoke()</code>方法来实现对请求的统一处理。</li></ul><h3 id="特点及使用环境-4">特点及使用环境</h3><h4 id="优点-4">优点</h4><ol><li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性</li><li>各代理方式：<ol><li>远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率</li><li>虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销</li><li>缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间</li><li>保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限</li></ol></li></ol><h4 id="缺点-4">缺点</h4><ol><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理）</li><li>实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理）</li></ol><h4 id="适用环境-4">适用环境</h4><ol><li>当客户端对象需要访问远程主机中的对象时可以使用远程代理</li><li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理</li><li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理</li><li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理</li><li>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理</li></ol>]]></content>
    
    
    <summary type="html">结构型模式关注如何组合类和对象以形成更大的结构。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深克隆与浅克隆</title>
    <link href="https://www.iuoyt.com/posts/316792e4.html"/>
    <id>https://www.iuoyt.com/posts/316792e4.html</id>
    <published>2023-12-28T06:58:15.000Z</published>
    <updated>2024-01-28T09:03:37.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅克隆-Shallow-Clone">浅克隆(Shallow Clone)</h2><ul><li><p>在浅克隆中，如果原型对象的成员变量是值类型(如int、double、byte、boolean、char等基本数据类型)，将复制一份给克隆对象；如果原型对象的成员变量是引用类型（如类、接口、数组等复杂数据类型），则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当原型对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228150057812.png" alt="image-20231228150057812"></p></li></ul><h2 id="深克隆-Deep-Clone">深克隆(Deep Clone)</h2><ul><li><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将被复制。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228164944861.png" alt="image-20231228164944861"></p></li></ul>]]></content>
    
    
    <summary type="html">根据在复制原型对象的同时是否复制包含在引用类型的成员变量，Java将复制分为两种类型。</summary>
    
    
    
    <category term="Java" scheme="https://www.iuoyt.com/categories/Java/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Java" scheme="https://www.iuoyt.com/tags/Java/"/>
    
  </entry>
  
</feed>
