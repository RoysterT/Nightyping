<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🌙Nightyping</title>
  
  <subtitle>技术，生活与美好</subtitle>
  <link href="https://www.iuoyt.com/atom.xml" rel="self"/>
  
  <link href="https://www.iuoyt.com/"/>
  <updated>2023-12-26T03:48:38.582Z</updated>
  <id>https://www.iuoyt.com/</id>
  
  <author>
    <name>Royster</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.net网站开发考点汇总</title>
    <link href="https://www.iuoyt.com/posts/471abbdf.html"/>
    <id>https://www.iuoyt.com/posts/471abbdf.html</id>
    <published>2023-12-24T06:16:28.000Z</published>
    <updated>2023-12-26T03:48:38.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课后习题">课后习题</h2><h3 id="填空题">填空题</h3><ol><li>(1.1.1).NET Framework主要包括<u><strong><code>公共语言运行库（CRL）</code></strong></u>和<u><strong><code>.NET Framework 类库</code></strong></u>。</li><li>(2.1.6)在单文件页模型中，C#代码必须包含于<u><strong><code>&lt;script&gt;…&lt;/script&gt;</code></strong></u>之间。</li><li>(3.1.1)C#使用的类库就是<u><strong><code>.NET Framework</code></strong></u>提供的类库。</li><li>(3.1.2)要在一个类中包含System.Data命名空间的语句是<u><strong><code>using System.Data</code></strong></u></li><li>(4.1.1)若在TextBox控件中输入内容并当焦点离开时能触发TextChanged事件，则应设置<u><strong><code>AutoPostBack=&quot;True&quot;</code></strong></u></li><li>(4.1.2)通过<u><strong><code>IsPostBack</code></strong></u>属性可判断页面是否第一次载入</li><li>(4.1.3)ASP.NET的服务器控件包括<u><strong><code>HTML服务器控件</code></strong></u>和<u><strong><code>Web服务器控件</code></strong></u></li><li>(4.1.6)当需要将TextBox控件作为密码输入框时，应设置<u><strong><code>TextMode=&quot;Password&quot;</code></strong></u></li></ol><h3 id="判断题">判断题</h3><ol><li>(1.2.3)一个页面中可以同时包含静态页面和动态页面。（ ✔ ）</li><li>(3.2.4)数组可以由一组数据类型不相同的元素组成。（ ❌ ）</li><li>(3.2.5)foreach适用于每句数组中的元素。（ ✔ ）</li><li>(3.2.6)当一个类实例化时，它的构造函数中包含的代码肯定会执行（ ✔ ）</li><li>(3.2.7)自动属性能使编译器自动地生成死邮变量以及默认的get和set访问器。（ ✔ ）</li><li>(4.2.1)单击Button类型控件会形成页面往返处理。（ ✔ ）</li><li>(4.2.2)当页面往返时，在触发控件的事件之前会触发Page.Load事件。（ ✔ ）</li><li>(4.2.3)不能在服务器端访问HTML服务器控件。（ ❌ ）</li></ol><h3 id="选择题">选择题</h3><ol><li><p>(1.3.3)以下选项不属于编程语言的是（ ）</p><p>A. <text>ASP.NET</text></p><p>B. Python</p><p>C. Visual C#</p><p>D. Java</p><p><strong>答案：A</strong></p></li><li><p>(2.3.3)App_Code文件夹用来存储（ ）</p><p>A. 数据库文件</p><p>B. 共享文件</p><p>C. 代码文件</p><p>D. 主题文件</p><p><strong>答案：C</strong></p></li><li><p>(2.3.4)Web.config文件不能用于（ ）</p><p>A. Application事件处理代码的定义</p><p>B. 数据库连接字符串的定义</p><p>C. 对文件夹的访问授权</p><p>D. 自定义应用程序的配置</p><p><strong>答案：A</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p><code>Web.config</code> 文件可以用于以下几个主要的目的：</p><ul><li><p><strong>应用程序设置（AppSettings）：</strong></p><p><code>Web.config</code> 文件允许你定义一组键值对，用于存储应用程序级别的设置信息，如数据库连接字符串、路径信息、或其他自定义配置。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appSettings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">&quot;ConnectionString&quot;</span> <span class="attr">value</span>=<span class="string">&quot;your_database_connection_string&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">&quot;MaxItemCount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appSettings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>连接字符串设置：</strong></p><p>连接到数据库的连接字符串通常会被存储在 <code>Web.config</code> 文件中。这使得在更改数据库时，只需修改配置文件而不必修改应用程序代码。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">&quot;YourDBConnection&quot;</span> <span class="attr">connectionString</span>=<span class="string">&quot;your_database_connection_string&quot;</span> <span class="attr">providerName</span>=<span class="string">&quot;System.Data.SqlClient&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">connectionStrings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>自定义错误页面设置：</strong></p><p><code>Web.config</code> 允许你配置应用程序的错误页面，包括自定义的错误消息和处理程序。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">customErrors</span> <span class="attr">mode</span>=<span class="string">&quot;On&quot;</span> <span class="attr">defaultRedirect</span>=<span class="string">&quot;Error.aspx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error</span> <span class="attr">statusCode</span>=<span class="string">&quot;404&quot;</span> <span class="attr">redirect</span>=<span class="string">&quot;NotFound.aspx&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">customErrors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>授权和身份验证设置：</strong></p><p><code>Web.config</code> 文件中可以定义访问控制、身份验证和授权规则，以保护应用程序的安全性。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authentication</span> <span class="attr">mode</span>=<span class="string">&quot;Forms&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">forms</span> <span class="attr">loginUrl</span>=<span class="string">&quot;Login.aspx&quot;</span> <span class="attr">defaultUrl</span>=<span class="string">&quot;Default.aspx&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authentication</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">authorization</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">deny</span> <span class="attr">users</span>=<span class="string">&quot;?&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorization</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>HTTP 模块和处理程序配置：</strong></p><p><code>Web.config</code> 允许你注册和配置HTTP模块和处理程序，以扩展应用程序的功能。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">httpModules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">&quot;YourModule&quot;</span> <span class="attr">type</span>=<span class="string">&quot;YourNamespace.YourModule&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">httpModules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">httpHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">verb</span>=<span class="string">&quot;*&quot;</span> <span class="attr">path</span>=<span class="string">&quot;*.yourExtension&quot;</span> <span class="attr">type</span>=<span class="string">&quot;YourNamespace.YourHandler, YourAssembly&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">httpHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>全局化和本地化设置：</strong></p><p><code>Web.config</code> 中可以配置全球化和本地化的设置，以支持多语言应用程序。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">globalization</span> <span class="attr">culture</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">uiCulture</span>=<span class="string">&quot;auto&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul>              </div>            </details></li><li><p>(3.3.1)下列数据类型属于值类型的是（ ）</p><p>A. struct</p><p>B. class</p><p>C. interface</p><p>D. delegate</p><p><strong>答案：A</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>在C#中值类型的变量直接存储数据，而引用类型的变量持有的是数据的引用，数据存储在数据堆中.</p><ul><li>值类型（value type）：byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。</li><li>引用类型（reference type）：string 和 class统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。</li></ul>              </div>            </details></li><li><p>(3.3.2)下列数据类型属于引用类型的（ ）</p><p>A. bool</p><p>B. char</p><p>C. string</p><p>D. enum</p><p><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>在C#中值类型的变量直接存储数据，而引用类型的变量持有的是数据的引用，数据存储在数据堆中.</p><ul><li>值类型（value type）：byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。</li><li>引用类型（reference type）：string 和 class统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。</li></ul>              </div>            </details></li><li><p>(3.3.5)下面对protected修饰符说法正确的是（ ）</p><p>A. 只能在派生类中访问</p><p>B. 只能在所属的类中访问</p><p>C. 能在当前应用程序中访问</p><p>D. 能在所属的类或派生类中访问</p><p><strong>答案：D</strong></p> <details class="folding-tag" ><summary> 内容详情 </summary>              <div class='content'>              <p>P45：</p><table><thead><tr><th>修饰符</th><th>作用范围</th></tr></thead><tbody><tr><td>public</td><td>访问不受限制，任何地方都可访问</td></tr><tr><td>internal</td><td>在当前程序中能被访问</td></tr><tr><td>protected</td><td>在所属的类或派生类中能被访问</td></tr><tr><td>protected internal</td><td>在当前的程序或派生类中能被访问</td></tr><tr><td>private</td><td>在所属的类中能被访问</td></tr></tbody></table>              </div>            </details></li><li><p>(4.3.1)Web服务器控件不包括（ ）</p><p>A. Table</p><p>B. Input</p><p>C. AdRotator</p><p>D. Calendar</p><p><strong>答案：B</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <table><thead><tr><th>类别</th><th>控件</th><th>描述</th></tr></thead><tbody><tr><td><strong>基本控件</strong></td><td>- <strong>Label</strong></td><td>显示文本或标签</td></tr><tr><td></td><td>- <strong>TextBox</strong></td><td>允许用户输入文本</td></tr><tr><td></td><td>- <strong>Button</strong></td><td>触发事件或提交表单</td></tr><tr><td></td><td>- <strong>CheckBox</strong></td><td>允许用户选择一个或多个选项</td></tr><tr><td></td><td>- <strong>RadioButton</strong></td><td>允许用户从一组选项中选择一个</td></tr><tr><td></td><td>- <strong>DropDownList</strong></td><td>提供下拉列表供用户选择</td></tr><tr><td><strong>数据控件</strong></td><td>- <strong>GridView</strong></td><td>显示和编辑数据表格</td></tr><tr><td></td><td>- <strong>DataList</strong></td><td>用于显示数据列表</td></tr><tr><td></td><td>- <strong>Repeater</strong></td><td>重复显示相同结构的数据项</td></tr><tr><td></td><td>- <strong>DetailsView</strong></td><td>显示单个数据项的详细信息</td></tr><tr><td><strong>导航控件</strong></td><td>- <strong>Menu</strong></td><td>创建导航菜单</td></tr><tr><td></td><td>- <strong>TreeView</strong></td><td>展示层次结构数据的树状图</td></tr><tr><td></td><td>- <strong>SiteMapPath</strong></td><td>显示网站导航路径</td></tr><tr><td><strong>用户输入验证</strong></td><td>- <strong>RequiredFieldValidator</strong></td><td>确保用户输入了必填字段</td></tr><tr><td></td><td>- <strong>RegularExpressionValidator</strong></td><td>使用正则表达式验证用户输入</td></tr><tr><td></td><td>- <strong>CompareValidator</strong></td><td>比较两个输入字段的值是否相同</td></tr><tr><td></td><td>- <strong>CustomValidator</strong></td><td>允许自定义验证逻辑</td></tr><tr><td><strong>安全性控件</strong></td><td>- <strong>Login</strong></td><td>提供用户登录功能</td></tr><tr><td></td><td>- <strong>LoginView</strong></td><td>根据用户的身份显示不同的内容</td></tr><tr><td></td><td>- <strong>PasswordRecovery</strong></td><td>提供用户密码恢复功能</td></tr><tr><td><strong>状态管理控件</strong></td><td>- <strong>ViewState</strong></td><td>用于在页面间保持数据状态</td></tr><tr><td></td><td>- <strong>SessionState</strong></td><td>在用户会话间保持数据状态</td></tr><tr><td></td><td>- <strong>ApplicationState</strong></td><td>在整个应用程序中保持数据状态</td></tr><tr><td><strong>文件上传控件</strong></td><td>- <strong>FileUpload</strong></td><td>允许用户上传文件</td></tr><tr><td><strong>AJAX控件</strong></td><td>- <strong>UpdatePanel</strong></td><td>允许部分页面刷新，而不是整个页面</td></tr><tr><td></td><td>- <strong>ScriptManager</strong></td><td>管理页面上的客户端脚本</td></tr><tr><td><strong>其他控件</strong></td><td>- <strong>Image</strong></td><td>显示图像</td></tr><tr><td></td><td>- <strong>HyperLink</strong></td><td>创建超链接</td></tr><tr><td></td><td>- <strong>Calendar</strong></td><td>提供日期选择功能</td></tr></tbody></table>              </div>            </details></li><li><p>(4.3.3)单击Button类型控件后能执行客户端脚本的属性是（ ）</p><p>A. OnClientClick</p><p>B. OnClick</p><p>C. OnCommandClick</p><p>D. OnClientCommand</p><p><strong>答案：A</strong></p></li></ol><h3 id="简答题">简答题</h3><ol><li><p>(2.4.6)简述Global.asax文件特点及作用</p> <details class="folding-tag" ><summary> 内容详情 </summary>              <div class='content'>              <p>P37：</p><p>Global.asax文件（全局应用程序类文件）是一个可选文件，用于包含响应应用程序级别和会话级别事件的代码。若一个网站中包含Global.asax，则必须存储于网站的根文件夹，且每个网站只能包含一个Global.asax文件。当用户向一个.aspx文件首次发出访问请求时，Web服务器都会执行Global.asax文件。因此，包含在Global.asax文件中的代码将首先被执行。 Global.asax文件中处理典型事件的方法包括：</p><ul><li><code>Application_Start()</code>：Web应用程序启动时运行的代码</li><li><code>Application_End()</code>：Web应用程序关闭时运行的代码</li><li><code>Application_Error()</code>： Web应用程序出现未处理的错误时运行的代码</li><li><code>Session_Start()</code>：用户访问Web应用程序启动新会话时运行的代码</li><li><code>Session_End()</code>：用户结束会话时运行的代码。</li></ul>              </div>            </details></li><li><p>(3.4.1)请说明修饰符 public、internal、protected、 protected intenal、private的区别。</p> <details class="folding-tag" ><summary> 内容详情 </summary>              <div class='content'>              <p>P45：</p><table><thead><tr><th>修饰符</th><th>作用范围</th></tr></thead><tbody><tr><td>public</td><td>访问不受限制，任何地方都可访问</td></tr><tr><td>internal</td><td>在当前程序中能被访问</td></tr><tr><td>protected</td><td>在所属的类或派生类中能被访问</td></tr><tr><td>protected internal</td><td>在当前的程序或派生类中能被访问</td></tr><tr><td>private</td><td>在所属的类中能被访问</td></tr></tbody></table>              </div>            </details></li><li><p>(3.4.2)简述值类型和引用类型的区别。</p> <details class="folding-tag" ><summary> 内容详情 </summary>              <div class='content'>              <p>P46：</p><p>值类型变量直接包含它们的数据，而引用类型变量存储它们的数据的引用。对于值类型，一个变量的操作不会影响另一个变量；而对于引用类型，两个变量可能引用同一个对象，因此对一个变量的操作可能会影响到另一个变量。</p><ul><li><p>值类型分为简单类型、结构类型、枚举类型。简单类型再分为整数类型、布尔类型、字 符类型和实数类型</p></li><li><p>引用类型包括class类型、接口类型、数组类型和委托类型。</p></li></ul><p>其他资料：</p><ul><li>值类型（value type）：byte，short，int，long，float，double，decimal，char，bool 和 struct 统称为值类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。</li><li>引用类型（reference type）：string 和 class统称为引用类型。当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。</li></ul>              </div>            </details></li></ol><h2 id="知识点">知识点</h2><ol><li><p>验证输入值的范围</p> <div class="tabs" id="验证范围"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#验证范围-1">RangeValidator控件</button></li><li class="tab"><button type="button" data-href="#验证范围-2">JS</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="验证范围-1"><p>P100：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;asp:RangeValidator </span><br><span class="line">ID=&quot;RangeValidator1&quot; </span><br><span class="line">runat=&quot;server&quot;</span><br><span class="line">ControlToValidate=&quot;TextBox1&quot; </span><br><span class="line">ErrorMessage=&quot;RangeValidator&quot;</span><br><span class="line">MaximumValue=&quot;9&quot; </span><br><span class="line">MinimumValue=&quot;0&quot;</span><br><span class="line">Type=&quot;Integer&quot;&gt;</span><br><span class="line">&lt;/asp:RangeValidator&gt;</span><br></pre></td></tr></table></figure><p>为验证输入值的范围，RangeValidator控件提供了 MaximumValue和MinimumValue属性，分别对应验证范围的最大值和最小值。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="验证范围-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户输入的值</span></span><br><span class="line"><span class="keyword">var</span> inputValue = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;inputNumber&#x27;</span>).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将输入转换为数值类型</span></span><br><span class="line"><span class="keyword">var</span> inputValueAsNumber = <span class="built_in">parseFloat</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数值范围</span></span><br><span class="line"><span class="keyword">var</span> minValue = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> maxValue = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查输入是否在范围内</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">isNaN</span>(inputValueAsNumber) &amp;&amp; inputValueAsNumber &gt;= minValue &amp;&amp; inputValueAsNumber &lt;= maxValue) &#123;</span><br><span class="line">    <span class="comment">// 在范围内</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>).<span class="property">innerText</span> = <span class="string">&#x27;输入在范围内&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不在范围内或输入无效</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>).<span class="property">innerText</span> = <span class="string">&#x27;请输入有效的数值，并确保在范围内&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p>Cookie和Session的使用、优缺点、区别</p> <div class="tabs" id="cookie&session"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#cookie&session-1">Cookie</button></li><li class="tab"><button type="button" data-href="#cookie&session-2">Session</button></li><li class="tab"><button type="button" data-href="#cookie&session-3">区别</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="cookie&session-1"><ul><li><p>Cookie是保存在客户端硬盘或内存中的一小段文本信息，如网站、用户、会话等有关的信息。一种典型的用途是通过Cookie保存用户是否已登录的信息。这样，在其他页面只要判断相应的Cookie值就能知道用户是否已经登录。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Cookie</span></span><br><span class="line">HttpCookie cookie = <span class="keyword">new</span> HttpCookie(<span class="string">&quot;UserInfo&quot;</span>);</span><br><span class="line">cookie.Value = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">cookie.Expires = DateTime.Now.AddDays(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Cookie到响应</span></span><br><span class="line">Response.Cookies.Add(cookie);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取Cookie</span></span><br><span class="line">HttpCookie userCookie = Request.Cookies[<span class="string">&quot;UserInfo&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> username = userCookie.Value;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li><p><strong>持久性：</strong> Cookie 可以设置过期时间，使得信息在客户端可以长时间保留。</p></li><li><p><strong>客户端存储：</strong> Cookie 存储在客户端，对服务器端负担较小。</p></li></ul></li><li><p>缺点：</p><ul><li><p><strong>安全性：</strong> Cookie 中的信息在客户端是可见的，可能被恶意用户查看或修改。</p></li><li><p><strong>大小限制：</strong> 单个 Cookie 的大小受到限制，通常为4 KB。</p></li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cookie&session-2"><ul><li><p>Session又称会话状态，在工程项目中应用广泛，典型的应用有存储用户信息、多页面间的信息传递、购物车等。Session产生在服务器端，只能为当前访问的用户服务。以用户对网站的最后一次访问开始计时，当计时达到会话设定时间并且期间没有访问操作时，则会话自动结束。如果同一个用户在浏览期间关闭浏览器后再访问同一个页面，服务器会为该用户产生新的Session。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据到Session</span></span><br><span class="line">Session[<span class="string">&quot;UserInfo&quot;</span>] = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="built_in">string</span> username = (<span class="built_in">string</span>)Session[<span class="string">&quot;UserInfo&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li><p><strong>安全性：</strong> 与 Cookie 不同，Session 数据存储在服务器端，客户端无法直接访问。</p></li><li><p><strong>无大小限制：</strong> Session 数据的大小不受客户端限制，可以存储更多的信息。</p></li></ul></li><li><p>缺点：</p><ul><li><p><strong>服务器资源：</strong> 由于 Session 数据存储在服务器端，可能对服务器资源产生较大的负担，尤其是在大量用户同时使用时。</p></li><li><p><strong>失效问题：</strong> 默认情况下，Session 会在一段时间内保持活动状态，但一旦过期或用户关闭浏览器，会话数据就会丢失。</p></li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cookie&session-3"><table><thead><tr><th>区别</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>存储位置</td><td>客户端</td><td>服务器端</td></tr><tr><td>安全性</td><td>在客户端是可见的</td><td>存储在服务器端，相对更安全</td></tr><tr><td>大小限制</td><td>4KB</td><td>10-20KB</td></tr><tr><td>生命周期</td><td>可以设置过期时间，使得信息可以在客户端保持较长时间</td><td>通常随着用户会话的结束而结束</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p>判断页面是否为第一次载入（IsPostBack）</p> <details class="folding-tag" ><summary> 内容详情 </summary>              <div class='content'>              <p>当控件的事件被触发时，Page.Load事件会在控件事件之前被触发。如果想在执行控件 的事件处理代码时不执行<code>Page_Load()</code>方法代码，可以通过判断Page.IsPostBack属性值实现，IsPostBack属性在用户第一次浏览页而时，会返回值false，否则返回值true。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Page_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsPostBack)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 页面首次加载时执行的代码</span></span><br><span class="line">        <span class="comment">// 这里可以放置初始化页面的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 页面是由用户交互引起的后续加载时执行的代码</span></span><br><span class="line">        <span class="comment">// 这里可以处理用户提交的数据等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details></li><li><p>控件的自动回调属性（AutoPostBack）</p> <details class="folding-tag" ><summary> 内容详情 </summary>              <div class='content'>              <p>控件事件以Click和Changed事件为主。</p><ul><li>Click事件被触发时会引起页面往返处理，即页面将被重新执行并触发Page.Load等事件。</li><li>Changed事件被触发时，先将事件的信息暂时保存在客户端的缓冲区中，等到下一次向服务器传递信息时，再和其他信息一起发送给服务器。</li></ul><p>若要让控件的Changed事件立即得到服务器的响应，就需要将该控件的 AutoPostBack属性值设为True。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;asp:DropDownList ID=&quot;ddlOptions&quot; runat=&quot;server&quot; AutoPostBack=&quot;true&quot; </span><br><span class="line">                  OnSelectedIndexChanged=&quot;SelectedChanged&quot;&gt;</span><br><span class="line">    &lt;asp:ListItem Text=&quot;Option 1&quot; Value=&quot;1&quot;&gt;&lt;/asp:ListItem&gt;</span><br><span class="line">    &lt;asp:ListItem Text=&quot;Option 2&quot; Value=&quot;2&quot;&gt;&lt;/asp:ListItem&gt;</span><br><span class="line">    &lt;asp:ListItem Text=&quot;Option 3&quot; Value=&quot;3&quot;&gt;&lt;/asp:ListItem&gt;</span><br><span class="line">&lt;/asp:DropDownList&gt;</span><br><span class="line">&lt;asp:Label ID=&quot;lblResult&quot; runat=&quot;server&quot; Text=&quot;&quot;&gt;&lt;/asp:Label&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用了 <code>DropDownList</code> 控件，并设置了 <code>AutoPostBack</code> 为 <code>true</code>，以便在选择项变化时自动回发页面。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">SelectedChanged</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当选择项发生变化时，此事件会触发</span></span><br><span class="line">    <span class="comment">// 在这里可以处理选择项变化后的逻辑</span></span><br><span class="line">    lblResult.Text = <span class="string">&quot;选择项变为: &quot;</span> + ddlOptions.SelectedItem.Text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户选择不同的选项时，<code>SelectedChanged</code> 事件会触发，因为 <code>AutoPostBack</code> 属性设置为 <code>true</code>。在事件处理程序中，将页面上的 <code>Label</code> 控件显示当前选择的选项。</p>              </div>            </details></li><li><p>数据库</p><ol><li><p>LinQ结合EF框架访问数据库（框架介绍或者怎么办）</p> <div class="tabs" id="内容详情"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#内容详情-1">投影</button></li><li class="tab"><button type="button" data-href="#内容详情-2">选择</button></li><li class="tab"><button type="button" data-href="#内容详情-3">排序</button></li><li class="tab"><button type="button" data-href="#内容详情-4">分组</button></li><li class="tab"><button type="button" data-href="#内容详情-5">聚合</button></li><li class="tab"><button type="button" data-href="#内容详情-6">连接</button></li><li class="tab"><button type="button" data-href="#内容详情-7">模糊查询</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="内容详情-1"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> projectedData = dbContext.Entities.Select(entity =&gt; <span class="keyword">new</span> &#123; </span><br><span class="line">    entity.Property1, </span><br><span class="line">    entity.Property2 </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="内容详情-2"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询语法</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> entity <span class="keyword">in</span> dbContext.Entities</span><br><span class="line">    <span class="keyword">where</span> entity.Property == someValue</span><br><span class="line">    <span class="keyword">select</span> entity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法语法</span></span><br><span class="line"><span class="keyword">var</span> query = dbContext.Entities</span><br><span class="line">    .Where(entity =&gt; entity.Property == someValue)</span><br><span class="line">    .Select(entity =&gt; entity);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="内容详情-3"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedData = dbContext.Entities.OrderBy(</span><br><span class="line">    entity =&gt; entity.Property</span><br><span class="line">);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="内容详情-4"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> groupedData = dbContext.Entities</span><br><span class="line">    .GroupBy(entity =&gt; entity.Category)</span><br><span class="line">    .Select(<span class="keyword">group</span> =&gt; <span class="keyword">new</span></span><br><span class="line">    &#123;</span><br><span class="line">        Category = <span class="keyword">group</span>.Key,</span><br><span class="line">        Count = <span class="keyword">group</span>.Count(),</span><br><span class="line">        Items = <span class="keyword">group</span>.ToList()</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="内容详情-5"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> groupedData = dbContext.Entities</span><br><span class="line">    .GroupBy(entity =&gt; entity.Category)</span><br><span class="line">    .Select(<span class="keyword">group</span> =&gt; <span class="keyword">new</span></span><br><span class="line">    &#123;</span><br><span class="line">        Category = <span class="keyword">group</span>.Key,</span><br><span class="line">        TotalAmount = <span class="keyword">group</span>.Sum(entity =&gt; entity.Amount),</span><br><span class="line">        AverageAmount = <span class="keyword">group</span>.Average(entity =&gt; entity.Amount),</span><br><span class="line">        MaxAmount = <span class="keyword">group</span>.Max(entity =&gt; entity.Amount),</span><br><span class="line">        MinAmount = <span class="keyword">group</span>.Min(entity =&gt; entity.Amount),</span><br><span class="line">        Items = <span class="keyword">group</span>.ToList()</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="内容详情-6"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> joinedData = dbContext.Table1.Join(</span><br><span class="line">                     dbContext.Table2,</span><br><span class="line">                     t1 =&gt; t1.Id,</span><br><span class="line">                     t2 =&gt; t2.Table1Id,</span><br><span class="line">                     (t1, t2) =&gt; <span class="keyword">new</span> &#123; </span><br><span class="line">                     Property1 = t1.Property, </span><br><span class="line">                     Property2 = t2.Property </span><br><span class="line">                     &#125;);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="内容详情-7"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> searchTerm = <span class="string">&quot;prefix&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"><span class="comment">// 开始位置</span></span><br><span class="line">result = dbContext.Entities</span><br><span class="line">    .Where(entity =&gt; entity.Property.StartsWith(searchTerm))</span><br><span class="line">    .ToList();</span><br><span class="line"><span class="comment">// 结束位置</span></span><br><span class="line">result = dbContext.Entities</span><br><span class="line">    .Where(entity =&gt; entity.Property.EndsWith(searchTerm))</span><br><span class="line">    .ToList();</span><br><span class="line"><span class="comment">// 包含</span></span><br><span class="line">result = dbContext.Entities</span><br><span class="line">    .Where(entity =&gt; entity.Property.Contains(searchTerm))</span><br><span class="line">    .ToList();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p><text>ADO.NET</text>、原生或LinQ+EF的区别和分别的优势</p> <div class="tabs" id="数据库"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#数据库-1">ADO.NET</button></li><li class="tab"><button type="button" data-href="#数据库-2">原生</button></li><li class="tab"><button type="button" data-href="#数据库-3">LinQ+EF</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="数据库-1"><ol><li><strong>特点：</strong><ul><li><a href="http://ADO.NET">ADO.NET</a> 是 .NET 平台下用于访问数据源的一组技术。</li><li>使用 <a href="http://ADO.NET">ADO.NET</a>，你需要手动编写 SQL 查询语句或存储过程，并执行这些查询。</li><li><a href="http://ADO.NET">ADO.NET</a> 提供了 <code>Connection</code>、<code>Command</code>、<code>DataReader</code> 等核心对象，开发者需要显式地管理这些对象。</li></ul></li><li><strong>优势：</strong><ul><li>直接控制：开发者可以直接控制数据库连接、执行命令和处理结果。</li><li>灵活性：可以编写任意复杂的 SQL 查询。</li></ul></li><li><strong>劣势：</strong><ul><li>繁琐：需要手动管理数据库连接、命令和结果集。</li><li>容易出错：需要防范 SQL 注入等安全问题。</li><li>与对象的映射较为手动，需要将数据手动转换为对象。</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="数据库-2"><ol><li><strong>特点：</strong><ul><li>直接使用原生 SQL 查询语句与数据库进行交互。</li><li>通常通过 <a href="http://ADO.NET">ADO.NET</a> 的 <code>SqlCommand</code> 和 <code>SqlDataReader</code> 等对象执行原生 SQL 查询。</li></ul></li><li><strong>优势：</strong><ul><li>性能：直接写 SQL 查询语句可以获得更高的性能。</li><li>灵活性：可以优化 SQL 查询，适用于复杂查询和性能敏感的场景。</li></ul></li><li><strong>劣势：</strong><ul><li>与特定数据库引擎相关：原生 SQL 查询可能依赖于特定数据库引擎的语法，不够数据库无关。</li><li>需要处理数据映射：需要手动将数据库结果映射到对象。</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="数据库-3"><ol><li><strong>特点：</strong><ul><li>LINQ 是 C# 中的语言集成查询，用于查询各种数据源。</li><li>Entity Framework (EF) 则是 .NET 平台的 ORM 框架，提供了对象和数据库之间的映射。</li><li>LINQ 可以与 EF 集成，通过 LINQ 查询语法查询数据库。</li></ul></li><li><strong>优势：</strong><ul><li>对象关系映射（ORM）：EF 提供了对象与数据库表之间的映射，减少了手动转换的工作。</li><li>强类型：LINQ 查询是强类型的，编译时检查错误。</li><li>抽象数据库引擎：EF 提供了对多种数据库引擎的支持，使得代码更具有可移植性。</li></ul></li><li><strong>劣势：</strong><ul><li>性能：在某些情况下，直接使用原生 SQL 查询可能获得更好的性能。</li><li>学习曲线：相比于直接使用 SQL，使用 LINQ + EF 需要一些学习和理解。</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p>三层架构</p></li></ol></li><li><p>页面跳转</p> <div class="tabs" id="页面跳转"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#页面跳转-1">a标签</button></li><li class="tab"><button type="button" data-href="#页面跳转-2">HyperLink</button></li><li class="tab"><button type="button" data-href="#页面跳转-3">Redirect()</button></li><li class="tab"><button type="button" data-href="#页面跳转-4">Execute()</button></li><li class="tab"><button type="button" data-href="#页面跳转-5">Transfer()</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="页面跳转-1"><p>通过设置 <code>href</code> 属性，可以指定链接的目标 URL。用户点击链接时，浏览器将加载新的页面。这是一种客户端跳转的方式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;newpage.html&quot;</span>&gt;</span>点击我跳转到新页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="页面跳转-2"><p>在代码中设置 <code>NavigateUrl</code> 属性，实现在服务器端进行页面重定向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;asp:HyperLink ID=&quot;hyperlink1&quot; runat=&quot;server&quot; NavigateUrl=&quot;newpage.aspx&quot;&gt;</span><br><span class="line">    点击我跳转到新页面</span><br><span class="line">&lt;/asp:HyperLink&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="页面跳转-3"><p><code>Response.Redirect()</code> 是在服务器端执行的一种页面重定向方式。通过这种方法，服务器将告诉浏览器要重定向到另一个页面。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在服务器端执行重定向</span></span><br><span class="line">Response.Redirect(<span class="string">&quot;newpage.aspx&quot;</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="页面跳转-4"><p><code>Server.Execute()</code> 方法允许你在服务器端执行另一个页面，然后将结果发送回原始页面。与简单的重定向不同，这种方式可以在两个页面之间共享数据。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在服务器端执行另一个页面</span></span><br><span class="line">Server.Execute(<span class="string">&quot;newpage.aspx&quot;</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="页面跳转-5"><p>与 <code>Response.Redirect()</code> 不同之处在于，它是在服务器上进行的，并且在客户端浏览器上看不到 URL 的更改。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在服务器端执行页面转发</span></span><br><span class="line">Server.Transfer(<span class="string">&quot;newpage.aspx&quot;</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p>页面跳转时携带数据的方法</p> <div class="tabs" id="cookie&session"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#cookie&session-1">Cookie</button></li><li class="tab"><button type="button" data-href="#cookie&session-2">Session</button></li><li class="tab"><button type="button" data-href="#cookie&session-3">参数URL</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="cookie&session-1"><ul><li><p>Cookie是保存在客户端硬盘或内存中的一小段文本信息，如网站、用户、会话等有关的信息。一种典型的用途是通过Cookie保存用户是否已登录的信息。这样，在其他页面只要判断相应的Cookie值就能知道用户是否已经登录。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Cookie</span></span><br><span class="line">HttpCookie cookie = <span class="keyword">new</span> HttpCookie(<span class="string">&quot;UserInfo&quot;</span>);</span><br><span class="line">cookie.Value = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">cookie.Expires = DateTime.Now.AddDays(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Cookie到响应</span></span><br><span class="line">Response.Cookies.Add(cookie);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取Cookie</span></span><br><span class="line">HttpCookie userCookie = Request.Cookies[<span class="string">&quot;UserInfo&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> username = userCookie.Value;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li><p><strong>持久性：</strong> Cookie 可以设置过期时间，使得信息在客户端可以长时间保留。</p></li><li><p><strong>客户端存储：</strong> Cookie 存储在客户端，对服务器端负担较小。</p></li></ul></li><li><p>缺点：</p><ul><li><p><strong>安全性：</strong> Cookie 中的信息在客户端是可见的，可能被恶意用户查看或修改。</p></li><li><p><strong>大小限制：</strong> 单个 Cookie 的大小受到限制，通常为4 KB。</p></li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cookie&session-2"><ul><li><p>Session又称会话状态，在工程项目中应用广泛，典型的应用有存储用户信息、多页面间的信息传递、购物车等。Session产生在服务器端，只能为当前访问的用户服务。以用户对网站的最后一次访问开始计时，当计时达到会话设定时间并且期间没有访问操作时，则会话自动结束。如果同一个用户在浏览期间关闭浏览器后再访问同一个页面，服务器会为该用户产生新的Session。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据到Session</span></span><br><span class="line">Session[<span class="string">&quot;UserInfo&quot;</span>] = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="built_in">string</span> username = (<span class="built_in">string</span>)Session[<span class="string">&quot;UserInfo&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li><p><strong>安全性：</strong> 与 Cookie 不同，Session 数据存储在服务器端，客户端无法直接访问。</p></li><li><p><strong>无大小限制：</strong> Session 数据的大小不受客户端限制，可以存储更多的信息。</p></li></ul></li><li><p>缺点：</p><ul><li><p><strong>服务器资源：</strong> 由于 Session 数据存储在服务器端，可能对服务器资源产生较大的负担，尤其是在大量用户同时使用时。</p></li><li><p><strong>失效问题：</strong> 默认情况下，Session 会在一段时间内保持活动状态，但一旦过期或用户关闭浏览器，会话数据就会丢失。</p></li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cookie&session-3"><ul><li><p>放参，在访问路径后接<code>?</code>和参数：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetPage.aspx?userName=John</span><br></pre></td></tr></table></figure></li><li><p>取参：</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在目标页面中读取 URL 参数</span></span><br><span class="line"><span class="built_in">string</span> userName = Request.QueryString[<span class="string">&quot;userName&quot;</span>];</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p>几个重要的类，通过这几个类能拿到什么</p> <div class="tabs" id="类"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#类-1">Service</button></li><li class="tab"><button type="button" data-href="#类-2">Request</button></li><li class="tab"><button type="button" data-href="#类-3">Response</button></li><li class="tab"><button type="button" data-href="#类-4">Application</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="类-1"><p>呃，似乎<text>asp.net</text> c#中没这玩意儿吧……</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="类-2"><ul><li><p><strong>QueryString：</strong> 获取包含查询字符串的集合。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">value</span> = Request.QueryString[<span class="string">&quot;param&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p><strong>Form：</strong> 获取包含表单数据的集合。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">value</span> = Request.Form[<span class="string">&quot;inputName&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p><strong>Cookies：</strong> 获取包含 Cookies 的集合。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">value</span> = Request.Cookies[<span class="string">&quot;cookieName&quot;</span>].Value;</span><br></pre></td></tr></table></figure></li><li><p><strong>Headers：</strong> 获取包含请求头的集合。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> userAgent = Request.Headers[<span class="string">&quot;User-Agent&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p><strong>HttpMethod：</strong> 获取请求的 HTTP 方法（GET、POST 等）。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> method = Request.HttpMethod;</span><br></pre></td></tr></table></figure></li><li><p><strong>InputStream：</strong> 获取请求的输入流，可用于读取原始请求数据。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(Request.InputStream))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> requestData = reader.ReadToEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="类-3"><ul><li><p><strong>Write：</strong> 向响应输出流写入文本。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.Write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>Redirect：</strong> 将客户端重定向到其他页面。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.Redirect(<span class="string">&quot;newpage.aspx&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>Clear：</strong> 清除响应缓冲区。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.Clear();</span><br></pre></td></tr></table></figure></li><li><p><strong>ContentType：</strong> 获取或设置响应内容的 MIME 类型。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.ContentType = <span class="string">&quot;text/html&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>AppendHeader：</strong> 向响应的 HTTP 标头添加一个值。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.AppendHeader(<span class="string">&quot;CustomHeader&quot;</span>, <span class="string">&quot;CustomValue&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>Cookies：</strong> 获取包含响应 Cookies 的集合。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpCookie cookie = <span class="keyword">new</span> HttpCookie(<span class="string">&quot;MyCookie&quot;</span>, <span class="string">&quot;CookieValue&quot;</span>);</span><br><span class="line">Response.Cookies.Add(cookie);</span><br></pre></td></tr></table></figure></li><li><p><strong>End：</strong> 结束响应，停止页面的执行。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.End();</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="类-4"><p>主要属性：</p><ul><li><p><strong><code>Application[&quot;Key&quot;]</code>：</strong> 用于存储和检索在应用程序级别共享的数据。这是一个类似于 <code>Session</code> 的键值对集合。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据</span></span><br><span class="line">Application[<span class="string">&quot;AppName&quot;</span>] = <span class="string">&quot;MyWebApp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索数据</span></span><br><span class="line"><span class="built_in">string</span> appName = (<span class="built_in">string</span>)Application[<span class="string">&quot;AppName&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Application.Contents</code>：</strong> 一个类似于 <code>Application[&quot;Key&quot;]</code> 的集合，包含应用程序级别共享的所有数据。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据</span></span><br><span class="line">Application.Contents[<span class="string">&quot;Counter&quot;</span>] = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索数据</span></span><br><span class="line"><span class="built_in">int</span> counter = (<span class="built_in">int</span>)Application.Contents[<span class="string">&quot;Counter&quot;</span>];</span><br></pre></td></tr></table></figure></li></ul><p>主要方法：</p><ul><li><p><strong><code>Application_Start</code>：</strong> 在应用程序启动时调用的事件处理程序。通常用于执行应用程序级别的初始化操作。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Application_Start</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 应用程序初始化代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Application_End</code>：</strong> 在应用程序关闭时调用的事件处理程序。通常用于执行应用程序级别的清理操作。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Application_End</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 应用程序关闭时的清理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Application_Error</code>：</strong> 在应用程序发生未处理的错误时调用的事件处理程序。通常用于记录错误或执行其他处理。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Application_Error</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理未处理的错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p>一些高级控件，如：UpdatePanel，进度条，表格 TreeView等等</p> <div class="tabs" id="内容详情"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#内容详情-1">UpdatePanel</button></li><li class="tab"><button type="button" data-href="#内容详情-2">Table</button></li><li class="tab"><button type="button" data-href="#内容详情-3">TreeView</button></li><li class="tab"><button type="button" data-href="#内容详情-4">进度条</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="内容详情-1"><p>P228：</p><ul><li><p>UpdatePanel控件是一个容器控件，该控件自身不会在页面上显示任何内容，主要作用是放置在其中的控件将具有局部刷新的功能。通过使用UpdatePanel控件，减少了整页回发时的屏幕“闪烁”并提高了页面交互性，改善了用户体验，同时也减少了在客户端和服务器之间传输的数据量。</p></li><li><p>一个页面上可以放置多个UpdatePanel控件。每个UpdatePanel控件可以指定独立的页面区域，实现独立的局部刷新功能。实际使用时将需要局部刷新的控件放在UpdatePanel控件内部的子元素中。另外,还可以利用控件的<code>&lt;Triggers&gt;</code>元素内的<code>&lt;asp:AsyncPostBackTrigger&gt;</code>元素定义触发器。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;asp:UpdatePanel ID=&quot;UpdatePanel1&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">    &lt;ContentTemplate&gt;</span><br><span class="line">        …&lt;%--添加需要局部刷新的控件--%&gt;</span><br><span class="line">    &lt;/ContentTemplate&gt;</span><br><span class="line">    &lt;Triggers&gt;</span><br><span class="line">        &lt;asp:AsyncPostBackTrigger ControlID=&quot;btnSubmit&quot; EventName=&quot;Click&quot; /&gt;</span><br><span class="line">    &lt;/Triggers&gt;</span><br><span class="line">&lt;/asp:UpdatePanel&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;asp:AsyncPostBackTrigger ControlID=&quot;btnSubmit&quot; EventName=&quot;Click&quot; /&gt;</code>定义了触发器， 表示在触发控件btnSubmit的Click事件后，会产生异步回发并刷新&lt;ContentTemplate&gt;元素中 的控件</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="内容详情-2"><ul><li><p>Table控件用于在Web窗体上动态地创建表格，是一种容器控件。Table对象由行（TableRow）对象组成，TableRow对象由单元格（TableCell）对象组成。定义的语法格式如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;asp:Table ID=&quot;Table1&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">&lt;asp:TableRow runat=&quot;server&quot;&gt;</span><br><span class="line">    &lt;asp:TableCell runat=&quot;server&quot;&gt;学号&lt;/asp:TableCell&gt;</span><br><span class="line">        &lt;asp:TableCell runat=&quot;server&quot;&gt;姓名&lt;/asp:TableCell&gt;</span><br><span class="line">    &lt;/asp:TableRow&gt;</span><br><span class="line">&lt;/asp:Table&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态生成表格：</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立一个行对象</span></span><br><span class="line">TableRow row = <span class="keyword">new</span> TableRow();</span><br><span class="line"><span class="comment">// 建立单元格对象</span></span><br><span class="line">TableCell cell1 = <span class="keyword">new</span> TableCell();</span><br><span class="line">TableCell cell2 = <span class="keyword">new</span> TableCell();</span><br><span class="line">TableCell cell3 = <span class="keyword">new</span> TableCell();</span><br><span class="line"><span class="comment">// 将控件添加到单元格</span></span><br><span class="line">TextBox txtinput = <span class="keyword">new</span> TextBox();</span><br><span class="line">cell3.Controls.Add(txtinput);</span><br><span class="line"><span class="comment">// 将单元格添加到行对象</span></span><br><span class="line">row.Cells.Add(cell1);</span><br><span class="line">row.Cells.Add(cell2);</span><br><span class="line">row.Cells.Add(cell3); </span><br><span class="line"><span class="comment">//添加行对象到表格对象(id:tbl)</span></span><br><span class="line">tbl.Rows.Add(row);</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="内容详情-3"><ul><li><p>TreeVievv控件常用于以树形结构显示分层数据的情形。利用TreeView控件可以实现网站导航，也可以用来显示XML、表格或关系数据。可以说，凡是树形层次关系的数据的显示，都可以用TreeView控件。</p></li><li><p>TreeView控件中的每个项都称为一个节点，每一个节点都是一个TreeNode对象。节点分为根节点、父节点、子节点和叶节点。最上层的节点是根节点，可以有多个根节点。没有子节点的节点是叶节点。定义的语法格式如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;asp:TreeView ID=&quot;TreeView1&quot; runat=&quot;server&quot;&gt;&lt;/asp:TreeView&gt;</span><br></pre></td></tr></table></figure></li><li><p>TreeView控件常用属性表</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>CollapselmageUrl</td><td>节点折叠后用于显示图片的URL</td></tr><tr><td>EnableClientScript</td><td>是否允许在客户端处理展开和折叠事件</td></tr><tr><td>ExpandDepth</td><td>第一次显示时所展开的级数</td></tr><tr><td>ExpandlmageUrl</td><td>节点展开后用于显示图片的URL</td></tr><tr><td>Nodes</td><td>获取所有的根节点集合</td></tr><tr><td>NoExpandlmageUrl</td><td>设置用于显示不可折叠（即无子节点）节点对应图片的URL</td></tr><tr><td>PathSeparator</td><td>节点之间的路径分隔符</td></tr><tr><td>SelectedNode</td><td>当前选中的节点</td></tr><tr><td>SelectedValue</td><td>当前选中的节点值</td></tr><tr><td>ShowCheckBoxes</td><td>是否在节点前显示复选框</td></tr><tr><td>ShowLines</td><td>节点间是否显示连接线</td></tr></tbody></table></li><li><p>TreeNode类常用属性表</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>ChildNodes</td><td>获取当前节点的下一级子节点集合</td></tr><tr><td>ImageUrl</td><td>获取或设置节点旁用于显不图片的URL</td></tr><tr><td>NavigateUrl</td><td>获取或设置单击节点时导航到的URL</td></tr><tr><td>Parent</td><td>获取当前节点的父节点</td></tr></tbody></table></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="内容详情-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><h2 id="编程题">编程题</h2><ol><li><p>用循环语句+条件语句判断符合条件的情况和输出，输出时要做异常处理</p> <details class="folding-tag" ><summary> 内容详情 </summary>              <div class='content'>              <p>语句举例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Page_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环语句</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 条件语句</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 输出</span></span><br><span class="line">                Response.Write(<span class="string">$&quot;Number <span class="subst">&#123;i&#125;</span> is even.&lt;br&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 输出</span></span><br><span class="line">                Response.Write(<span class="string">$&quot;Number <span class="subst">&#123;i&#125;</span> is odd.&lt;br&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        Response.Write(<span class="string">$&quot;An error occurred: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details></li><li><p>C#类的写法（包括构造方法，有返回值的函数、互相继承的两个类，类的多态）</p> <details class="folding-tag" ><summary> 内容详情 </summary>              <div class='content'>              <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有返回值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Some generic sound&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog，继承自 Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造方法，调用基类构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof! Woof!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建基类实例</span></span><br><span class="line">        Animal genericAnimal = <span class="keyword">new</span> Animal(<span class="string">&quot;Generic Animal&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建派生类实例</span></span><br><span class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用基类函数</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Generic Animal says: <span class="subst">&#123;genericAnimal.MakeSound()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用派生类函数</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;myDog.Name&#125;</span> says: <span class="subst">&#123;myDog.MakeSound()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多态性示例，基类引用指向派生类对象</span></span><br><span class="line">        Animal polyAnimal = <span class="keyword">new</span> Dog(<span class="string">&quot;Rex&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;polyAnimal.Name&#125;</span> says: <span class="subst">&#123;polyAnimal.MakeSound()&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details></li></ol>]]></content>
    
    
    <summary type="html">ASP.NET网站开发考点整理总结</summary>
    
    
    
    
    <category term=".net" scheme="https://www.iuoyt.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>《Android移动开发基础案例教程》（第2版）课后习题答案</title>
    <link href="https://www.iuoyt.com/posts/b8eb778b.html"/>
    <id>https://www.iuoyt.com/posts/b8eb778b.html</id>
    <published>2023-12-20T09:44:01.000Z</published>
    <updated>2023-12-25T13:58:45.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章-Android基础入门">第1章 Android基础入门</h2><h3 id="填空题">填空题</h3><ol><li>Dalvik虚拟机中的Dx工具会把部分class文件转换成<u><strong><code>dex</code></strong></u>文件</li><li>如果希望在XML布局文件中调用颜色资源文件，可以使用<u><strong><code>@color</code></strong></u>调用</li><li>Android程序入口的Activity是在<u><strong><code>AndroidManifest.xml</code></strong></u>文件中注册的</li><li>Android中查看应用程序日志的工具是<u><strong><code>LogCat</code></strong></u></li></ol><h3 id="判断题">判断题</h3><ol><li><p>Dalvik虚拟机是Google公司设计的用于Android平台的虚拟机（ ✔ ）</p></li><li><p>Android应用程序的主要语言是Java。（ ✔ ）</p></li><li><p>Android采用分层结构，分别是应用程序层、应用程序框架层、核心类库和Linux内核（ ✔ ）</p></li><li><p>第三代移动通信技术（3G）包括TD-LTE和FDD-LTE两种制式（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>世界3G技术的3大标准：美国CDMA2000，欧洲WCDMA，中国TD-SCDMA</p><p>4G LTE系统有两种制式：TD-LTE和FDD-LTE</p>              </div>            </details></li><li><p>Android程序中，<code>Log.e()</code>用于输出警告级别的日志信息（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P29：</p><table><thead><tr><th>日志输出方法</th><th>日志级别</th><th>备注</th></tr></thead><tbody><tr><td><code>Log.v()</code></td><td>verbose</td><td>打印琐碎、意义较小的日志信息</td></tr><tr><td><code>Log.d()</code></td><td>debug</td><td>打印一些调试信息</td></tr><tr><td><code>Log.i()</code></td><td>information</td><td>打印一些比较重要的数据</td></tr><tr><td><code>Log.w()</code></td><td>warn</td><td>打印一些警告信息</td></tr><tr><td><code>Log.e()</code></td><td>error</td><td>打印程序中的错误信息</td></tr></tbody></table>              </div>            </details></li><li><p>每个Dalvik虚拟机实例都是一个独立的进程空间，并且每个进程之间不可以通信（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P16：每个Android应用程序都运行在一个Dalvik虚拟机实例中，而每一个Dalvik虚拟机实例都是一个独立的进程空间，每个进程之间可以通信。</p>              </div>            </details></li></ol><h3 id="选择题">选择题</h3><ol><li><p>Dalvik虚拟机是基于（    ）的架构<br>A. 栈<br>B. 堆<br>C. 寄存器<br>D. 存储器<br><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P4：Dalvik虚拟机是Google 公司设计的，是在Android平台上运行的虚拟机，其指令集基于寄存器架构，通过执行其特有的dex文件来实现对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。</p>              </div>            </details></li><li><p>Android程序中的主题和样式资源，通常放在哪个目录下（    ）<br>A. res/drawable<br>B. res/layout<br>C. res/values<br>D. res/assets<br><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P22：主题资源定义在res/values目录下的styles.xml文件中</p>              </div>            </details></li><li><p>下列关于AndroidManifest.xml文件的说法中，错误的是（    ）<br>A. 它是整个程序的配置文件<br>B. 可以在该文件中配置程序所需的权限<br>C. 可以在该文件中注册程序用到的组件<br>D. 该文件可以设置UI布局<br><strong>答案：D</strong></p></li><li><p>Dalvik虚拟机属于Android体系结构中的哪一层（    ）<br>A. 应用程序层<br>B. 应用程序框架层<br>C. 核心类库层<br>D. Linux内核层<br><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P3：</p><ol><li>应用程序层：一个核心应用程序的集合，所有安装在手机上的应用程序都属于这一层。</li><li>应用程序框架层：提供了构建应用程序时用到的各种API，例如活动管理器(Activity Manager)、通知管理器(Notification Manager)、内容提供者(Content Provider)等</li><li>核心类库：中包含了系统库及Android运行时库（Android Runtime）。<ul><li>系统库通过C/C++库为Android提供主要的特性支持，如OpenGL/ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持</li><li>Android运行时库主要提供了一些核心库，能够允许开发者使用Java语言来编写Android应用程序。另外，Android运行时库中还包含了<strong>Dalvik虚拟机</strong>，它使得每一个Android应用程序都能运行在独立的进程中，并且拥有一个自己的Dalvik虚拟机实例。</li></ul></li><li>Linux内核层：为Android设备的各种硬件提供了底层的驱动，如显示驱动（Display Driver）、音频驱动（Aduio Drivers）、照相机驱动（Camera Driver）、蓝牙驱动（Bluetooth Driver）、电源管理驱动（Power Management）等</li></ol>              </div>            </details></li><li><p>Android中短信、联系人管理、浏览器等属于Android体系结构中的哪一层（    ）<br>A. 应用程序层<br>B. 应用程序框架层<br>C. 核心类库层<br>D. Linux内核层<br><strong>答案：A</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P3：</p><ol><li>应用程序层：一个核心应用程序的集合，<strong>所有安装在手机上的应用程序</strong>都属于这一层。</li><li>.应用程序框架层：提供了构建应用程序时用到的各种API，例如活动管理器(Activity Manager)、通知管理器(Notification Manager)、内容提供者(Content Provider)等</li><li>核心类库：中包含了系统库及Android运行时库（Android Runtime）。<ul><li>系统库通过C/C++库为Android提供主要的特性支持，如OpenGL/ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持</li><li>Android运行时库主要提供了一些核心库，能够允许开发者使用Java语言来编写Android应用程序。另外，Android运行时库中还包含了<strong>Dalvik 虚拟机</strong>，它使得每一个Android应用程序都能运行在独立的进程中，并且拥有一个自己的Dalvik虚拟机实例。</li></ul></li><li>Linux内核层：为Android设备的各种硬件提供了底层的驱动，如显示驱动（Display Driver）、音频驱动（Aduio Drivers）、照相机驱动（Camera Driver）、蓝牙驱动（Bluetooth Driver）、电源管理驱动（Power Management）等</li></ol>              </div>            </details></li></ol><h3 id="简答题">简答题</h3><ol><li><p>简述如何搭建Android开发环境。<br>答：Android开发环境的搭建分为几个关键步骤：</p><ul><li>下载并安装AndroidStudio工具，进行相关配置设置，包括安装路径和工具设置。</li><li>创建模拟器，选择合适的模拟设备，下载所需的AndroidSDKSystemImage并创建模拟设备。</li><li>下载所需的SDK版本和SDKTools工具，可以在AndroidStudio中的DefaultSettings中进行下载和设置。</li></ul></li><li><p>简述Android源代码的编译过程。<br>答：Android源代码编译过程包括以下步骤：</p><ul><li>Java源文件经过JDK编译器编译为class文件。</li><li>Dalvik虚拟机中的Dx工具将部分class文件转换为dex文件。</li><li>dex文件在Dalvik虚拟机中进一步优化成odex文件。</li></ul></li><li><p>简述Android系统架构包含的层次以及各层的特点。<br>答：Android系统架构分为四个层次：</p><ul><li>应用程序层（Applications）：包含手机中安装的应用程序集合。</li><li>应用程序框架层（ApplicationFramework）：提供构建应用程序所需的API，例如活动管理器。</li><li>核心类库（Libraries）：包含系统库和Android运行环境。</li><li>Linux内核（LinuxKernel）：提供底层驱动，如显示驱动和音频驱动，与设备硬件交互。</li></ul></li></ol><h2 id="第2章-Android常见界面布局">第2章 Android常见界面布局</h2><h3 id="填空题-2">填空题</h3><ol><li>Android的常见布局都直接或者间接地继承自<u><strong><code>ViewGroup</code></strong></u>类</li><li>Android中的TableLayout继承自<u><strong><code>LinearLayout</code></strong></u></li><li>TableLayout可以通过<u><strong><code>TableRow</code></strong></u>控制表格的行数</li><li><u><strong><code>RelativeLayout</code></strong></u>布局通过相对定位的方式指定子控件的位置</li><li>在R.java文件中，<code>android:id</code>属性会自动生成对应的<u><strong><code>int</code></strong></u>类型的值</li></ol><h3 id="判断题-2">判断题</h3><ol><li><p>ViewGroup是盛装界面控件的容器（ ✔ ）</p></li><li><p>如果在FrameLayout中放入3个所有属性都相同的按钮，那么能够在屏幕上显示的是第1个被添加的按钮（ ❌ ）</p></li><li><p>Android中的布局文件通常放在<code>res/layout</code>文件夹中（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P31：布局文件通常放在res/layout文件夹中，我们可以在该文件夹的XML布局文件中编写布局。</p>              </div>            </details></li><li><p>TableLayout继承自LinearLayout，因此它完全支持LinearLayout所支持的属性（ ✔ ）</p></li><li><p>LinearLayout中的<code>android:layout_weight</code>属性用于设置布局内控件所占的权重（ ✔ ）</p></li></ol><h3 id="选择题-2">选择题</h3><ol><li><p>下列属性中，用于设置LinearLayout方向的是（    ）<br>A. <code>orientation</code><br>B. <code>gravity</code><br>C. <code>layout_gravity</code><br>D. <code>padding</code><br><strong>答案：A</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>android:orientation</code></td><td>设置布局内控件的排列顺序</td></tr><tr><td><code>android:gravity</code></td><td>设置文本内容的位置，如设置成“center” ,文本将居中显小</td></tr><tr><td><code>layout_gravity</code></td><td>设置该View相对与父View的位置</td></tr><tr><td><code>android:padding </code></td><td>设置当前布局与该布局中控件的距离</td></tr></tbody></table>              </div>            </details></li><li><p>下列选项中，不属于Android布局的是（    ）<br>A. FrameLayout<br>B. LinearLayout<br>C. Button<br>D. RelativeLayout<br><strong>答案：C</strong></p></li><li><p>FrameLayout是将其中的组件放在自己的哪个位置（    ）<br>A. 左上角<br>B. 右上角<br>C. 左下角<br>D. 右下角<br><strong>答案：A</strong></p></li><li><p>对于XML布局文件，<code>android:layout_width</code>属性的值不可以是什么（    ）<br>A. <code>match_parent</code><br>B. <code>fill_parent</code><br>C. <code>wrap_content</code><br>D. <code>match_content</code><br><strong>答案：D</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P33：android:layout_width</p><p>该属性用于设置布局的宽度，其值可以是具体的尺寸，如50dp,也可以是系统定义的值。系统定义的 值的具体介绍如下。</p><ul><li><strong>fill_parent</strong>：表示该布局的宽度与父容器（从根元素讲是屏幕）的宽度相同。</li><li><strong>match_parent</strong>：与fill_parent的作用相同，从Android 2.2.0开始推荐使用match_parent。</li><li><strong>wrap_content</strong>：表示该布局的宽度恰好能包裹它的内容。</li></ul>              </div>            </details></li><li><p>下列关于RelativeLayout的描述，正确的是（    ）<br>A. RelativeLayout表示绝对布局，可以自定义控件的x、y的位置<br>B. RelativeLayout表示帧布局，可以实现标签切换的功能<br>C. RelativeLayout表示相对布局，其中控件的位置都是相对位置<br>D. RelativeLayout表示表格布局，需要配合TableRow布局一起使用<br><strong>答案：C</strong></p></li></ol><h3 id="简答题-2">简答题</h3><ol><li>列举Android中的常用布局，并简述它们各自的特点<br>Android中有五种常用布局，分别为RelativeLayout（相对布局）、LinearLayout（线性布局）、FrameLayout（帧布局）、TableLayout（表格布局）、ConstraintLayout（约束布局），他们的特点具体如下：<ul><li><strong>RelativeLayout（相对布局）</strong>：该布局是通过相对位置的方式指定该布局内子控件的位置。</li><li><strong>LinearLayout（线性布局）</strong>：该布局可通过<code>android:orientation</code>属性指定该布局内的子控件水平和竖直排列。</li><li><strong>TableLayout（表格布局）</strong>：采用行、列的形式来管理控件。m通常搭配TableRow布局使用，一个TableRow代表一行，在TableRow中添加的控件代表一列。</li><li><strong>FrameLayout（帧布局）</strong>：该布局会在屏幕上创建一块空白区域，添加到该区域中的每个子控件占一帧，这些帧会一个一个叠加在一起，后加入的控件会叠加在上一个控件上层。默认情况下，帧布局中的所有控件会与左上角对齐。</li><li><strong>ConstraintLayout（约束布局）</strong>：该布局是Android2.2新添加的布局，他适用于可视化的方式编写界面布局，他有相对定位、居中定位和倾向、Chain等性质。</li></ul></li></ol><h2 id="第3章-Android常见界面控件">第3章 Android常见界面控件</h2><h3 id="判断题-3">判断题</h3><ol><li><p>Android的控件样式，其每一个XML属性都对应一个Java方法。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>Android中的控件样式除了可以使用XML属性设置，也可以使用Java中的方法设置。<strong>控件的每一个XML属性都对应一个Java方法</strong>，例如，TextView控件的<code>android:textColor</code>属性对应的是Java中的<code>setTextColor()</code>方法。</p>              </div>            </details></li><li><p>当指定RadioButton控件的<code>android:checked</code>属性为true时，表示该控件为未选中状态。（ ❌ ）</p></li><li><p>AlertDialog对话框能够直接通过new关键字创建对象。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p><img src="https://oss.iuoyt.com/img/posts/image-20231223161435868.png" alt="image-20231223161435868"></p>              </div>            </details></li><li><p>Toast是Android提供的轻量级信息提醒机制，用于向用户提示即时消息。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P57：<strong>Toast类是Android提供的轻量级信息提醒机制，用于向用户提示即时消息</strong>，它显示在应用程序界面的最上层，显示一段时间后自动消失不会打断当前操作，也不获得焦点。</p>              </div>            </details></li><li><p>ListView控件中的数据是通过数据适配器加载的。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P66：在Android 5.0之后，Google公司提供了用于在有限的窗口范围内显示大量数据的控件RecyclerView。与ListView控件相似，RecyclerView控件同样是以列表的形式展示数据，并且数据<strong>都是通过数据适配器加载</strong>的。但是，RecyclerView控件的功能更加强大。</p>              </div>            </details></li></ol><h3 id="选择题-3">选择题</h3><ol><li><p>在XML布局文件中定义了一个Button控件，决定Button控件上显示的文字的属性是（    ）。<br>A. <code>android:value</code><br>B. <code>android:text</code><br>C. <code>android:id</code><br>D. <code>android:textvalue</code><br><strong>答案：B</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>android:value</code></td><td>为属性分配的值</td></tr><tr><td><code>android:text</code></td><td>显示的文本信息</td></tr><tr><td><code>android:id</code></td><td>设置布局的标识</td></tr><tr><td><code>android:textvalue</code></td><td>（不存在该属性）</td></tr></tbody></table>              </div>            </details></li><li><p>下列选项中，哪个用于设置TextView控件中文字的大小？（    ）<br>A. <code>android:textSize=&quot;18&quot;</code><br>B. <code>android:size=&quot;18&quot;</code><br>C. <code>android:textSize='18sp'</code><br>D. <code>android:size=&quot;18sp&quot;</code><br><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>在Android中，<code>android:textSize</code>属性用于设置TextView控件中文字的大小。在这个属性中，你可以指定文字大小的单位，通常使用<code>sp</code>（缩放独立像素）作为单位，以确保在不同屏幕密度上有更好的适应性。</p>              </div>            </details></li><li><p>使用EditText控件时，当文本内容为空时，如果想做一些提示，那么可以使用的属性是（    ）。<br>A. <code>android:text</code><br>B. <code>android:background</code><br>C. <code>android:inputType</code><br>D. <code>android:hint</code><br><strong>答案：D</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>android:text</code></td><td>显示的文本信息</td></tr><tr><td><code>android:background</code></td><td>设置背景样式</td></tr><tr><td><code>android:inputType</code></td><td>设置输入类型</td></tr><tr><td><code>android:hint</code></td><td>设置一个在文本框中显示的提示文本</td></tr></tbody></table>              </div>            </details></li><li><p>为了让一个ImageView控件显示一张图片，可以设置的属性是（    ）。<br>A. <code>android:src</code><br>B. <code>android:background</code><br>C. <code>android:img</code><br>D. <code>android:value</code><br><strong>答案：A</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P51：ImageView控件常用属性</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td><code>android:layout_width</code></td><td>设置ImageView控件的宽度</td></tr><tr><td><code>android:layout_height</code></td><td>设置ImageView控件的高度</td></tr><tr><td><code>android:id</code></td><td>设置ImageView控件的唯一标识</td></tr><tr><td><code>android:background</code></td><td>设置ImageView控件的背景</td></tr><tr><td><code>android:layout_margin</code></td><td>设置当前控件与屏幕边界或周围控件的距离</td></tr><tr><td><code>android:src</code></td><td><strong>设置ImageView控件需要显示的图片资源</strong></td></tr><tr><td><code>android:scaleType</code></td><td>将图片资源缩放或移动，以适应ImageView控件的宽高</td></tr><tr><td><code>android:tint</code></td><td>将图片渲染成指定的颜色</td></tr></tbody></table>              </div>            </details></li><li><p>下列关于ListView控件的说法中，正确的是（    ）。<br>A. ListView控件的条目不能设置点击事件<br>B. ListView控件不设置数据适配器也能显示数据内容<br>C. 当数据超出能显示的范围时，ListView自动具有可滚动的特性<br>D. 一共有100条数据，若ListView控件当前能显示10条，则产生了100个View控件<br><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>A. ListView 控件的条目是可以设置点击事件的，通常通过设置 <code>OnItemClickListener</code> 来处理点击事件</p><p>B. 为了在 ListView 中显示数据，需要使用数据适配器（例如 ArrayAdapter、BaseAdapter 等）将数据与 ListView 绑定在一起</p><p>D. ListView 控件不会直接创建所有的 View 控件来显示数据，而是根据需要动态地创建和重用 View 控件。在屏幕上一次性显示的 View 控件数量通常是可见项的个数，而不是数据的总条目数。这样可以提高性能并减少内存占用。</p>              </div>            </details></li><li><p>CheckBox控件被选中的监听事件通常使用以下哪个方法？（    ）<br>A. <code>setOnClickListener</code><br>B. <code>setOnCheckedChangeListener</code><br>C. <code>setOnMenuItemSelectedListener</code><br>D. <code>setOnCheckedListener</code><br><strong>答案：B</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>通常，会使用 <code>setOnCheckedChangeListener</code> 方法来监听 CheckBox 控件的选中状态变化。这个方法接受一个 <code>CompoundButton.OnCheckedChangeListener</code> 接口作为参数，当 CheckBox 的状态发生改变时，会触发该接口的回调方法。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CheckBox</span> <span class="variable">checkBox</span> <span class="operator">=</span> findViewById(R.id.checkBox);</span><br><span class="line"></span><br><span class="line">checkBox.setOnCheckedChangeListener(<span class="keyword">new</span> <span class="title class_">CompoundButton</span>.OnCheckedChangeListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="type">boolean</span> isChecked)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理 CheckBox 被选中或取消选中的事件</span></span><br><span class="line">        <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">            <span class="comment">// CheckBox 被选中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// CheckBox 被取消选中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details></li><li><p>当使用EditText控件时，能够将文本框设置为多行显示的属性是（    ）<br>A. <code>android:lines</code><br>B. <code>android:layout_height</code><br>C. <code>android:textcolor</code><br>D. <code>android:textsize</code><br><strong>答案：A</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>使用 <code>android:lines</code> 属性可以将 EditText 控件设置为多行显示。这个属性用于指定 EditText 中显示的行数。例如，设置 <code>android:lines=&quot;3&quot;</code> 可以将 EditText 的高度设置为显示三行文本的高度。</p>              </div>            </details></li><li><p>下列关于AlertDialog对话框的描述，错误的是（    ）。<br>A. 使用new关键字创建AlertDialog对话框的实例<br>B. 对话框的显示需要调用<code>show()</code>方法<br>C. <code>setPositiveButton()</code>方法是用来设置确定按钮的<br>D. <code>setNegativeButton()</code>方法是用来设置取消按钮的<br><strong>答案：A</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p><img src="https://oss.iuoyt.com/img/posts/image-20231223161435868.png" alt="image-20231223161435868"></p>              </div>            </details></li></ol><h3 id="简答题-3">简答题</h3><ol><li><p>简述ListView与RecyclerView的区别<br>答：ListView与RecyclerView的区别包括：</p><ul><li><strong>展示效果</strong>：RecyclerView通过LayoutManager支持更多的布局方式，如横向、竖向列表、瀑布流、GridView等；ListView只能实现竖直的列表效果。</li><li><strong>适配器</strong>：RecyclerView使用<code>RecyclerView.Adapter</code>，将<code>getView()</code>方法拆分为<code>onCreateViewHolder()</code>和<code>onBindViewHolder()</code>，强制使用ViewHolder，使代码规范化，性能更优。</li><li><strong>复用效果</strong>：RecyclerView自动管理Item对象的复用，ListView需要手动处理convertView的复用。</li><li><strong>动画效果</strong>：RecyclerView可通过<code>setItemAnimator()</code>方法添加Item动画效果，ListView不支持直接为Item添加动画效果。</li></ul></li><li><p>简述实现Button按钮的点击事件的方式有哪几种？<br>答：实现Button点击事件的方式有三种：</p><ul><li>在布局文件中指定onClick属性的方式设置点击事件。</li><li>使用匿名内部类的方式设置点击事件。</li><li>通过为Activity实现OnClickListener接口的方式设置点击事件。</li></ul></li><li><p>简述AlertDialog对话框的创建过程<br>答：AlertDialog对话框创建步骤如下：</p><ul><li>调用AlertDialog的静态内部类Builder创建AlertDialog.Builder的对象。</li><li>调用AlertDialog.Builder的<code>setTitle()</code>和<code>setIcon()</code>方法分别设置AlertDialog对话框的标题名称和图标。</li><li>调用AlertDialog.Builder的<code>setMessage()</code>、<code>setSingleChoiceItems()</code>或者<code>setMultiChoiceItems()</code>方法设置AlertDialog对话框的内容为简单文本、单选列表或者为多选列表。</li><li>调用AlertDialog.Builder的<code>setPositiveButton()</code>和<code>setNegativeButton()</code>方法设置AlertDialog对话框的确定和取消按钮。</li><li>调用AlertDialog.Builder的<code>create()</code>方法创建AlertDialog对象。</li><li>调用AlertDialog对象的<code>show()</code>方法显示该对话框。</li><li>调用AlertDialog对象的<code>dismiss()</code>方法取消该对话框。</li></ul> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p><img src="https://oss.iuoyt.com/img/posts/image-20231223161435868.png" alt="image-20231223161435868"></p>              </div>            </details></li></ol><h2 id="第4章-程序活动单元Activity">第4章 程序活动单元Activity</h2><h3 id="填空题-3">填空题</h3><ol><li><p>Activity的启动模式包括standard、singleTop、singleTask和<u><strong><code>singleInstance</code></strong></u></p></li><li><p>启动一个新的Activity并且获取这个Activity的返回数据，需要重写<u><strong><code>startActivityForResult()</code></strong></u>方法。</p></li><li><p>发送隐式Intent后，Android会使用<u><strong><code>IntentFilter</code></strong></u>匹配相应的组件。</p></li><li><p>在清单文件中Activity添加&lt;intent-filter&gt;标签时，必须添加的属性名为<u><strong><code>&lt;category android:name = &quot;android.intent.category.DEFAULT&quot;/&gt;</code></strong></u>，否则隐式Intent无法开启该Activity。</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P85：需要注意的是，在使用隐式Intent开启Activity时，系统会默认为该Intent添加category属性的name，其值为<code>android.intent.category.DEFAULT</code>，因此为了被开启的Activity能够接收隐式Intent，必须在AndroidManifest.xml 文件中Activity对应的<code>&lt;intent-filter&gt;&lt;/intent-filter&gt;</code>标签中，将Activity的&lt;category/&gt;<code>标签中属性</code>android:name<code> 的值设置为</code>androidintent.category.DEFAULT`。</p>              </div>            </details></li><li><p>Activity的<u><strong><code>finish()</code></strong></u>方法用于关闭当前的Activity。</p></li></ol><h3 id="判断题-4">判断题</h3><ol><li><p>如果Activity不设置启动模式，则默认为standard。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <ol><li><p><strong>standard（默认模式）</strong></p><p>每启动一个Activity，就会在栈顶创建一个新的实例。</p></li><li><p><strong>singleTop</strong></p><p>如果该 Activity 已经是任务栈的栈顶，则不会创建新实例，而是通过 <code>onNewIntent</code> 方法传递新的 Intent。如果不在栈顶，则会创建新实例并放入栈顶。</p></li><li><p><strong>singleTask</strong></p><p>如果该 Activity 在任务栈中已存在，则将其上的所有 Activity 出栈，使得该 Activity 成为栈顶。如果不存在，则创建一个新实例。</p></li><li><p><strong>singleInstance</strong></p><p>类似 <code>singleTask</code>，但它会创建一个新的任务栈，并且该 Activity 是这个任务栈中的唯一 Activity。通常用于单独运行的任务，与其他应用的任务隔离。</p></li></ol>              </div>            </details></li><li><p>Fragment与Activity的生命周期方法是一致的。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">Activity</th><th style="text-align:center">Fragment</th><th>方法作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>onAttach()</code></td><td style="text-align:center"></td><td style="text-align:center">✔</td><td>和 Activity 建立关联时调用</td></tr><tr><td style="text-align:center"><code>onCreate()</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td>创建时调用，通常做一些初始化设置。</td></tr><tr><td style="text-align:center"><code>onCreateView()</code></td><td style="text-align:center"></td><td style="text-align:center">✔</td><td>创建视图（加载布局）时调用</td></tr><tr><td style="text-align:center"><code>onActivityCreated()</code></td><td style="text-align:center"></td><td style="text-align:center">✔</td><td>相关联的Activity已经创建完成时调用</td></tr><tr><td style="text-align:center"><code>onStart()</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td>即将可见时调用。</td></tr><tr><td style="text-align:center"><code>onResume()</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td>获取焦点时调用</td></tr><tr><td style="text-align:center"><code>onPause()</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td>被其他Activity覆盖或屏幕锁屏时调用</td></tr><tr><td style="text-align:center"><code>onStop()</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td>对用户不可见时调用</td></tr><tr><td style="text-align:center"><code>onDestroyView()</code></td><td style="text-align:center"></td><td style="text-align:center">✔</td><td>关联的视图被移除时调用</td></tr><tr><td style="text-align:center"><code>onRestart()</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td>从停止状态到再次启动状态时调用</td></tr><tr><td style="text-align:center"><code>onDestroy()</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td>销毁时调用</td></tr><tr><td style="text-align:center"><code>onDetach()</code></td><td style="text-align:center"></td><td style="text-align:center">✔</td><td>和 Activity 解除关联时调用</td></tr></tbody></table><p><img src="https://oss.iuoyt.com/img/posts/image-20231223171216425.png" alt="image-20231223171216425"></p><p><img src="https://oss.iuoyt.com/img/posts/image-20231223171146580.png" alt="image-20231223171146580"></p>              </div>            </details></li><li><p>如果想要关闭当前的Activity，可以调用Activity提供的<code>finish()</code>方法。（ ✔ ）</p></li><li><p>&lt;intent-filter&gt;标签中间只能包含一个action属性。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P86：<code>&lt;intent-filter&gt;</code>标签中间<strong>可以罗列多个action属性</strong>，但是当使用隐式Intent激活组件时， 只要声明Intent携带的action属性与其中一个<code>&lt;intent-filter&gt;</code>标签的action属性相同，action属性就匹配成功。</p>              </div>            </details></li><li><p>默认情况下，Activity的启动模式是standard。（ ✔ ）</p></li></ol><h3 id="选择题-4">选择题</h3><ol><li><p>下列选项中，不属于Android四大组件的是（    ）。<br>A. Service<br>B. Activity<br>C. Handler<br>D. ContentProvider<br><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P79：Android 中的四大组件分别是 Activity（活动）、Service（服务）、ContentProvider（内容提供者） 和 BroadcastReceiver（广播接收者）</p>              </div>            </details></li><li><p>下列关于Android中Activity管理方式的描述中，正确的是（    ）。<br>A. Android以堆的形式管理Activity<br>B. Android以栈的形式管理Activity<br>C. Android以树的形式管理Activity<br>D. Android以链表的形式管理Activity<br><strong>答案：B</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P92：Android的任务栈是一种用来存放Activity实例的容器。任务栈最大的特点就是先进后出，它主要有两个基本操作，分别是压栈和出栈。通常Android应用程序都有一个任务栈，每打开一个Activity时，该Activity 就会被压入任务栈。每销毁一个Activity时，该Activity就会被弹出任务栈。用户操作的Activity永远都是栈顶的Activity。</p>              </div>            </details></li><li><p>下列选项中，哪个不是Activity生命周期方法？（    ）<br>A. <code>onCreate()</code><br>B. <code>startActivity()</code><br>C. <code>onStart()</code><br>D. <code>onResume()</code><br><strong>答案：B</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P80：Activity的生命周期方法</p><table><thead><tr><th style="text-align:center">方法名</th><th>方法作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>onCreate()</code></td><td>创建时调用，通常做一些初始化设置。</td></tr><tr><td style="text-align:center"><code>onStart()</code></td><td>即将可见时调用。</td></tr><tr><td style="text-align:center"><code>onResume()</code></td><td>获取焦点时调用</td></tr><tr><td style="text-align:center"><code>onPause()</code></td><td>被其他Activity覆盖或屏幕锁屏时调用</td></tr><tr><td style="text-align:center"><code>onStop()</code></td><td>对用户不可见时调用</td></tr><tr><td style="text-align:center"><code>onRestart()</code></td><td>从停止状态到再次启动状态时调用</td></tr><tr><td style="text-align:center"><code>onDestroy()</code></td><td>销毁时调用</td></tr></tbody></table><p><img src="https://oss.iuoyt.com/img/posts/image-20231223171216425.png" alt="image-20231223171216425"></p>              </div>            </details></li><li><p>下列方法中，哪个是启动Activity的方法？（    ）<br>A. <code>startActivity()</code><br>B. <code>goToActivity()</code><br>C. <code>startActivityForResult()</code><br>D. 以上都是<br><strong>答案：A</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P84：启动和关闭Activity</p><ul><li>启动Activity：创建Activity后，可以通过<code>startActivity()</code>方法启动创建的Activity。</li><li>关闭Activity：如果想要关闭当前的Activity，可以调用Activity提供的<code>finish()</code>方法</li></ul>              </div>            </details></li><li><p>下列关于Intent的描述中，正确的是（    ）。<br>A. Intent不能够实现应用程序间的数据共享<br>B. Intent可以实现界面的切换，还可以在不同组件间直接进行数据传递<br>C. 使用显式Intent可以不指定要跳转的目标组件<br>D. 隐式Intent不会明确指出需要激活的目标组件，所以无法实现组件之间的数据跳转<br><strong>答案：B</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>A. Intent是用于应用程序间通信的一种机制，因此可以用于实现应用程序间的数据共享</p><p>C. 使用显式Intent时，需要指定要跳转的目标组件。显式Intent用于明确指定要启动的组件。</p><p>D. 隐式Intent可以实现组件之间的数据跳转。虽然隐式Intent不会明确指出需要激活的目标组件，但通过匹配Intent的过滤条件，系统可以找到匹配的组件来处理Intent。</p>              </div>            </details></li></ol><h3 id="简答题-4">简答题</h3><ol><li><p>简述Activity的生命周期方法及什么时候被调用。<br>答：Activity一共有7个方法，这些方法和调用的时机具体如下：</p><ul><li><code>onCreate()</code>：Activity创建时调用，通常做一些初始化设置。</li><li><code>onStart()</code>：Activity即将可见时调用。</li><li><code>onResume()</code>：Activity获取焦点时调用。</li><li><code>onPause()</code>：当前Activity被其他Activity覆盖或屏幕锁屏时调用。</li><li><code>onStop()</code>：Activity对用户不可见时调用。</li><li><code>onDestroy()</code>：Activity销毁时调用。</li><li><code>onRestart()</code>：Activity从停止状态到再次启动时调用。</li></ul></li><li><p>简述Activity的四种启动模式及其特点。<br>答：Activity的四种启动模式分别为standard、singleTop、singleTask和singleInstance，这些模式的特点具体如下：</p><ul><li>standard（标准模式）：每启动一个Activity就会在栈顶创建一个新的实例。</li><li>singleTop（单顶模式）：当被启动的Activity位于栈顶时，复用该Activity实例。</li><li>singleTask（单任务模式）：当被启动的Activity在栈中存在实例时，会直接复用此Activity实例，并把当前Activity上面的所有实例弹出栈。</li><li>singleInstance（单实例模式）：会启动一个新的任务栈来管理该Activity。</li></ul></li><li><p>简述Activity、Intent、IntentFilter的作用。<br>答：</p><ul><li>Activity表示活动，是一个负责与用户交互的组件，每个Android应用中都会用Activity来显示界面以及处理界面上一些控件的事件。</li><li>Intent表示意图，是程序中各组件间进行交互的一种方式，它不仅可以指定当前组件要执行的动作，还可以在不同组件之间进行数据传递。</li><li>IntentFilter为过滤器，当发送一个隐式Intent后，Android系统会将它与程序中的每一个组件的过滤器进行匹配，匹配属性有action、data、category，需要这三个属性都匹配成功才能唤起相应的组件。</li></ul></li></ol><h2 id="第5章-数据存储">第5章 数据存储</h2><h3 id="判断题-5">判断题</h3><ol><li><p>SQLite是Android自带的一个轻量级的数据库，支持基本SQL语法。（ ✔ ）</p></li><li><p>Android中的文件存储方式，分为内部存储方式和外部存储方式。（ ✔ ）</p></li><li><p>使用<code>openFileOutput()</code>方法打开应用程序的输出流时，只需要指定文件名。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P108：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> </span><br><span class="line">    <span class="operator">=</span> openFileOutput(String name, <span class="type">int</span> mode)</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> </span><br><span class="line">    <span class="operator">=</span> openFileInput(String name)</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>openFileOutput()</code>方法用于打开应用程序中对应的输出流，将数据存储到指定的文件中； <code>openFilelnput()</code>方法用于打开应用程序对应的输入流，读取指定文件中的数据，它们的参数<code>name</code>表示文件名； <code>mode</code>表示文件的操作模式，也就是读写文件的方式。<code>mode</code>的取值有4种，具体如下：</p><ul><li>MODE_PRIVATE：该文件只能被当前程序读写</li><li>MODE_APPEND：该文件的内容可以追加</li><li>MODE_WORLD_READABLE：该文件的内容可以被其他程序读</li><li>MODE_WORLD_WRITEABLE：该文件的内容可以被其他程序写</li></ul>              </div>            </details></li><li><p>当AndroidSDK版本低于2.3时，应用程序想要操作SD卡数据，必须在清单文件中添加权限。（ ✔ ）</p></li><li><p>SQLiteDatabase类的<code>update()</code>方法用于删除数据库表中的数据。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P119：SQLiteDatabase基本操作</p><p>常用方法如下：</p><ul><li><p>新增数据</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert(</span><br><span class="line">    String table, </span><br><span class="line">    String nullColumnHack, </span><br><span class="line">    ContentValues values</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete(</span><br><span class="line">    String table, </span><br><span class="line">    String whereClause, </span><br><span class="line">    String[] whereArgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>修改数据</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">update(</span><br><span class="line">    String table, </span><br><span class="line">    ContentValues values, </span><br><span class="line">    String whereClause, </span><br><span class="line">    String[] whereArgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>查询数据</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query(</span><br><span class="line">String table, </span><br><span class="line">String[] columns, </span><br><span class="line">String selection, </span><br><span class="line">String[] selectionArgs, </span><br><span class="line">String groupBy, </span><br><span class="line">String having, </span><br><span class="line">String orderBy</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>执行SQL语句</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execSQL(String sql)</span><br></pre></td></tr></table></figure></li></ul>              </div>            </details></li><li><p>SQLite数据库的事务操作满足原子性、一致性、隔离性和持续性。（ ✔ ）</p></li></ol><h3 id="选择题-5">选择题</h3><ol><li><p>下列关于SharedPreferences存取文件的描述中，错误的是（    ）<br>A. 属于移动存储解决方式<br>B. SharedPreferences处理的就是键值对<br>C. 读取xml的路径是<code>/sdcard/shared_prefs</code><br>D. 文本的保存格式是xml<br><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P115：SharedPreferences存储</p><ul><li><p>SharedPreferences是Android平台上一个轻量级的存储类，当程序中有一些少量数据需要持久化存储时，可以使用SharedPreferences进行存储。例如存储程序中的用户名、密码、自定义的一些参数等。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取sp对象，参数“data”表示文件名，MODE_PRIVATE表示文件操作模式</span></span><br><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;data&quot;</span>, MODE_PRIVATE);</span><br><span class="line"><span class="comment">// 获取编辑器</span></span><br><span class="line">SharedPreferences.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sp.edit();</span><br><span class="line"><span class="comment">// 存入String类型数据</span></span><br><span class="line">editor.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">// 存入Int类型数据</span></span><br><span class="line">editor.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 提交存储的数据</span></span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure></li><li><p>由上述代码可知，Editor对象是以键值对（key/value）的形式保存数据的，并且根据数据类型的不同会调用不同的方法。操作完数据后，一定要调用<code>commit()</code>方法进行数据提交，否则所有操作不生效。</p></li><li><p>需要注意的是，SharedPreferences中的Editor编辑器是通过键值对的形式将数据保存在<code>data/data/&lt;package-name&gt;/shared_prefs</code> 文件夹的 XML 文件中，其中 value 值只能是 Float、Int、Long、Boolean、String、Set&lt;String&gt;类型的数据</p></li></ul>              </div>            </details></li><li><p>下列选项中，不属于<code>getSharedPreferences()</code>方法的文件操作模式参数是（    ）。<br>A. <code>Context.MODE_PRIVATE</code><br>B. <code>Context.MODE_PUBLIC</code><br>C. <code>Context.MODE_WORLD_READABLE</code><br>D. <code>Context.MODE_WORLD_WRITEABLE</code><br><strong>答案：B</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>Context.MODE_PRIVATE</code></td><td>创建的文件只能被当前应用访问</td></tr><tr><td><code>Context.MODE_WORLD_READABLE</code></td><td>表示文件可被其他应用读取，在较新的 Android 版本中已经被废弃</td></tr><tr><td><code>Context.MODE_WORLD_WRITEABLE</code></td><td>表示文件可被其他应用写入，在较新的 Android 版本中已经被废弃</td></tr></tbody></table>              </div>            </details></li><li><p>下列方法中，（    ）是SharedPreferences获取其编辑器的方法。<br>A. <code>getEdit()</code><br>B. <code>edit()</code><br>C. <code>setEdit()</code><br>D. <code>getAll</code><br><strong>答案：B</strong></p></li><li><p>Android对数据库的表进行查询操作时，会使用SQLiteDatabase类中的（    ）方法。<br>A. <code>insert()</code><br>B. <code>execSQL()</code><br>C. <code>query()</code><br>D. <code>update()</code><br><strong>答案：C</strong></p></li><li><p>下列关于SQLite数据库的描述中，错误的是（    ）。<br>A. SqliteOpenHelper类有创建数据库和更新数据库版本的功能<br>B. SqliteDatabase类是用来操作数据库的<br>C. 每次调用SqliteDatabase类的<code>getWritableDatabase()</code>方法时，都会执行SqliteOpenHelper类的<code>onCreate()</code>方法<br>D. 当数据库版本发生变化时，会调用SqliteOpenHelper类的<code>onUpgrade()</code>方法更新数据库<br><strong>答案：C</strong></p></li><li><p>下列初始化SharedPreferences的代码中，正确的是（    ）。<br>A. <code>SharedPreferencessp = newSharedPreferences();</code><br>B. <code>SharedPreferencessp = SharedPreferences.getDefault();</code><br>C. <code>SharedPreferencessp = SharedPreferences.Factory();</code><br>D. <code>SharedPreferencessp = getSharedPreferences();</code><br><strong>答案：D</strong></p></li></ol><h3 id="简答题-5">简答题</h3><ol><li><p>简述数据库事务的4个基本要素。<br>答：事务的操作比较严格，他必须满足ACID，ACID是指数据库事务正确执行的四个基本要素的缩写，这些要素包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），接下来针对这四个基本要素进行详细解释。</p><ul><li><strong>原子性</strong>：表示事务是一个不可再分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li><li><strong>一致性</strong>：表示事务开始之前和结束之后，数据库的完整性没有被破坏。也就是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</li><li><strong>隔离性</strong>：表示并发的事务是相互隔离的，也就是一个事务内部的操作都必须封锁起来，不会被其他事务影响到。</li><li><strong>持久性</strong>：表示事务一旦提交后，该事务对数据做的更改便持久保存在数据库中，并不会被回滚，即使出现了断电等事故，也不会影响数据库中的数据。</li></ul></li><li><p>简述Android数据存储的方式。<br>答：Android平台提供的五种数据存储方式，分别为文件存储、SharedPreferences、SQLite数据库、ContentProvider和网络存储，这些存储方式的特点如下。</p><ul><li>文件存储：Android提供了openFileInput()和openFileOutput()方法来读取设备上的文件，其读取方式与Java中I/O程序是完全一样的。</li><li>SharedPreferences：这是Android提供的用来存储一些简单的配置信息的一种机制，他采用了XML格式将数据存储到设备中。通常情况下，我们使用SharedPreferences存储一些应用程序的各种配置信息，如用户名、密码等。</li><li>SQLite数据库：SQLite是Android自带的一个轻量级的数据库，他运算速度快，占用资源少，还支持基本SQL语法，一般使用他作为复杂数据的存储引擎，可以存储用户信息等。</li><li>ContentProvider：Android四大组件之一，主要用于应用程序之间的数据交换，他可以将自己的数据共享给其他应用程序使用。</li><li>网络存储：需要与Android网络数据包打交道，将数据存储到服务器上，通过网络提供的存储空间来存储/获取数据信息。</li></ul></li></ol><h2 id="第6章-内容提供者和内容观察者">第6章 内容提供者和内容观察者</h2><h3 id="判断题-6">判断题</h3><ol><li><p>Uri主要由3部分组成，分别是scheme、authority和path。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P128：</p><p><strong>Uri主要由3部分组成，分别是scheme、authority和path</strong>。</p><ul><li>scheme是以<code>content://</code>开头的前缀，表示操作的数据被ContentProvider控制，不会被修改</li><li>authority表示为ContentProvider设置的唯一标识，该标识主要用来区分不同的应用程序，一般为了避免不同authority产生冲突，会采用程序包名的方式命名</li><li>path表示资源或数据，当访问者需要操作不同的数据时，该部分可以动态修改。</li></ul>              </div>            </details></li><li><p>内容观察者用于观察指定Uri代表的数据的变化。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P138：</p><p>如果应用程序需要实时监听ContentProvider共享的数据是否发生变化，则需要使用Android提供的内容观察者。</p>              </div>            </details></li><li><p>内容提供者的主要功能是实现跨程序共享数据的功能。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P127：</p><p>在Android中，应用程序之间是相互独立的，分别运行在自己的进程中。若应用程序之间需要<strong>共享数据，则会用到ContentProvider</strong>。ContentProvider是Android的四大组件之一，其功能是在不同程序之间实现数据共享。它不仅允许一个程序访问另一个程序中的数据，同时还可以选择只对哪一部分数据进行共享，从而保证程序中的隐私数据不被泄露。</p>              </div>            </details></li><li><p>在Android中，当通过内容解析者读取手机通讯录数据库的内容时，不需要加入读取手机通讯录的权限。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P134：</p><p>因为在获取手机通讯录数据之前，需要申请读取手机通讯录的权限，所以需要在ContactActivity 中创建<code>getPermissions()</code>方法用于申请读取手机通讯录的权限，同时还需要在ContactActivity中重写 <code>onRequestPermissionsResult()</code>方法，在该方法中获取读取通讯录权限是否申请成功的信息。</p>              </div>            </details></li><li><p>Android的UriMatcher类用于匹配Uri。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P131：</p><p>每个ContentProvider都会有一个Uri，当对ContentProvider中的数据进行操作时，会通过对应的Uri指 定相关的数据并进行操作。如果一个ContentProvider中含有多个数据源（例如多个表），就需要对不同的Uri 进行区分，此时可以用UriMatcher类对Uri进行匹配</p>              </div>            </details></li></ol><h3 id="选择题-6">选择题</h3><ol><li><p>如果一个应用程序想要访问另外一个应用程序的数据库，那么需要通过（    ）实现。<br>A. BroadcastReceiver<br>B. Activity<br>C. ContentProvider<br>D. AIDL<br><strong>答案：C</strong></p></li><li><p>下列方法中，哪个方法能够得到ContentProvider的实例对象？（    ）<br>A. <code>newContentResolver()</code><br>B. <code>getContentResolver()</code><br>C. <code>newInstance()</code><br>D. <code>ContentUris.newInstance()</code><br><strong>答案：B</strong></p></li><li><p>自定义内容观察者时，需要继承的类是（    ）。<br>A. BaseObserver<br>B. ContentObserver<br>C. BasicObserver<br>D. DefalutObserver<br><strong>答案：B</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P138：创建内容观察者</p><p>在Android程序中，创建一个继承ContentObserver类的MyObserver类，在该类中重写父类的构造方法与<code>onChange()</code>方法，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObserver</span> <span class="keyword">extends</span> <span class="title class_">ContentObserver</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyObserver</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(handler);</span><br><span class="line">&#125;</span><br><span class="line">©Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(<span class="type">boolean</span> selfChange)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.onChange(selfChange);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details></li><li><p>查询手机系统短信时，内容提供者对应的Uri为（    ）。<br>A. <code>Contacts.Photos.CONTENT_URI</code><br>B. <code>Contacts.People.CONTENT_URI</code><br>C. <code>“content://sms/”</code><br>D. <code>Media.EXTERNAL_CONTENT_URI</code><br><strong>答案：C</strong></p></li><li><p>下列关于ContentProvider的描述，错误的是（    ）。<br>A. ContentProvider是一个抽象类，只有继承后才能使用<br>B. ContentProvider只有在AndroidManifest.xml文件中注册后才能运行<br>C. ContentProvider为其他应用程序提供了统一的访问数据库的方式<br>D. 以上说法都不对<br><strong>答案：D</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>A、B、C都是对的，所以D是错的</p>              </div>            </details></li></ol><h3 id="简答题-6">简答题</h3><ol><li><p>简述内容提供者的工作原理。<br>答：假设B程序需要操作A程序数据库中的数据，一般需要A程序使用ContentProvider暴露数据，才能被其他程序操作。B程序通过ContentResolver操作A程序暴露出来的数据，而A程序会将操作结果返回给ContentResolver，然后ContentResolver再将操作结果返回给B程序。</p></li><li><p>简述内容观察者的工作原理。<br>答：使用ContentObserver观察A程序的数据时，首先要在A程序的ContentProvider中调用ContentResolver的<code>notifyChange()</code>方法。调用此方法后，当B程序操作A程序中的数据时，A程序会向“消息中心”发送数据变化的消息，此时C程序会观察到“消息中心”的数据有变化，会触发ContentObserver的<code>onChange()</code>方法。</p></li></ol><h2 id="第7章-广播机制">第7章 广播机制</h2><h3 id="填空题-4">填空题</h3><ol><li><u><strong><code>BroadcastReceiver</code></strong></u>用来监听来自系统或者应用程序的广播。</li><li>广播接收者的注册方式有两种，分别是<u><strong><code>动态注册</code></strong></u>和<u><strong><code>静态注册</code></strong></u>。</li></ol><h3 id="判断题-7">判断题</h3><ol><li><p>Broadcast表示广播，它是一种运用在应用程序之间传递消息的机制。（ ✔ ）</p></li><li><p>在清单文件注册广播接收者时，可在&lt;intent-filter&gt;标签中使用priority属性设置优先级别，属性值越大，优先级越高。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P156：</p><ul><li>在动态注册广播接收者时，可以使用IntentFilter对象的<code>setPriority()</code>方法设置优先级别，例如， <code>intentFilter.setPriority(1000)</code>。这里需要说明的是，<code>setPriority()</code>方法中传递的值越大，优先级越高。</li><li>如果两个广播接收者的优先级相同，则先注册的广播接收者优先级高。也就是说，如果两个程序监听了同一个广播事件，同时设置了相同的优先级，则先安装的程序优先接收。</li></ul>              </div>            </details></li><li><p>有序广播的广播效率比无序广播更高。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P155：</p><ul><li>无序广播是完全异步执行的，发送广播时，所有监听这个广播的广播接收者都会接收到此广播消息，但接收和执行的顺序不确定。无序广播的效率较高，但无法被拦截。</li><li>有序广播是按照广播接收者声明的优先级别被依次接收，发送广播时，只会有一个广播接收者能够接收此消息，在此广播接收者中逻辑执行完毕之后，广播才会继续传递。相比无序广播，有序广播的广播效率较低，但此类型广播的广播接收者是有先后顺序的，并可被拦截。</li></ul>              </div>            </details></li><li><p>动态注册的广播接收者的生命周期依赖于注册广播的组件。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P151：</p><p>动态注册的广播接收者是否被注销依赖于注册广播接收者的组件，例如在Activity中注 册了广播接收者，当Activity销毁时广播接收者也会被注销。</p>              </div>            </details></li><li><p>Android中广播接收者必须在清单文件里面注册。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>广播接收者的注册方式有两种，分别是动态注册和静态注册。</p><ul><li>动态注册是在Activity中通过代码注册广 播接收者</li><li>静态注册是在清单文件中通过配置广播接收者完成注册</li></ul><p>需要注意的是，在Android 8.0版本之后的系统中，通过静态注册方式注册的广播接收者已经接收不到广播了，必须通过动态注册才可以接收广播。</p>              </div>            </details></li></ol><h3 id="选择题-7">选择题</h3><ol><li><p>下列选项中关于广播类型的说法，错误的是（    ）。（多选）<br>A. Android中的广播类型分为有序广播和无序广播<br>B. 无序广播按照一定的优先级进行接收<br>C. 无序广播可以被拦截，可以被修改数据<br>D. 有序广播按照一定的优先级进行发送<br><strong>答案：BC</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P155：</p><ul><li>无序广播是完全异步执行的，发送广播时，所有监听这个广播的广播接收者都会接收到此广播消息，但接收和执行的顺序不确定。无序广播的效率较高，但无法被拦截。</li><li>有序广播是按照广播接收者声明的优先级别被依次接收，发送广播时，只会有一个广播接收者能够接收此消息，在此广播接收者中逻辑执行完毕之后，广播才会继续传递。相比无序广播，有序广播的广播效率较低，但此类型广播的广播接收者是有先后顺序的，并可被拦截。</li></ul>              </div>            </details></li><li><p>广播机制作为Android组件间的通信方式，使用的场景有哪些？（    ）（多选）<br>A. 在同一个App内部的同一组件内进行消息通信<br>B. 在不同App的组件之间进行消息通信<br>C. 在同一个App内部的不同组件之间进行消息通信（单个进程）<br>D. 在同一个App具有多个进程的不同组件之间进行消息通信<br><strong>答案：ABCD</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>广播作为Android组件间的通信方式，可以使用的场景有以下几种</p><ul><li>第1种场景：在同一个App内部的同一组件内进行消息通信（单个或多个线程之间）</li><li>第2种场景：在同一个App内部的不同组件之间进行消息通信（单个进程）</li><li>第3种场景：在同一个App具有多个进程的不同组件之间进行消息通信</li><li>第4种场景：在不同App的组件之间进行消息通信</li><li>第5种场景：在特定情况下，Android与App之间进行消息通信</li></ul><p>在上述场景中，第1种场景虽然可以使用广播机制，但是直接使用扩展变量作用域、接口的回调等方式 处理会相对比较简单；第2种场景使用广播机制来处理会比较复杂。只有第3、4、5种场景涉及不同进程 间的消息通信，非常适合使用广播机制的方式来处理。</p>              </div>            </details></li></ol><h3 id="简答题-7">简答题</h3><ol><li>广播机制的实现过程<br>答：Android中的广播使用观察者模式，实现过程如下：<ul><li>广播接收者通过Binder机制在AMS（ActivityManagerService）中进行注册。</li><li>广播发送者通过Binder机制向AMS发送广播。</li><li>AMS查找符合条件的广播接收者，将广播发送到相应的消息循环队列中。</li><li>执行消息循环时，获取到发送的广播，回调广播接收者的<code>onReceive()</code>方法并进行相关处理。</li></ul></li><li>有序广播和无序广播的区别<br>答：区别包括：<ul><li>发送广播方法不同：有序广播使用<code>sendOrderedBroadcast()</code>，而无序广播使用<code>sendBroadcast()</code>。</li><li>广播接收者执行顺序：<ul><li>有序广播的接收者按照优先级顺序执行，高优先级先执行。</li><li>无序广播是完全异步执行，接收和执行的顺序不确定。</li></ul></li><li>拦截广播：有序广播的接收者可以拦截广播，而无序广播不能被拦截。</li><li>效率：有序广播的效率相对较低，因为需要按照优先级顺序执行。</li></ul></li></ol><h2 id="第8章-服务">第8章 服务</h2><h3 id="填空题-5">填空题</h3><ol><li><p>如果想要停止<code>bindService()</code>方法启动的服务，需要调用<u><strong><code>unBindService()</code></strong></u>方法。</p></li><li><p>Android服务的通信方式分为<u><strong><code>本地服务</code></strong></u>和<u><strong><code>远程服务</code></strong></u>。</p></li><li><p>远程服务通过<u><strong><code>AIDL</code></strong></u>实现服务的通信。</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P175：</p><p>在Android中，各个应用程序都运行在自己的进程中，如果想要完成不同进程之间的通信，就需要使用远程服务通信。远程服务通信是通过AIDL（Android Interface Definition Language）实现的，它是一种接口定义语言（Interface Definition Language），其语法格式非常简单，与Java中定义接口类似，但是存在一些差异，具体介绍如下。</p><ul><li>AIDL定义接口的源代码必须以.aidl结尾。</li><li>AIDL接口中用到的数据类型，除了基本数据类型String、List、Map、CharSequence之外，其他类型全部都需要导入包，即使它们在同一个包中。</li></ul>              </div>            </details></li></ol><h3 id="判断题-8">判断题</h3><ol><li><p>服务运行在子线程中。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P165：</p><p>Service总是在后台运行，其运行并不是在子线程中而是在主线程中，只是它没有界面而已，它要处理的耗时操作需要开启子线程进行处理，否则程序会出现ANR (程序没有响应)异常。</p>              </div>            </details></li><li><p>不管使用哪种方式启动服务，它的生命周期都是一样的。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P166：</p><p>与Activity类似，服务也有生命周期，服务的生命周期与启动服务的方式有关。服务的启动方式有两种， 一种是通过<code>startService()</code>方法启动服务，另一种是通过<code>bindService()</code>方法启动服务。<strong>使用不同的方式启动服务， 其生命周期会不同。</strong></p><p><img src="https://oss.iuoyt.com/img/posts/image-20231223192449975.png" alt="image-20231223192449975"></p><p>由图可知，当调用<code>startService()</code>方法启动服务时，程序执行生命周期方法的顺序依次为<code>onCreate()</code>、<code> onStartCommand()</code>、<code>onDestroy()</code>。当通过<code>bindService()</code>方法启动服务时，执行生命周期方法的顺序依次为 <code>onCreate()</code>、 <code>onBind()</code>、<code>onUnbind()</code>、<code>onDestroy()</code>。</p>              </div>            </details></li><li><p>使用服务的通信方式进行通信时，必须保证服务是以绑定的方式开启的，否则无法通信。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P175：</p><p>在Android中，服务的通信方式有两种，一种是本地服务通信，另一种是远程服务通信。本地服务通信是指应用程序内部的通信，远程服务通信是指两个应用程序之间的通信。<strong>使用这两种方式进行通信时必须保证服务以绑定方式开启，否则无法进行通信和数据交换</strong></p>              </div>            </details></li><li><p>一个组件只能绑定一个服务。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P171：</p><p>当一个组件通过调用<code>bindService()</code>方法启动服务时，服务会与组件绑定，程序允许组件与服务交互，组件一旦退出或者调用<code>unbindService()</code>方法解绑服务，服务就会被销毁。<strong>多个组件可以绑定一个服务</strong>。</p>              </div>            </details></li><li><p>远程服务和本地服务都运行在同一个进程中。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>远程服务与本地服务的区别是：</p><ul><li>远程服务与调用者不在同一个进程里（即远程服务是运行在另外一个进程）</li><li>本地服务则是与调用者运行在同一个进程里</li></ul>              </div>            </details></li></ol><h3 id="选择题-8">选择题</h3><ol><li><p>如果通过bindService方式开启服务，那么服务的生命周期是（    ）<br>A. <code>onCreate()</code>→<code>onStart()</code>→<code>onBind()</code>→<code>onDestroy()</code><br>B. <code>onCreate()</code>→<code>onBind()</code>→<code>onDestroy()</code><br>C. <code>onCreate()</code>→<code>onBind()</code>→<code>onUnBind()</code>→<code>onDestroy()</code><br>D. <code>onCreate()</code>→<code>onStart()</code>→<code>onBind()</code>→<code>onUnBind()</code>→<code>onDestroy()</code><br><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P167：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231223192449975.png" alt="image-20231223192449975"></p><p>由图可知，当调用<code>startService()</code>方法启动服务时，程序执行生命周期方法的顺序依次为<code>onCreate()</code>、<code> onStartCommand()</code>、<code>onDestroy()</code>。当通过<code>bindService()</code>方法启动服务时，执行生命周期方法的顺序依次为 <code>onCreate()</code>、 <code>onBind()</code>、<code>onUnbind()</code>、<code>onDestroy()</code>。</p>              </div>            </details></li><li><p>下列关于服务的描述中，错误的是（    ）<br>A. 服务没有用户可见的界面，不能与用户交互<br>B. 服务可以通过<code>Context.startService()</code>来启动<br>C. 服务可以通过<code>Context.bindService()</code>来启动<br>D. 服务无须在清单文件中进行配置<br><strong>答案：D</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P151：</p><p>广播接收者的注册方式有两种，分别是动态注册和静态注册。动态注册是在Activity中通过代码注册广播接收者，静态注册是在清单文件中通过配置广播接收者完成注册。需要注意的是，在Android 8.0版本之后的系统中，通过静态注册方式注册的广播接收者已经接收不到广播了，必须通过动态注册才可以接收广播。</p>              </div>            </details></li><li><p>下列关于服务的方法描述，错误的是（    ）<br>A. <code>onCreate()</code>表示第一次创建服务时执行的方法<br>B. 调用<code>startService()</code>方法启动服务时执行的方法是<code>onStartCommand()</code><br>C. 调用<code>bindService()</code>方法启动服务时执行的方法是<code>onBind()</code><br>D. 调用<code>startService()</code>方法断开服务绑定时执行的方法是<code>onUnbind()</code><br><strong>答案：D</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P167：服务生命周期中的方法</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>onCreate()</code></td><td>第一次创建服务时执行的方法</td></tr><tr><td><code>onStartCommand()</code></td><td>调用startService()方法启动服务时执行的方法</td></tr><tr><td><code>onBind()</code></td><td>调用<code>bindService()</code>方法启动服务时执行的方法</td></tr><tr><td><code>onUnbind()</code></td><td>调用<code>unBindService()</code>方法断开服务绑定时执行的方法</td></tr><tr><td><code>onDestory()</code></td><td>服务被销毁时执行的方法</td></tr></tbody></table><p><img src="https://oss.iuoyt.com/img/posts/image-20231223192449975.png" alt="image-20231223192449975"></p><p>由图可知，当调用<code>startService()</code>方法启动服务时，程序执行生命周期方法的顺序依次为<code>onCreate()</code>、<code> onStartCommand()</code>、<code>onDestroy()</code>。当通过<code>bindService()</code>方法启动服务时，执行生命周期方法的顺序依次为 <code>onCreate()</code>、 <code>onBind()</code>、<code>onUnbind()</code>、<code>onDestroy()</code>。</p>              </div>            </details></li></ol><h3 id="简答题-8">简答题</h3><ol><li><p>简述服务的两种启动方式的区别。<br>答：Service的启动方式分别可以调用<code>startService()</code>、<code>bindService()</code>方法，这两个启动方式的区别如下所示：</p><ul><li>生命周期不同：<br><code>startService()</code>：使用该方法开启Service时，执行的生命周期方法依次为<code>onCreate()</code>、<code>onStartCommand()</code>、<code>onDestroy()</code>。<br><code>bindService()</code>：使用该方法开启Service时，执行的生命周期方法依次为：<code>onCreate()</code>、<code>onBind()</code>、<code>onUnbind()</code>、<code>onDestroy()</code>。</li><li>停止服务的方法不同：<br><code>startService()</code>：调用<code>stopSelf()</code>、<code>stopService()</code>方法停止服务。<br><code>bindService()</code>：调用<code>unbindService()</code>方法停止服务。</li><li>组件的关联不同：<br><code>startService()</code>：当一个组件通过此方法开启服务时，服务与开启该组件没有关联，即使开启服务的组件被销毁，服务依旧运行。<br><code>bindService()</code>：当一个组件通过此方法开启服务时，服务会与该组件绑定，组件一旦被销毁，该服务也会被销毁。</li></ul></li><li><p>简述服务的生命周期。<br>答：使用不同的方式启动服务，其生命周期会不同。</p><ul><li>开启服务的方法分别为<code>startService()</code>、<code>bindService()</code>。<br>当通过<code>startService()</code>方法启动服务时，执行的生命周期方法依次为<code>onCreate()</code>、<code>onStartCommand()</code>、<code>onDestroy()</code>。<br>当通过<code>bindService()</code>方法启动服务时，执行的生命周期方法依次为<code>onCreate()</code>、<code>onBind()</code>、<code>onUnbind()</code>、<code>onDestroy()</code>。</li><li>其生命周期方法的具体含义如下：<br><code>onCreate()</code>：第一次创建服务时执行的方法。<br><code>onStartCommand()</code>：调用<code>startService()</code>方法启动服务时执行的方法。<br><code>onBind()</code>：调用<code>bindService()</code>方法启动服务时执行的方法。<br><code>onUnbind()</code>：调用<code>unBindService()</code>方法断开服务绑定时执行的方法。<br><code>onDestroy()</code>：服务被销毁时执行的方法。</li></ul></li></ol><h2 id="第9章-网络编程">第9章 网络编程</h2><h3 id="填空题-6">填空题</h3><ol><li>HttpURLConnection继承自<u><strong><code>URLConnection</code></strong></u>类。</li><li>Android默认提供的内置浏览器使用的是<u><strong><code>WebKit</code></strong></u>引擎。</li><li>在Android的解析JSON数据的org.json包中，最重要的两个类是<u><strong><code>JSONObject</code></strong></u>和JSONArray。</li></ol><h3 id="判断题-9">判断题</h3><ol><li><p>HttpURLConnection用于发送HTTP请求和获取HTTP响应。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P183：</p><p>Android对HTTP通信提供了很好的支持，通过标准的Java类HttpURLConnection便可实现基于URL的请求及响应功能。HttpURLConnection继承自URLConnection类，它可以发送和接收任何类型和长度的数据， 也可以设置网络请求的方式和超时时间。</p>              </div>            </details></li><li><p>Android中的WebView控件是专门用于浏览网页的，其使用方法与其他控件一样。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P185：</p><p>在Android程序中，WebView控件是专门用于浏览网页的，其使用方法与其他控件一样，既可以在XML 布局文件中使用&lt;WebView&gt;标签来添加，也可以在Java文件中使用new关键字来创建。</p>              </div>            </details></li><li><p>在Android中要访问网络，必须在AndroidManifest.xml中注册网络访问权限。（ ✔ ）</p></li><li><p>HttpURLConnection是抽象类，不能直接实例化对象，需要使用URL的<code>openConnection()</code>方法获得。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>URLConnection 与 HttpURLConnection都是抽象类，无法直接创建实例化对象， 但可以通过 <a href="http://java.net">java.net</a> 包 URL 类中的 openConnection()方法创建 URLConnection 与 HttpURLConnection实例</p>              </div>            </details></li><li><p>使用HttpURLConnection进行HTTP网络通信时，GET请求方式只能发送大小在1024字节内的数据。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P184：</p><p>GET方式以实体的方式得到由请求URL指向的资源信息，它向服务器提交的参数跟在请求URL后面。使用GET方式访问网络URL的内容一般要小于1024字节。</p>              </div>            </details></li></ol><h3 id="选择题-9">选择题</h3><ol><li><p>Android针对HTTP实现网络通信的方式主要包括（    ）。（多选）<br>A. 使用HttpURLConnection实现<br>B. 使用ServiceConnection实现<br>C. 使用HttpClient实现<br>D. 使用HttpConnection实现<br><strong>答案：AC</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>Android 中实现网络通信的方式主要包括使用 HttpURLConnection 和 HttpClient。其中，HttpURLConnection 是 Android 提供的一个用于执行 HTTP 请求的类，而 HttpClient 是 Apache 提供的一个强大的 HTTP 客户端库，Android 6.0 及以上版本不再推荐使用 HttpClient。</p><p>B 中的 ServiceConnection 是用于绑定服务的接口，并不直接用于实现网络通信。</p><p>D 中的 HttpConnection 并非 Android 标准的类。</p>              </div>            </details></li><li><p>Android中HttpURLConnection的输入／输出流操作被统一封装成了（    ）。（多选）<br>A. HttpGet<br>B. HttpPost<br>C. HttpRequest<br>D. HttpResponse<br><strong>答案：ABD</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>HttpClient实际上是对Java提供方法的一些封装，在HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost、HttpGet和HttpResponse</p>              </div>            </details></li></ol><h3 id="简答题-9">简答题</h3><ol><li>简述使用HttpURLConnection访问网络的步骤。<br>答：使用HttpURLConnection访问网络的步骤如下：<ul><li>创建URL对象。</li><li>调用URL对象的<code>openConnection()</code>方法获取HttpURLConnection对象。</li><li>调用<code>setRequestMethod()</code>方法设置http请求的方式。</li><li>通过<code>setConnectTimeout()</code>方法设置连接的超时时间。</li><li>调用<code>getInputStream()</code>方法获取服务器返回的输入流。</li><li>最后调用<code>disconnect()</code>方法关闭http连接。</li></ul></li></ol><h2 id="第10章-图形图像处理">第10章 图形图像处理</h2><h3 id="判断题-10">判断题</h3><ol><li><p>Paint类表示画笔，主要用于描述图形的颜色和风格。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>Paint类表示画笔，主要用于描述图形的颜色和风格，如线宽、颜色、透明度和填充效果等信息。</p>              </div>            </details></li><li><p>Android提供的Matrix类能够结合其他API对图形进行变换，例如旋转、缩放、倾斜。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P208：</p><p>Android提供了Matrix类，它本身并不能对图形或 图像进行变换，但是它与其他API结合能够控制图形图像的变换，例如旋转、缩放、倾斜等效果都能够实现。 接下来通过一张表来列举Matrix类中实现平移、旋转、缩放和倾斜特效对应的方法。</p>              </div>            </details></li><li><p>Bitmap类的decodeFile方法用于从文件中解析Bitmap对象。（ ✔ ）</p></li></ol><h3 id="选择题-10">选择题</h3><ol><li><p>下列关于Android动画的描述中，正确的是（    ）。（多选）<br>A. Android中的动画通常分为逐帧动画和补间动画两种<br>B. 逐帧动画就是顺序播放一组预定义的静态图像而形成的动画效果<br>C. 补间动画就是通过对场景中的对象不断进行图像变化来产生动画效果<br>D. 实现补间动画时，只需要定义动画开始和结束的关键帧，其他过渡由系统自动计算补齐<br><strong>答案：ABC</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P211：</p><p>为了实现这些动画效果，Android给我们提供了 3种动画模式，分别是补间动画、逐帧动画和属性动画。</p><ul><li>补间动画是通过对View进行一系列的动画操作来实现动画效果的，其中动画操作包括平移、 缩放、旋转、改变透明度等</li><li>逐帧动画是按照提前准备好的静态图像顺序播放，利用人眼的“视觉暂留”原理，让用户产生动画错觉的动画效果。逐帧动画的工作原理比较简单，其实就是将一个完整的动画拆分成一张一张单独的图片，然后再将这些图片按照顺序依次播放，类似播放电影的工作原理</li><li>在Android 3.0之后，Android给我们提供了一种全新的动画模式——属性动画，它是一种对属性值不断进行操作的模式，也就是可以将值赋给指定对象的指定属性，该指定属性可以是任意对象的任意属性。通过属性动画我们仍然可以对一个View进行平移、缩放、旋转和透明度渐变等操作，同时也可以对自定义View中的Point（点）对象进行动画操作。在实现这些动画操作时，我们只需要设置动画的运行时长、动画的类型、动画属性的初始值和结束值即可</li></ul>              </div>            </details></li><li><p>Android提供了哪些补间动画？（    ）。（多选）<br>A. 透明度渐变动画（AlphaAnimation）<br>B. 旋转动画（RotateAnimation）<br>C. 缩放动画（ScaleAnimation）<br>D. 平移动画（TranslateAnimation）<br><strong>答案：ABCD</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P211：</p><p>在Android中，补间动画包括透明度渐变动画（AlphaAnimation）、旋转动画（RotateAnimation）、缩放动画（ScaleAnimation）、平移动画（TranslateAnimation）</p>              </div>            </details></li><li><p>Android绘制图像时最常用的类包括（    ）。（多选）<br>A. Bitmap类<br>B. BitmapFactory类<br>C. Paint类<br>D. Canvas类<br><strong>答案：ABCD</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P205：</p><p>Android中常用的绘图类有Bitmap类、BitmapFactory类、Paint类及Canvas类，通过对这几个类的使用可以分别实现创建位图、将指定资源解析为位图、创建画笔、绘制画布功能。</p>              </div>            </details></li><li><p>在Android中，使用Canvas类中的（    ）方法可以绘制椭圆。<br>A. <code>drawRect()</code><br>B. <code>drawOval()</code><br>C. <code>drawCircle()</code><br>D. <code>drawLine()</code><br><strong>答案：B</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P207：Canvas类的常用绘图方法</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>drawRect()</code></td><td>使用画笔僦族巨形</td></tr><tr><td><code>drawOval()</code></td><td>使用画笔筑椭圆形</td></tr><tr><td><code>drawCircle()</code></td><td>使用画笔在指定位置画出指定半径的圆</td></tr><tr><td><code>drawLine()</code></td><td>使用画笔在指定位置国线</td></tr><tr><td><code>drawRoundRect()</code></td><td>使用画笔斛指定圆角矩形，其中rx表示x轴圆角半径，ry表示y轴圆角半径</td></tr></tbody></table>              </div>            </details></li><li><p>下列关于Canvas类的描述，错误的是（    ）。<br>A. Canvas类表示画布<br>B. Canvas类可以绘制各种各样的图形<br>C. Canvas类和Paint类的作用一样<br>D. Canvas类的<code>drawRect()</code>方法用于绘制矩形<br><strong>答案：C</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P207：</p><p>Canvas类代表画布，通过该类提供的方法可以绘制各种图形（如矩形、圆形、线条等）。Canvas类的常用绘图方法如下：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>drawRect()</code></td><td>使用画笔僦族巨形</td></tr><tr><td><code>drawOval()</code></td><td>使用画笔筑椭圆形</td></tr><tr><td><code>drawCircle()</code></td><td>使用画笔在指定位置画出指定半径的圆</td></tr><tr><td><code>drawLine()</code></td><td>使用画笔在指定位置国线</td></tr><tr><td><code>drawRoundRect()</code></td><td>使用画笔斛指定圆角矩形，其中rx表示x轴圆角半径，ry表示y轴圆角半径</td></tr></tbody></table>              </div>            </details></li></ol><h3 id="简答题-10">简答题</h3><ol><li><p><strong>简述逐帧动画的工作原理。</strong></p><p>答：逐帧（Frame）动画的工作原理非常简单，类似与动画片的工作原理，他按照事先准备好的静态图片顺序进行播放，并利用人眼的“视觉暂留”原理，让用户产生动画的错觉。</p></li></ol><h2 id="第11章-多媒体应用开发">第11章 多媒体应用开发</h2><h3 id="判断题-11">判断题</h3><ol><li><p>SurfaceView控件继承自View，它是显示图像的控件。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P233：</p><p><strong>SurfaceView控件继承自View，它是显示图像的控件</strong>，具有双缓冲技术，即其内部有两个线程，分别用于更新界面和后台计算，当完成各自的任务后可以无限循环交替更新和计算。SurfaceView控件的这种特性可以避免因画图任务繁重而造成主线程阻塞，从而提高程序的性能，因此在游戏开发中会常用到SurfaceView控件，例如设置游戏中的背景、人物、动画等。</p>              </div>            </details></li><li><p>SurfaceView控件具有双缓冲技术。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P233：</p><p>SurfaceView控件继承自View，它是显示图像的控件，<strong>具有双缓冲技术</strong>，即其内部有两个线程，分别用于更新界面和后台计算，当完成各自的任务后可以无限循环交替更新和计算。SurfaceView控件的这种特性可以避免因画图任务繁重而造成主线程阻塞，从而提高程序的性能，因此在游戏开发中会常用到SurfaceView控件，例如设置游戏中的背景、人物、动画等。</p>              </div>            </details></li><li><p>使用MediaPlayer类播放视频时，SurfaceView控件显示视频的时候必须要在子线程中更新。（ ❌ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P233：</p><p>使用VideoView控件播放视频虽然很方便，但是在播放视频时消耗的系统内存比较大。为此Android还提供了另一种播放视频的方式，就是将MediaPlayer类和SurfaceView控件结合使用。其中，MediaPlayer类用于播放视频，SurfaceView控件用于显示视频图像。 SurfaceView控件继承自View，它是显示图像的控件，具有双缓冲技术，即其内部有两个线程，分别用于更新界面和后台计算，当完成各自的任务后可以无限循环交替更新和计算。SurfaceView控件的这种特性可以避免因画图任务繁重而造成主线程阻塞，从而提高程序的性能，因此在游戏开发中会常用到SurfaceView控件，例如设置游戏中的背景、人物、动画等。</p>              </div>            </details></li><li><p>Android中可以使用SoundPool类同时播放多个音频文件。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P227：</p><p>由于使用MediaPlayer类播放音频时占用的内存资源较多，且不支持同时播放多个音频，所以Android还提供了另一个播放音频的类——SoundPool。SoundPool即音频池，<strong>可以同时播放多个短小的音频</strong>，而且占用的资源比较少，它适合在应用程序中播放按键音或者消息提示音等。</p>              </div>            </details></li><li><p>使用VideoView控件播放视频时，需要使用<code>setVideoPath()</code>方法设置播放视频路径。（ ✔ ）</p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P231：</p><p>播放本地视频时需要调用VideoView控件的<code>setVideoPath()</code>方法，将本地视频地址传入该方法中即可。</p><p>播放网络视频时需要调用VideoView控件的<code>setVideoURI()</code>方法，通过调用<code>parse()</code>方法将网 络视频地址转换为Uri并传递到<code>setVideoURI()</code>方法中。</p>              </div>            </details></li></ol><h3 id="选择题-11">选择题</h3><ol><li><p>下列关于多媒体应用开发的描述中，正确的是（    ）。（多选）<br>A. 可以使用MediaPlayer类或SoundPool类播放音频<br>B. 使用MediaPlayer类每次只能播放一个音频，适用于播放长音乐或背景音乐<br>C. 使用SoundPool类可以同时播放多个短小音频，适用于播放按键音或消息提示音<br>D. SoundPool类和SurfaceView控件一起使用，还可以播放视频<br><strong>答案：ABC</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P225：</p><p>Android应用程序中播放音频文件的功能一般都是通过MediaPlayer类实现的，该类提供了一些方法支持多种格式的音频文件。</p><p>P227：</p><p>由于使用MediaPlayer类播放音频时占用的内存资源较多，且不支持同时播放多个音频，所以Android还提供了另一个播放音频的类——SoundPool。SoundPool即音频池，<strong>可以同时播放多个短小的音频</strong>，而且占用的资源比较少，它适合在应用程序中播放按键音或者消息提示音等。</p><p>P233：</p><p>使用VideoView控件播放视频虽然很方便，但是在播放视频时消耗的系统内存比较大。为此Android还提供了另一种播放视频的方式，就是将MediaPlayer类和SurfaceView控件结合使用。其中，MediaPlayer类用于播放视频，SurfaceView控件用于显示视频图像。</p>              </div>            </details></li><li><p>MediaPlayer类中的setAudioStreamType（方法支持的音频类型包括（    ）。（多选）<br>A. 音乐<br>B. 响铃<br>C. 闹钟<br>D. 提示音<br><strong>答案：ABCD</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建MediaPlayer 类的对象</span></span><br><span class="line"><span class="type">MediaPlayer</span> <span class="variable">mediaPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaPlayer</span> ();</span><br><span class="line"><span class="comment">//设置音频类型</span></span><br><span class="line">mediaPlayer.setAudioStreamType (AudioManager.STREAM_MUSIC); </span><br></pre></td></tr></table></figure><p><code>setAudioStreamType()</code>方法中传递的参数表示音频类型，音频类型有很多种，常用的有以下几种：</p><ul><li><code>AudioManager.STREAM_MUSIC</code> ：音乐</li><li><code>AudioManager.STREAM_RING</code>：响铃</li><li><code>AudioManager.STREAM_ALARM</code>：闹钟</li><li><code>AudioManager.STREAM_NOTIFICATION</code>：提示音</li></ul>              </div>            </details></li><li><p>下列关于MediaPlayer类的描述，错误的是（    ）。<br>A. MediaPlayer类是用于播放音频和视频的<br>B. MediaPlayer类对音频文件提供了非常全面的控制方法<br>C. MediaPlayer类会调用底层的音频驱动播放音频<br>D. MediaPlayer类只可以播放音频而不能播放视频<br><strong>答案：D</strong></p> <details class="folding-tag" ><summary> 题目解释 </summary>              <div class='content'>              <p>P234：</p><p>使用MediaPlayer类播放音频与播放视频的步骤类似，唯一不同的是播放视频时需要把视频显示在SurfaceView控件上，所以需要通过<code>setDisplay()</code>方法将SurfaceView控件与MediaPlayer类进行关联</p>              </div>            </details></li></ol><h3 id="简答题-11">简答题</h3><ol><li><p>简述使用MediaPlayer播放音频的步骤。<br>答：使用MediaPlayer播放音频包含以下几个步骤：</p><ul><li>创建MediaPlayer对象</li><li>调用<code>setAudioStreamType()</code>设置音频的类型</li><li>设置数据源</li><li>调用<code>start()</code>方法播放音频文件</li><li>调用<code>stop()</code>方法停止播放音频文件</li><li>调用<code>release()</code>方法释放MediaPlayer对象占用的资源</li></ul></li><li><p>简要介绍一下SoundPool使用的场景。<br>答：SoundPool又称为音频池，它适合在应用程序中播放按键音或者消息提示音等短小的多个音频。</p></li></ol>]]></content>
    
    
    <summary type="html">《Android移动开发基础案例教程》（第2版）课后习题答案</summary>
    
    
    
    
    <category term="Android移动开发" scheme="https://www.iuoyt.com/tags/Android%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux简单操作速查</title>
    <link href="https://www.iuoyt.com/posts/f31ac9c6.html"/>
    <id>https://www.iuoyt.com/posts/f31ac9c6.html</id>
    <published>2023-12-17T09:21:18.000Z</published>
    <updated>2023-12-21T11:03:39.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户操作">用户操作</h2><h3 id="修改密码（passwd）">修改密码（passwd）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132259181.png" alt="image-20231221132259181"></p><h3 id="创建新用户（adduser）">创建新用户（adduser）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132357801.png" alt="image-20231221132357801"></p><h3 id="删除用户（deluser）">删除用户（deluser）</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser &lt;username&gt; --remove-home</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132840664.png" alt="image-20231221132840664"></p><h3 id="查看当前用户（whoami）">查看当前用户（whoami）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132422791.png" alt="image-20231221132422791"></p><h3 id="切换到用户（su）">切换到用户（su）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -l <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132619718.png" alt="image-20231221132619718"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>将 COMMAND 传递至启动的 shell</td></tr><tr><td><code>-h</code></td><td>显示帮助信息并退出</td></tr><tr><td><code>-l</code></td><td>将 shell 设为登录 shell</td></tr><tr><td><code>-p</code></td><td>不重置环境变量并保持同一 shell</td></tr><tr><td><code>-s</code></td><td>使用 SHELL 而非 passwd 中的默认值</td></tr></tbody></table><h3 id="查看所属用户组（groups）">查看所属用户组（groups）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132654167.png" alt="image-20231221132654167"></p><p>其中冒号之前表示用户，后面表示该用户所属的用户组</p><h3 id="授予sudo权限">授予sudo权限</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -G sudo <span class="variable">&lt;username&gt;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo adduser <span class="variable">&lt;username&gt;</span> sudo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132741744.png" alt="image-20231221132741744"></p><h3 id="移除sudo权限">移除sudo权限</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser <span class="tag">&lt;<span class="name">username</span>&gt;</span> sudo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132808881.png" alt="image-20231221132808881"></p><h2 id="目录操作">目录操作</h2><h3 id="查看当前路径（pwd）">查看当前路径（pwd）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-P</code></td><td>显示实际物理路径，而非使用连接（link）路径</td></tr><tr><td><code>-L</code></td><td>当目录为连接路径时，显示连接路径</td></tr></tbody></table><p><img src="https://doc.shiyanlou.com/courses/uid871732-20200826-1598406299890" alt="图片描述"></p><h3 id="切换目录（cd）">切换目录（cd）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>cd ~</code></td><td>进入当前用户主目录</td></tr><tr><td><code>cd /</code></td><td>进入系统根目录</td></tr><tr><td><code>cd ..</code></td><td>从当前目录进入父目录</td></tr><tr><td><code>cd -</code></td><td>从当前目录进入上次所在目录</td></tr></tbody></table><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132945769.png" alt="image-20231221132945769"></p><h3 id="查看目录内容（ls）">查看目录内容（ls）</h3><ul><li><p>只显示文件名：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133003656.png" alt="image-20231221133003656"></p></li><li><p>显示详细信息：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133018031.png" alt="image-20231221133018031"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-a</code></td><td>–all 列出目录下的所有文件，包括以 . 开头的隐含文件</td></tr><tr><td><code>-l</code></td><td>除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</td></tr><tr><td><code>-h</code></td><td>–human-readable 以容易理解的格式列出文件大小（例如 1K 234M 2G)</td></tr><tr><td><code>-t</code></td><td>以文件修改时间排序</td></tr></tbody></table><p>隐藏文件前带<code>.</code></p></li><li><p>查看目录完整属性：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -<span class="keyword">dl</span> [<span class="symbol">&lt;dirpath&gt;</span>]</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133100480.png" alt="image-20231221133100480"></p></li><li><p>显示所有文件大小</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -aSsh</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133334152.png" alt="image-20231221133334152"></p></li></ul><h3 id="创建目录（mkdir）">创建目录（mkdir）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [option] &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221141238014.png" alt="image-20231221141238014"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-m</code></td><td>设定权限&lt;模式&gt;</td></tr><tr><td><code>-p</code></td><td>多级创建，可以是一个路径名称。若路径中某些目录尚不存在，系统将自动建立好</td></tr><tr><td><code>-v </code></td><td>每次创建新目录都显示信息</td></tr></tbody></table><h3 id="删除目录（rm-r）">删除目录（rm -r）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r [option] &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221141153974.png" alt="image-20231221141153974"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-f</code></td><td>忽略不存在的文件，从不给出提示</td></tr><tr><td><code>-i</code></td><td>进行交互式删除</td></tr><tr><td><code>-r</code></td><td>指示 rm 将参数中列出的全部目录和子目录均递归地删除（删除目录时必须）</td></tr><tr><td><code>-v</code></td><td>详细显示进行的步骤</td></tr></tbody></table><h3 id="复制目录（cp-r）">复制目录（cp -r）</h3><p>也就是递归复制文件</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">dir</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142500949.png" alt="image-20231221142500949"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定目标目录</td></tr><tr><td><code>-i</code></td><td>覆盖前询问（使前面的 -n 选项失效）</td></tr><tr><td><code>-n</code></td><td>不要覆盖已存在的文件（使前面的 -i 选项失效）</td></tr><tr><td><code>-s</code></td><td>对源文件建立符号链接，而非复制文件</td></tr><tr><td><code>-f</code></td><td>强行复制文件或目录，不论目的文件或目录是否已经存在</td></tr><tr><td><code>-u</code></td><td>只在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件</td></tr></tbody></table><h3 id="移动目录（mv）">移动目录（mv）</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">dir</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221141444450.png" alt="image-20231221141444450"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>若需覆盖文件，则覆盖前先行备份</td></tr><tr><td><code>-f</code></td><td>如果目标文件已经存在，不会询问而直接覆盖</td></tr><tr><td><code>-i</code></td><td>若目标文件已经存在时，就会询问是否覆盖</td></tr><tr><td><code>-u</code></td><td>若目标文件已经存在，且源文件比较新，才会更新</td></tr><tr><td><code>-t</code></td><td>该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后</td></tr></tbody></table><h2 id="文件操作">文件操作</h2><h3 id="查看文件信息（ll）">查看文件信息（ll）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ll</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142520514.png" alt="image-20231221142520514"></p><h3 id="查看文件大小（du-h）">查看文件大小（du -h）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h &lt;<span class="built_in">dir</span>/file&gt;</span><br></pre></td></tr></table></figure><h3 id="查看文件类型（file）">查看文件类型（file）</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">file</span> &lt;<span class="built_in">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142534603.png" alt="image-20231221142534603"></p><h3 id="查看文件（cat）">查看文件（cat）</h3><ul><li><p>正序查看</p>  <figure class="highlight plaintext"><figcaption><span><file></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [option] &lt;file&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142851473.png" alt="image-20231221142851473"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-A</code></td><td>等价于 <code>-vET</code></td></tr><tr><td><code>-b</code></td><td>对非空输出行编号</td></tr><tr><td><code>-e</code></td><td>等价于 <code>-vE</code></td></tr><tr><td><code>-E</code></td><td>在每行结束处显示 $</td></tr><tr><td><code>-n</code></td><td>对输出的所有行编号，由 1 开始对所有输出的行数编号</td></tr><tr><td><code>-s</code></td><td>有连续两行以上的空白行，就代换为一行的空白行</td></tr><tr><td><code>-t</code></td><td>与 <code>-vT</code> 等价</td></tr><tr><td><code>-T</code></td><td>将跳格字符显示为 <code>^I</code></td></tr><tr><td><code>-u</code></td><td>（被忽略）</td></tr><tr><td><code>-v </code></td><td>使用 <code>^</code> 和 <code>M-</code>引用，除了 LFD 和 TAB 之外</td></tr></tbody></table></li><li><p>倒序查看</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac &lt;<span class="built_in">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142908437.png" alt="image-20231221142908437"></p></li></ul><h3 id="文件计算行号查看（nl）">文件计算行号查看（nl）</h3><ul><li><p>nl 命令在 linux 系统中用来计算文件中的行号。nl 可以将输出的文件内容自动加上行号，其默认的结果与 cat -n 有点不太一样。 nl 可以将行号做较多的显示设计，包括位数与是否自动补齐 0 等等的功能。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [<span class="keyword">option</span>] [<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221143002997.png" alt="image-20231221143002997"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>指定行号指定的方式，主要有两种：</td></tr><tr><td><code>-b a</code></td><td>表示不论是否为空行，也同样列出行号（类似 <code>cat -n</code>）</td></tr><tr><td><code>-b t</code></td><td>如果有空行，空的那一行不要列出行号（默认值）</td></tr><tr><td><code>-n</code></td><td>列出行号表示的方法，主要有三种：</td></tr><tr><td><code>-n ln</code></td><td>行号在屏幕的最左方显示</td></tr><tr><td><code>-n rn</code></td><td>行号在自己栏位的最右方显示，且不加 0</td></tr><tr><td><code>-n rz</code></td><td>行号在自己栏位的最右方显示，且加 0</td></tr><tr><td><code>-w</code></td><td>行号栏位的占用的位数</td></tr></tbody></table></li></ul><h3 id="阅读文件">阅读文件</h3><h4 id="more">more</h4><ul><li><p>功能类似 <code>cat</code> ，<code>cat</code> 命令是将整个文件的内容从上到下显示在屏幕上。 <code>more</code> 命令会一页一页的显示，方便使用者逐页阅读，而最基本的指令就是按<kbd>Enter</kbd>向下滚动一行，按<kbd>Space</kbd>往下一页显示，按<kbd>B</kbd>键就会往回（back）一页显示，按<kbd>=</kbd>输出当前行行号，按下 <kbd>H</kbd>显示帮助，按下<kbd>Q</kbd>退出。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221145143202.png" alt="image-20231221145143202"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>+n</code></td><td>从笫 n 行开始显示</td></tr><tr><td><code>-n</code></td><td>定义屏幕大小为 n 行</td></tr><tr><td><code>+/pattern</code></td><td>在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示</td></tr><tr><td><code>-c</code></td><td>从顶部清屏，然后显示</td></tr><tr><td><code>-d</code></td><td>提示“Press space to continue，’q’ to quiet”，禁用响铃功能</td></tr><tr><td><code>-p</code></td><td>通过清除窗口而不是滚屏来对文件进行换页，与-c 选项相似</td></tr><tr><td><code>-s</code></td><td>把连续的多个空行显示为一行</td></tr><tr><td><code>-u</code></td><td>把文件内容中的下划线去掉</td></tr></tbody></table></li></ul><h4 id="less">less</h4><ul><li><p>是 linux 正统查看文件内容的工具，功能极其强大</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">less</span> [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-e</code></td><td>当文件显示结束后，自动离开</td></tr><tr><td><code>-f</code></td><td>强迫打开特殊文件，例如外围设备代号、目录和二进制文件</td></tr><tr><td><code>-i</code></td><td>忽略搜索时的大小写</td></tr><tr><td><code>-m</code></td><td>显示类似 more 命令的百分比</td></tr><tr><td><code>-N</code></td><td>显示每行的行号</td></tr><tr><td><code>-s</code></td><td>显示连续空行为一行</td></tr></tbody></table></li><li><p>常用操作：</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>/字符串</td><td>向下搜索“字符串”的功能</td></tr><tr><td>?字符串</td><td>向上搜索“字符串”的功能</td></tr><tr><td>n</td><td>重复前一个搜索（与 / 或 ? 有关）</td></tr><tr><td>N</td><td>反向重复前一个搜索（与 / 或 ? 有关）</td></tr><tr><td>b</td><td>向前翻一页</td></tr><tr><td>d</td><td>向后翻半页</td></tr><tr><td>q</td><td>退出 less 命令</td></tr><tr><td>空格键</td><td>向后翻一页</td></tr><tr><td>向上键</td><td>向上翻动一行</td></tr><tr><td>向下键</td><td>向下翻动一行</td></tr></tbody></table></li></ul><h4 id="head">head</h4><ul><li><p>用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221145838128.png" alt="image-20231221145838128"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-q</td><td>隐藏文件名</td></tr><tr><td>-v</td><td>显示文件名</td></tr><tr><td>-c&lt;字节&gt;</td><td>显示字节数</td></tr><tr><td>-n&lt;行数&gt;</td><td>显示的行数</td></tr></tbody></table></li></ul><h4 id="tail">tail</h4><ul><li><p>用于显示指定文件末尾内容。常用查看日志文件，默认为尾部10行。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221145910940.png" alt="image-20231221145910940"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-f</code></td><td>循环读取</td></tr><tr><td><code>-q</code></td><td>不显示处理信息</td></tr><tr><td><code>-v</code></td><td>显示详细的处理信息</td></tr><tr><td><code>-c&lt;字节&gt;</code></td><td>显示的字节数</td></tr><tr><td><code>-n&lt;行数&gt;</code></td><td>显示行数</td></tr></tbody></table></li></ul><h3 id="创建文件（touch）">创建文件（touch）</h3><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">touch</span> &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>批量创建文件</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">touch</span> file&#123;<span class="number">1</span>..<span class="number">5</span>&#125;.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221150514197.png" alt="image-20231221150514197"></p></li></ul><h3 id="删除文件（rm）">删除文件（rm）</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221150534482.png" alt="image-20231221150534482"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-f</code></td><td>忽略不存在的文件，从不给出提示</td></tr><tr><td><code>-i</code></td><td>进行交互式删除</td></tr><tr><td><code>-r</code></td><td>指示 rm 将参数中列出的全部目录和子目录均递归地删除</td></tr><tr><td><code>-v</code></td><td>详细显示进行的步骤</td></tr></tbody></table><h3 id="编辑文件（vim）">编辑文件（vim）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建并写入文件（echo-）">创建并写入文件（echo &gt;&gt;）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Text&quot;</span> &gt;&gt; <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221151525050.png" alt="image-20231221151525050"></p><h3 id="多行编辑（cat）">多行编辑（cat）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; &lt;file&gt; &lt;&lt; <span class="string">eof</span></span><br><span class="line"><span class="string">……</span></span><br><span class="line"><span class="string">eof</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221151402910.png" alt="image-20231221151402910"></p><h3 id="复制文件（cp）">复制文件（cp）</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221150733380.png" alt="image-20231221150733380"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定目标目录</td></tr><tr><td><code>-i</code></td><td>覆盖前询问（使前面的 -n 选项失效）</td></tr><tr><td><code>-n</code></td><td>不要覆盖已存在的文件（使前面的 -i 选项失效）</td></tr><tr><td><code>-s</code></td><td>对源文件建立符号链接，而非复制文件</td></tr><tr><td><code>-f</code></td><td>强行复制文件或目录，不论目的文件或目录是否已经存在</td></tr><tr><td><code>-u</code></td><td>只在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件</td></tr></tbody></table><h3 id="设置文件权限（chmod）">设置文件权限（chmod）</h3><table><thead><tr><th style="text-align:left">#</th><th style="text-align:left">权限</th><th style="text-align:left">rwx</th><th style="text-align:left">二进制</th></tr></thead><tbody><tr><td style="text-align:left">7</td><td style="text-align:left">读 + 写 + 执行</td><td style="text-align:left">rwx</td><td style="text-align:left">111</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">读 + 写</td><td style="text-align:left">rw-</td><td style="text-align:left">110</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">读 + 执行</td><td style="text-align:left">r-x</td><td style="text-align:left">101</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">只读</td><td style="text-align:left">r–</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">写 + 执行</td><td style="text-align:left">-wx</td><td style="text-align:left">011</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">只写</td><td style="text-align:left">-w-</td><td style="text-align:left">010</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">只执行</td><td style="text-align:left">–x</td><td style="text-align:left">001</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">无</td><td style="text-align:left">—</td><td style="text-align:left">000</td></tr></tbody></table><ul><li><p>数字表示</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">rwx</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>文件调用权限分为三级 :</p><ul><li>文件所有者（Owner）</li><li>用户所在用户组（Group）</li><li>其它用户（Other Users）</li></ul></li><li><p>权限分为三种：</p><ul><li>可读（Read）</li><li>可写（Write）</li><li>可执行（Execute）</li></ul></li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="img"></p></li><li><p>字符表示</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">u</span>&gt;</span><span class="tag">&lt;<span class="name">op</span>&gt;</span><span class="tag">&lt;<span class="name">permission</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>用户组部分表示：</p><table><thead><tr><th style="text-align:left">who</th><th style="text-align:left">用户类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>u</code></td><td style="text-align:left">user</td><td style="text-align:left">文件所有者</td></tr><tr><td style="text-align:left"><code>g</code></td><td style="text-align:left">group</td><td style="text-align:left">文件所有者所在组</td></tr><tr><td style="text-align:left"><code>o</code></td><td style="text-align:left">others</td><td style="text-align:left">所有其他用户</td></tr><tr><td style="text-align:left"><code>a</code></td><td style="text-align:left">all</td><td style="text-align:left">所有用户, 相当于 <em>ugo</em></td></tr></tbody></table></li><li><p>符号部分表示：</p><table><thead><tr><th style="text-align:left">Operator</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">为指定的用户类型增加权限</td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">去除指定用户类型的权限</td></tr><tr><td style="text-align:left"><code>=</code></td><td style="text-align:left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table></li><li><p>权限部分表示：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">名字</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>r</code></td><td style="text-align:left">读</td><td style="text-align:left">设置为可读权限</td></tr><tr><td style="text-align:left"><code>w</code></td><td style="text-align:left">写</td><td style="text-align:left">设置为可写权限</td></tr><tr><td style="text-align:left"><code>x</code></td><td style="text-align:left">执行权限</td><td style="text-align:left">设置为可执行权限</td></tr><tr><td style="text-align:left"><code>X</code></td><td style="text-align:left">特殊执行权限</td><td style="text-align:left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td style="text-align:left"><code>s</code></td><td style="text-align:left">setuid/gid</td><td style="text-align:left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td style="text-align:left"><code>t</code></td><td style="text-align:left">粘贴位</td><td style="text-align:left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td></tr></tbody></table></li></ul></li><li><p>效果相同语句举例：</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="keyword">a</span>=rwx <span class="built_in">file</span></span><br><span class="line">chmod <span class="number">777</span> <span class="built_in">file</span></span><br></pre></td></tr></table></figure>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod ug=rwx,o=x <span class="built_in">file</span></span><br><span class="line">chmod <span class="number">771</span> <span class="built_in">file</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="移动文件（mv）">移动文件（mv）</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>若需覆盖文件，则覆盖前先行备份</td></tr><tr><td><code>-f</code></td><td>如果目标文件已经存在，不会询问而直接覆盖</td></tr><tr><td><code>-i</code></td><td>若目标文件已经存在时，就会询问是否覆盖</td></tr><tr><td><code>-u</code></td><td>若目标文件已经存在，且源文件比较新，才会更新</td></tr><tr><td><code>-t</code></td><td>该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后</td></tr></tbody></table><h3 id="重命名文件（mv）">重命名文件（mv）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv <span class="tag">&lt;<span class="name">旧名称</span>&gt;</span> <span class="tag">&lt;<span class="name">新名称</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>批量重命名：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量将这5个后缀为.txt的文本文件重命名为以.c为后缀的文件:</span></span><br><span class="line"><span class="attribute">rename</span> <span class="string">&#x27;s/\.txt/\.c/&#x27;</span> <span class="regexp">*.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量将这5个文件，文件名和后缀改为大写:</span></span><br><span class="line">rename <span class="string">&#x27;y/a-z/A-Z/&#x27;</span> <span class="regexp">*.c</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="vim基础操作">vim基础操作</h2><h3 id="进入vim编辑（普通模式）">进入vim编辑（普通模式）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>游标操作：在普通模式下使用方向键或者<kbd>h</kbd>、<kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd>键移动游标</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td><kbd>h</kbd></td><td>左</td></tr><tr><td><kbd>l</kbd></td><td>右（小写 L）</td></tr><tr><td><kbd>j</kbd></td><td>下</td></tr><tr><td><kbd>k</kbd></td><td>上</td></tr><tr><td><kbd>w</kbd></td><td>移动到下一个单词</td></tr><tr><td><kbd>b</kbd></td><td>移动到上一个单词</td></tr></tbody></table></li><li><p>快速操作：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除游标所在的字符</td></tr><tr><td><code>X</code></td><td>删除游标所在前一个字符</td></tr><tr><td><code>Delete</code></td><td>同 <code>x</code></td></tr><tr><td><code>dd</code></td><td>删除整行</td></tr><tr><td><code>dw</code></td><td>删除一个单词（不适用中文）</td></tr><tr><td><code>d$</code>或<code>D</code></td><td>删除至行尾</td></tr><tr><td><code>d^</code></td><td>删除至行首</td></tr><tr><td><code>dG</code></td><td>删除到文档结尾处</td></tr><tr><td><code>d1G</code></td><td>删至文档首部</td></tr></tbody></table></li></ul><h3 id="写入内容（插入模式）">写入内容（插入模式）</h3><ul><li><p>进入：输入<code>i </code>（insert／插入）或者<code>a</code>（append／追加）</p></li><li><p>退出：按下<kbd>Esc</kbd>回到普通模式</p></li><li><p>更多命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>在当前光标处进行编辑</td></tr><tr><td><code>I</code></td><td>在行首插入</td></tr><tr><td><code>A</code></td><td>在行末插入</td></tr><tr><td><code>a</code></td><td>在光标后插入编辑</td></tr><tr><td><code>o</code></td><td>在当前行后插入一个新行</td></tr><tr><td><code>O</code></td><td>在当前行前插入一个新行</td></tr><tr><td><code>cw</code></td><td>替换从光标所在位置后到一个单词结尾的字符</td></tr></tbody></table></li></ul><h3 id="命令模式">命令模式</h3><ul><li><p>在普通模式下输入<code>:</code>进入命令模式</p></li><li><p>退出vim：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:q!</code></td><td>强制退出，不保存</td></tr><tr><td><code>:q</code></td><td>退出</td></tr><tr><td><code>:wq!</code></td><td>强制保存并退出</td></tr><tr><td><code>:w &lt;文件路径&gt;</code></td><td>另存为</td></tr><tr><td><code>:saveas 文件路径</code></td><td>另存为</td></tr><tr><td><code>:x</code></td><td>保存并退出</td></tr><tr><td><code>:wq</code></td><td>保存并退出</td></tr></tbody></table></li><li><p>或者使用<kbd>Shift</kbd> + <kbd>Z</kbd> <kbd>Z</kbd>（按两次z）保存并退出vim</p></li></ul><h2 id="bash操作">bash操作</h2><h3 id="定义变量">定义变量</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> tmp</span><br></pre></td></tr></table></figure><h3 id="变量赋值">变量赋值</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tmp</span><span class="operator">=</span>shiyanlou</span><br></pre></td></tr></table></figure><h3 id="读取变量">读取变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><h3 id="新建子终端">新建子终端</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bash</span></span><br></pre></td></tr></table></figure><h3 id="时间测量（time）">时间测量（time）</h3><ul><li><p>time 命令常用于测量一个命令的运行时间，包括实际使用时间（real time）、用户态使用时间（the process spent in user mode）、内核态使用时间（the process spent in kernel mode）。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">time</span> <span class="selector-attr">[command]</span></span><br></pre></td></tr></table></figure></li><li><p>测量 date 命令运行的时间</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">time</span> <span class="built_in">date</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740854918" alt="img"></p><p>从上面的结果可以到：实际运行时间为 0.005s，用户 cpu 时间为 0.001s，系统 cpu 时间为 0.001s。</p><p>其中，用户 CPU 时间和系统 CPU 时间之和为 CPU 时间，即命令占用 CPU 执行的时间总和。实际时间要大于 CPU 时间，因为 Linux 是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。</p></li></ul><h2 id="搜索操作">搜索操作</h2><h3 id="where">where</h3><ul><li><p>只能检索二进制文件（<code>-b</code>)、man帮助文件(<code>-m</code>)和源代码文件(<code>-s</code>)</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> find</span><br></pre></td></tr></table></figure></li></ul><h3 id="which">which</h3><ul><li><p>在 PATH 变量指定的路径中搜索可执行文件的所在位置，一般用来确认系统中是否安装了指定的软件。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which <span class="tag">&lt;<span class="name">可执行文件名称</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="whereis">whereis</h3><ul><li><p>通过<code>/var/lib/mlocate/mlocate.db</code>数据库查找，主要用于定位可执行文件、源代码文件和帮助文件在文件系统中的位置。whereis 命令还具有搜索源代码、指定备用搜索路径和搜索不寻常项的功能。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>定位可执行文件</td></tr><tr><td><code>-m</code></td><td>定位帮助文件</td></tr><tr><td><code>-s</code></td><td>定位源代码文件</td></tr><tr><td><code>-u</code></td><td>搜索默认路径下除可执行文件、源代码文件和帮助文件以外的其它文件</td></tr><tr><td><code>-B</code></td><td>指定搜索可执行文件的路径</td></tr><tr><td><code>-M</code></td><td>指定搜索帮助文件的路径</td></tr><tr><td><code>-S</code></td><td>指定搜索源代码文件的路径</td></tr></tbody></table></li></ul><h3 id="locate">locate</h3><ul><li><p>locate 命令跟 whereis 命令类似，且它们使用的是相同的数据库。但 whereis 命令只能搜索可执行文件、联机帮助文件和源代码文件，如果要获得更全面的搜索结果，可以使用 locate 命令。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [option] <span class="tag">&lt;<span class="name">搜索字符串</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-q</code></td><td>安静模式，不会显示任何错误讯息</td></tr><tr><td><code>-n</code></td><td>至多显示 n 个输出</td></tr><tr><td><code>-r</code></td><td>使用正则表达式做寻找的条件</td></tr><tr><td><code>-V</code></td><td>显示版本信息</td></tr></tbody></table></li><li><p>安装并立即更新一次数据库：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install locate</span><br><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure></li></ul><h3 id="find">find</h3><ul><li><p>主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="selector-attr">[path]</span> <span class="selector-attr">[option]</span> <span class="selector-attr">[动作表达式]</span></span><br></pre></td></tr></table></figure><p>默认路径是当前目录，默认表达式为 -print。</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td><code>-print</code></td><td>将匹配的文件输出到标准输出</td></tr><tr><td><code>-exec</code></td><td>对匹配的文件执行该参数所给出的 shell 命令</td></tr><tr><td><code>-name</code></td><td>按照文件名查找文件</td></tr><tr><td><code>-type</code></td><td>查找某一类型的文件</td></tr><tr><td><code>-prune</code></td><td>不在当前指定的目录中查找，如果同时使用 <code>-depth</code> 选项，那么 <code>-prune</code> 将被忽略</td></tr><tr><td><code>-user</code></td><td>按照文件属主来查找文件</td></tr><tr><td><code>-group</code></td><td>按照文件所属的组来查找文件</td></tr><tr><td><code>-mtime -n +n</code></td><td>按照文件的更改时间来查找文件，<code>-n</code> 表示文件更改时间距现在小于 n 天，<code>+n</code> 表示文件更改时间距现在大于 n 天</td></tr></tbody></table>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印当前目录下的文件目录列表</span></span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印当前目录下所有以.txt 结尾的文件名</span></span><br><span class="line"><span class="built_in">find</span> . -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印当前目录下所有以.txt 或.pdf 结尾的文件名</span></span><br><span class="line"><span class="built_in">find</span> . \( -name <span class="string">&quot;*.pdf&quot;</span> -or -name <span class="string">&quot;*.txt&quot;</span> \)</span><br><span class="line"><span class="comment"># 打印当前目录下所有不以.txt 结尾的文件名</span></span><br><span class="line"><span class="built_in">find</span> . ! -name <span class="string">&quot;*.txt&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="打包与解压">打包与解压</h2><h3 id="zip">zip</h3><h4 id="打包">打包</h4><ul><li><p>将test目录打包</p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -r -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>将目录 /home/shiyanlou/Desktop 打包成一个文件，<code>-r</code>参数表示递归打包包含子目录的全部内容，<code>-q</code> 参数表示安静模式，即不向屏幕输出信息，<code>-o</code>表示输出文件，需在其后紧跟打包输出文件名。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231221181820531.png" alt="image-20231221181820531"></p></li><li><p>加密打包：<code>-e</code></p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -r -<span class="keyword">e</span> -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221182845455.png" alt="image-20231221182845455"></p></li><li><p>适配Windows换行：<code>-l</code>，将 <code>LF</code> 转换为 <code>CR+LF</code></p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -r -<span class="keyword">l</span> -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="解压">解压</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip <span class="tag">&lt;<span class="name">zip_file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>安静模式：<code>-q</code>，不存在的目录会自动创建</p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -q <span class="keyword">test</span>.<span class="keyword">zip</span> -<span class="keyword">d</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>仅查看内容：<code>-l</code></p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -<span class="keyword">l</span> <span class="keyword">test</span>.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure></li><li><p>指定编码：<code>-O</code></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK <span class="tag">&lt;<span class="name">中文压缩文件.zip</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="tar">tar</h3><h4 id="打包-2">打包</h4><ul><li><p>打包为<code>.tar</code></p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -Pcf <span class="keyword">test</span>.tar <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183411352.png" alt="image-20231221183411352"></p><p><code>-P</code> 保留绝对路径符，<code>-c</code> 表示创建一个 tar 包文件，<code>-f</code> 用于指定创建的文件名，注意文件名必须紧跟在 <code>-f</code> 参数之后</p></li><li><p>打包为<code>.tar.gz</code>：<code>-z</code></p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf <span class="keyword">test</span>.tar.gz <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183533959.png" alt="image-20231221183533959"></p></li><li><p>更多格式：</p><table><thead><tr><th>压缩文件格式</th><th>参数</th></tr></thead><tbody><tr><td><code>*.tar.gz</code></td><td><code>-z</code></td></tr><tr><td><code>*.tar.xz</code></td><td><code>-J</code></td></tr><tr><td><code>*tar.bz2</code></td><td><code>-j</code></td></tr></tbody></table></li></ul><h4 id="解压-2">解压</h4><ul><li><p>解压<code>.tar</code></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf shiyanlou<span class="selector-class">.tar</span> <span class="selector-attr">[-C &lt;tardir&gt;]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183711774.png" alt="image-20231221183711774"></p><p>解包一个文件（<code>-x</code> 参数）到指定路径的<strong>已存在</strong>目录（<code>-C</code> 参数）</p></li><li><p>解压<code>.tar.gz</code>：<code>-z</code></p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183815734.png" alt="image-20231221183815734"></p></li></ul><h4 id="不解压查看">不解压查看</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf <span class="keyword">test</span>.tar</span><br></pre></td></tr></table></figure><h2 id="帮助操作">帮助操作</h2><h3 id="help">help</h3><ul><li><p>只能用于显示内建命令的帮助信息（仅能在bash中使用）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li><p>通常外部命令都有<code>--help</code>参数</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="man">man</h3><ul><li><p>得到的内容比用 help 更多更详细，而且man没有内建与外部命令的区分</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">man</span> <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>按下<kbd>Q</kbd>退出查看</p></li></ul><h3 id="info">info</h3><ul><li><p>安装：</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install <span class="keyword">info</span></span><br></pre></td></tr></table></figure>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">info</span> ls</span><br></pre></td></tr></table></figure><p>按下<kbd>Q</kbd>退出查看</p></li></ul><h2 id="语句控制">语句控制</h2><h3 id="多语句执行">多语句执行</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="number">1</span><span class="comment">; 语句2 ;语句3</span></span><br></pre></td></tr></table></figure><h3 id="条件执行（-）">条件执行（&amp;&amp; ||）</h3><ul><li><p><code>&amp;&amp;</code>：如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的语句，否则不执行</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="selector-tag">A</span> &amp;&amp; 语句<span class="selector-tag">B</span></span><br></pre></td></tr></table></figure></li><li><p><code>||</code>：和<code>&amp;&amp;</code>相反，返回1则执行后面的语句</p></li></ul><h3 id="管道（-）">管道（|）</h3><ul><li><p>将前一语句的输出作为下一语句的输入</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc | less</span><br></pre></td></tr></table></figure></li></ul><h2 id="文本处理">文本处理</h2><h3 id="标准输出处理（xargs）">标准输出处理（xargs）</h3><ul><li><p>xargs 命令可以从标准输入接收输入，并把输入转换为一个特定的参数列表。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">command</span> | xargs [<span class="keyword">option</span>] [<span class="keyword">command</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-n</code></td><td>指定每行最大的参数数量</td></tr><tr><td><code>-d</code></td><td>指定分隔符</td></tr></tbody></table></li><li><p>将多行输入转换为单行输出</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt <span class="string">| xargs</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486436814" alt="img"></p></li><li><p>将单行输入转换为多行输出</p>  <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7&quot; | xargs -n 3</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486477811" alt="img"></p></li><li><p>将单行输入转换为多行输出，指定分隔符为 i</p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cat</span> <span class="selector-tag">b</span><span class="selector-class">.txt</span> | <span class="selector-tag">xargs</span> <span class="selector-tag">-d</span> <span class="selector-tag">i</span> <span class="selector-tag">-n</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486635856" alt="img"></p></li><li><p>查找当前目录下所有 c 代码文件，统计总行数</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="keyword">type</span> <span class="type">f </span>-name <span class="string">&quot;*.c&quot;</span> | xargs wc -l</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486674638" alt="img"></p></li></ul><h3 id="文本切分（cut）">文本切分（cut）</h3><ul><li><p>cut 命令是一个将文本按列进行切分的小工具，它可以指定分隔每列的定界符。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>以字节为单位进行分割</td></tr><tr><td><code>-c</code></td><td>以字符为单位进行分割</td></tr><tr><td><code>-d</code></td><td>自定义分隔符，默认为制表符</td></tr><tr><td><code>-f</code></td><td>自定义字段</td></tr><tr><td><code>--complement</code></td><td>抽取整个文本行，除了那些由 <code>-c</code> 或 <code>-f</code> 选项指定的文本</td></tr></tbody></table></li><li><p>取出<code>/etc/passwd</code>文件中以<code>:</code>为分隔符的第1个字段和第6个字段</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="regexp">/etc/</span>passwd -d <span class="string">&#x27;:&#x27;</span> -f <span class="number">1</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231217204359115.png" alt="image-20231217204359115"></p></li><li><p>取指定数量字符</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前五个（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c -<span class="number">5</span></span><br><span class="line"><span class="comment"># 前五个之后的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span>-</span><br><span class="line"><span class="comment"># 第五个</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span></span><br><span class="line"><span class="comment"># 2到5之间的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">2</span>-<span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="匹配字符串（grep）">匹配字符串（grep）</h3><ul><li><p>grep 用来找到文件中的匹配文本，并且能够接受正则表达式和通配符，同时可以用多个 grep 命令选项来生成各种格式的输出。</p></li><li><p>grep 通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回 0，如果搜索不成功，则返回 1，如果搜索的文件不存在，则返回 2</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> [option] <span class="symbol">&lt;pattern&gt;</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>计算找到‘搜寻字符串’（即 pattern）的次数</td></tr><tr><td><code>-i</code></td><td>忽略大小写的不同，所以大小写视为相同</td></tr><tr><td><code>-n</code></td><td>输出行号</td></tr><tr><td><code>-v</code></td><td>反向选择，打印不匹配的行</td></tr><tr><td><code>-r</code></td><td>递归搜索</td></tr><tr><td><code>--color=auto</code></td><td>将找到的关键词部分加上颜色显示</td></tr></tbody></table></li><li><p>将<code>/etc/passwd</code>文件中出现 root 的行取出来，关键词部分加上颜色显示</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">&quot;root&quot;</span> <span class="regexp">/etc/</span>passwd --color=auto</span><br><span class="line">cat <span class="regexp">/etc/</span>passwd | <span class="keyword">grep</span> <span class="string">&quot;root&quot;</span> --color=auto</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219124625381.png" alt="image-20231219124625381"></p></li><li><p>将<code>/etc/passwd</code>文件中没有出现 root 和 nologin 的行取出来</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -v <span class="string">&quot;root&quot;</span> <span class="regexp">/etc/</span>passwd | <span class="keyword">grep</span> -v <span class="string">&quot;nologin&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219124700264.png" alt="image-20231219124700264"></p></li></ul><h3 id="内容统计（wc）">内容统计（wc）</h3><ul><li><p>wc 命令是一个统计的工具，主要用来显示文件所包含的行、字和字节数。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>统计字节数</td></tr><tr><td><code>-l</code></td><td>统计行数</td></tr><tr><td><code>-m</code></td><td>统计字符数，这个标志不能与 <code>-c</code> 标志一起使用</td></tr><tr><td><code>-w</code></td><td>统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串</td></tr><tr><td><code>-L</code></td><td>打印最长行的长度</td></tr></tbody></table></li><li><p>统计文件数</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计/bin目录下的命令个数，即文件个数</span></span><br><span class="line"><span class="built_in">ls</span> /bin | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li></ul><h3 id="排序（sort）">排序（sort）</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-n</code></td><td>基于字符串的长度来排序，使用此选项允许根据数字值排序，而不是字母值</td></tr><tr><td><code>-k</code></td><td>指定排序关键字</td></tr><tr><td><code>-b</code></td><td>默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略每行开头的空格，从第一个非空白字符开始排序</td></tr><tr><td><code>-m</code></td><td>只合并多个输入文件</td></tr><tr><td><code>-r</code></td><td>按相反顺序排序，结果按照降序排列，而不是升序</td></tr><tr><td><code>-t</code></td><td>自定义分隔符，默认为制表符</td></tr></tbody></table><ul><li><p>列出<code>/usr/share/</code>目录下使用空间最多的前 10 个目录文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -s /usr/share/* | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219130029985.png" alt="image-20231219130029985"></p></li><li><p>对 ls 命令输出信息中的空间使用大小字段进行排序</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /usr/bin/ | <span class="built_in">sort</span> -nr -k 5 | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219130116293.png" alt="image-20231219130116293"></p></li></ul><h3 id="去重（uniq）">去重（uniq）</h3><ul><li><p>uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。</p></li><li><p>uniq 只能用于排过序的数据输入，因此，uniq 要么使用管道，要么将排过序的文件作为输入，并总是以这种方式与 sort 命令结合起来使用。</p>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uni<span class="string">q [option]</span> &lt;file&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>在每行前加上表示相应行目出现次数的前缀编号</td></tr><tr><td><code>-d</code></td><td>只输出重复的行</td></tr><tr><td><code>-u</code></td><td>只显示唯一的行</td></tr><tr><td><code>-D</code></td><td>显示所有重复的行</td></tr><tr><td><code>-f</code></td><td>比较时跳过前 n 列</td></tr><tr><td><code>-i</code></td><td>在比较的时候不区分大小写</td></tr><tr><td><code>-s</code></td><td>比较时跳过前 n 个字符</td></tr><tr><td><code>-w</code></td><td>对每行第 n 个字符以后的内容不作对照</td></tr></tbody></table></li><li><p>找出<code>/bin</code>目录和<code>/usr/bin</code>目录下所有相同的命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -d</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781011797" alt="img"></p></li><li><p>现有文件内容如下，红色方框里的内容表示区号，现在要统计出各个区号的总人数</p><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781055838" alt="img"></p><p>实现思路：首先按区号对每行信息排序，然后使用 uniq 命令对区号进行重复行统计。使用命令如下：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sort</span> -k <span class="number">4</span>.<span class="number">1</span>n,<span class="number">4</span>.<span class="number">1</span>n student.txt | uniq -c -f <span class="number">3</span> -w <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781089813" alt="img"></p></li></ul><h3 id="更改字符（tr）">更改字符（tr）</h3><ul><li><p>tr 命令常被用来更改字符，我们可以把它看作是一种基于字符的查找和替换操作。换字是一种把字符从一个字母转换为另一个字母的过程，tr 可以从标准输入中替换、缩减和删除字符，并将结果写到标准输出。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> <span class="selector-attr">[option]</span> SET1 <span class="selector-attr">[SET2]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td><code>-s</code></td><td>去除set1指定的在输入文本中连续并重复的字符</td></tr></tbody></table></li><li><p>将输入的字符大写转换为小写</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;THIS IS SHIYANLOU!&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219125549403.png" alt="image-20231219125549403"></p></li><li><p>将输入的字符中的数字删除</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;THIS 123 IS S1HIY5ANLOU!&#x27;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;0-9&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219125607524.png" alt="image-20231219125607524"></p></li></ul><h3 id="Tab替换空格（col）">Tab替换空格（col）</h3><ul><li><p><code>col</code>命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">col</span><span class="meta"> [option]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-x</code></td><td>将<code>Tab</code>转换为空格</td></tr><tr><td><code>-h</code></td><td>将空格转换为<code>Tab</code>（默认选项）</td></tr></tbody></table>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看<span class="regexp">/etc/</span>protocols中的不可见字符，可以看到很多^I，这其实就是Tab转义成可见字符的符号</span><br><span class="line">cat -A <span class="regexp">/etc/</span>protocols</span><br><span class="line"># 使用 col -x将<span class="regexp">/etc/</span>protocols中的Tab转换为空格,然后再使用cat查看，发现^I不见了</span><br><span class="line">cat <span class="regexp">/etc/</span>protocols | col -x | cat -A</span><br></pre></td></tr></table></figure></li></ul><h3 id="合并字段（join）">合并字段（join）</h3><ul><li><p>join将两个文件中指定栏位相同的行连接起来，即按照两个文件中共同拥有的某一列，将对应的行拼接成一行</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">join</span> [option] <span class="symbol">&lt;file1&gt;</span> <span class="symbol">&lt;file2&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定分隔符，默认为Tab</td></tr><tr><td><code>-i</code></td><td>忽略大小写的差异</td></tr><tr><td><code>-1</code>（数字1）</td><td>指明第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td><code>-2</code></td><td>指明第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table></li><li><p>将两个文件中的第一个字段作为匹配字段，连接两个文件</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join <span class="selector-tag">a</span><span class="selector-class">.txt</span> <span class="selector-tag">b</span>.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781241207" alt="img"></p></li><li><p>指定两个文件的第三个字段为匹配字段，连接两个文件</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">join</span> -<span class="number">1</span> <span class="number">3</span> -<span class="number">2</span> <span class="number">3</span> c.txt d.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/document-uid370051labid370timestamp1490930024622.png" alt="此处输入图片的描述"></p></li></ul><h3 id="简单合并文件（paste）">简单合并文件（paste）</h3><ul><li><p>paste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;...</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-s</code></td><td>将每个文件合并成行而不是按行粘贴</td></tr><tr><td><code>-d</code></td><td>自定义分隔符，默认为制表符</td></tr></tbody></table></li><li><p>将<code>student.txt</code>和<code>telphone.txt</code>文件中的内容按列拼接</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> student.txt telphone.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid369time1420780031604" alt="img"></p></li><li><p>将<code>student.txt</code>和<code>telphone.txt</code>文件中的内容按列拼接，指定分隔符为<code>:</code></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste student<span class="selector-class">.txt</span> telphone<span class="selector-class">.txt</span> -d <span class="string">&#x27;:&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid369time1420780078087" alt="img"></p></li><li><p>将<code>student.txt</code>和<code>telphone.txt</code>文件中的内容各自拼接成一行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -s student.txt telphone.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid369time1420780124133" alt="img"></p></li></ul><h3 id="比较文本文件（comm）">比较文本文件（comm）</h3><ul><li><p>comm 命令将逐行比较已经排序的两个文件。显示结果包括 3 列：第 1 列为只在第一个文件中找到的行，第 2 列为只在第二个文件中找到的行，第 3 列为两个文件的共有行。</p>  <figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comm [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">file1</span>&gt;</span> </span><span class="language-xml"><span class="tag">&lt;<span class="name">file2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-1</code>（数字1）</td><td>不输出文件 1 特有的行</td></tr><tr><td><code>-2</code></td><td>不输出文件 2 特有的行</td></tr><tr><td><code>-3</code></td><td>不输出两个文件共有的行</td></tr></tbody></table></li><li><p>比较<code>file1.txt</code>和<code>file2.txt</code>两个文件的内容</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">comm</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781783879" alt="img"></p></li><li><p>比较<code>file1.txt</code>和<code>file2.txt</code>两个文件的内容，只显示两个文件共有的内容</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">comm</span> -<span class="number">12</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781829807" alt="img"></p></li></ul><h3 id="监测文件差异（diff）">监测文件差异（diff）</h3><ul><li><p>类似 comm 命令，diff 命令被用来监测文件之间的差异。然而，diff 是一款更加复杂的工具，它支持许多输出格式，并且一次能处理许多文本文件。diff 能够递归地检查源码目录，通常称之为源码树。diff 程序的一个常见用例是创建 diff 文件或者补丁，它会被其它程序使用，例如 patch 程序，来把文件从一个版本转换为另一个版本。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>上下文模式，显示全部内文，并标出不同之处</td></tr><tr><td><code>-u</code></td><td>统一模式，以合并的方式来显示文件内容的不同</td></tr><tr><td><code>-a</code></td><td>只会逐行比较文本文件</td></tr><tr><td><code>-N</code></td><td>在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：Only in 目录。若使用 -N 参数，则 diff 会将文件 A 与一个空白的文件比较</td></tr><tr><td><code>-r</code></td><td>递归比较目录下的文件</td></tr></tbody></table></li><li><p>显示<code>file1.txt</code>和<code>file2.txt</code>两个文件的差异</p>  <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">diff</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781912223" alt="img"></p><p>上面结果显示中的“1d0”表示<code>file1.txt</code>文件比<code>file2.txt</code>文件多了第一行，“4c3,4”表示<code>file1.txt</code>文件的第四行和<code>file2.txt</code>文件的第三、四行不同。</p><blockquote><p>diff 的 normal 显示格式有三种提示:</p><ul><li>a - add</li><li>c - change</li><li>d - delete</li></ul></blockquote></li><li><p>从上面例一的显示结果可以知道，<code>file1.txt</code>和<code>file2.txt</code>两个文件的差异不易直观看出，这时可以使用上下文模式显示</p>  <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff  -<span class="keyword">c</span> file<span class="number">1</span>.txt  file<span class="number">2</span>.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781985260" alt="img"></p><blockquote><p><code>+</code> 添加行，这一行将会出现在第二个文件内，而不是第一个文件内</p><p><code>-</code> 删除行，这一行将会出现在第一个文件中，而不是第二个文件内</p><p><code>!</code> 更改行，将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分</p></blockquote></li><li><p>查看<code>file1.txt</code>和<code>file2.txt</code>两个文件的差异，使用统一模式显示</p>  <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">diff</span> -u file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420782103081" alt="img"></p></li></ul><h3 id="文本中应用更改（patch）">文本中应用更改（patch）</h3><ul><li><p>patch 命令被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p num</code></td><td>忽略几层文件夹</td></tr><tr><td><code>-E</code></td><td>如果发现了空文件，那么就删除它</td></tr><tr><td><code>-R</code></td><td>取消打过的补丁</td></tr></tbody></table></li><li><p>生成<code>file1.txt</code>和<code>file2.txt</code>的 diff 文件，然后应用 patch 命令更新<code>file1.txt</code>文件</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff  -Naur file1<span class="selector-class">.txt</span>  file2<span class="selector-class">.txt</span> &gt; patchdiff<span class="selector-class">.txt</span></span><br><span class="line">patch &lt; patchdiff.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420782242319" alt="img"></p></li><li><p>取消上面打过的补丁</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">patch</span> -R &lt; patchdiff.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420782287649" alt="img"></p></li></ul><h2 id="空间管理">空间管理</h2><h3 id="查看目录结构（tree）">查看目录结构（tree）</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tree</span> &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p>安装方式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install tree</span><br></pre></td></tr></table></figure><h3 id="磁盘占用情况（df）">磁盘占用情况（df）</h3><ul><li><p>df （disk free）命令的功能是用来检查 linux 服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-a</code></td><td>全部文件系统列表</td></tr><tr><td><code>-h</code></td><td>方便阅读方式显示</td></tr><tr><td><code>-i</code></td><td>显示 inode 信息</td></tr><tr><td><code>-T</code></td><td>文件系统类型</td></tr><tr><td><code>-t&lt;文件系统类型&gt;</code></td><td>只显示选定文件系统的磁盘信息</td></tr><tr><td><code>-x&lt;文件系统类型&gt;</code></td><td>不显示选定文件系统的磁盘信息</td></tr></tbody></table></li><li><p>显示磁盘使用情况</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740116614" alt="img"></p></li><li><p>以 inode 模式来显示磁盘使用情况</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -i</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740127431" alt="img"></p></li><li><p>列出文件系统的类型</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -T</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740135464" alt="img"></p></li><li><p>显示指定类型磁盘</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -t ext4</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740147180" alt="img"></p></li></ul><h3 id="查看使用空间（du）">查看使用空间（du）</h3><ul><li><p>du（disk usage）命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示目录中所有文件的大小。</td></tr><tr><td><code>-b</code></td><td>显示目录或文件大小时，以 byte 为单位。</td></tr><tr><td><code>-c</code></td><td>除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</td></tr><tr><td><code>-k</code></td><td>以 KB(1024bytes)为单位输出。</td></tr><tr><td><code>-m</code></td><td>以 MB 为单位输出。</td></tr><tr><td><code>-s</code></td><td>仅显示总计，只列出最后加总的值。</td></tr><tr><td><code>-h</code></td><td>以 K，M，G 为单位，提高信息的可读性。</td></tr></tbody></table></li><li><p>显示指定文件所占空间，以方便阅读的格式显示</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h file1.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740343106" alt="img"></p></li><li><p>显示指定目录所占空间，以方便阅读的格式显示</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h Desktop</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740370569" alt="img"></p></li><li><p>显示几个文件或目录各自占用磁盘空间的大小，并且统计总和</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -ch file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740386138" alt="img"></p></li><li><p>按照空间大小逆序排序显示</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740400752" alt="img"></p></li></ul>]]></content>
    
    
    <summary type="html">Linux中常用的简单操作</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的进程</title>
    <link href="https://www.iuoyt.com/posts/62cfef17.html"/>
    <id>https://www.iuoyt.com/posts/62cfef17.html</id>
    <published>2023-12-01T11:31:29.000Z</published>
    <updated>2023-12-01T15:06:50.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序与进程">程序与进程</h2><ul><li><p>简单地说，程序就是为了完成某种任务而设计的软件，进程就是运行中的程序。</p></li><li><p>程序只是一些列指令的集合，是一个静止的实体，而进程则有以下特性：</p><ul><li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li><li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li><li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li><li>异步性：进程以不可预知的速度向前推进。</li><li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li></ul></li><li><p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。</p><blockquote><p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p></blockquote></li><li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li></ul><h2 id="进程的属性">进程的属性</h2><h3 id="进程的分类">进程的分类</h3><h4 id="按功能和服务对象">按功能和服务对象</h4><ul><li>从这个角度看，可以将进程分为用户进程与系统进程<ul><li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li><li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li></ul></li></ul><h4 id="按应用程序的服务类型">按应用程序的服务类型</h4><ul><li>从这个角度看，可以将进程分为交互进程、批处理进程、守护进程<ul><li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。</li></ul></li></ul><h3 id="进程的衍生">进程的衍生</h3><h4 id="父进程与子进程">父进程与子进程</h4><ul><li><p>子进程是由父进程开启的，比如在终端中输入<code>bash</code>再启动一个终端，那么新打开的终端则称为子进程，前者则为父进程。关于父进程与子进程便会涉及这两个系统调用 <code>fork()</code> 与 <code>exec()</code>：</p><ul><li><code>fork()</code>：主要作用是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</li><li><code>exec()</code>：作用是切换子进程中的执行程序，也就是替换其从父进程复制过来的代码段与数据段</li></ul></li><li><p>子进程在退出前主函数<code>main()</code>会执行<code>exit(n)</code>或者<code>return n</code>返回一个信号值，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。</p></li></ul><h4 id="僵尸进程">僵尸进程</h4><ul><li>正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 <code>reason for termination</code> 。之后，父进程会使用 <code>wait(&amp;status)</code> 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。</li><li>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。</li></ul><h4 id="孤儿进程">孤儿进程</h4><ul><li>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。</li></ul><h4 id="进程0（内核初始化进程）">进程0（内核初始化进程）</h4><ul><li>进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 <code>fork()</code> 创建出一个子进程运行 <code>/sbin/init</code> 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。</li></ul><h3 id="进程组与Session">进程组与Session</h3><ul><li>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</li><li>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 <code>getpgrp()</code> 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</li><li>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，Session 中的每个进程都称为一个工作(job)。</li></ul><h3 id="工作管理">工作管理</h3><ul><li><p>并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。</p></li><li><p>结束前台进程可以使用<kbd>Ctrl</kbd>+<kbd>C</kbd>，但无法结束后台进程。</p></li><li><p>如果使用<code>&amp;</code>符号，进程则会在后台中运行，查看运行中的进程可以使用<code>ls &amp;</code>，得到序号如<code>[1] 204</code>分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224354846.png" alt="image-20231201224354846"></p></li><li><p>如果希望暂停当前工作并存放到后台可以使用<kbd>Ctrl</kbd>+<kbd>Z</kbd></p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224613524.png" alt="image-20231201224613524"></p></li><li><p>被放置到后台的工作可以使用<code>jobs</code>查看。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224819667.png" alt="image-20231201224819667"></p><p>其中第一列显示的为被放置后台 job 的编号，而第二列的 <code>+</code> 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，<code>-</code> 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令。</p></li><li><p>如果希望将后台的工作拿到前台继续进行，可以使用<code>fg</code>命令：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后面不加参数提取预设工作，加参数提取指定工作的编号</span></span><br><span class="line"><span class="comment">#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</span></span><br><span class="line"><span class="attribute">fg</span><span class="meta"> [%jobnumber]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201225144514.png" alt="image-20231201225144514"></p></li><li><p>而如果希望其在后台继续而不拿到前台，可以使用<code>bg</code>命令：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与fg类似，加参则指定，不加参则取预设</span></span><br><span class="line"><span class="attribute">bg</span><span class="meta"> [%jobnumber]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201225553266.png" alt="image-20231201225553266"></p></li><li><p>如果希望删除后台的工作，可以使用<code>kill</code>命令结束进程：</p>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kill的使用格式如下</span></span><br><span class="line"><span class="keyword">kill</span> -signal %jobnumber</span><br><span class="line"></span><br><span class="line"><span class="comment">#signal从1-64个信号值可以选择，可以这样查看</span></span><br><span class="line"><span class="keyword">kill</span> －l</span><br></pre></td></tr></table></figure><p>其中常用的有这些信号值</p></li></ul><table><thead><tr><th>信号值</th><th>作用</th></tr></thead><tbody><tr><td>-1</td><td>重新读取参数运行，类似与restart</td></tr><tr><td>-2</td><td>如同 ctrl+c 的操作退出</td></tr><tr><td>-9</td><td>强制终止该任务</td></tr><tr><td>-15</td><td>正常的方式终止该任务</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Linux 中也难免遇到某个程序无响应的情况，可以通过一些命令来帮助我们让系统能够更流畅的运行。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下软件安装</title>
    <link href="https://www.iuoyt.com/posts/cf3716a6.html"/>
    <id>https://www.iuoyt.com/posts/cf3716a6.html</id>
    <published>2023-12-01T03:09:15.000Z</published>
    <updated>2023-12-01T15:04:02.973Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Linux上通常有四种方式安装软件：<ul><li>在线安装</li><li>从磁盘安装deb软件包</li><li>从二进制软件包安装</li><li>从源代码编译安装</li></ul></li><li>这篇文章中使用的场景均为Ubuntu下，不一定适用于其他Linux发行版。</li></ul><h2 id="使用apt-get安装软件">使用apt-get安装软件</h2><ul><li><p>现在如果想安装一个名为<code>w3m</code>（命令行的简易网页浏览器），那么可以输入如下命令：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install w3m</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201175216825.png" alt="image-20231201175216825"></p></li><li><p>在软件安装完成后，无法直接使用<kbd>Tab</kbd>补全命令，可以先执行如下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h3 id="apt包管理工具介绍">apt包管理工具介绍</h3><blockquote><p>APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 <code>apt-</code> 开头的多个工具，如 <code>apt-get</code> <code>apt-cache</code> <code>apt-cdrom</code> 等，在Debian系列的发行版中使用。</p></blockquote><ul><li>当在执行安装操作时，首先<code>apt-get</code> 工具会在<strong>本地</strong>的一个数据库中搜索软件的相关信息，并根据这些信息在相关的服务器上下载软件安装。</li><li>我们需要定期从服务器上下载一个软件包列表，系统会使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有<strong>软件依赖</strong>信息的记录，对于软件依赖，比如：安装 <code>w3m</code> 软件的时候，而这个软件需要 <code>libgc1c2</code> 这个软件包才能正常工作，这个时候 <code>apt-get</code> 在安装软件的时候会将其一并安装，以保证 <code>w3m</code> 能正常工作。</li></ul><h3 id="apt-get">apt-get</h3><ul><li><code>apt-get</code> 是用于处理 <code>apt</code>包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些<code>apt-get</code>包含的常用的一些工具：</li></ul><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><code>install</code></td><td>其后加上软件包名，用于安装一个软件包</td></tr><tr><td><code>update</code></td><td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td></tr><tr><td><code>upgrade</code></td><td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次<code>update</code></td></tr><tr><td><code>dist-upgrade</code></td><td>解决依赖关系并升级(存在一定危险性)</td></tr><tr><td><code>remove</code></td><td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td></tr><tr><td><code>autoremove</code></td><td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td></tr><tr><td><code>purge</code></td><td>与remove相同，但会完全移除软件包，包含其配置文件</td></tr><tr><td><code>clean</code></td><td>移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/</td></tr><tr><td><code>autoclean</code></td><td>移除已安装的软件的旧版本软件包</td></tr></tbody></table><ul><li><code>apt-get</code>的常用参数如下：</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-y</code></td><td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td></tr><tr><td><code>-s</code></td><td>模拟安装</td></tr><tr><td><code>-q</code></td><td>静默安装方式，指定多个<code>q</code>或者<code>-q=#</code>,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td></tr><tr><td><code>-f</code></td><td>修复损坏的依赖关系</td></tr><tr><td><code>-d</code></td><td>只下载不安装</td></tr><tr><td><code>--reinstall</code></td><td>重新安装已经安装但可能存在问题的软件包</td></tr><tr><td><code>--install-suggests</code></td><td>同时安装APT给出的建议安装的软件包</td></tr></tbody></table><h3 id="使用apt-get安装软件包">使用apt-get安装软件包</h3><ul><li><p>就像前面演示的一样，只需要执行<code>apt-get install &lt;软件包名&gt;</code>即可。</p></li><li><p>但有时需要重新对软件包进行安装，比如在系统被破坏、软件配置错误等时候，则可以加上<code>--reinstall</code>参数进行重新安装，比如对前面安装的<code>w3m</code>进行重装：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="comment">--reinstall install w3m</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201180918092.png" alt="image-20231201180918092"></p></li></ul><h3 id="更换软件源与软件升级">更换软件源与软件升级</h3><ul><li><p>如果希望更换软件的下载源，可以到<code>/etc/apt</code>目录下修改<code>sources.list</code>文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>apt/sources.list</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201181658888.png" alt="image-20231201181658888"></p></li><li><p>更新软件源可以使用如下命令：</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201181015727.png" alt="image-20231201181015727"></p></li><li><p>对所有没有依赖问题的软件包进行升级：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> upgrade</span><br></pre></td></tr></table></figure></li><li><p>全部升级并解决依赖关系：</p>  <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="built_in">dist</span>-upgrade</span><br></pre></td></tr></table></figure></li></ul><h3 id="卸载软件">卸载软件</h3><ul><li><p>现在想卸载掉<code>w3m</code>这个软件，可以使用同样的命令，带上<code>remove</code>参数即可完成卸载：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="built_in">remove</span> w3m</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201182239343.png" alt="image-20231201182239343"></p></li><li><p>如果希望不保留配置文件的移除，可以使用：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> purge w3m</span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="comment">--purge remove</span></span><br></pre></td></tr></table></figure></li><li><p>同时也可以移除不再需要的被依赖软件包：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> autoremove</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201182505496.png" alt="image-20231201182505496"></p></li></ul><h3 id="软件搜索">软件搜索</h3><ul><li><p>如果不确定需要的软件是否已经安装，可以使用搜索功能：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache search soft<span class="symbol">name1</span> soft<span class="symbol">name2</span> soft<span class="symbol">name3</span>……</span><br></pre></td></tr></table></figure><p><code>apt-cache</code> 命令是针对本地数据进行相关操作的工具，<code>search</code> 顾名思义在本地的数据库中寻找有关 <code>softname1</code> <code>softname2</code> …… 相关软件的信息。</p></li></ul><h2 id="使用dpkd安装">使用dpkd安装</h2><h3 id="安装deb软件包">安装deb软件包</h3><ul><li>我们可以经常在网络上见到以<code>deb</code>形式打包的软件包，这些软件包就需要使用<code>dpkg</code>命令来安装，常用参数如下：</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-i</code></td><td>安装指定deb包</td></tr><tr><td><code>-R</code></td><td>后面加上目录名，用于安装该目录下的所有deb安装包</td></tr><tr><td><code>-r</code></td><td>remove，移除某个已安装的软件包</td></tr><tr><td><code>-I</code></td><td>显示<code>deb</code>包文件的信息</td></tr><tr><td><code>-s</code></td><td>显示已安装软件的信息</td></tr><tr><td><code>-S</code></td><td>搜索已安装的软件包</td></tr><tr><td><code>-L</code></td><td>显示已安装软件包的目录信息</td></tr></tbody></table><ul><li><p>首先使用<code>apt-get</code>加上<code>-d</code>参数只下载不安装，下载<code>emacs</code>编辑器的deb包：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> -d install -y emacs</span><br></pre></td></tr></table></figure></li><li><p>下载完成后，可以在<code>/var/cache/apt/archives/</code>查看下载的内容：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="regexp">/var/</span>cache<span class="regexp">/apt/</span>archives/</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201190916849.png" alt="image-20231201190916849"></p></li><li><p>将第一个文件拷贝到用户目录下，并使用<code>dpkg</code>安装：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cp</span> /var/cache/apt/archives/emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb ~</span><br><span class="line"><span class="attribute">sudo</span> dpkg -I emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201191438879.png" alt="image-20231201191438879"></p></li><li><p>但如果安装的软件包还有额外依赖，那么意味着直接使用<code>dpkg</code>命令会出现一些问题，因为<code>dpkg</code>无法解决依赖关系问题：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dpkg -i emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201191718630.png" alt="image-20231201191718630"></p></li><li><p>为了解决这个问题，可以使用<code>apt-get</code>的<code>-f</code>参数修复依赖关系的安装：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> -f install -y</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看已安装软件包的安装目录">查看已安装软件包的安装目录</h3><ul><li><p>如果希望知道每个软件分别安装到了什么地方，可以使用<code>dpkg</code>的<code>-L</code>参数查看deb包目录信息：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dpkg -L emacs24</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201192702116.png" alt="image-20231201192702116"></p></li></ul>]]></content>
    
    
    <summary type="html">介绍Linux中软件安装的几种方式，及apt、dpkg工具的使用。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux正则表达式相关命令</title>
    <link href="https://www.iuoyt.com/posts/9505e307.html"/>
    <id>https://www.iuoyt.com/posts/9505e307.html</id>
    <published>2023-11-24T10:14:53.000Z</published>
    <updated>2023-11-25T03:20:44.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式">正则表达式</h2><blockquote><p><strong>正则表达式</strong>：计算机科学的一个概念，使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p></blockquote><h3 id="选择">选择</h3><ul><li><code>|</code>竖直分隔符表示选择，例如<code>boy|girl</code>可以匹配<code>boy</code>或者<code>girl</code></li></ul><h3 id="数量限定">数量限定</h3><ul><li><code>+</code>表示前面的字符必须出现至少一次（1次或多次），例如<code>ab+cd</code>，可以匹配<code>abcd</code>，<code>abbcd</code>等</li><li><code>?</code>表示前面的字符最多出现一次（0次或1次），例如<code>colou?r</code>，可以匹配<code>color</code>或者<code>colour</code></li><li><code>*</code>星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、1次或多次），例如<code>0*42</code>可以匹配<code>42</code>、<code>042</code>、<code>0042</code>、<code>00042</code>等</li></ul><h3 id="范围和优先级">范围和优先级</h3><ul><li><code>()</code>圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，<code>gr(a|e)y</code>等价于<code>gray|grey</code>（这里体现了优先级，竖直分隔符用于选择<code>a</code>或者<code>e</code>而不是<code>gra</code>和<code>ey</code>），<code>(grand)?father</code>匹配<code>father</code>和<code>grandfather</code>（这里体现了范围，<code>?</code>将圆括号内容作为一个整体匹配）</li></ul><h3 id="更多语法">更多语法</h3><table><thead><tr><th style="text-align:center">字符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td><strong>将下一个字符标记为一个特殊字符、或一个原义字符。</strong> 例如，<code>n</code>匹配字符<code>n</code>，<code>\n</code>匹配一个换行符，序列<code>\\</code>匹配<code>\</code>而<code>\(</code>则匹配<code>(</code></td></tr><tr><td style="text-align:center">^</td><td><strong>匹配输入字符串的开始位置</strong></td></tr><tr><td style="text-align:center">$</td><td><strong>匹配输入字符串的结束位置</strong></td></tr><tr><td style="text-align:center">{n}</td><td><strong>匹配确定的n次（n为非负整数）</strong>。例如，<code>o&#123;2&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code></td></tr><tr><td style="text-align:center">{n,}</td><td><strong>至少匹配n次（n为非负整数）</strong>。例如，<code>o&#123;2,&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但能匹配<code>foooood</code>中的所有<code>o</code>。<code>o&#123;1,&#125;</code>等价于<code>o+</code>，<code>o&#123;0,&#125;</code>则等价于<code>o*</code></td></tr><tr><td style="text-align:center">{n,m}</td><td><strong>最少匹配n次且最多匹配m次（m和n均为非负整数，其中n&lt;=m）。</strong> 例如，<code>o&#123;1,3&#125;</code>将匹配<code>fooooood</code>中的前三个<code>o</code>。<code>o&#123;0,1&#125;</code>等价于<code>o?</code>。请注意在逗号和两个数之间不能有空格</td></tr><tr><td style="text-align:center">*</td><td><strong>匹配前面的子表达式零次或多次</strong>。例如，<code>zo</code>能匹配<code>z</code>、<code>zo</code>以及<code>zoo</code>。<code>*</code>等价于<code>&#123;0,&#125;</code></td></tr><tr><td style="text-align:center">+</td><td><strong>匹配前面的子表达式一次或多次</strong>。例如，<code>zo+</code>能匹配<code>zo</code>以及<code>zoo</code>，但不能匹配<code>z</code>。<code>+</code>等价于<code>&#123;1,&#125;</code></td></tr><tr><td style="text-align:center">?</td><td><strong>匹配前面的子表达式零次或一次</strong>。例如，<code>do(es)?</code>可以匹配<code>do</code>或<code>does</code>中的<code>do</code>。<code>?</code>等价于<code>&#123;0,1&#125;</code></td></tr><tr><td style="text-align:center">限制符+?</td><td>当该字符紧跟在任何一个其他限制符（<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code>）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串<code>oooo</code>，<code>o+?</code>将匹配单个<code>o</code>，而<code>o+</code>将匹配所有<code>o</code></td></tr><tr><td style="text-align:center">.</td><td><strong>匹配除<code>\n</code>之外的任何单个字符</strong>。要匹配包括<code>\n</code>在内的任何字符，请使用像(.|\n)的模式</td></tr><tr><td style="text-align:center">(pattern)</td><td><strong>匹配pattern并获取这一匹配的子字符串</strong>。该子字符串用于向后引用。要匹配圆括号字符，请使用<code>\(</code>或<code>\)</code></td></tr><tr><td style="text-align:center">x|y</td><td><strong>匹配x或y</strong>。例如z|food能匹配<code>z</code>或<code>food</code>，(z|f)ood则匹配<code>zood</code>或<code>food</code></td></tr><tr><td style="text-align:center">[xyz]</td><td>字符集合，<strong>匹配所包含的任意一个字符</strong>。例如，<code>[abc]</code>可以匹配<code>plain</code>中的<code>a</code>。其中特殊字符仅有反斜线<code>\</code>保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符<code>^</code>如果出现在首位则表示负值字符集合，如果出现在字符串中间就仅作为普通字符。<strong>连字符<code>-</code> 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符</strong></td></tr><tr><td style="text-align:center">[^xyz]</td><td>排除型字符集合，<strong>匹配未列出的任意字符。</strong> 例如，<code>[^abc]</code>可以匹配<code>plain</code>中的<code>plin</code></td></tr><tr><td style="text-align:center">[a-z]</td><td>字符范围，<strong>匹配指定范围内的任意字符。</strong> 例如，<code>[a-z]</code>可以匹配<code>a</code>到<code>z</code>范围内的任意小写字母字符</td></tr><tr><td style="text-align:center">[^a-z]</td><td>排除型的字符范围，<strong>匹配任何不在指定范围内的任意字符</strong>。例如，<code>[^a-z]</code>可以匹配任何不在<code>a</code>到<code>z</code>范围内的任意字符</td></tr></tbody></table><h3 id="优先级">优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>高</td><td>\</td><td>转义符</td></tr><tr><td></td><td>(), (?:), (?=), []</td><td>括号和中括号</td></tr><tr><td></td><td>*、+、?、{n}、{n,}、{n,m}</td><td>限定符</td></tr><tr><td></td><td>^、$、\任何元字符</td><td>定位点和序列</td></tr><tr><td>低</td><td>|</td><td>选择</td></tr></tbody></table><h2 id="相关命令">相关命令</h2><h3 id="grep模式匹配命令">grep模式匹配命令</h3><h4 id="基本操作">基本操作</h4><ul><li><code>grep</code>命令用于打印输出文本中匹配的模式串，使用正则表达式作为匹配的条件。这个命令支持三种正则表达式引擎，用三种参数指定，在不使用perl语言的情况下用的大多数正则表达式都是前两种：</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-E</code></td><td style="text-align:center">POSIX扩展正则表达式，ERE</td></tr><tr><td style="text-align:center"><code>-G</code></td><td style="text-align:center">POSIX基本正则表达式，BRE</td></tr><tr><td style="text-align:center"><code>-P</code></td><td style="text-align:center">Perl正则表达式，PCRE</td></tr></tbody></table><ul><li><code>grep</code>命令有如下常用参数：</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:left">将二进制文件作为文本来进行匹配</td></tr><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:left">统计以模式匹配的数目</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:left">忽略大小写</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:left">显示匹配文本所在行的行号</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:left">反选，输出不匹配行的内容</td></tr><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:left">递归匹配查找</td></tr><tr><td style="text-align:center"><code>-A n</code></td><td style="text-align:left">n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行</td></tr><tr><td style="text-align:center"><code>-B n</code></td><td style="text-align:left">n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行</td></tr><tr><td style="text-align:center"><code>--color=auto</code></td><td style="text-align:left">将输出中的匹配项设置为自动颜色显示</td></tr></tbody></table><h4 id="使用基本正则表达式BRE">使用基本正则表达式BRE</h4><h5 id="位置">位置</h5><ul><li><p>查找<code>/etc/group</code>文件中以<code>shiyanlou</code>开头的行：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">&#x27;shiyanlou&#x27;</span> <span class="regexp">/etc/g</span>roup</span><br><span class="line"><span class="keyword">grep</span> <span class="string">&#x27;^shiyanlou&#x27;</span> <span class="regexp">/etc/g</span>roup</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191055543.png" alt="image-20231124191055543"></p></li></ul><h5 id="数量">数量</h5><ul><li><p>匹配以<code>z</code>开头以<code>o</code>结尾的所有字符串：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;zero</span>\nzo\nzoo&#x27; | grep <span class="symbol">&#x27;z</span>.*o&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191223808.png" alt="image-20231124191223808"></p></li><li><p>将匹配以<code>z</code>开头以<code>o</code>结尾，中间包含一个任意字符的字符串：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;zero</span>\nzo\nzoo&#x27; | grep <span class="symbol">&#x27;z</span>.o&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191353795.png" alt="image-20231124191353795"></p></li><li><p>将匹配以<code>z</code>开头,以任意多个<code>o</code>结尾的字符串：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;zo*&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191447803.png" alt="image-20231124191447803"></p></li></ul><h5 id="选择-2">选择</h5><ul><li><p><code>grep</code>默认是区分大小写的，接下来对字符串<code>1234\nabcd</code>进行如下操作。</p></li><li><p>匹配所有的小写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[a-z]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191630543.png" alt="image-20231124191630543"></p></li><li><p>匹配所有的数字：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[0-9]&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:digit:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191950057.png" alt="image-20231124191950057"></p></li><li><p>匹配所有的小写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:lower:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192147548.png" alt="image-20231124192147548"></p></li><li><p>匹配所有的大写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd\nABCD&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:upper:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192246970.png" alt="image-20231124192246970"></p></li><li><p>匹配所有的字母和数字，包括0-9,a-z,A-Z：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:alnum:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192348521.png" alt="image-20231124192348521"></p></li><li><p>匹配所有的字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:alpha:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192435784.png" alt="image-20231124192435784"></p></li><li><p>完整的特殊符号列表及说明：</p></li></ul><table><thead><tr><th style="text-align:center">特殊符号</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>[:alnum:]</code></td><td>代表英文大小写字母及数字，亦即 0-9, A-Z, a-z</td></tr><tr><td style="text-align:center"><code>[:alpha:]</code></td><td>代表任何英文大小写字母，亦即 A-Z, a-z</td></tr><tr><td style="text-align:center"><code>[:blank:]</code></td><td>代表空白键与 [Tab] 按键两者</td></tr><tr><td style="text-align:center"><code>[:cntrl:]</code></td><td>代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del… 等等</td></tr><tr><td style="text-align:center"><code>[:digit:]</code></td><td>代表数字而已，亦即 0-9</td></tr><tr><td style="text-align:center"><code>[:graph:]</code></td><td>除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键</td></tr><tr><td style="text-align:center"><code>[:lower:]</code></td><td>代表小写字母，亦即 a-z</td></tr><tr><td style="text-align:center"><code>[:print:]</code></td><td>代表任何可以被列印出来的字符</td></tr><tr><td style="text-align:center"><code>[:punct:]</code></td><td>代表标点符号 (punctuation symbol)，亦即：&quot; ’ ? ! ; : # $…</td></tr><tr><td style="text-align:center"><code>[:upper:]</code></td><td>代表大写字母，亦即 A-Z</td></tr><tr><td style="text-align:center"><code>[:space:]</code></td><td>任何会产生空白的字符，包括空白键, [Tab], CR 等等</td></tr><tr><td style="text-align:center"><code>[:xdigit:]</code></td><td>代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</td></tr></tbody></table><h5 id="排除">排除</h5><ul><li><p>在字符串中排除字符：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;geek\ngood&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[^o]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192843061.png" alt="image-20231124192843061"></p>  <div class="tip "><p>当<code>^</code>放到中括号内为排除字符，否则表示行首</p></div></li></ul><h4 id="使用扩展正则表达式ERE">使用扩展正则表达式ERE</h4><div class="tip "><p>通过<code>grep</code>使用扩展正则表达式需要加上<code>-E</code>参数，或使用<code>egrep</code></p></div><h5 id="数量-2">数量</h5><ul><li><p>只匹配<code>zo</code>：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> -E <span class="string">&#x27;zo&#123;1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193420972.png" alt="image-20231124193420972"></p></li><li><p>匹配以<code>zo</code>开头的所有单词：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> -E <span class="string">&#x27;zo&#123;1,&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193513268.png" alt="image-20231124193513268"></p></li></ul><h5 id="选择-3">选择</h5><ul><li><p>匹配<code>www.shiyanlou.com</code>和<code>www.google.com</code>：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27; | grep -<span class="type">E</span> <span class="symbol">&#x27;www</span>\.(shiyanlou|google)\.com&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193714766.png" alt="image-20231124193714766"></p></li><li><p>或者匹配不包含<code>baidu</code>的内容：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27; | grep -<span class="type">Ev</span> <span class="symbol">&#x27;www</span>\.baidu\.com&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193823247.png" alt="image-20231124193823247"></p></li></ul><div class="tip "><p>因为<code>.</code>号有特殊含义，所以需要转义</p></div><h3 id="sed流编辑器">sed流编辑器</h3><ul><li><p><code>sed</code>命令的基本格式如下：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [参数]... [执行命令] [输入文件]...</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用参数">常用参数</h4><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-n</code></td><td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td></tr><tr><td style="text-align:center"><code>-e</code></td><td>用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td></tr><tr><td style="text-align:center"><code>-f filename</code></td><td>指定执行filename文件中的命令</td></tr><tr><td style="text-align:center"><code>-r</code></td><td>使用扩展正则表达式，默认为标准正则表达式</td></tr><tr><td style="text-align:center"><code>-i</code></td><td>将直接修改输入文件内容，而不是打印到标准输出设备</td></tr></tbody></table><h4 id="执行命令">执行命令</h4><ul><li><p><code>sed</code>命令中可以有单条或多条执行命令，每条执行命令之间使用<code>;</code>分隔，执行命令格式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[n1]</span><span class="selector-attr">[,n2]</span>command</span><br><span class="line"><span class="selector-attr">[n1]</span><span class="selector-attr">[~step]</span>command</span><br></pre></td></tr></table></figure><p>其中n1,n2表示输入内容的行号，它们之间为<code>,</code>逗号则表示从n1到n2行，如果为<code>～</code>波浪号则表示从n1开始以step为步进的所有行；command为执行动作。</p></li><li><p>其中一些命令可以在后面加上作用范围，比如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/sad/happy/g&#x27;</span> <span class="built_in">test</span></span><br><span class="line">sed -i <span class="string">&#x27;s/sad/happy/4&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>其中，第一句命令的<code>g</code>表示全局范围，第二句命令的<code>4</code>表示指定行中第四个匹配的字符串，上面两句都是将范围内的<code>sad</code>更改为<code>happy</code>。</p></li><li><p>下面为一些常用动作指令：</p></li></ul><table><thead><tr><th style="text-align:center">命令</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>s</code></td><td>行内替换</td></tr><tr><td style="text-align:center"><code>c</code></td><td>整行替换</td></tr><tr><td style="text-align:center"><code>a</code></td><td>插入到指定行的后面</td></tr><tr><td style="text-align:center"><code>i</code></td><td>插入到指定行的前面</td></tr><tr><td style="text-align:center"><code>p</code></td><td>打印指定行，通常与<code>-n</code>参数配合使用</td></tr><tr><td style="text-align:center"><code>d</code></td><td>删除指定行</td></tr></tbody></table><h4 id="操作举例">操作举例</h4><ul><li><p>首先得到一个用于测试的文本文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/etc/</span>passwd ~</span><br></pre></td></tr></table></figure></li><li><p>打印指定行（2-5）：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nl</span> passwd | sed -n &#x27;<span class="number">2</span>,<span class="number">5</span>p&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195346741.png" alt="image-20231124195346741"></p></li><li><p>打印奇数行：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nl</span> passwd | sed -n &#x27;<span class="number">1</span>~<span class="number">2</span>p&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195457985.png" alt="image-20231124195457985"></p></li><li><p>行内替换，将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;,并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sed</span> -n <span class="string">&#x27;s/shiyanlou/hehe/gp&#x27;</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195627471.png" alt="image-20231124195627471"></p></li><li><p>删除某行（30）：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl passwd <span class="string">| grep &quot;</span>shiyanlou<span class="string">&quot;</span></span><br><span class="line">sed -i &#x27;30d&#x27; passwd</span><br><span class="line">nl passwd <span class="string">| grep &quot;</span>shiyanlou<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195906463.png" alt="image-20231124195906463"></p></li></ul><h3 id="awk文本处理语言">awk文本处理语言</h3><h4 id="简单介绍">简单介绍</h4><blockquote><p><code>AWK</code>是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一，其名称得自于它的创始人Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和Brian Wilson Kernighan（布莱恩·柯林汉）姓氏的首个字母.AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”，它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK是一种用于处理文本的编程语言工具。</p></blockquote><ul><li><p>在大多数linux发行版上面，实际使用的是gawk（GNU awk，awk的GNU版本），在ubuntu环境上，默认提供的是mawk，系统已经创建好了<code>awk</code>指向mawk的符号链接：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll <span class="regexp">/usr/</span>bin/awk</span><br></pre></td></tr></table></figure></li></ul><h4 id="基础概念">基础概念</h4><ul><li><p><code>awk</code>所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：</p>  <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pattern</span> &#123;action&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>awk</code>处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，<code>awk</code>以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符。</p></li></ul><h4 id="基本格式">基本格式</h4><ul><li><p><code>awk</code>命令的基本格式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="selector-attr">[-F fs]</span> <span class="selector-attr">[-v var=value]</span> <span class="selector-attr">[-f prog-file | <span class="string">&#x27;program text&#x27;</span>]</span> <span class="selector-attr">[file...]</span></span><br></pre></td></tr></table></figure><p>其中<code>-F</code>参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，<code>-v</code>用于预先为<code>awk</code>程序指定变量，<code>-f</code>参数用于指定<code>awk</code>命令要执行的程序文件，或者在不加<code>-f</code>参数的情况下直接将程序语句放在这里，最后为<code>awk</code>需要处理的文本输入，且可以同时输入多个文本文件。</p></li></ul><h4 id="具体操作">具体操作</h4><ul><li><p>先用<code>vim</code>新建一个文本文档：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>输入如下内容：</p>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I <span class="keyword">like</span> linux</span><br><span class="line">www.shiyanlou.com</span><br></pre></td></tr></table></figure><p>按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出</p></li><li><p>使用<code>awk</code>将文本内容打印到终端：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print&#125;&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124201201455.png" alt="image-20231124201201455"></p></li><li><p>将test的第一行的每个字段单独显示为一行，其他行则直接显示：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">1</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span> <span class="variable">$2</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span> <span class="variable">$3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">print&#125;</span><br><span class="line">&#125;&#x27; test</span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">OFS</span><span class="operator">=</span><span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">print <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">print&#125;</span><br><span class="line">&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124224624617.png" alt="image-20231124224624617"></p></li><li><p>将test的第二行的以点为分段的字段换成以tab为分隔：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="operator">-</span><span class="type">F</span>&#x27;.&#x27; &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">2</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span> <span class="variable">$2</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span> <span class="variable">$3</span></span><br><span class="line">&#125;&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124224952656.png" alt="image-20231124224952656"></p><p>或者：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;</span><br><span class="line"><span class="type">BEGIN</span>&#123;</span><br><span class="line"><span class="type">FS</span><span class="operator">=</span><span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="type">OFS</span><span class="operator">=</span><span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">&#125;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">2</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span></span><br><span class="line">&#125;&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124225037736.png" alt="image-20231124225037736"></p></li></ul><h4 id="常见内置变量">常见内置变量</h4><table><thead><tr><th style="text-align:center">变量名</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>FILENAME</code></td><td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td></tr><tr><td style="text-align:center"><code>$0</code></td><td>当前记录的内容</td></tr><tr><td style="text-align:center"><code>$N</code></td><td>N表示字段号，最大值为<code>NF</code>变量的值</td></tr><tr><td style="text-align:center"><code>FS</code></td><td>字段分隔符，由正则表达式表示，默认为&quot; &quot;空格</td></tr><tr><td style="text-align:center"><code>RS</code></td><td>输入记录分隔符，默认为<code>\n</code>，即一行为一个记录</td></tr><tr><td style="text-align:center"><code>NF</code></td><td>当前记录字段数</td></tr><tr><td style="text-align:center"><code>NR</code></td><td>已经读入的记录数</td></tr><tr><td style="text-align:center"><code>FNR</code></td><td>当前输入文件的记录数，请注意它与NR的区别</td></tr><tr><td style="text-align:center"><code>OFS</code></td><td>输出字段分隔符，默认为&quot; &quot;空格</td></tr><tr><td style="text-align:center"><code>ORS</code></td><td>输出记录分隔符，默认为<code>\n</code></td></tr></tbody></table><h2 id="实战训练">实战训练</h2><ol><li><p>辨析pattern space和hold space的概念</p><ul><li><p>Pattern space（模式空间）</p><ul><li><p>用于存储当前处理的文本行的缓冲区。在<code>sed</code>的处理过程中，文本逐行读取，每一行都被存储在Pattern space中，然后在Pattern space中进行模式匹配和操作。</p></li><li><p>当<code>sed</code>读取一行文本时，该行文本被放入Pattern space中，然后执行可能的操作，如查找和替换。处理完一行后，Pattern space中的内容可以被输出，也可以保留用于后续处理。</p></li></ul></li><li><p>Hold space（保持空间）</p><ul><li><p>用于在处理多行文本时保存额外的信息。与Pattern space不同，Hold space可以在不同的时刻存储不同的内容，而Pattern space则主要用于当前正在处理的行。</p></li><li><p><code>sed</code>提供的命令允许将Pattern space中的内容移动到Hold space中，反之亦然。这使得在处理多行文本时能够保留和操作先前处理的文本行的信息。</p></li></ul></li><li><p>在<code>sed</code>脚本中，可以使用<code>h</code>或<code>H</code>命令将Pattern space的内容转移到Hold space，使用<code>g</code>或<code>G</code>命令将Hold space的内容转移回Pattern space，区别如下：</p></li></ul></li></ol><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>g</code></td><td>将hold space中的内容拷贝到pattern space中，原来pattern space里的内容被覆盖</td></tr><tr><td><code>G</code></td><td>将hold space中的内容扩充到pattern space最后（换行）</td></tr><tr><td><code>h</code></td><td>将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖</td></tr><tr><td><code>H</code></td><td>将pattern space中的内容扩充到hold space最后（换行）</td></tr><tr><td><code>d</code></td><td>删除pattern space当前行，并读入下一新行到pattern space中</td></tr><tr><td><code>D</code></td><td>删除pattern space中的第一行，不读入下一行</td></tr></tbody></table><ol start="2"><li><p>基于pattern space和hold space实现将一个文本倒序输出</p><ul><li><p>新建一个文本，作为实验内容：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim testfile</span></span><br></pre></td></tr></table></figure></li><li><p>输入以下内容，然后保存文件：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br><span class="line">li<span class="symbol">ne6</span></span><br></pre></td></tr></table></figure></li><li><p>查看写入内容：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">awk</span> <span class="string">&#x27;&#123;print&#125;&#x27;</span> testfile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125004735382.png" alt="image-20231125004735382"></p></li><li><p>我们执行<code>sed</code>命令时能看到的输出都为Pattern space中的内容（当前处理的文本行的缓冲区），因此思路为借助Hold space对Pattern space当前的内容进行操作。</p></li><li><p>那么当前Pattern space在开始执行时依次存储的内容如下：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">line1</span> <span class="comment">#第一次执行</span></span><br><span class="line">line2 <span class="comment">#第二次执行</span></span><br><span class="line">line3 <span class="comment">#第三次执行</span></span><br><span class="line">line4 <span class="comment">#第四次执行</span></span><br></pre></td></tr></table></figure></li><li><p>现在希望将第一行放到第二行的后方，Pattern space变为如下内容：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span> <span class="attr">#第一次执行</span></span><br><span class="line"><span class="attr">line2</span>\<span class="symbol">nline1</span> <span class="attr">#第二次执行</span></span><br><span class="line"><span class="attr">line3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br></pre></td></tr></table></figure></li><li><p>那么经过多次执行操作，最后Pattern space期望变为内容如下：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span> <span class="attr">#第一次执行</span></span><br><span class="line"><span class="attr">line2</span>\<span class="symbol">nline1</span> <span class="attr">#第二次执行</span></span><br><span class="line"><span class="attr">line3</span>\<span class="symbol">nline2</span>\<span class="symbol">nline1</span> <span class="attr">#第三次执行</span></span><br><span class="line"><span class="attr">line4</span>\<span class="symbol">nline3</span>\<span class="symbol">nline2</span>\<span class="symbol">nline1</span> <span class="attr">#第四次执行</span></span><br></pre></td></tr></table></figure><p>如果完成上述操作，则会输出内容如下：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br></pre></td></tr></table></figure><p>由此看来，需要在每次扩展前一行到当前行的同时删除掉前一行的内容，最终仅保留最后一行的内容，即：</p>  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一次执行后当前行被删除</span></span><br><span class="line"><span class="comment">#第二次执行后当前行被删除</span></span><br><span class="line"><span class="comment">#第三次执行后当前行被删除</span></span><br><span class="line">line4<span class="string">\nline3\nline2\nline1</span> <span class="comment">#第四次执行</span></span><br></pre></td></tr></table></figure></li><li><p>整理思路得到对每一行执行的操作如下：</p><ul><li>将当前行扩展到下一行（Pattern space）后方，中间使用<code>\n</code>分隔</li><li>删除当前行，然后读取下一行</li></ul></li><li><p>但是，需要注意以下两个问题：</p><ul><li><code>sed</code>命令中使用分号<code>;</code>分隔的多个语句（①;②;③）如执行顺序为：第一行的 ① -&gt; ② -&gt; ③，然后才是第二行的 ① -&gt; ② -&gt; ③，以此类推。因为Pattern space是逐行读取的。</li><li>使用程序完成第①步操作并非可以只用一步完成，应该是先在下一行后方添加换行符，然后将当前行内容扩展到下一行。</li></ul></li><li><p>但如果对每一行都添加换行符，那么最终在<code>line1</code>的后方会多出一个多余的换行符，因此<code>line1</code>的后方不应该添加换行符。同时“删除当前行”操作在直行道最后一行时，也不应该删除最后一行，否则会丢失所有行的内容。</p></li><li><p>那么最终的操作如下：</p><ul><li>在每一行（除了第一行）后增加一个换行符（可以理解为将空内容换行扩展到当前行后方）</li><li>将当前行内容不换行扩展到下一行后方</li><li>将当前行删除（除非是最后一行），然后移动到下一行</li></ul></li><li><p>这个步骤中的前两步也可以换种思路，其中暂存区借助Hold space实现：</p><ul><li>将暂存区（开始时为空）内容换行扩展到当前行（除了第一行）：<code>1!G</code>，第一行以外的行都执行G操作（将hold space中的内容换行扩充到pattern space最后）</li><li>将当前行内容暂存：<code>h</code>，全部行都执行h操作（将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖）</li><li>删除当前行，移动到下一行（除非是最后一行）：<code>$!d</code>，最后一行以外的行都执行d操作（删除pattern space当前行，并读入下一新行到pattern space中）</li></ul></li><li><p>因此完整命令如下：</p>  <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;<span class="number">1</span><span class="title">!G</span><span class="comment">;h;$!d&#x27; testfile</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125024055225.png" alt="image-20231125024055225"></p></li></ul></li><li><p>基于pattern space和hold space实现交换奇数行和偶数行</p><ul><li><p>将当前行存储到暂存区：<code>h</code>（将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖）</p></li><li><p>如果不是最后一行，那么完成以下两步操作：</p><ul><li>移动到下一行：<code>n</code>（将pattern space中的内容切换到下一行）</li><li>在当前行末尾换行扩展暂存区内容：<code>G</code>（将hold space中的内容换行扩充到pattern space最后）</li></ul></li><li><p>显示当前行：<code>p</code></p></li><li><p>由于已经在命令执行过程中显示了需要的内容，那么无需在执行完成后依次显示Pattern space的内容：<code>-n</code>，否则会显示如下内容：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line5</span></span><br><span class="line">li<span class="symbol">ne6</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line6</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br></pre></td></tr></table></figure></li><li><p>那么完整命令如下：</p>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -<span class="built_in">n</span> &#x27;h;$!&#123;<span class="built_in">n</span>;G&#125;;p&#x27; testfile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125031850044.png" alt="image-20231125031850044"></p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">Linux中匹配正则表达式的相关命令</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux数据流重定向</title>
    <link href="https://www.iuoyt.com/posts/5a9cd021.html"/>
    <id>https://www.iuoyt.com/posts/5a9cd021.html</id>
    <published>2023-11-17T13:56:49.000Z</published>
    <updated>2023-11-25T03:21:37.575Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在之前的Linux笔记中有使用过<code>&gt;</code>、<code>&gt;&gt;</code>，比如如下指令：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; <span class="literal">redirect</span> </span><br><span class="line">echo <span class="string">&#x27;www.shiyanlou.com&#x27;</span> &gt;&gt; <span class="literal">redirect</span></span><br><span class="line">cat <span class="literal">redirect</span></span><br></pre></td></tr></table></figure><p>这部分命令用于将文本字符串 “hello shiyanlou” 输出到（<code>&gt;</code>）<code>redirect</code>文件中，此时文件并不存在，因此将自动创建<code>redirect</code>文件写入字符串，然后再次使用 <code>echo</code> 命令输出字符串<code>www.shiyanlou.com</code>追加到（<code>&gt;&gt;</code>）文件<code>redirect</code>中。</p></li></ul><h3 id="简单的重定向">简单的重定向</h3><ul><li>Linux中默认提供了三种特殊设备，用于终端的显示和输出，分别为<code>stdin</code>（标准输入,对应于你在终端的输入），<code>stdout</code>（标准输出，对应于终端的输出），<code>stderr</code>（标准错误输出，对应于终端的输出）。</li></ul><table><thead><tr><th style="text-align:center">文件描述符</th><th style="text-align:center">设备文件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center"><code>/dev/stdin</code></td><td style="text-align:center">标准输入</td></tr><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center"><code>/dev/stdout</code></td><td style="text-align:center">标准输出</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center"><code>/dev/stderr</code></td><td style="text-align:center">标准错误</td></tr></tbody></table><ul><li><p>可以这样使用文件描述符，比如默认使用终端的标准输入和标准输出作为命令的输入和输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p>此时输入的内容也会在按下<kbd>Enter</kbd>时显示出来。</p><p>（按下<kbd>Ctrl</kbd>+<kbd>C</kbd>退出）</p></li><li><p>将cat的连续输出（heredoc方式）重定向到一个文件：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir Documents</span><br><span class="line">cat &gt; Documents/test.c &lt;&lt;EOF</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>这一段内容的作用是将文件作为标准输出，那么之后输入的内容都会被保存在文件<code>/Documents/test.c</code>中，<code>&lt;&lt;EOF</code>是文本输入的定界符，表示以下内容将作为输入直到遇到 “EOF” 为止。</p></li><li><p>将一个文件作为命令的输入，标准输出作为命令的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193411117.png" alt="image-20231117193411117"></p></li><li><p>将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hi&#x27;</span> | <span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193603353.png" alt="image-20231117193603353"></p></li><li><p>将echo命令的输出从默认的标准输出重定向到一个普通文件：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; <span class="literal">redirect</span></span><br><span class="line">cat <span class="literal">redirect</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193628856.png" alt="image-20231117193628856"></p></li></ul><h3 id="标准错误重定向">标准错误重定向</h3><ul><li><p>有时执行指令得到的输出同事包含了标准输出和标准错误，比如如下操作，使用<code>cat</code>命令同时读取两个文件，其中一个存在，另一个不存在：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c</span><br></pre></td></tr></table></figure><p>可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息.</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117194508097.png" alt="image-20231117194508097"></p></li><li><p>接下来将输出重定向到一个文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c &gt; somefile</span><br></pre></td></tr></table></figure><p>但是依然出现了错误信息，而查看重定指向的文件，已经写入了期望包含的内容</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195102336.png" alt="image-20231117195102336"></p></li><li><p>如果希望将错误或者警告都隐藏，那就可以用到前面提到的文件描述符了。将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> Documents/test.c hello.c &gt;somefile  <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c &amp;&gt;somefilehell</span><br></pre></td></tr></table></figure><p>查看文件内容，可以看到错误信息也被写入到文件中了：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195418320.png" alt="image-20231117195418320"></p></li></ul><h3 id="使用tee命令同时重定向到多个文件">使用tee命令同时重定向到多个文件</h3><ul><li><p>如果既需要将输出重定向到文件，也需要将信息大隐刀终端，那么可以使用<code>tee</code>来实现：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | <span class="built_in">tee</span> hello</span><br></pre></td></tr></table></figure><p>可以看到内容既输出在了终端，同时也被写入到了文件当中：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195716791.png" alt="image-20231117195716791"></p></li></ul><h3 id="永久重定向">永久重定向</h3><ul><li><p>上面的操作完成的重定向只是临时的，如果希望做到永久重定向，可以使用<code>exec</code>命令完成，其作用是使用指定的命令替换当前的Shell，即使用一个进程替换当前进程，或者指定新的重定向。</p></li><li><p>先开启一个子Shell，然后使用exec替换当前进程的重定向，将标准输出重定向到一个文件：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">zsh</span></span><br><span class="line"><span class="attribute">exec</span> <span class="number">1</span>&gt;somefile</span><br></pre></td></tr></table></figure><p>那么后面执行的命令的输出都将被重定向到文件中，,直到退出当前子shell，或取消exec的重定向。</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">cat somefile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117201225039.png" alt="image-20231117201225039"></p></li></ul><h3 id="创建输出文件描述符">创建输出文件描述符</h3><ul><li><p>在Shel 中有9个文件描述符，上面仅仅是使用了默认提供的0、1、2号文件描述符。另外我们还可以使用3-8的文件描述符，只是它们默认没有打开而已。你可以使用下面命令查看当前 Shell 进程中打开的文件描述符：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /dev/fd/;<span class="built_in">ls</span> -Al</span><br></pre></td></tr></table></figure></li><li><p>使用<code>exec</code>命令可以创建新的文件描述并使用：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zsh</span><br><span class="line">exec <span class="number">3</span>&gt;somefile</span><br><span class="line">cd <span class="regexp">/dev/</span>fd/;ls -Al;cd -</span><br><span class="line">echo <span class="string">&quot;this is test&quot;</span> &gt;&amp;<span class="number">3</span></span><br><span class="line">cat somefile</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>  <div class="tip "><p>注意上面的第四句命令中，<code>&gt;</code>与<code>&amp;</code>之间不应该有空格，如果有空格则会出错</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231117202354262.png" alt="image-20231117202354262"></p></li></ul><h3 id="关闭文件描述符">关闭文件描述符</h3><ul><li><p>刚才设置了3号文件描述符，可以使用如下命令将其关闭：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br><span class="line"><span class="built_in">cd</span> /dev/fd;<span class="built_in">ls</span> -Al;<span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117202538761.png" alt="image-20231117202538761"></p></li></ul><h3 id="完全屏蔽命令的输出">完全屏蔽命令的输出</h3><ul><li><p>在Linux中有一个被称为“黑洞”的设备文件，所有导入它的数据都会“消失“</p><blockquote><p>在类UNIX系统中，<code>/dev/null</code>，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。</p></blockquote></li><li><p>我们可以利用<code>/dev/null</code>屏蔽命令的输出：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> Documents/test.c <span class="number">1</span>&gt;/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面这样的操作将使你得不到任何输出结果。</p></li></ul><h3 id="使用-xargs-分割参数列表">使用 xargs 分割参数列表</h3><ul><li><p><code>xargs</code>是一条UNIX和类UNIX操作系统的常用命令，它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p></li><li><p>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果。比如这个命令用于将<code>/etc/passwd</code>文件按<code>:</code>分割取第一个字段排序后，使用<code>echo</code>命令生成一个列表：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> -d: -f1 &lt; <span class="regexp">/etc/</span>passwd | <span class="built_in">sort</span> | xargs echo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117203054249.png" alt="image-20231117203054249"></p></li></ul><h3 id="实战训练">实战训练</h3><blockquote><p>理解下面这段代码的作用，实际这段代码不会正常工作，请结合这一小节的知识分析这段代码没有正确工作的原因，并设法解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">rm</span> -iv <span class="variable">$filename</span></span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>这段代码的作用是将<code>ls</code>命令读取到的全部文件依次删除。</p></li><li><p>但是在删除文件时会提示是否确认删除文件，而输入被<code>ls</code>得到的结果重定向了，因此无法完成确认操作，上述代码无法完成执行。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117214749645.png" alt="image-20231117214749645"></p></li><li><p>因此需要在删除文件时由控制台输入是否确认删除文件，而在读取删除列表时再从重定向中获得输入，修改后代码如下：</p><ul><li><p>将文件描述符3指向标准输入：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">exec</span> <span class="number">3</span>&lt;&amp;<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>删除文件，由文件描述符3提供确认操作给<code>rm</code>命令，使其能够正确执行：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -iv <span class="variable">$filename</span> &lt;&amp;3</span><br></pre></td></tr></table></figure></li><li><p>遍历列表，依次删除文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  &lt;delete operation&gt;</span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>因此，完整代码如下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&lt;&amp;0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">rm</span> -iv <span class="variable">$filename</span> &lt;&amp;3</span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117215259645.png" alt="image-20231117215259645"></p></li></ul>]]></content>
    
    
    <summary type="html">Linux中的数据流重定向是一种通过改变进程的标准输入、标准输出和标准错误的方法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中简单的文本处理</title>
    <link href="https://www.iuoyt.com/posts/d51277ac.html"/>
    <id>https://www.iuoyt.com/posts/d51277ac.html</id>
    <published>2023-11-16T07:02:16.000Z</published>
    <updated>2023-11-25T03:22:30.659Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tr命令">tr命令</h3><ul><li><p><code>tr</code>命令可以用来删除一段文本中的某些文字，或者将其替换。</p></li><li><p>使用方法：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> <span class="selector-attr">[option]</span>..<span class="selector-class">.SET1</span> <span class="selector-attr">[SET2]</span></span><br></pre></td></tr></table></figure></li><li><p>其中常用选项有：</p></li></ul><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-d</code></td><td>删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td style="text-align:center"><code>-s</code></td><td>去除set1指定的在输入文本中连续并重复的字符</td></tr></tbody></table><ul><li><p>比如，删除“hello shiyanlou”字段中的所有o、l、h：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;olh&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141547102.png" alt="image-20231116141547102"></p></li><li><p>再比如，将&quot;hello&quot; 中的“ll”,去重为一个“l”：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27;l&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141658700.png" alt="image-20231116141658700"></p></li><li><p>将输入文本，全部转换为大写或小写输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;input some text here&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[:lower:]&#x27;</span> <span class="string">&#x27;[:upper:]&#x27;</span></span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;input some text here&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141758138.png" alt="image-20231116141758138"></p></li></ul><h3 id="col命令">col命令</h3><ul><li>col命令可以将tab字符换成对等数量的空格键，或者反转这个操作，使用方式为<code>col [option]</code>，常见选项有：</li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center">将<code>Tab</code>转换为空格</td></tr><tr><td style="text-align:center"><code>-h</code></td><td style="text-align:center">将空格转换为<code>Tab</code>（默认选项）</td></tr></tbody></table><ul><li><p>比如，查看<code>/etc/protocols</code>中的不可见字符，可以看到很多 <code>^I</code> ，这其实就是 Tab 转义成可见字符的符号：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -A <span class="regexp">/etc/</span>protocols</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142042116.png" alt="image-20231116142042116"></p></li><li><p>使用<code>col -x</code>将<code>/etc/protocols</code>中的 Tab 转换为空格,然后再使用<code>cat</code>查看，发现<code>^I</code>不见了：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/protocols | col -x | <span class="built_in">cat</span> -A</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142151386.png" alt="image-20231116142151386"></p></li></ul><h3 id="join命令">join命令</h3><ul><li><p><code>join</code>命令用于将两个文件中包含相同内容的那一行合并在一起，使用方法：</p>  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">join</span> [<span class="keyword">option</span>]... file1 file2</span><br></pre></td></tr></table></figure></li><li><p>常用选项有：</p></li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-t</code></td><td style="text-align:center">指定分隔符，默认为空格</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:center">忽略大小写的差异</td></tr><tr><td style="text-align:center"><code>-1</code></td><td style="text-align:center">指明第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td style="text-align:center"><code>-2</code></td><td style="text-align:center">指明第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table><ul><li><p>首先在用户家目录下创建两个文件，然后进行合并：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 hello&#x27;</span> &gt; file1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 shiyanlou&#x27;</span> &gt; file2</span><br><span class="line"><span class="built_in">join</span> file1 file2</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142537075.png" alt="image-20231116142537075"></p></li><li><p>将<code>/etc/passwd</code>与<code>/etc/shadow</code>两个文件合并，指定以’:'作为分隔符：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">join</span> -t<span class="string">&#x27;:&#x27;</span> <span class="regexp">/etc/</span>passwd <span class="regexp">/etc/</span>shadow</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142620545.png" alt="image-20231116142620545"></p></li></ul><h3 id="paste命令">paste命令</h3><ul><li><code>paste</code>与<code>join</code>类似，是在不对比数据的情况下，简单地将多个文件合并起来，并以Tab隔开，格式为<code>paste [option] file...</code>，常用选项有：</li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-d</code></td><td style="text-align:center">指定合并的分隔符，默认为Tab</td></tr><tr><td style="text-align:center"><code>-s</code></td><td style="text-align:center">不合并到一行，每个文件为一行</td></tr></tbody></table><ul><li><p>先创建三个文件，分别存入不同内容：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> hello &gt; file1</span><br><span class="line"><span class="keyword">echo</span> shiyanlou &gt; file2</span><br><span class="line"><span class="keyword">echo</span> www.shiyanlou.<span class="keyword">com</span> &gt; file3</span><br></pre></td></tr></table></figure><p>使用<code>:</code>作为分隔符进行合并：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -d <span class="string">&#x27;:&#x27;</span> file1 file2 file3</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116143257454.png" alt="image-20231116143257454"></p><p>将三个文件内容进行简单合并，每个文件占一行：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -s file1 file2 file3</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116143308307.png" alt="image-20231116143308307"></p></li></ul><h3 id="实战训练">实战训练</h3><blockquote><p>在<a href="/posts/c67b19b2">文件打包与解压缩</a>中提到 Windows/dos 与 Linux/UNIX 文本文件一些特殊字符<code>不一致</code></p><p>如断行符 Windows 为 CR+LF(<code>\r\n</code>)，Linux/UNIX 为 LF(<code>\n</code>)。使用<code>cat -A 文本</code> 可以看到文本中包含的不可见特殊字符。Linux 的<code>\n</code>表现出来就是一个<code>$</code>，而 Windows/dos的表现为<code>^M$</code>，可以直接使用<code>dos2unix</code>和<code>unix2dos</code>工具在两种格式之间进行转换，使用<code>file</code>命令可以查看文件的具体类型。</p><p>不过现在希望<strong>在不使用上述两个转换工具的情况下，使用前面学过的命令手动完成 dos 文本格式到 UNIX 文本格式的转换。</strong></p></blockquote><ul><li><p>Windows的回车符仅比Linux/Unix下多出一个<code>\r</code>那么将Windows文本中的<code>\r</code>全部删除即可实现：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> -d <span class="string">&#x27;\r&#x27;</span> &lt; dos_file<span class="selector-class">.txt</span> &gt; unix_file.txt</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>&lt; dos_file.txt</code>: 从名为<code>dos_file.txt</code>的文件读取输入。</p></li><li><p><code>&gt; unix_file.txt</code>: 将输出写入名为<code>unix_file.txt</code>的文件。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Linux中几个简单的文本处理命令</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令执行顺序控制与管道</title>
    <link href="https://www.iuoyt.com/posts/7ab3ca3a.html"/>
    <id>https://www.iuoyt.com/posts/7ab3ca3a.html</id>
    <published>2023-11-10T11:55:16.000Z</published>
    <updated>2023-11-10T11:57:47.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令执行顺序的控制">命令执行顺序的控制</h2><ul><li><p>通常情况下，使用命令行都是输入完一条指令然后立即执行，然后再输入下一条指令。如果需要一次输入多条指令，再一并执行的话，可以使用<code>;</code>将多条指令隔开来，在一行里写下，那么在按下<kbd>Enter</kbd>的时候，会一次性执行完输入的全部命令。</p></li><li><p>但如果在顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就可能会造成花了时间，最终却得到一个错误结果的情况，并且有时还不能直观的看出是否正确执行。那么这时就需要有选择性地执行命令，比如上一条命令执行成功后才继续执行下一条，否则应该如何处理。比如使用一个<code>witch</code>来做判断，如果安装了<code>cowsay</code>命令就执行，否则什么也不做：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cowsay&gt;<span class="regexp">/dev/</span><span class="literal">null</span> &amp;&amp; cowsay -f head-in ohch~</span><br></pre></td></tr></table></figure><p>其中<code>&amp;&amp;</code>符号前的内容是执行条件，作为<code>&amp;&amp;</code>后语句是否执行的前提判断，如果<code>cowsay&gt;/dev/null</code>执行成功，那么会返回结果<code>0</code>，<code>&amp;&amp;</code>后的语句就会执行。</p></li><li><p>同样的，shell中也有类似于逻辑或的<code>||</code>，在此处与<code>&amp;&amp;</code>做出相反的结果，即当<code>||</code>前的语句执行结果≠0时，才执行后方的语句，比如如果未安装<code>cowsay</code>命令，那么显示出未安装提示：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cowsay&gt;/dev/<span class="literal">null</span> <span class="string">|| echo &quot;</span>cowsay has not been install, please run &#x27;sudo apt-get install cowsay&#x27; to install<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&amp;&amp;</code>和<code>||</code>可以结合起来使用，比如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110180631916.png" alt="image-20231110180631916"></p><p>意思为检查是否安装了<code>cowsay</code>，如果安装了则显示<code>exist</code>，否则显示<code>not exist</code>。上面的语句是先使用<code>&amp;&amp;</code>再使用<code>||</code>，那么如果反过来会出现什么结果呢：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110180645027.png" alt="image-20231110180645027"></p><p>这一次同时输出了<code>not exist</code>和<code>exist</code>的结果，因为<code>&amp;&amp;</code>后的语句执行条件是前一句执行成功，而在执行<code>||</code>判断时返回结果≠0，所以执行了<code>||</code>后的语句，从而也执行了<code>&amp;&amp;</code>后的语句。</p></li></ul><h2 id="管道">管道</h2><ul><li>管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。</li><li>管道又分为匿名管道和具名管道。在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由<code>|</code>分隔符表示，<code>|</code>在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。</li></ul><h3 id="管道的使用">管道的使用</h3><ul><li><p>现在尝试查看<code>/etc</code>下有那些文件和目录：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc</span><br></pre></td></tr></table></figure><p>输出的内容比较多，此时不妨使用管道将<code>ls</code>输出的结果使用<code>less</code>查看：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc | less</span><br></pre></td></tr></table></figure></li></ul><h3 id="cut命令">cut命令</h3><ul><li><p><code>cut</code>命令用于打印每一行的某一字段，比如现在需要打印<code>/etc/passwd</code>文件中以<code>:</code>位分隔符的第一个字段和第六个字段分别作为用户名和其家目录：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="regexp">/etc/</span>passwd -d <span class="string">&#x27;:&#x27;</span> -f <span class="number">1</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110191238613.png" alt="image-20231110191238613"></p></li><li><p>打印<code>/etc/passwd</code>文件中每一行的前N个字符：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前五个（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c -<span class="number">5</span></span><br><span class="line"><span class="comment"># 前五个之后的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span>-</span><br><span class="line"><span class="comment"># 第五个</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span></span><br><span class="line"><span class="comment"># 2到5之间的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">2</span>-<span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="grep命令">grep命令</h3><ul><li><p>grep命令用于在文本中或stdin中查找匹配字符串，如果结合正则表达式可以实现复杂切高效的查找和匹配，一般格式为：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [命令选项]... 用于匹配的表达式 [文件]...</span><br></pre></td></tr></table></figure></li><li><p>比如，搜索<code>/home/shiyanlou</code>目录下所有包含<code>shiyanlou</code>的文本文件，并显示出所在文本中的行号，其中<code>-r</code>表示地柜搜索子目录中的文件，<code>-n</code>表示打印匹配项的行号，<code>-I</code>表示忽略二进制文件：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -rnI <span class="string">&quot;shiyanlou&quot;</span> ~</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110191733110.png" alt="image-20231110191733110"></p></li><li><p>同时也可以使用正则表达式，比如查找以<code>yanlou</code>结尾的字符串：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> | grep <span class="string">&quot;.*yanlou$&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192022608.png" alt="image-20231110192022608"></p></li></ul><h3 id="wc命令">wc命令</h3><ul><li><p><code>wc</code>命令是简单小巧的计数工具，用于统计并输出一个文件中行、单词和字节的数目，比如输出<code>/etc/passwd</code>文件的统计信息：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192208836.png" alt="image-20231110192208836"></p></li><li><p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行数</span></span><br><span class="line">wc -l <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 单词数</span></span><br><span class="line">wc -w <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 字节数</span></span><br><span class="line">wc -c <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 字符数</span></span><br><span class="line">wc -m <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 最长行字节数</span></span><br><span class="line">wc -L <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192540334.png" alt="image-20231110192540334"></p>  <div class="tip info"><p>对于西文字符，一个字符就是一个字节，对于中文字符，一个汉字通常不小于2字节，视编码而定。</p></div></li><li><p>再结合管道，统计<code>/etc</code>下所有目录数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -dl /etc/*/ | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193359731.png" alt="image-20231110193359731"></p></li></ul><h3 id="sort命令">sort命令</h3><ul><li><p><code>sort</code>命令用于排序，即将输入按照一定方式进行排序，然后再输出，支持的排序方式包括但不限于：字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序……</p></li><li><p>默认为字典排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193609728.png" alt="image-20231110193609728"></p></li><li><p>反转排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -r</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193716806.png" alt="image-20231110193716806"></p></li><li><p>按照特定字段排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k 3</span><br></pre></td></tr></table></figure><p><code>-t</code>参数用于指定字段的分隔符，这里是以&quot;:&quot;作为分隔符；<code>-k 字段号</code>用于指定对哪一个字段进行排序。这里<code>/etc/passwd</code>文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上<code>-n</code>参数，此处按照分割后的第三个字段（第二个<code>:</code>后的字段）排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k 3 -n</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193958323.png" alt="image-20231110193958323"></p></li></ul><h3 id="uniq命令">uniq命令</h3><ul><li><p><code>uniq</code>命令用于过滤或者输出重复行。比如使用<code>history</code>查看最近执行过的命令，但只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194319562.png" alt="image-20231110194319562"></p><p>虽然<code>uniq</code>去除了大部分重复行，但可以看出这里仍然存在两条<code>ls</code>的记录，这是因为<code>uniq</code>命令只能去除连续的重复行，而非全文去重，如果需要达到全文去重的效果，那么需要对字段先进行排序操作：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> -u</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194620796.png" alt="image-20231110194620796"></p></li><li><p>如果希望查看重复的行，再分别统计重复次数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -dc</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194746551.png" alt="image-20231110194746551"></p><p>仅查看重复的行，而不统计重复次数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -D</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194831567.png" alt="image-20231110194831567"></p></li></ul>]]></content>
    
    
    <summary type="html">Linux中命令同时执行的方法与管道的相关使用方式。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="https://www.iuoyt.com/posts/f9c29644.html"/>
    <id>https://www.iuoyt.com/posts/f9c29644.html</id>
    <published>2023-11-06T11:37:40.000Z</published>
    <updated>2023-11-11T11:19:47.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><ul><li><p>软件的<strong>可维护性</strong><span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">可维护性</span><span class="reference-title">参考资料</span></span></span>和<strong>可复用性</strong><span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">可复用性</span><span class="reference-title">参考资料</span></span></span>是两个非常重要的用于衡量软件质量的属性。</p><table><thead><tr><th>原则名称</th><th>英文名称</th><th>定义</th><th style="text-align:center">使用频率</th></tr></thead><tbody><tr><td>单一职责原则</td><td>Single Responsibility Principle， SRP</td><td>一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中</td><td style="text-align:center">★★★★☆</td></tr><tr><td>开闭原则</td><td>Open-Closed Principle， OCP</td><td>软件实体应当对扩展开放，对修改关闭</td><td style="text-align:center">★★★★★</td></tr><tr><td>里氏代换原则</td><td>Liskov Substitution Principle， LSP</td><td>所有引用基类的地方必须能透明地使用其子类的对象</td><td style="text-align:center">★★★★★</td></tr><tr><td>依赖倒转原则</td><td>Dependence Inversion Principle， DIP</td><td>高层模块不应该以来低层模块，它们都应该依赖抽象；抽象不应该依赖于细节，细节应该依赖于抽象</td><td style="text-align:center">★★★★★</td></tr><tr><td>接口隔离原则</td><td>Interface Segregation Principle， ISP</td><td>客户端不应该依赖那些它不需要的接口</td><td style="text-align:center">★★☆☆☆</td></tr><tr><td>合成复用原则</td><td>Composite Reuse Principle， CRP</td><td>有线使用对象组合，而不是通过继承来打到复用的目的</td><td style="text-align:center">★★★★☆</td></tr><tr><td>迪米特法则</td><td>Law of Demeter， LoD</td><td>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</td><td style="text-align:center">★★★☆☆</td></tr></tbody></table></li></ul><h2 id="单一职责原则">单一职责原则</h2><ul><li><p>定义：<strong>一个对象应该只包含单一的职责</strong>，并且该职责被完整地封装在一个类中。</p></li><li><p>另一种定义方式：就一个类而言，应该仅有一个引起它变化的原因。</p></li><li><p>在软件系统中，一个类承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，相当于将这些职责耦合在一起，当其中一个职责变化时可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将他们封装在同一类中。</p><blockquote><p>在<code>CustomerDataChart</code>类的方法中，<code>getConnection()</code>方法用于连接数据库，<code>findCustomers()</code>用于查询所有的客户信息，<code>createChart()</code>用于创建图表，<code>displayChart()</code>用于显示图表。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231107110617712.png" alt="image-20231107110617712"></p><p><code>CustomerDataChart</code>类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用<code>findCustomers()</code>方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它拥有不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，<code>CustomerDataChart</code>类可拆分为以下3个类。</p><ol><li><code>DBUtil</code>：负责连接数据库，包含数据库连接方法<code>getConnection()</code></li><li><code>CustomerDAO</code>：负责操作数据库中的Customer表，包含对Customer表的增、删、改、查等方法，例如<code>findCustomers()</code></li><li><code>CustomerDataChart</code>：负责图表的生成和显示，包含<code>createChart()</code>和<code>displayChart()</code>方法</li></ol><p>重构后的结构图：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231107110956731.png" alt="image-20231107110956731"></p></blockquote></li></ul><h2 id="开闭原则">开闭原则</h2><ul><li>开闭原则是面向对象的客服用设计的第一块基石，定义：<strong>软件实体应当对扩展开放，对修改关闭</strong>，即软件实体应<strong>尽量在不修改原有代码的情况下进行扩展</strong>。</li><li>任何软件都需要面临一个很重要的问题，即需求会随着时间的推移而发生变化。当软件系统需要面对新的需求时应尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，寿命越来越长，维护成本也越来越高，设计满足开闭原则的软件也变得越来越重要。为了满足开闭原则，需要对系统进行<strong>抽象化设计</strong>，抽象化是开闭原则的关键，定义系统的抽象层，再通过具体的类进行扩展。</li></ul><h2 id="里氏替换原则">里氏替换原则</h2><blockquote><p>如果对每一个类型为S的对象o1都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时程序P的行为没有变化，那么类型S是类型T的子类型。</p></blockquote><ul><li>通俗来说，里氏替换原则即<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>，表明<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常</strong>，反之则不成立。比如：如果我喜欢所有动物，那么我一定喜欢狗，因为狗是动物的子类；但如果我喜欢狗，并不能断定我喜欢所有的动物。</li><li>里氏替换原则是实现开闭原则的重要方法之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时在确定其子类的类型，用子类对象来替换父类对象。</li><li>在运用历史替换原则时应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现在父类中声明的方法，在运行时子类实例替换父类实例，可以很方便地扩展系统的功能，无需修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</li></ul><h2 id="依赖倒转原则">依赖倒转原则</h2><ul><li><p>依赖倒转原则是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p></li><li><p>依赖倒转原则的定义：<strong>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。<strong>简单地说，依赖倒转原则要求</strong>针对接口编程，不要针对实现编程</strong>。</p></li><li><p>依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而非使用具体类来做这些事情。一个具体类应当只实现接口或者抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p></li><li><p>引入抽象层后，系统具有很好的灵活性，在程序中<strong>尽量使用抽象层进行编程</strong>，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无需修改原有系统的源代码。</p></li><li><p>实现依赖倒转原则需要针对抽象层编程，而将具体类通过依赖注入的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时采用抽象的形式来注入所依赖的对象。</p><blockquote><p>常见的注入方式有3种：</p><ol><li>构造注入：通过构造函数来传入具体类的对象</li><li>设值注入（Setter注入）：通过Setter方法来传入具体类的对象</li><li>接口注入：通过在接口中声明的业务方法来传入具体类的对象</li></ol></blockquote></li></ul><h2 id="接口隔离原则">接口隔离原则</h2><ul><li>接口隔离原则定义：<strong>客户端不应该依赖那些它不需要的接口</strong>。当一个接口太大时需要将它分割成一些更细小的接口，使用该接口的客户端进需要知道与之相关的方法即可。</li><li>“接口”有两种含义：<ul><li>如果理解为一个类型所提供的所有方法特征的集合的时候，可以将接口理解成角色，一个接口只能代表一个角色，每个角色都有它特地的一个接口，此时这个原则可以叫“角色隔离原则”。</li><li>如果把接口理解成狭义的特定语言的接口，那么接口隔离原则表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li></ul></li></ul><h2 id="合成复用原则">合成复用原则</h2><ul><li>合成复用原则又称组合/聚合复用原则，定义：<strong>优先使用对象组合，而不是通过继承来达到复用的目的</strong>，即在一个新的对象里通过关联关系（包裹组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派<strong>调用已有对象</strong>的方法打到复用功能的目的。</li><li>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的某些内部细节对于子类来说是可见的，因此这种复用又称为“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变。</li><li>组合或聚合关系可以将已有的对象（亦可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使成员对象的内部实现对于新对象不可见，所以这种复用又称为“黑箱”复用。</li></ul><h2 id="迪米特法则">迪米特法则</h2><ul><li><p>迪米特法则定义：<strong>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。其要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统符合迪米特法则，那么当其中的某一个模块发生修改时就会尽量少地影响其他模块，扩展会相对容易。</p></li><li><p>应用迪米特法则可以降低系统的耦合度，使类与类之间保持松散的耦合关系。</p></li><li><p>迪米特法则还有几种定义形式，例如：不要和“陌生人”说话，只与你的直接朋友通信，“朋友”包括如下几类：</p><ol><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ol><p>这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p></li><li><p>迪米特法则还要求在设计系统时应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。</p></li></ul><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="javascript:void">维护性是指软件能够被理解、改正、适应及扩展的难易程度</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="javascript:void">可复用性是指软件能够被重复使用的难易程度</a></div>]]></content>
    
    
    <summary type="html">如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="面向对象设计原则" scheme="https://www.iuoyt.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概述</title>
    <link href="https://www.iuoyt.com/posts/bb7571ed.html"/>
    <id>https://www.iuoyt.com/posts/bb7571ed.html</id>
    <published>2023-11-06T10:45:37.000Z</published>
    <updated>2023-11-25T03:23:21.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是设计模式">什么是设计模式</h2><ul><li><p>设计模式是一种用于对软件系统中不断重现的设计问题的解决方案进行文档化的技术，目的是提高代码的可维护性、可扩展性、重用性和可靠性，以及让他人更容易理解代码。</p></li><li><p>GoF对设计模式的定义如下：</p><blockquote><p>设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。</p></blockquote></li></ul><h2 id="设计模式的基本要素">设计模式的基本要素</h2><ol><li><p>模式名称</p><p>每种设计模式都有一个名称来描述模式的问题、解决方案和效果，以便开发人员更好地理解模式并方便沟通交流。</p></li><li><p>问题</p><p>问题描述了应该在何时使用模式，包含了设计中存在的问题以及问题存在的原因。</p></li><li><p>解决方案</p><p>解决方案描述了设计模式的组成成分，以及这些组成成分之间的相互关系、各自的职责和协作方式。</p></li><li><p>效果</p><p>效果描述了模式应用的效果以及在使用模式时应权衡的问题。</p></li></ol><h2 id="设计模式的分类">设计模式的分类</h2><ul><li>通常情况下都是按照目的来划分各种设计模式，可以分为创建型（Creational）、结构性（Structural）和行为型（Behavioral）3类。</li><li>以下23种设计模式并非都是孤立存在的，很多模式之间存在联系，例如访问者模式操作对象结构中的元素时通常需要使用迭代器模式，在解释器模式中定义终结符表达式和非终结符表达式时可以使用组合模式。因此，如果合理搭配不同的设计模式，可以充分发挥每种设计模式的优势，完成一些更复杂的设计工作。</li></ul><h3 id="创建型模式">创建型模式</h3><ul><li>创建型模式主要用于<strong>创建对象</strong>，包括如下5种模式：</li></ul><table><thead><tr><th>模式名称</th><th style="text-align:left">英文名称</th><th>模式说明</th><th style="text-align:center">使用频率</th></tr></thead><tbody><tr><td>抽象工厂模式</td><td style="text-align:left">Abstract Factory</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</td><td style="text-align:center">★★★★★</td></tr><tr><td>建造者模式</td><td style="text-align:left">Builder</td><td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td><td style="text-align:center">★★☆☆☆</td></tr><tr><td>工厂方法模式</td><td style="text-align:left">Factory Method</td><td>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</td><td style="text-align:center">★★★★★</td></tr><tr><td>原型模式</td><td style="text-align:left">Prototype</td><td>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象</td><td style="text-align:center">★★★☆☆</td></tr><tr><td>单例模式</td><td style="text-align:left">Singleton</td><td>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例</td><td style="text-align:center">★★★★☆</td></tr></tbody></table><h3 id="结构型模式">结构型模式</h3><ul><li>结构型模式主要用于<strong>处理类或对象的组合</strong>，包括如下7种模式：</li></ul><table><thead><tr><th>模式名称</th><th>英文名称</th><th>模式说明</th><th>使用频率</th></tr></thead><tbody><tr><td>适配器模式</td><td>Adapter</td><td>将一个类的接口转换成客户希望的另一个接口，让不兼容的类可以一起工作</td><td>★★★★☆</td></tr><tr><td>桥接模式</td><td>Bridge</td><td>将抽象部分与它的实现部分解耦，使得两者都能够独立变化</td><td>★★★☆☆</td></tr><tr><td>组合模式</td><td>Composite</td><td>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构，让客户端可以统一对待单个对象和组合对象</td><td>★★★★☆</td></tr><tr><td>装饰模式</td><td>Decorator</td><td>动态地给一个对象增加一些额外的职责，就扩展功能而言，装饰模式提供可一种比使用子类更加灵活的替代方案</td><td>★★★☆☆</td></tr><tr><td>外观模式</td><td>Facade</td><td>为子系统中的一组接口提供一个统一的入口，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td><td>★★★★★</td></tr><tr><td>享元模式</td><td>Flyweight</td><td>运用共享技术有效地支持大量细粒度对象的复用</td><td>★☆☆☆☆</td></tr><tr><td>代理模式</td><td>Proxy</td><td>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问</td><td>★★★★☆</td></tr></tbody></table><h3 id="行为型模式">行为型模式</h3><ul><li>行为型模式主要用于<strong>描述类或对象怎样交互和怎样分配职责</strong>，包括如下11种模式：</li></ul><table><thead><tr><th>模式名称</th><th>英文名称</th><th>模式说明</th><th>使用频率</th></tr></thead><tbody><tr><td>职责链模式</td><td>Chain of Responsibility</td><td>避免将一个请求的发送者与接受者耦合在一起，让多个对象都有机会处理请求，或接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止</td><td>★★☆☆☆</td></tr><tr><td>命令模式</td><td>Command</td><td>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作</td><td>★★★★☆</td></tr><tr><td>解释器模式</td><td>Interpreter</td><td>给定一个语言，定义它的文法的一种表示，并给定一个解释器，这个解释器使用该表示方法来解释语句中的句子</td><td>★☆☆☆☆</td></tr><tr><td>迭代器模式</td><td>Iterator</td><td>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示</td><td>★★★★★</td></tr><tr><td>中介者模式</td><td>Mediator</td><td>定义一个对象来封装一系列对象的交互，中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</td><td>★★☆☆☆</td></tr><tr><td>备忘录模式</td><td>Memento</td><td>在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</td><td>★★☆☆☆</td></tr><tr><td>观察者模式</td><td>Observer</td><td>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新</td><td>★★★★★</td></tr><tr><td>状态模式</td><td>State</td><td>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎是修改了它的类</td><td>★★★☆☆</td></tr><tr><td>策略模式</td><td>Strategy</td><td>定义一系列算法，将每一个算法封装起来，让他们可以相互替换，使得算法可以独立于使用它的客户而变化</td><td>★★★★☆</td></tr><tr><td>模板方法模式</td><td>Template Method</td><td>定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td><td>★★★☆☆</td></tr><tr><td>访问者模式</td><td>Visitor</td><td>表示一个作用于某对象结构中的各个元素的操作，可以在不改变各个元素的类的前提下定义作用于这些元素的新操作</td><td>★☆☆☆☆</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">设计模式是一种用于对软件系统中不断重现的设计问题的解决方案进行文档化的技术，目的是提高代码的可维护性、可扩展性、重用性和可靠性。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://www.iuoyt.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux任务计划crontab</title>
    <link href="https://www.iuoyt.com/posts/b38a663c.html"/>
    <id>https://www.iuoyt.com/posts/b38a663c.html</id>
    <published>2023-11-03T10:18:50.000Z</published>
    <updated>2023-11-25T03:23:38.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="crontab简介">crontab简介</h2><ul><li><p><code>crontab</code>命令用于设置周期性被执行的命令，并将其存放于 crontab 文件中，以供之后读取和执行。</p></li><li><p><code>crontab</code>储存的指令被守护进程激活，<code>crond</code>为其守护进程，<code>crond</code>常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p></li><li><blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="crontab准备">crontab准备</h2><ul><li><p>使用<code>rsyslog</code>可以通过日志中的信息来得知任务是否被执行了：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install -y rsyslog</span><br><span class="line">sudo<span class="built_in"> service </span>rsyslog start</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103174614045.png" alt="image-20231103174614045"></p></li></ul><h2 id="crontab使用">crontab使用</h2><h3 id="新增任务">新增任务</h3><ul><li><p>首先来添加一个计划任务：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -e</span></span><br></pre></td></tr></table></figure><p>如果是第一次启动则会出现如下内容，选择编辑工具，通常使用2号vim工具：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103174813614.png" alt="image-20231103174813614"></p></li><li><p>接下来会进入下面的界面，这个界面就是添加计划的地方：<br><img src="https://oss.iuoyt.com/img/posts/image-20231103175001232.png" alt="image-20231103175001232"></p></li><li><p>接下来按下<kbd>i</kbd>进入编辑模式，在最后一行添加如下内容，作用是每分钟在用户目录下创建一个以当前的年月日时分秒为名字的空白文件：</p>  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">1</span> * * * * touch /home/shiyanlou/$(<span class="keyword">date</span> +\%Y\%m\%d\%H\%M\%S)</span><br></pre></td></tr></table></figure></li><li><p>然后按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出，输入如下指令查看文件内容：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -l</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180017702.png" alt="image-20231103180017702"></p></li><li><p>虽然已经添加了任务，但如果cron的进程并没有启动，那么任务也不会被执行，可以通过如下两种方式确定cron是否已启动：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 第一种</span></span><br><span class="line">ps aux <span class="string">| grep cron</span></span><br><span class="line"><span class="meta"># 第二种</span></span><br><span class="line">pgrep cron</span><br></pre></td></tr></table></figure></li><li><p>如果已经启动，在用户目录下使用<code>ll</code>命令，可以看到：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180524732.png" alt="image-20231103180524732"></p></li><li><p>通过如下命令可以查看到执行任务命令之后在日志中的信息反馈：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tail -f /<span class="keyword">var</span>/<span class="built_in">log</span>/syslog</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180704821.png" alt="image-20231103180704821"></p></li></ul><h3 id="删除任务">删除任务</h3><ul><li><p>当不需要再自动执行任务，可以使用如下命令：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -r</span></span><br></pre></td></tr></table></figure></li><li><p>执行后再查看任务列表，可以看到已经没有正在执行的任务：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180918834.png" alt="image-20231103180918834"></p></li></ul><h3 id="系统级任务">系统级任务</h3><ul><li><p>如果需要定义系统级别定时任务，可以使用sudo权限编辑crontab文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>crontab</span><br></pre></td></tr></table></figure></li><li><p>cron服务的最小检测时间为分钟，所以cron每分钟会去文件中读取一次内容</p></li></ul><h3 id="cron的相关文件">cron的相关文件</h3><ul><li><p>在<code>/etc</code>目录下查看cron相关的文件：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ll</span> /etc | <span class="keyword">grep</span> cron</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103181401458.png" alt="image-20231103181401458"></p></li><li><p>其中部分作用如下：</p></li></ul><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>/etc/cron.daily</code></td><td style="text-align:center">在每天的6点25分时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.hourly</code></td><td style="text-align:center">在每小时的17分钟时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.monthly</code></td><td style="text-align:center">在每月1号的6点52分时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.weekly</code></td><td style="text-align:center">在每周第七天的6点47分时执行一次</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文介绍了如何在Linux中使用crontab进行计划任务</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的帮助命令</title>
    <link href="https://www.iuoyt.com/posts/8039f3ce.html"/>
    <id>https://www.iuoyt.com/posts/8039f3ce.html</id>
    <published>2023-10-27T11:49:12.000Z</published>
    <updated>2023-11-25T03:23:57.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内建命令与外部命令">内建命令与外部命令</h2><h3 id="内建命令">内建命令</h3><ul><li>内建命令是shell的一部分，包含一些比较简单的系统命令，通常在Linux系统加载运行时就会被驻留在内存系统中，因此执行速度比外部命令快。</li></ul><h3 id="外部命令">外部命令</h3><ul><li>外部命令是Linux系统中的实用程序部分，因为功能较为强大，其包含的程序量也会很大，所以不能随着系统启动被加载到内存中。</li></ul><h3 id="查看命令的类型">查看命令的类型</h3><ul><li><p>使用<code>type</code>命令可以查看其为内建或是外部命令：</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;命令&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231027193923068.png" alt="image-20231027193923068"></p></li><li><p>通常会得到如下结果：</p></li></ul><table><thead><tr><th style="text-align:center">结果</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center"><code>xxx is a shell builtin</code></td><td style="text-align:center">内建命令</td></tr><tr><td style="text-align:center"><code>xxx is /usr/bin/xxx</code></td><td style="text-align:center">外部命令</td></tr><tr><td style="text-align:center"><code>xxx is an alias for xx --xxx</code></td><td style="text-align:center">命令别名</td></tr></tbody></table><h2 id="帮助命令的使用">帮助命令的使用</h2><h3 id="help命令">help命令</h3><ul><li><p>help命令是用于显示shell内建命令的简要帮助信息，因此无法得到外部命令或者命令别名的相关帮助，比如输入<code>help ls</code>命令则会得到“无匹配帮助主题”的提示。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231027194155526.png" alt="image-20231027194155526"></p></li><li><p>而对于外部命令，通常带有一个获取帮助的参数<code>--help</code>，输入以获取该命令的帮助文档：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="man命令">man命令</h3><ul><li><p><code>man</code>命令得到的内容比<code>help</code>更多更详细，而且<code>man</code>没有内建命令与外部命令的区分。<code>man</code>命令是显示系统手册页中的内容，通常为对命令的解释信息和相关描述。</p></li><li><p>使用<code>man</code>命令得到的内容第一行会显示出该命令在文档中所处的章节位置，如使用<code>man ls</code>，则会显示<code>LS(1)</code>，其中<code>LS</code>为手册名称，<code>(1)</code>表示位于该手册的第几章节。在<code>man</code>手册中一共有如下章节：</p></li></ul><table><thead><tr><th style="text-align:center">章节数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center">Standard commands （标准命令）</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center">System calls （系统调用）</td></tr><tr><td style="text-align:center"><code>3</code></td><td style="text-align:center">Library functions （库函数）</td></tr><tr><td style="text-align:center"><code>4</code></td><td style="text-align:center">Special devices （设备说明）</td></tr><tr><td style="text-align:center"><code>5</code></td><td style="text-align:center">File formats （文件格式）</td></tr><tr><td style="text-align:center"><code>6</code></td><td style="text-align:center">Games and toys （游戏和娱乐）</td></tr><tr><td style="text-align:center"><code>7</code></td><td style="text-align:center">Miscellaneous （杂项）</td></tr><tr><td style="text-align:center"><code>8</code></td><td style="text-align:center">Administrative Commands （管理员命令）</td></tr><tr><td style="text-align:center"><code>9</code></td><td style="text-align:center">其他（Linux特定的）， 用来存放内核例行程序的文档</td></tr></tbody></table><h3 id="info命令">info命令</h3><ul><li><p>如果环境中没有<code>info</code>命令，那么可以自行手动安装：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 info</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install <span class="built_in">info</span></span><br><span class="line"><span class="comment"># 查看 ls 命令的 info</span></span><br><span class="line"><span class="built_in">info</span> ls</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">本文介绍了如何利用 Linux 系统自带的帮助工具与文档查看命令的用法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件打包与解压缩</title>
    <link href="https://www.iuoyt.com/posts/c67b19b2.html"/>
    <id>https://www.iuoyt.com/posts/c67b19b2.html</id>
    <published>2023-10-13T15:19:13.000Z</published>
    <updated>2023-10-13T15:23:37.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="压缩打包程序">压缩打包程序</h2><h3 id="使用zip打包文件夹">使用zip打包文件夹</h3><ul><li><p>使用<code>zip</code>命令可以将文件夹打包，比如使用下面的命令将目录<code>/home/shiyanlou/Desktop</code>打包成一个文件，并查看打包后文件的大小和类型，其中<code>-r</code>参数表示递归打包包含子目录的全部内容，<code>-q</code>参数表示为安静模式，即不输出信息到屏幕，<code>-o</code>表示输出文件，在后面紧跟上输出的文件名称：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line"><span class="keyword">zip</span> -r -q -o shiyanlou.<span class="keyword">zip</span> /home/shiyanlou/Desktop</span><br><span class="line">du -<span class="keyword">h</span> shiyanlou.<span class="keyword">zip</span></span><br><span class="line"><span class="keyword">file</span> shiyanlou.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221318522.png" alt="image-20231013221318522"></p></li><li><p>为打包设置压缩级别（9：最高压缩度，速度最慢；1：最快速度，压缩率低），进行重新打包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r -<span class="number">9</span> -q -o shiyanlou_9.zip <span class="regexp">/home/</span>shiyanlou<span class="regexp">/Desktop -x ~/</span>*.zip</span><br><span class="line">zip -r -<span class="number">1</span> -q -o shiyanlou_1.zip <span class="regexp">/home/</span>shiyanlou<span class="regexp">/Desktop -x ~/</span>*.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221533479.png" alt="image-20231013221533479"></p></li><li><p>使用<code>du</code>命令再次查看压缩得到的文件，其中<code>-h</code>为以人可读的形式展现，<code>-d</code>表示查看文件的深度：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">du</span> -h -d <span class="number">0</span> <span class="regexp">*.zip</span> <span class="regexp">~ |</span> sort</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221602101.png" alt="image-20231013221602101"></p></li><li><p>注意：压缩文件使用的路径只能使用绝对路径，否则不起作用。理论上默认压缩级别是最高的，但在文件较小时难以看出差别。</p></li><li><p>由于WIndows和Linux/Unix在文本处理格式上存在差异，比如换行符，WIndows上为<code>CR+LF</code>，但Linux/Unix上为<code>LF</code>，所以一些在Linux/Unix上的换行在Windows系统上看起来像是没有换行，为了解决此类问题，还需要在命令中做出一些修改，加上<code>-l</code>参数将<code>LF</code>转换为<code>CR+LF</code>达到上述目的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -l -o shiyanlou.zip <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221943861.png" alt="image-20231013221943861"></p></li></ul><h3 id="创建加密zip包">创建加密zip包</h3><ul><li><p>在打包文件时添加上<code>-e</code>参数可以创建加密压缩包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -e -o shiyanlou_encryption.zip <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222055429.png" alt="image-20231013222055429"></p></li></ul><h2 id="解压缩打包程序">解压缩打包程序</h2><h3 id="解压缩文件">解压缩文件</h3><ul><li><p>将之前打包的<code>shiyanlou.zip</code>解压到当前目录下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unzip</span> shiyanlou.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222137966.png" alt="image-20231013222137966"></p></li><li><p>与之前相同，使用<code>-q</code>参数使用安静模式解压文件，而使用<code>-d</code>参数指定解压目录：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -<span class="selector-tag">q</span> shiyanlou<span class="selector-class">.zip</span> -d ziptest</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222224693.png" alt="image-20231013222224693"></p></li><li><p>如果上面指定的目录不存在，则会直接创建。</p></li><li><p>如果只想查看压缩包的内容，而不进行解压操作，可以使用<code>-l</code>参数：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unzip</span> -l shiyanlou.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222521006.png" alt="image-20231013222521006"></p></li></ul><h3 id="解决解压乱码问题">解决解压乱码问题</h3><ul><li><p>通常在Windows系统上创建的压缩文件，如果包名中含有中文的目录或者以中文作为文件名命名的文件，通常会采用GBK编码，而Linux则是默认使用哪个UTF-8编码，如果不加以处理直接解压，则会出现乱码问题，可以在解压缩时使用<code>-O</code>参数指定文件编码：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK 压缩文件<span class="string">.zip</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="tar打包工具">tar打包工具</h2><h3 id="打包">打包</h3><ul><li><p>比起<code>zip</code>，在Lin上更常使用的是<code>tar</code>工具，<code>tar</code>可以将7z、gzip、xz、bzip2等格式进行打包或者解包，仅仅是参数不同，比起<code>zip</code>使用较为方便。</p></li><li><p>创建一个tar包，使用<code>-P</code>参数保留绝对路径符，<code>-c</code>表示创建一个tar包文件，<code>-f</code>用于指定创建的文件名，其后紧跟文件名称，如果加上<code>-v</code>参数，那么会以可视的形式输出打包的文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">tar -P -cf shiyanlou.tar <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222601275.png" alt="image-20231013222601275"></p><blockquote><p>在使用多个参数时，可以使用连续书写方式：如同时使用<code>-c</code>与<code>-f</code>参数 ，则可以写成<code>-cf</code></p></blockquote></li></ul><h3 id="解包">解包</h3><ul><li><p>同样是使用<code>tar</code>命令，加上<code>-x</code>参数则是对文件进行解包，<code>-C</code>参数指定解压到的目标文件夹：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir tardir</span><br><span class="line">tar -xf shiyanlou.tar -C tardir</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222938219.png" alt="image-20231013222938219"></p></li><li><p>只查看而不解压文件使用<code>-t</code>参数：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -tf shiyanlou.tar</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223001893.png" alt="image-20231013223001893"></p></li><li><p>如果需要在解压时保留文件的属性和跟随链接（符号链接或软连接）可以使用<code>-p</code>参数和<code>-h</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cphf etc.tar /etc</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建其他形式的打包程序">创建其他形式的打包程序</h3><table><thead><tr><th style="text-align:center">压缩文件格式</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:center"><code>*.tar.gz</code></td><td style="text-align:center"><code>-z</code></td></tr><tr><td style="text-align:center"><code>*.tar.xz</code></td><td style="text-align:center"><code>-J</code></td></tr><tr><td style="text-align:center"><code>*tar.bz2</code></td><td style="text-align:center"><code>-j</code></td></tr></tbody></table><ul><li><p>比如创建<code>.tar.gz</code>文件，加上<code>-z</code>参数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf shiyanlou.tar.gz <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223140457.png" alt="image-20231013223140457"></p></li><li><p>解压<code>.tar.gz</code>文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><blockquote><p>创建一个名为 test 的文件，分别用 zip 和 tar 打包成压缩包，再解压到 /home/shiyanlou 目录。</p></blockquote><ul><li><p>创建一个名为 test 的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">touch</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223345818.png" alt="image-20231013223345818"></p></li><li><p>分别用 zip 和 tar 打包成压缩包：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br><span class="line">tar -P -<span class="keyword">cf</span> <span class="keyword">test</span>.tar <span class="keyword">test</span></span><br><span class="line"><span class="keyword">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013230521245.png" alt="image-20231013230521245"></p></li><li><p>再解压到 /home/shiyanlou 目录:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">unzip <span class="keyword">test</span>.<span class="keyword">zip</span></span><br><span class="line">tar -xf <span class="keyword">test</span>.tar</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013230641542.png" alt="image-20231013230641542"></p></li></ul>]]></content>
    
    
    <summary type="html">这篇文章介绍了Linux上常用的压缩/解压工具（zip，tar）的使用。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境变量与文件查找</title>
    <link href="https://www.iuoyt.com/posts/287535e7.html"/>
    <id>https://www.iuoyt.com/posts/287535e7.html</id>
    <published>2023-10-08T15:49:56.000Z</published>
    <updated>2023-11-25T03:24:27.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境变量">环境变量</h2><h3 id="环境变量-2">环境变量</h3><h4 id="变量">变量</h4><ul><li><p>在Shell中创建一个变量可以使用<code>declare</code>命令，但并非任何形式的变量名都是可用的，变量名只能是由英文字母、数字或者下划线组成，且不能由数字开头。比如创建一个tmp变量：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> tmp</span><br></pre></td></tr></table></figure></li><li><p>使用<code>=</code>运算符为变量赋值：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tmp</span><span class="operator">=</span>shiyanlou</span><br></pre></td></tr></table></figure></li><li><p>使用<code>echo</code>和<code>$</code>符号可以查看变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008230724020.png" alt="image-20231008230724020"></p></li></ul><h4 id="环境变量-3">环境变量</h4><ul><li><p>环境变量的作用域比自定义变量要大，比如Shell的环境变量作用于自身和它的子进程</p></li><li><p>有三个和环境变量相关的命令，<code>set</code>、<code>env</code>和<code>export</code>。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。</p></li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>set</code></td><td style="text-align:center">显示当前Shell所有变量，包括内建环境变量、用户自定义变量及导出的环境变量</td></tr><tr><td style="text-align:center"><code>env</code></td><td style="text-align:center">显示与当前用户相关的环境变量，还可以让命令在指定环境中运行</td></tr><tr><td style="text-align:center"><code>export</code></td><td style="text-align:center">显示从Shell中导出成环境变量的变量，能通过它将自定义变量导出为环境变量</td></tr></tbody></table><p><img src="https://doc.shiyanlou.com/linux_base/5-3.png" alt="img"></p><ul><li><p>用<code>export</code>来体验一下环境变量与普通变量的，先在Shell中设置一个变量<code>temp=shiyanlou</code>，然后创建一个子Shell查看temp变量的值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp=shiyanlou</span><br><span class="line">echo <span class="variable">$temp</span></span><br><span class="line">zsh</span><br><span class="line">echo <span class="variable">$temp</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">export temp</span><br><span class="line">zsh</span><br><span class="line">echo <span class="variable">$temp</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008230934536.png" alt="image-20231008230934536"></p></li><li><p>通常为了与普通变量区分，习惯将环境变量名都设为大写</p></li></ul><h4 id="永久生效">永久生效</h4><ul><li><p>在关机之后，或者关闭shell，环境变量就会消失，可以将变量写入存放变量的文件中：<code>/etc/bashrc</code>和<code>/etc/profile</code>，分别存放的是shell变量和环境变量，或者用户目录下的隐藏文件<code>.profile</code>，仅对当前用户生效，可以使用<code>ls -a</code>查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231056722.png" alt=".profile文件"></p></li></ul><h3 id="命令的查找路径与顺序">命令的查找路径与顺序</h3><ul><li><p>在Shell中命令的执行是通过环境变量<code>PATH</code>搜索的，查看<code>PATH</code>环境变量的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231225585.png" alt="image-20231008231225585"></p></li><li><p>系统会从PATH中以此查找，如果存在相同的命令，则执行先找到的那个</p></li><li><p>接下来创建一个最简单的可执行Shell脚本和使用C语言创建的程序：</p><ul><li><p>在家目录创建一个<code>mybin</code>目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> mybin</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231345401.png" alt="image-20231008231345401"></p></li><li><p>进入新创建的目录，创建一个Shell脚本文件并编辑：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> mybin</span><br><span class="line">touch hello_shell.<span class="keyword">sh</span></span><br><span class="line">gedit hello_shell.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><blockquote><p>如果遇到gedit提示：[Unable to init server: 无法连接： 拒绝连接]，可以使用如下命令解决：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">DISPLAY</span>=localhost:1</span><br><span class="line">xhost local:gedit</span><br></pre></td></tr></table></figure><p>若出现以下内容，表示问题解决：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">non-network <span class="keyword">local</span> connections being added <span class="keyword">to</span> <span class="keyword">access</span> control list</span><br></pre></td></tr></table></figure><p>若还无法解决，可以使用vim编辑器</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> hello_shell.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在脚本中写入如下内容（第一行不可省略）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++));<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello shell&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></li><li><p>为文件添加可执行权限：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">chmod</span> <span class="number">755</span> hello_shell.sh</span><br></pre></td></tr></table></figure></li><li><p>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello_shell.sh</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233557594.png" alt="image-20231008233557594"></p></li><li><p>创建一个C语言程序并编辑：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch hello_world.<span class="keyword">c</span></span><br><span class="line">gedit hello_world.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></li><li><p>写入如下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后使用<code>gcc</code>生成可执行文件：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello_world hello_world.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></li><li><p>运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello_world</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233742246.png" alt="image-20231008233742246"></p></li></ul></li><li><p>在返回到家目录后，如果再想运行刚才创建的两个程序，会提示命令找不到，除非加上命令的完整路径。如果希望可以像执行系统命令一样执行运行刚才创建的程序，可以将脚本文件添加到PATH环境变量中。</p></li></ul><h3 id="添加自定义路径到PATH环境变量">添加自定义路径到PATH环境变量</h3><ul><li><p>PATH路径是以<code>:</code>作为分隔符的，如果希望将上面的<code>mybin</code>目录加入PATH路径，则需要写入以下信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:/home/shiyanlou/mybin</span></span><br></pre></td></tr></table></figure></li><li><p><strong>需要注意的是，这里一定要使用绝对路径</strong></p></li><li><p>那么现在就可以直接执行写下的两个命令了：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello<span class="emphasis">_shell.sh</span></span><br><span class="line"><span class="emphasis">hello_</span>world</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233916073.png" alt="image-20231008233916073"></p></li><li><p>但给PATH追加一条路径只会在当前Shell有效，一旦退出终端，再打开就会发现又失效了，那么可以利用用户home目录中一个在启动shell时自动运行的脚本。zsh的配置文件为<code>.zshrc</code>，相应Bash的配置文件为<code>.bashrc</code>，使用命令将路径添加到<code>.zshrc</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PATH=<span class="variable">$PATH</span>:/home/shiyanlou/mybin&quot;</span> &gt;&gt; .zshrc</span><br></pre></td></tr></table></figure><blockquote><p>上面命令中的<code>&gt;&gt;</code>表示将标准输出以追加的方式重定向到一个文件中。</p></blockquote></li></ul><h3 id="修改和删除已有变量">修改和删除已有变量</h3><h4 id="变量修改">变量修改</h4><ul><li>变量修改有如下几种方式：</li></ul><table><thead><tr><th style="text-align:center">变量设置方式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">${变量名#匹配字串}</td><td style="text-align:center">从头向后开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td style="text-align:center">${变量名##匹配字串}</td><td style="text-align:center">从头向后开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td style="text-align:center">${变量名%匹配字串}</td><td style="text-align:center">从尾向前开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td style="text-align:center">${变量名%%匹配字串}</td><td style="text-align:center">从尾向前开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td style="text-align:center">${变量名/旧的字串/新的字串}</td><td style="text-align:center">将符合旧字串的第一个字串替换为新的字串</td></tr><tr><td style="text-align:center">${变量名//旧的字串/新的字串}</td><td style="text-align:center">将符合旧字串的全部字串替换为新的字串</td></tr></tbody></table><ul><li><p>比如要修改前面添加到PATH的环境变量，为了避免误操作导致命令找不到，我们先将PATH赋值给一个新定义的自定义变量：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span>=$<span class="built_in">PATH</span></span><br><span class="line"><span class="built_in">echo</span> $<span class="built_in">path</span></span><br><span class="line"><span class="built_in">path</span>=$&#123;<span class="built_in">path</span><span class="variable">%/home/shiyanlou/mybin&#125;</span></span><br><span class="line"><span class="variable">path=$&#123;path%</span>*/mybin&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除变量">删除变量</h4><ul><li><p>可以使用<code>unset</code>命令删除一个环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> temp</span><br></pre></td></tr></table></figure></li></ul><h3 id="让环境变量立刻生效">让环境变量立刻生效</h3><ul><li><p>在Shell中修改了一个配置脚本文件后，必须要退出终端重新启动才可以生效，如果希望立即生效，可以使用<code>source</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure></li><li><p><code>source</code>命令还有一个别名<code>.</code>，或者使用以下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">. ./.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="搜索文件">搜索文件</h2><h3 id="whereis">whereis</h3><ul><li><p><code>whereis</code>搜索很快，因为并没有从硬盘中依次查找，而是从数据库中查询</p></li><li><p><code>whereis</code>只能搜索二进制文件（-b）、man帮助文件（-m）和源代码文件（-s）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis who</span><br><span class="line">whereis <span class="built_in">find</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008234411280.png" alt="image-20231008234411280"></p></li></ul><h3 id="locate">locate</h3><ul><li><p>通过<code>/var/lib/mlocate/mlocate.db</code>数据库查找，但这个文件只会由系统每天自动执行<code>updatedb</code>命令更新一次</p></li><li><p>查找<code>/usr/share/</code>下的所有jpg文件：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install locate</span><br><span class="line">locate /usr/<span class="keyword">share</span>/\*.jpg</span><br></pre></td></tr></table></figure></li><li><p>如果只想统计数目可以加上<code>-c</code>参数，忽略大小写查找使用<code>-i</code>参数</p></li></ul><h3 id="which">which</h3><ul><li><p>which本身是Shell内建的一个命令，通常用来确定是否安装了某个指定的软件，因为其只通过PATH环境变量指定的路径中查找：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">which</span> <span class="keyword">man</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="find">find</h3><ul><li><p>find命令是四种查找中最强大的，格式为<code>find [path] [option] [action]</code></p></li><li><p>表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">find</span> <span class="regexp">/etc/</span> -name interfaces</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><ul><li><p>找出 /etc/ 目录下的所有以 .list 结尾的文件。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">find</span> <span class="regexp">/etc/</span> -name \*.list </span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008234711794.png" alt="image-20231008234711794"></p></li></ul>]]></content>
    
    
    <summary type="html">本文介绍Linux环境变量的作用与用法，及几种搜索文件的方法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用Github Desktop进行简单的团队合作开发</title>
    <link href="https://www.iuoyt.com/posts/79105230.html"/>
    <id>https://www.iuoyt.com/posts/79105230.html</id>
    <published>2023-09-23T03:56:14.000Z</published>
    <updated>2023-10-08T16:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册Git平台账号">注册Git平台账号</h2><ul><li>首先，创建一个云端的项目仓库。借助Github或者Gitee，可以将你的项目托管在云端，以便团队的各成员都能方便地拉取与提交自己的代码。你可以使用Github，也可以是Gitee，来完成你的云端项目部署。</li><li>如何选择？<ul><li>Github作为全球最大的开源平台，已有许多年的历史。作为老牌开元平台，有着许许多多优秀的代码仓库。但因为网络原因，国内会有无法访问的情况。</li><li>Gitee是由一家中国公司建立的，较新的开源平台，由于服务器设立在境内，因此无须担心网络问题。</li></ul></li></ul><div class="tabs" id="注册git平台账号"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#注册git平台账号-1">Github</button></li><li class="tab"><button type="button" data-href="#注册git平台账号-2">Gitee</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="注册git平台账号-1"><ul><li><p>如果你还没有注册过Github账号，那么需要先前往<a href="https://github.com/signup">Github注册页面</a>注册一个账号。</p></li><li><p>填入你的个人邮箱和密码</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134102664.png" alt="image-20230923134102664"></p></li><li><p>按下<kbd>continue</kbd>进入下一步，填写你的用户名，如果提示<code>Username is not available.  </code>，说明这个用户名被占用了，那么你需要更换一个用户名。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134511421.png" alt="image-20230923134511421"></p></li><li><p>再次按下<kbd>continue</kbd>进入下一步</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134643032.png" alt="image-20230923134643032"></p><blockquote><p>您是否希望通过电子邮件接收产品更新和通知？<br>键入 &quot;y &quot;表示是，键入 &quot;n &quot;表示否</p></blockquote></li><li><p>按下<kbd>continue</kbd>，进入人机验证环节，只需要做<strong>几道十分简单</strong>的计算题。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134933266.png" alt="image-20230923134933266"></p></li><li><p>点击<kbd>Create account</kbd>，进入邮箱验证环节，输入你的邮箱收到的来自Github发送的验证码。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="注册git平台账号-2"><ul><li><p>首先进入<a href="https://gitee.com/signup">Gitee注册页面</a>，填写你的注册信息</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145301278.png" alt="image-20230923145301278"></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145447312.png" alt="image-20230923145447312"></p></li><li><p>点击<kbd>立即注册</kbd>完成注册，然后跳转到开始页面。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145611958.png" alt="image-20230923145611958"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="创建项目仓库">创建项目仓库</h2><p>团队协作中，只需要一个成员创建项目仓库即可，其他成员可以在仓库创建完成后加入合作。</p><div class="tabs" id="创建项目仓库"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#创建项目仓库-1">使用Github创建</button></li><li class="tab"><button type="button" data-href="#创建项目仓库-2">使用Gitee创建</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="创建项目仓库-1"><ul><li><p>注册完账户后，会自动跳转到<a href="https://github.com/join/get-started">开始页面</a>，选择<kbd>Create a repository</kbd>创建你的项目仓库</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923142743690.png" alt="image-20230923142743690"></p></li><li><p>填写项目信息，如果为私密仓库，填写项目名称与选择仓库类型即可，然后点击<kbd>Create repository</kbd>创建仓库。如果选择私密仓库，后面的连接到仓库步骤中则必须登录Github Desktop客户端。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923143955037.png" alt="image-20230923143955037"></p></li><li><p>完成创建后，就会自动跳转到你的仓库页面了。此时，你暂时无需操作任何内容，继续完成后续步骤即可，但不要关闭这个页面，之后的步骤还会用到。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923144222170.png" alt="image-20230923144222170"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="创建项目仓库-2"><ul><li><p>点击开始页面中的<kbd>创建我的仓库</kbd>按钮进入仓库创建页面</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145747679.png" alt="image-20230923145747679"></p></li><li><p>填写仓库信息，点击<kbd>创建</kbd>完成仓库创建</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145955632.png" alt="image-20230923145955632"></p></li><li><p>完成创建后，就会自动跳转到你的仓库页面了。此时，你暂时无需操作任何内容，继续完成后续步骤即可，但不要关闭这个页面，之后的步骤还会用到。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923150036301.png" alt="image-20230923150036301"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="下载Github-Desktop客户端">下载Github Desktop客户端</h2><ul><li><p>借助Github Desktop客户端，团队协作的完成可以无需使用任何Git命令，上手极为容易。</p></li><li><p>首先进入<a href="https://desktop.github.com/">Github Desktop官网</a>下载桌面客户端。</p><blockquote><p>阿里云盘下载：<a href="https://www.aliyundrive.com/s/2s84Cawtt8u">WIndows x64</a></p><p>百度网盘下载：<a href="https://pan.baidu.com/s/1xfTIb5Yw15zLBqTNF--Ypg?pwd=1234">Windows x64</a>  <a href="https://pan.baidu.com/s/1yv82gCEILLTwi8qh4RM8eA?pwd=1234">macOs</a></p><p>夸克网盘下载：<a href="https://pan.quark.cn/s/3d87b87a8738">Windows x64</a>  <a href="https://pan.quark.cn/s/b09b6f32dc84">macOs</a></p></blockquote><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923152058408.png" alt="image-20230923152058408"></p></li><li><p>启动安装程序</p></li></ul><div class="tabs" id="githubdesktop"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#githubdesktop-1">有Github账号</button></li><li class="tab"><button type="button" data-href="#githubdesktop-2">无Github账号</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="githubdesktop-1"><ul><li><p>点击<kbd>Sign in to Github.com</kbd>登录你的Github账户</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923153134.jpg" alt="img_20230923153134"></p></li><li><p>在网页中认证桌面端登录</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923153402.jpg" alt="img_20230923153402"></p></li><li><p>使用你的Github信息作为Git的提交信息（Use my GitHub account name and email address），然后点击<kbd>Finish</kbd></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923153442.jpg" alt="img_20230923153442"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="githubdesktop-2"><ul><li><p>点击安装程序，选择下方的跳过登录（Skip this step）</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923160412584.png" alt="image-20230923160412584"></p></li><li><p>填写你的Git提交信息，这里设置的信息会作为你在Git仓库提交的联系方式，之后也可以进行修改</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923155542.png" alt="img_20230923155542"></p></li><li><p>点击<kbd>Finish</kbd>提交</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="连接到仓库">连接到仓库</h2><p>接下来，只需要将本地仓库连接到你的Git平台账户仓库即可，回到之前新建的的仓库页面。</p><div class="tabs" id="连接到仓库"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#连接到仓库-1">Github</button></li><li class="tab"><button type="button" data-href="#连接到仓库-2">Gitee</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="连接到仓库-1"><ul><li><p>复制仓库的git链接</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923162030088.png" alt="image-20230923162030088"></p></li><li><p>回到Github Desktop客户端，选择克隆一个仓库（Clone a repository)</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923162158.jpg" alt="img_20230923162158"></p></li><li><p>在弹出的窗口中填写刚才复制的链接，选择本地仓库保存的位置（空文件夹），点击<kbd>Clone</kbd>完成连接。如果出现连接错误，注意仓库是否为隐私仓库，如果为隐私仓库，则一定要在Github Desktop中登录你的Github账户。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923162524508.png" alt="image-20230923162524508"></p></li><li><p>在资源管理器中进入你的项目文件夹，现在可以将你的项目文件放到仓库文件夹中了。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="连接到仓库-2"><ul><li><p>复制仓库的Git链接</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923164138920.png" alt="image-20230923164138920"></p></li><li><p>回到Github Desktop客户端，选择克隆一个仓库（Clone a repository)</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923162158.jpg" alt="img_20230923162158"></p></li><li><p>在弹出的窗口中填写刚才复制的链接，选择本地仓库保存的位置（空文件夹），点击<kbd>Clone</kbd>完成连接。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923164615076.png" alt="image-20230923164615076"></p></li><li><p>登录到Gitee，点击<kbd>Save and retry</kbd></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923164733738.png" alt="image-20230923164733738"></p></li><li><p>在资源管理器中进入你的项目文件夹，现在可以将你的项目文件放到仓库文件夹中了。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="提交本地项目">提交本地项目</h2><ul><li><p>如果本地仓库与托管库有内容差异，那么Github Desktop中会显示出所有有差异的项，现在只需要将这些修改项提交到托管库</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923165327854.png" alt="image-20230923165327854"></p></li><li><p>现在已经可以在Git库中看到刚才的提交了</p></li></ul><h2 id="邀请协作">邀请协作</h2><p>邀请别的成员进入项目，即可通过Git平台进行协作</p><div class="tabs" id="邀请协作"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#邀请协作-1">Github</button></li><li class="tab"><button type="button" data-href="#邀请协作-2">Gitee</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="邀请协作-1"><ul><li><p>在网页端的项目页中点击<kbd>Setting</kbd> -&gt; <kbd>Collaborate</kbd> -&gt; <kbd>Add people</kbd>，搜索其他成员的用户名、邮箱等信息</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923165745288.png" alt="image-20230923165745288"></p></li><li><p>选择账号，然后点击”Add to this repository&quot;完成添加成员</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="邀请协作-2"><ul><li><p>在网页端的项目页中点击<kbd>管理</kbd> -&gt; <kbd>仓库成员管理</kbd> -&gt; <kbd>全部</kbd> -&gt; <kbd>添加仓库成员</kbd> -&gt; <kbd>邀请用户</kbd></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923170308310.png" alt="image-20230923170308310"></p></li><li><p>点击<kbd>直接添加</kbd>，选择权限并搜索账户的用户名和邮箱，选择用户完成添加</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923170630827.png" alt="image-20230923170630827"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="从Git获取更新">从Git获取更新</h2><ul><li><p>当其他成员提交了代码后，你进行本地开发前，要从Git平台中拉取更新。打开Github Desktop客户端，点击“Fetch origin”拉取更新</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923171022885.png" alt="image-20230923171022885"></p></li><li><p>此时，本地的项目文件就已经被更新到最新了</p></li></ul><h2 id="内容冲突">内容冲突</h2><ul><li><p>当两个成员先后提交项目到托管库时，可能会出现代码冲突的情况，即两个人都改了同一行内容，这时，后提交的人则需要从代码库先拉取代码到本地，对于有冲突的内容，可以在Github Desktop客户端中手动解决冲突。完成本地的代码合并后，可以再次提交，此时可以提交成功。</p></li><li><p>尽管冲突处理可能并不容易，但尽请在完成一个新任务后尽快提交一次代码。如果一直未将本地的代码与托管库合并，就可能会造成更多的冲突哦。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注册Git平台账号&quot;&gt;注册Git平台账号&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首先，创建一个云端的项目仓库。借助Github或者Gitee，可以将你的项目托管在云端，以便团队的各成员都能方便地拉取与提交自己的代码。你可以使用Github，也可以是Gitee，来完成你的云端</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="https://www.iuoyt.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux目录结构及文件基本操作</title>
    <link href="https://www.iuoyt.com/posts/7c63bae8.html"/>
    <id>https://www.iuoyt.com/posts/7c63bae8.html</id>
    <published>2023-09-23T03:13:32.000Z</published>
    <updated>2023-11-25T03:24:40.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux目录结构">Linux目录结构</h2><ul><li>Windows系统中，存储是以盘符和分区为主，因此在经过一段时间的使用后，文件目录会相对混乱。</li><li>UNIX/Linux则是以目录为主，文件构成树形目录结构。</li></ul><h3 id="FHS标准">FHS标准</h3><ul><li>FHS（FileSystem Hierarchy Standard，文件系统层次结构标准）规定了Linux的部分目录结构，其定义了两层规范：<ul><li>第一层是 <code>/</code>，规定了各文件应该放置的位置，如 <code>/etc</code>应该放置设置文件，<code>/bin</code>应该放置可执行文件。</li><li>第二层则是针对 <code>/usr</code>及 <code>/var</code>两个目录的定义，例如 <code>/var/log</code>用于存放系统日志文件。<br><img src="https://doc.shiyanlou.com/linux_base/4-1.png" alt="FHS标准"></li></ul></li></ul><h3 id="目录路径">目录路径</h3><ul><li><p>在目录中进行切换可以使用 <code>cd</code>命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;<span class="built_in">path</span>&gt;/&lt;to&gt;/&lt;<span class="built_in">dir</span>&gt;</span><br><span class="line"><span class="built_in">cd</span> .. # 进入上一级目录</span><br><span class="line"><span class="built_in">cd</span> ~  # 进入当前用户home目录</span><br></pre></td></tr></table></figure></li><li><p>查看当前位置使用 <code>pwd</code></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103108351.png" alt="image-20230923103108351"></p></li><li><p>如果路径以 <code>/</code>开头，则表示为绝对路径，路径则是从根目录开始查找。否则是相对路径，则是以当前目录作为起点进行查找。</p></li></ul><h2 id="Linux文件的基本操作">Linux文件的基本操作</h2><h3 id="新建文件">新建文件</h3><ul><li><p>使用 <code>touch</code>命令创建空白文件，如下，回到用户目录，然后创建 <code>test</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">touch test</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103135750.png" alt="image-20230923103135750"></p></li></ul><h3 id="新建目录">新建目录</h3><ul><li><p>使用 <code>mkdir</code>创建一个空白目录，创建多级目录，可以使用 <code>-p</code>参数：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mytest</span><br><span class="line"><span class="built_in">mkdir</span> -p father/son/grandson</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103203314.png" alt="image-20230923103203314"></p></li></ul><h3 id="复制">复制</h3><ul><li><p>使用 <code>cp</code>（copy）命令复制一个文件到指定目录下，将之前创建的 <code>test</code>文件复制到刚才创建的多级目录下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp test father/son/grandson</span><br><span class="line"><span class="built_in">cd</span> father/son/grandson</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103323402.png" alt="image-20230923103323402"></p></li></ul><h3 id="复制目录">复制目录</h3><ul><li><p>复制目录仍然使用的是 <code>cp</code>命令，但需要加上 <code>-r</code>或者 <code>-R</code>参数，表示递归复制，如下，将father目录移动到新建的 <code>family</code>目录下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> family</span><br><span class="line">cp -r father family</span><br><span class="line"><span class="built_in">tree</span> family/</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103713970.png" alt="image-20230923103713970"></p></li></ul><h3 id="删除">删除</h3><ul><li><p>使用 <code>rm</code>（remove）命令删除文件或目录，删除 <code>test</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm test</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103742690.png" alt="image-20230923103742690"></p></li><li><p>如果需要删除一些为只读权限的文件，可以使用 <code>-f</code>参数强制删除，强制删除 <code>test</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f test</span><br></pre></td></tr></table></figure></li><li><p>如果需要删除的是目录，则同样需要加上 <code>-r</code>或 <code>-R</code>参数，删除family目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r family</span><br></pre></td></tr></table></figure></li></ul><h3 id="移动文件与文件重命名">移动文件与文件重命名</h3><ul><li><p>使用 <code>mv</code>（move）移动文件（剪切操作），将 <code>file1</code>移动到 <code>Documents</code>目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Documents</span><br><span class="line">touch file1</span><br><span class="line">mv file1 Documents</span><br><span class="line"><span class="built_in">cd</span> Documents</span><br><span class="line"><span class="built_in">tree</span> Documents/</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104045186.png" alt="image-20230923104045186"></p></li><li><p>使用 <code>mv</code>同样可以对文件进行重命名，将文件 <code>file1</code>重命名为 <code>myfile</code>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Documents</span><br><span class="line">mv file1 myfile</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104134698.png" alt="image-20230923104134698"></p></li><li><p>如果需要重命名的文件太多，使用 <code>mv</code>则会非常麻烦，此时可以使用 <code>rename</code>进行批量重命名，其参数则使用perl正则表达式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"># 批量创建<span class="number">5</span>个文件</span><br><span class="line">touch file&#123;<span class="number">1</span>..<span class="number">5</span>&#125;.txt</span><br><span class="line"># 批量修改后缀为.c</span><br><span class="line"><span class="built_in">rename</span> &#x27;s/\.txt/\.c/&#x27; *.txt</span><br><span class="line"># 将文件名称和后缀都改为大写</span><br><span class="line"><span class="built_in">rename</span> &#x27;y/a-z/A-Z/&#x27; *.c</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104411900.png" alt="image-20230923104411900"></p></li></ul><h3 id="查看文件">查看文件</h3><ul><li><p>使用 <code>cat</code>命令正序查看文件，使用 <code>tac</code>倒序查看文件，加上 <code>-n</code>参数则显示行号，使用 <code>cat</code>命令查看 <code>passwd</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">cp /etc/passwd passwd</span><br><span class="line">cat -n passwd</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104503707.png" alt="image-20230923104503707"></p></li><li><p>使用 <code>nl</code>命令与 <code>cat -n</code>相同，都是添加行号并显示，<code>nl</code>命令包括如下参数：</p></li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:center">指定添加行号的方式</td></tr><tr><td style="text-align:center"><code>-b a</code></td><td style="text-align:center">无论是否为空行，都列出行号（<code>cat -n</code>）</td></tr><tr><td style="text-align:center"><code>-b t</code></td><td style="text-align:center">只列出非空行的编号并显示（默认）</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:center">设置行号的样式</td></tr><tr><td style="text-align:center"><code>-n ln</code></td><td style="text-align:center">在行号字段最左边显示</td></tr><tr><td style="text-align:center"><code>-n rn</code></td><td style="text-align:center">在行号字段最右边显示，不补0</td></tr><tr><td style="text-align:center"><code>-n rz</code></td><td style="text-align:center">在行号字段最右边显示，补0</td></tr><tr><td style="text-align:center"><code>-w</code></td><td style="text-align:center">行号字段占用的位数（默认6位）</td></tr></tbody></table><ul><li><p>使用 <code>more</code>和 <code>less</code>可以分页查看文件,打开文件后默认只显示一屏的内容，可以使用<kbd>Enter</kbd>向下滚动一行，使用<kbd>Space</kbd>向下滚动一屏，按下<kbd>h</kbd>显示帮助，按下<kbd>q</kbd>退出。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">more</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104701100.png" alt="image-20230923104701100"></p></li><li><p>使用 <code>head</code>或 <code>tail</code>命令查看文件前几行（默认10）或尾几行，使用 <code>-n</code>参数可以指定查看行数：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head passwd</span><br><span class="line"># 查看最后一行内容</span><br><span class="line">tail -n <span class="number">1</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104730835.png" alt="image-20230923104730835"></p></li><li><p><code>tail</code>命令还有一个 <code>-f</code>参数，这个参数可以不断读取文件内容并显示，从而达到监控文件的作用</p></li></ul><h3 id="查看文件类型">查看文件类型</h3><ul><li><p>使用 <code>file</code>可以查看文件类型：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file /bin/ls</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104951833.png" alt="image-20230923104951833"></p><p>说明这是一个可执行文件，运行在 64 位平台，并使用了动态链接文件（共享库）。</p></blockquote></li></ul><h3 id="编辑文件">编辑文件</h3><ul><li><p>可以使用编辑器编辑文件，比如使用vim编辑器：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim passwd</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><ol><li><p>创建一个 homework 目录，建立名为 1.txt～10.txt 文件，并删除 1.txt～5.txt 。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> homework</span><br><span class="line">touch &#123;<span class="number">1</span>..<span class="number">10</span>&#125;.txt</span><br><span class="line">rm &#123;<span class="number">1</span>..<span class="number">5</span>&#125;.txt</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923105312850.png" alt="image-20230923105312850"></p></li><li><p>Linux 的日志文件在哪个目录？</p><p>日志文件存储在 <code>/var/log</code>目录下</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923105427851.png" alt="image-20230923105427851"></p></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了Linux的文件组织目录结构、相对路径和绝对路径、对文件的移动、复制、重命名、编辑等操作。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux用户及文件权限管理</title>
    <link href="https://www.iuoyt.com/posts/337bc2f3.html"/>
    <id>https://www.iuoyt.com/posts/337bc2f3.html</id>
    <published>2023-09-17T08:13:02.000Z</published>
    <updated>2023-12-21T09:50:18.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户操作">用户操作</h2><h3 id="查看用户">查看用户</h3><p>输出当前使用终端的用户名</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937806007" alt="查看用户"></p><h3 id="创建用户">创建用户</h3><p>使用root用户登录，创建新用户。创建用户需要满足以下条件：</p><ul><li><p>知道当前用户的登录密码</p><blockquote><p>重置用户密码：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;sudo passwd &lt;username&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>当前用户必须在sudo用户组</p></li></ul><ol><li>创建一个叫lilei的用户：</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser lilei</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937837548" alt="创建用户"></p><ol start="2"><li>创建好用户后，讲用户添加到系统，并为用户创建<code>home</code>目录</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /home</span><br></pre></td></tr></table></figure><ol start="3"><li>切换到lilei用户，并查看当前用户名：</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su -l lilei</span><br><span class="line">who am i</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937853403" alt="切换用户lilei"></p><h3 id="用户组">用户组</h3><h4 id="查看用户组">查看用户组</h4><h5 id="方法一">方法一</h5><p>使用<code>groups</code>命令查询用户组</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups shiyanlou</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937855752" alt="查看用户组"></p><h5 id="方法二">方法二</h5><p>通过<code>/etc/group</code>文件查看</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | <span class="built_in">sort</span></span><br><span class="line">cat /etc/group | grep -E &quot;shiyanlou&quot;</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937857521" alt="通过/etc/group查看用户组"></p><h4 id="加入用户组">加入用户组</h4><p>默认创建的用户不具有<code>sudo</code>权限，可以加入sudo用户组使其具有<code>sudo</code>权限。使用<code>usermod</code>命令添加权限：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su shiyanlou</span><br><span class="line">groups lilei</span><br><span class="line">sudo usermod -G sudo lilei</span><br><span class="line">groups lilei</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937859202" alt="加入用户组"></p><h3 id="删除用户">删除用户</h3><p>使用<code>deluser</code>命令删除用户：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser lilei --remove-home</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937860913" alt="删除用户"></p><h2 id="Linux文件权限">Linux文件权限</h2><h3 id="列出文件">列出文件</h3><ul><li>使用长格式列出文件：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937863052" alt="长格式列出文件"></p><ul><li>查看全部文件（包括隐藏文件）</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -A</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937865050" alt="查看全部文件"></p><ul><li>使用长格式列出所有文件</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -Al</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937868681" alt="长格式列出所有文件"></p><ul><li>查看目录完整属性</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -dl &lt;dirname&gt;</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937871460" alt="查看目录完整属性"></p><ul><li>显示所有文件大小</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -AsSh</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937873687" alt="显示所有文件大小"></p><h3 id="查看文件">查看文件</h3><p>使用<code>cat &lt;filename&gt;</code>命令读取文件内容</p><h3 id="变更文件所有者">变更文件所有者</h3><ul><li>新建<code>iphone6</code>目录，查看目录创建人</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su lilei</span><br><span class="line"><span class="built_in">cd</span> /home/lilei</span><br><span class="line">touch iphone6</span><br><span class="line">ll iphone6</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937876019" alt="查看文件创建人"></p><ul><li>切换身份，并变更创建人身份</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su shiyanlou</span><br><span class="line"><span class="built_in">cd</span> /home/lilei</span><br><span class="line">ls iphone6</span><br><span class="line">sudo chown shiyanlou iphone6</span><br><span class="line">ll iphone6</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230917153225613.png" alt="变更创建人"></p><h3 id="修改文件权限">修改文件权限</h3><h4 id="方法一-二进制数字表示">方法一 二进制数字表示</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">rwx</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>文件调用权限分为三级 :</p><ul><li>文件所有者（Owner）</li><li>用户组（Group）</li><li>其它用户（Other Users）</li></ul></li><li><p>权限分为三种：</p><ul><li>可读（Read）</li><li>可写（Write）</li><li>可执行（Execute）</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="img"></p></li></ul><blockquote><p>每个文件的三组权限（拥有者，所属用户组，其他用户，<strong>记住这个顺序是一定的</strong>）对应一个 &quot; rwx &quot;，也就是一个 “ 7 ”</p><p><img src="https://doc.shiyanlou.com/linux_base/3-14.png" alt="img"></p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">echo</span> \&quot;hello shiyanlou\&quot;&quot; &gt; iphone6</span><br><span class="line">chmod <span class="number">600</span> iphone6</span><br><span class="line">ll iphone6</span><br><span class="line">su lilei</span><br><span class="line">cat /home/lilei/iphone6</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937882239" alt="修改权限1"></p><h4 id="方法二-符号表示">方法二 符号表示</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">u</span>&gt;</span><span class="tag">&lt;<span class="name">op</span>&gt;</span><span class="tag">&lt;<span class="name">permission</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>用户组部分表示：</p><table><thead><tr><th style="text-align:left">who</th><th style="text-align:left">用户类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>u</code></td><td style="text-align:left">user</td><td style="text-align:left">文件所有者</td></tr><tr><td style="text-align:left"><code>g</code></td><td style="text-align:left">group</td><td style="text-align:left">文件所有者所在组</td></tr><tr><td style="text-align:left"><code>o</code></td><td style="text-align:left">others</td><td style="text-align:left">所有其他用户</td></tr><tr><td style="text-align:left"><code>a</code></td><td style="text-align:left">all</td><td style="text-align:left">所有用户, 相当于 <em>ugo</em></td></tr></tbody></table></li><li><p>符号部分表示：</p><table><thead><tr><th style="text-align:left">Operator</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">为指定的用户类型增加权限</td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">去除指定用户类型的权限</td></tr><tr><td style="text-align:left"><code>=</code></td><td style="text-align:left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table></li><li><p>权限部分表示：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">名字</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>r</code></td><td style="text-align:left">读</td><td style="text-align:left">设置为可读权限</td></tr><tr><td style="text-align:left"><code>w</code></td><td style="text-align:left">写</td><td style="text-align:left">设置为可写权限</td></tr><tr><td style="text-align:left"><code>x</code></td><td style="text-align:left">执行权限</td><td style="text-align:left">设置为可执行权限</td></tr><tr><td style="text-align:left"><code>X</code></td><td style="text-align:left">特殊执行权限</td><td style="text-align:left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td style="text-align:left"><code>s</code></td><td style="text-align:left">setuid/gid</td><td style="text-align:left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td style="text-align:left"><code>t</code></td><td style="text-align:left">粘贴位</td><td style="text-align:left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td></tr></tbody></table></li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod go-rw iphone6</span><br></pre></td></tr></table></figure><h3 id="adduser-useradd">adduser &amp; useradd</h3><blockquote><p>useradd 只创建用户，创建完了用 passwd lilei 去设置新用户的密码。adduser 会创建用户，创建目录，创建密码（提示你设置），做这一系列的操作。其实 useradd、userdel 这类操作更像是一种命令，执行完了就返回。而 adduser 更像是一种程序，需要你输入、确定等一系列操作。</p></blockquote><h2 id="实战训练">实战训练</h2><p><strong>题目</strong></p><blockquote><p>添加一个用户 <code>loutest</code>，使用 <code>sudo</code> 创建文件 <code>/opt/forloutest</code>，设置成用户 <code>loutest</code> 可以读写。</p></blockquote><ol><li><p>添加用户<code>loutest</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser loutest</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937214794" alt="添加用户"></p></li><li><p>创建文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /opt/forloutest</span><br></pre></td></tr></table></figure></li><li><p>设置读写权限并测试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chown loutest:loutest /opt/forloutest</span><br><span class="line">sudo chmod <span class="number">600</span> /opt/forloutest</span><br><span class="line">cat /opt/forloutest</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937457242" alt="权限设置"></p></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了Linux 中创建、删除用户，及用户组等操作，以及Linux 中的文件权限设置。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.iuoyt.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LC 1. 两数之和</title>
    <link href="https://www.iuoyt.com/posts/d98ef1d2.html"/>
    <id>https://www.iuoyt.com/posts/d98ef1d2.html</id>
    <published>2023-08-20T06:12:26.000Z</published>
    <updated>2023-08-20T11:17:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><ul><li>序号：1</li><li>题目：两数之和</li><li>难度：简单</li><li>标签：数组、哈希表</li></ul><details class="folding-tag" open><summary> 题目描述 </summary>              <div class='content'>              <blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,7,11,15]</span>, target = 9</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br><span class="line">解释：因为 nums<span class="comment">[0]</span> + nums<span class="comment">[1]</span> == 9 ，返回 <span class="comment">[0, 1]</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,2,4]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,3]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>$2 &lt;= nums.length &lt;= 10^4$</li><li>$-10^9 &lt;= nums[i] &lt;= 10^9$</li><li>$-10^9 &lt;= target &lt;= 10^9$</li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong> 你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p></blockquote>              </div>            </details><hr><h2 id="题解-方法1（枚举法）">题解-方法1（枚举法）</h2><h3 id="思路">思路</h3><ul><li>暴力枚举</li><li>遍历数组中所有的数字，查找符合求和满足条件的值。内层循环查找的开始位置可以是外层循环位置的后一位，因为前方的值已经匹配过，无需遍历。</li></ul><h3 id="代码">代码</h3><div class="tabs" id="代码"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#代码-1">Java</button></li><li class="tab"><button type="button" data-href="#代码-2">C++</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="代码-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="代码-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="复杂度分析">复杂度分析</h3><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="题解-方法2（哈希表）">题解-方法2（哈希表）</h2><h3 id="思路-2">思路</h3><ul><li>哈希表</li><li>通过哈希表可以将内层时间复杂度O(n)降为O(1)。在哈希表中询问是否存在<code>target - nums[i]</code>的值，不存在则将当前值存入哈希表。</li></ul><h3 id="代码-2">代码</h3><div class="tabs" id="代码"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#代码-1">Java</button></li><li class="tab"><button type="button" data-href="#代码-2">C++</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="代码-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashTable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashTable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="代码-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashTable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashTable.<span class="built_in">find</span>(target - nums[i]) != hashTable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;hashTable[target - nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="复杂度分析-2">复杂度分析</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul>]]></content>
    
    
    <summary type="html">LeetCode：1. 两数之和</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.iuoyt.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.iuoyt.com/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.iuoyt.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://www.iuoyt.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Git分支管理</title>
    <link href="https://www.iuoyt.com/posts/935337f5.html"/>
    <id>https://www.iuoyt.com/posts/935337f5.html</id>
    <published>2023-08-04T04:24:21.000Z</published>
    <updated>2023-08-04T10:50:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分支创建与切换">分支创建与切换</h2><ul><li><p>创建一个分支可以使用<code>git branch</code>命令，比如可以使用这个语句创建一个testing分支，这会在当前所在的提交对象上创建一个指针：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch testing</span><br></pre></td></tr></table></figure></li><li><p>创建完testing分支后，情况如下：</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="HEAD 指向当前所在的分支。"></p></li><li><p>使用<code>git branch</code>创建好分支后并不会自动切换到新的分支，切换到一个分支，可以使用<code>git checkout</code>命令，比如这条命令将会切换HEAD指针到testing分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure></li><li><p>HEAD指针指向了testing分支</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="HEAD 指向当前所在的分支。"></p></li><li><p>当然，Git也可以在创建分支的同时切换到当前分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="分支提交">分支提交</h2><ul><li><p>HEAD当前指向testing分支，那么现在更新一些内容然后进行提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim test.rb</span><br><span class="line">git commit -a -m &#x27;update testing&#x27;</span><br></pre></td></tr></table></figure></li><li><p>提交完成后，分支情况就变成现在这样：</p><p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" alt="HEAD 分支随着提交操作自动向前移动。"></p></li><li><p>如果现在再将HEAD移动回master分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png" alt="检出时 HEAD 随之移动。"></p><p>这个时候，你的工作目录和你在开始修改tetsing分支之前一模一样。当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p></li><li><p>现在在master分支下再进行一次修改并提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim test.rb</span><br><span class="line">git commit -a -m &#x27;update master&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/advance-master.png" alt="项目分叉历史。"></p></li></ul><h2 id="项目分叉历史">项目分叉历史</h2><ul><li><p>查看当前项目的分叉历史，可以使用<code>git log</code>命令进行查看，它会输出提交历史、各个分支的指向以及项目的分支分叉情况：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate --graph --all</span></span><br><span class="line">* c2b9e (HEAD, master) update master</span><br><span class="line">| * 87ab2 (testing) update testing</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure></li><li><p>Git的分支实质上仅是包含所指对象校验和（长度为40的SHA-1值字符串）的文件，所以创建和销毁分支都可以做到非常的高效。</p></li></ul><h2 id="删除分支">删除分支</h2><ul><li><p>使用带有<code>-d</code>的<code>git branch</code>命令可以删除分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d testing</span><br></pre></td></tr></table></figure></li></ul><h2 id="合并分支">合并分支</h2><ul><li><p>假设当前已有master分支如下：</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-1.png" alt="一个简单的提交历史。"></p></li><li><p>现在，需要解决追踪系统的#53问题，新建了一个iss53分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch iss53</span><br><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" alt="创建一个新分支指针。"></p></li><li><p>现在在iss53分支进行了一些更改：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">git commit -a -m &#x27;added a new footer [issue 53]&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" alt=" 分支随着工作的进展向前推进。"></p></li></ul><h3 id="快进式（fast-forward）合并">快进式（fast-forward）合并</h3><ul><li><p>现在需要对主分支进行一次紧急修复，切换到master分支并进行一次热修复：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b hotfix</span><br><span class="line">vim index.html</span><br><span class="line">git commit -a -m &#x27;fixed the broken email address&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="基于  分支的紧急问题分支（hotfix branch）。"></p></li><li><p>经过检验，热修复分支解决了问题，那么现在需要将master分支与hotfix分支进行合并：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge hotfix</span></span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>由于你想要合并的分支 <code>hotfix</code> 所指向的提交 <code>C4</code> 是你所在的提交 <code>C2</code> 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt=" 被快进到 。"></p></li></ul><h3 id="二路合并">二路合并</h3><ul><li>二路合并是最简单的一种合并方式，将两个文件进行逐行比对，如果行内容有差异就报冲突，这时候就需要人工合并差异了。</li></ul><h3 id="三路合并（递归三路合并）">三路合并（递归三路合并）</h3><ul><li><p>对于较少差异的分支，使用二路合并尚且可以接受，但对于较大差异的分支，使用二路合并就非常麻烦了。因此出现了三路合并方法：首先找到两个分支的共同父节点（Base），如果A分支对某内容进行了修改，B分支对这个内容未进行修改，那么会应用A分支的修改，反之应用B分支的修改。</p><p><img src="https://upload-images.jianshu.io/upload_images/11893784-6b0f41a62e828d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p></li><li><p>回到之前的情景。解决完紧急问题后，需要恢复到之前的工作中，进行后续工作的提交。同时删除hotfix分支，因为已经完成了此次修复，不再需要：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix</span></span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout iss53</span></span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;finished the new footer [issue 53]&#x27;</span></span></span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="继续在  分支上的工作。"></p></li><li><p>现在iss53问题已经被修复，需要与master分支进行合并：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="一次典型合并中所用到的三个快照。"></p></li><li><p>因为master分支并非是iss53分支的父节点，Git会对这两个分支进行一次简单的三路合并。虽然此次合并写作’recursive’策略，但并非递归三路合并，在Git的输出中，三路合并与递归三路合并都是’recursive’策略，递归三路合并策略通常用于更加复杂的合并场景。</p></li></ul><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="一个合并提交。"></p><h2 id="处理合并冲突">处理合并冲突</h2><ul><li><p>如果两个分支都对同一段内容做了更改，Git就无法完成合并操作，在合并时就会报合并冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>可以使用<code>git status</code>查看当前产生冲突而未合并状态的文件</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></li><li><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>手动合并完成后，对冲突文件使用<code>git add</code>将其标记为冲突已解决。</p></li><li><p>如果想使用图形化界面来处理冲突操作，可以使用<code> git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突。退出工具后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决。</p></li></ul><h2 id="分支管理">分支管理</h2><ul><li><p>使用不带参数的<code>git branch</code>命令可以查看当前分支的列表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>其中，带有<code>*</code>的master分支代表当前HEAD指针所指向的分支。</p></li><li><p>如果需要查看每一个分支的最后一次提交，可以使用<code>git branch -v</code>命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure></li><li><p>还可以使用<code>--merged</code>与<code>--no-merged</code>筛选当前已合并或未合并到当前分支的分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>git branch -d</code>删除分支，如果删除分支包含了还未合并的工作，则会删除失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d testing</span></span><br><span class="line">error: The branch &#x27;testing&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D testing&#x27;.</span><br></pre></td></tr></table></figure><p>可以使用<code>-D</code>完成强制删除。</p></li></ul><h2 id="远程分支">远程分支</h2><ul><li><p>假设有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-1.png" alt="克隆之后的服务器与本地仓库。"></p></li><li><p>如果在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-2.png" alt="本地与远程的工作可以分叉。"></p></li><li><p>如果要与远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（本例中为 <code>git fetch origin</code>）。 这个命令查找 ``origin’’ 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-3.png" alt=" 更新你的远程仓库引用。"></p></li></ul><h2 id="变基">变基</h2><h3 id="变基的使用">变基的使用</h3><ul><li><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。假设现在有两个分支分别提交了更新</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-1.png" alt="分叉的提交历史。"></p></li><li><p>如果使用<code>merge</code>合并两个分支，那么会产生一次新的快照。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-2.png" alt="通过合并操作来整合分叉了的历史。"></p></li><li><p>使用另一种方法：提取C4中引入的补丁和修改，然后再C3的基础上应用一次，这种操作称为<strong>变基（rebase）</strong>。比如，检出experiment分支，将其变基到master分支上：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout experiment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-3.png" alt="将  中的修改变基到  上。"></p></li><li><p>现在回到master分支上，进行一次快进合并：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge experiment</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-4.png" alt=" 分支的快进合并。"></p><p>此时的C4’快照就和使用merge合并产生的C5快照一模一样了。这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。例如向某个其他人维护的项目贡献代码时，首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p></li><li><p>对于一个主题分支中再分出一个主题分支的提交，如下图结构</p><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-1.png" alt="从一个主题分支里再分出一个主题分支的提交历史。"></p><p>如果希望合并client到master分支，但不希望将server分支合并，此时就可以使用<code>--onto</code>选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master server client</span><br></pre></td></tr></table></figure><p>这条语句的意思是：取出 <code>client</code> 分支，找出它从 <code>server</code> 分支分歧之后的补丁， 然后把这些补丁在 <code>master</code> 分支上重放一遍，让 <code>client</code> 看起来像直接基于 <code>master</code> 修改一样。</p><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-2.png" alt="截取主题分支上的另一个主题分支，然后变基到其他分支。"></p></li><li><p>那么现在可以使用快进合并合并master分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge client</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-3.png" alt="快进合并  分支，使之包含来自  分支的修改。"></p></li><li><p>如果现在需要将server分支也合并进来，使用变基操作，完成合并，然后删除多余的分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge server</span><br><span class="line">git branch -d client</span><br><span class="line">git branch -d server</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-5.png" alt="最终的提交历史。"></p></li></ul><h3 id="变基的问题">变基的问题</h3><ul><li><p>如果当别人正在基于分支进行开发，那么不应该将分支使用变基合并到主分支上。变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p></li><li><p>比如，现在有一个公开仓库，你从当前仓库克隆到本地并在此基础上进行开发。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-1.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发。"></p></li><li><p>然后，某人向该仓库提交了一些修改，其中还包括一次合并。你抓取了远程分支上的修改，然后合并到你的本地分支上。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-2.png" alt="抓取别人的提交，合并到自己的开发分支。"></p></li><li><p>接下来，这个开发者又决定将合并操作回滚，更换为使用变基合并，并使用<code>git push --force</code>命令覆盖了服务器上的提交历史。然后你向服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-3.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。"></p></li><li><p>此时，如果你执行<code>git pull</code>命令提交，就会将已经抛弃的C4和C6快照恢复，最终仓库会如下图所示，变得混乱。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></p></li></ul><h3 id="解决因变基产生的合并问题">解决因变基产生的合并问题</h3><ul><li><p>假如真的遇到了类似的问题，可以使用一些操作解决。实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p></li><li><p>这种情况下，如果并非执行合并，而是使用<code>git rebase teamone/master</code>，Git就会执行以下操作：</p><ul><li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li><li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li><li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li><li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li></ul><p>那么将会产生如下结构：</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-5.png" alt="在一个被变基然后强制推送的分支上再次执行变基。"></p><p>不过，这种操作需要保证C4’和C4是一样的，否则变基操作将无法识别，并新建另一个类似C4的补丁。</p></li><li><p>还有另一种简单的方法是使用<code>git pull --rebase</code>，或者手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p></li></ul><h2 id="Learn-Git-Branching">Learn Git Branching</h2><ul><li>在<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a>上，可以进行一部分git命令的教学实验，或者使用沙盒进行测试，通过具象化的图形可以帮助对Git操作的理解。</li></ul>]]></content>
    
    
    <summary type="html">使用分支意味着可以将当前的工作从开发主线上分离开来，以免影响开发主线。</summary>
    
    
    
    <category term="学习笔记" scheme="https://www.iuoyt.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="https://www.iuoyt.com/tags/Git/"/>
    
  </entry>
  
</feed>
